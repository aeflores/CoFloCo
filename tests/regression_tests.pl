/** <module> regression_tests 

This module performs regression tests, it can save the results of analyzing a benchmark
and checking that the new results match the saved ones.

save_regression(Options) runs a benchmark and saves the results of each file 'file' into a file 'file.results'


check_regression(Options) runs a benchmark and compares the results of each file 'file' with the results
stored in the file 'file.results'.

Options is a list of pairs key:value. Every option has a default value.
The possible options are:

key:verbosity
	value: 1 to 3 
	description: how much information is printed
  		1-
  		2-
  		3-
  	default: 1
 
key:discard_output
	value: yes or no
	description: discard the output generated by CoFloCo without printing it or not.
	default: yes

key:benchmark
	value: testing, all, imperative, imperative_long or functional (as defined by predicate benchmark)
	description: benchmark selects the directories of examples that will be analized.
		all the files belonging to the corresponding directories that end 
		in '.ces' will be analyzed except the ones ending in '.excluded.ces'
		benchmark also select the default profiles that will be executed (see option profiles)
	default: testing

key:profiles
	value: a list of profile names as defined in predicate profile_list e.g. default, complete, completeCompress1, completeCompress1...
	description: The profiles specify the parameter used to analyze each file, to exercise different parts of the code.
	default: the default profiles are taken from the definition of the selected benchmark
	

key:overwrite
	value: yes or no
	description: when saving the analysis results, if the result for a file and a profile already exist,
	the result can be overwritten (if overwrite is set to yes) or the old result kept (if overwrite is set to no)
	default: no
	
key:categories
	value: a list of category names as defined in predicate facts e.g. initial_problem,parameters,refinement...
	description:This option specifies the results that are checked. Predicates storing results are divided into 
		related categories and one can select to check only some of the categories.
	default: By default all categories are taken


Examples:

save_regression([]).
	run regression tests and save it with all the default options
	
check_regression([benchmark:testing,  discar output:no,  verbosity:3, profiles:[complete,ubs,lbs], categories:[closed_bounds]]).
	check regression test benchmark 'testing' printing out the output of each CoFloCo's execution (discard_output:no) and
	detailed information about the comparison (verbosity:3).
	This command runs 3 profiles in each file (complete,ubs,lbs) but only compares the information in the predicates
	that belong to the category (closed_bounds)
	
@author Antonio Flores Montoya

@copyright Copyright (C) 2014-2017 Antonio Flores Montoya

@license This file is part of CoFloCo. 
    CoFloCo is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    any later version.

    CoFloCo is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with CoFloCo.  If not, see <http://www.gnu.org/licenses/>.
*/

:-module(regression_tests,[
	save_regression/0,
	save_regression/1,
	check_regression/0,
	check_regression/1,
	save_regression_file/1,
	save_regression_file/2,
	check_regression_file/1,
	check_regression_file/2
	]).

:-use_module('../src/main_cofloco').
:-use_module(library(clpfd)).
:-use_module(stdlib(set_list),[from_list_sl/2,difference_sl/3]).

%benchmark definitions
benchmark(testing,['../examples/testing'],[default,complete,completeCompress1,completeCompress2]).
benchmark(all,['../examples'],[ubsCompress2]).
benchmark(imperative,['../examples/examples_from_literature'],[ubs,lbs]).
benchmark(imperative_long,['../examples/examples_from_literature','../examples/challenging_patterns'],[ubsCompress1,ubsCandidatesCompress]).
benchmark(functional,['../examples/raML'],[ubs,lbs]).

%file extension definitions
input_format('.ces').
excluded_input_format('.excluded.ces').

%profile definitions
profile_list([
	profile(default,[]),
	profile(complete,['-v',3,'-debug','-conditional_ubs','yes','-conditional_lbs','yes']),
	profile(completeCompress1,['-compress_chains','1','-solve_fast','-conditional_ubs','yes','-conditional_lbs','yes']),
	profile(completeCompress2,['-compress_chains','2','-solve_fast','-conditional_ubs','yes','-conditional_lbs','yes']),
	
	profile(ubs,['-solve_fast','-compute_ubs','yes','-compute_lbs','no','-conditional_ubs','yes']),
	profile(ubsCompress1,['-solve_fast','-compute_ubs','yes','-compute_lbs','no','-compress_chains',1]),
	profile(ubsCompress2,['-solve_fast','-compute_ubs','yes','-compute_lbs','no','-compress_chains',2]),
	
	profile(ubsCandidates,['-solve_fast','-compute_ubs','yes','-compute_lbs','no','-n_candidates',2]),
	profile(ubsCandidatesCompress,['-solve_fast','-compute_ubs','yes','-compute_lbs','no','-n_candidates',2,'-compress_chains',1]),
	
	profile(lbs,['-solve_fast','-compute_ubs','no','-compute_lbs','yes','-conditional_lbs','yes']),
	profile(lbsCompress1,['-compress_chains',1,'-solve_fast','-compute_ubs','no','-compute_lbs','yes','-conditional_lbs','yes']),
	profile(lbsCompress2,['-compress_chains',2,'-solve_fast','-compute_ubs','no','-compute_lbs','yes','-conditional_lbs','yes'])

	
]).

%stored results definitions
facts([
	category(initial_problem,
		[pred(db,input_eq,5),
		pred(db,entry_eq,2),
		pred(db,ground_equation_header,1),
		pred(db,reset_scc,3),
		pred(db,input_output_vars,3)
	]),
	category(parameters,[pred(params,param,2)]),
	category(preprocessing,
		[pred('SCCs',crs_graph,1),
		pred('SCCs',crs_scc,6)]),
	category(refinement, [
		pred(db,eq_ph,8),
		pred(db,eq_refined,2),
		pred(db,loop_ph,6),
		pred(db,phase_loop,5), 
		pred(chains,chain,3),
		pred(chains,phase,3)
	]),
	category(invariants,
	[
	 	pred(invariants,backward_invariant,4),
		pred(invariants,context_insensitive_backward_invariant,3),
	  	pred(invariants,forward_invariant,4),
	 	pred(invariants,context_insensitive_forward_invariant,3),
	 	pred(invariants,scc_forward_invariant,3),
	 	pred(invariants,phase_transitive_closure,5),
	 	pred(invariants,phase_transitive_star_closure,5),
	 	pred(db,external_call_pattern,5)
	]),
	category(termination,
	[  
		 pred(ranking_functions,ranking_function,4),	
		 pred(ranking_functions,partial_ranking_function,7),
		 pred(termination_checker,termination_argument,4),
		 pred(db,non_terminating_chain,3)
	]),
	category(bounds,
	[
		 pred(phase_solver,phase_cost,4),
		 pred(cost_equation_solver,loop_cost,5),
		 pred(chain_solver,chain_cost,5),
		 pred(db,upper_bound,4),
		 pred(db,external_upper_bound,3)
	]),
	category(closed_bounds,
	[
  		pred(db,closed_upper_bound,3),
  		pred(db,closed_lower_bound,3),
  		pred(db,single_closed_upper_bound,2),
  		pred(db,conditional_bound,3)
	])
]).




get_option(Options,Key,Val):-
	member(Key:Val2,Options),!,
	Val=Val2.
%default options	
get_option(_,verbosity,1).
get_option(_,discard_output,yes).
get_option(_,benchmark,testing).
get_option(_,overwrite,no).

get_option(Options,profiles,DefaultProfiles):-
	get_option(Options,benchmark,Benchmark),
	benchmark(Benchmark,_,DefaultProfiles).
	
get_option(_,categories,CategoryNames):-
	facts(Categories),
	maplist(get_category_name,Categories,CategoryNames).
get_category_name(category(Name,_),Name).


save_regression:-
	save_regression([]).
	
save_regression(Options):-
	get_option(Options,benchmark,BenchmarkName),
	benchmark(BenchmarkName,Paths,_),
	input_format(InputFormat),
	excluded_input_format(ExcludedFormat),
	foldl(get_files_recursively(InputFormat,ExcludedFormat),Paths,[],Entries),
	foldl(analyze_file(save,Options),Entries,[],[]).

check_regression:-
	check_regression([]).
	
check_regression(Options):-
	get_option(Options,benchmark,BenchmarkName),
	benchmark(BenchmarkName,Paths,_),
	input_format(InputFormat),
	excluded_input_format(ExcludedFormat),
	foldl(get_files_recursively(InputFormat,ExcludedFormat),Paths,[],Entries),
	foldl(analyze_file(check,Options),Entries,[],ResultSummary),
	print_summary(ResultSummary).

		
save_regression_file(File):-
	save_regression_file(File,[]).		
save_regression_file(File,Options):-
	analyze_file(save,Options,File,[],[]).

check_regression_file(File):-
	check_regression_file(File,[]).
check_regression_file(File,Options):-
	analyze_file(check,Options,File,[],ResultSummary),
	print_summary(ResultSummary).
		
analyze_file(CheckSave,Options,Entry,Accum,Results):-
	ansi_format([bold],'Example ~p~n',[Entry]), 		 		 	    
	get_result_file(Entry,ResultFile),
	%(CheckSave=save->
	%	reset_file(ResultFile);true),
	get_option(Options,profiles,Profiles),
	get_profiles(Profiles,ProfileList),
	foldl(analyze_file_profile(CheckSave,Options,Entry,ResultFile),ProfileList,Accum,Results).

get_profiles(ProfileNames,ProfilesSelected):-
	profile_list(Profiles),
	include(profile_name_in_list(ProfileNames),Profiles,ProfilesSelected).

profile_name_in_list(Names,profile(Name,_)):-
	member(Name,Names),!.
	
analyze_file_profile(CheckSave,Options,Entry,ResultFile,profile(ProfileName,Params),Accum,Results):-	
	(get_option(Options,discard_output,yes)->
		open_null_stream(S),
		set_output(S),
		%fixme a query should not have backtracking
		catch(cofloco_query(['-i',Entry|Params]),Exception,true),!	,
		set_output(user_output),
		close(S)
		;
		%fixme a query should not have backtracking
		catch(cofloco_query(['-i',Entry|Params]),Exception,true),!
	),
	(CheckSave=save->
		save_analysis(Options,ResultFile,ProfileName,Exception),
		Results=Accum
		;
		check_analysis(ResultFile,ProfileName,Exception,Options,Result),
		Results=[(Entry, ProfileName,Result)|Accum]
	),!.%cut any unwanted choice point

 
check_analysis(File,ProfileName,Exception,Options,Res):-
	collect_results(ProfileName,Exception,NewResult),
	catch(
	(	open(File,read,S),
		(read_results(S,ProfileName,OldResult)->
			compare_results(NewResult,OldResult,Options,Res)
			;
			Res=false
		),
		close(S)
	),
		_,
		(Res=false,ansi_format([fg(red)],'File ~p not found~n',[File]))
	).
	

compare_results(result(ProfileName,Categories,Exception),
		 	    result(ProfileName,Categories2,Exception2),Options,Res):-
	ansi_format([bold],'Checking run profile ~p~n',[ProfileName]), 		 		 	    
	ansi_format([bold],'Checking exception~n',[]), 		 	 
	(Exception=Exception2->	ResException=true;ResException=false),
	result_message(ResException,'Exception ',[]),
	
	get_option(Options,verbosity,Verbosity),
	get_option(Options,categories,CategoryNames),
	
    cond_message(Verbosity,1,print_diffs(ResException,Exception,Exception2)),	
	foldl(compare_category(Verbosity,CategoryNames),Categories,Categories2,true,ResCategories),
	and(ResException,ResCategories,Res),
	result_message(Res,'Run profile ~p ',[ProfileName]).

	

compare_category(Verbosity,Categories,categoryRes(Name,PredicateRes),categoryRes(Name,PredicateRes2),ResAccum,ResOut):-
	member(Name,Categories),!,
	cond_message(Verbosity,1,ansi_format([bold],'Checking category ~p~n',[Name])), 		
	foldl(compare_predicate(Verbosity),PredicateRes,PredicateRes2,true,Res),
	cond_message(Verbosity,1,result_message(Res,'Category ~p ',[Name])),
	and(ResAccum,Res,ResOut).
 
compare_category(_Verbosity,_Categories,categoryRes(Name,_PredicateRes),categoryRes(Name,_PredicateRes2),Res,Res).
	
compare_predicate(Verbosity,predicateRes(Name/Arity,Set),predicateRes(Name/Arity,Set2),ResAccum,ResOut):-
	difference_sl(Set,Set2,Diff1),
	difference_sl(Set2,Set,Diff2),	
	((Diff1=[],Diff2=[])->	Res=true;Res=false),
	cond_message(Verbosity,2,result_message(Res,'Predicate ~p ',[Name/Arity])),
    cond_message(Verbosity,3,print_diffs(Res,Diff1,Diff2)),
    and(ResAccum,Res,ResOut).

cond_message(Verbosity,Level,Pred):-
	(Verbosity >= Level->
		call(Pred)
		;
		true).

print_summary(ResultSummary):-
	ansi_format([bold],'Summary of the regression test~n',[]),
	reverse(ResultSummary,Rev),
	maplist(print_summary_elem,Rev).
	
print_summary_elem((File,Profile,Result)):-
	result_message(Result,'File: ~p Profile ~p ',[File,Profile]).

print_diffs(false,Diff1,Diff2):-
	ansi_format([fg(red)],'New: ~p~n',[Diff1]), 
	ansi_format([fg(red)],'Original: ~p~n',[Diff2]).
print_diffs(true,_Diff1,_Diff2).

result_message(true,Message,Elems):-	
		ansi_format([fg(green)],Message,Elems),
		ansi_format([fg(green)],'OK~n',[]).
result_message(false,Message,Elems):-	
		ansi_format([fg(red)],Message,Elems),
		ansi_format([fg(red)],'FAIL~n',[]).		

and(true,true,true):-!.
and(_,_,false).

%TODO
save_analysis(Options,File,ProfileName,Exception):-
	collect_results(ProfileName,Exception,NewResult),
	update_results(Options,File,NewResult).
	
collect_results(ProfileName,Exception,result(ProfileName,Results,Exception)):-
	facts(Categories),
	(Exception=none->true;true),
	maplist(collect_category,Categories,Results).

collect_category(category(Name,Predicates),categoryRes(Name,PredicateContents)):-
	maplist(collect_predicate,Predicates,PredicateContents).
	
collect_predicate(pred(Module,Name,Arity),predicateRes(Name/Arity,ResultSet)):-
	functor(Template,Name,Arity),
	findall(Template,
	(call(Module:Template),
	 max_var_number(Template,1,Max),
	 Next #= Max+1,
	 numbervars(Template,Next,_)
	 ),ResultList),
	 from_list_sl(ResultList,ResultSet).
	


read_results(S,ProfileName,Result) :-
	%results have to be ground
	read_term(S,Term,[variable_names([])]),
	(
		Term=result(ProfileName,_,_)->
		Result=Term
	; 
	  	Term == end_of_file->
	  	ansi_format([fg(red)],'Result with profile ~p not found~n',[ProfileName]),
	  	fail
	    
	;
	    read_results(S,ProfileName,Result)
	).
read_all_results(S,Results) :-
	%results have to be ground
	read_term(S,Term,[variable_names([])]),
	(
		Term=result(_,_,_)->
		Results=[Term|Results1],
		read_all_results(S,Results1)
	; 
	  	Term == end_of_file->
	  	Results=[]
	;
		ansi_format([fg(red)],'Read illegal term ~p~n',[Term]),
	    read_all_results(S,Results)
	).



save_results(S,Result):-
	set_prolog_flag(print_write_options,[quoted(true),numbervars(false)]),
	pretty_print_result(S,Result).

update_results(Options,File, Result):-
	catch(
		(
		open(File,read,Sread),
		read_all_results(Sread,All_results),
		close(Sread)
		)
	,_Expception,All_results=[]),
	result_name(Result,ProfileName),
	(results_contain(All_results,ProfileName)->
		(get_option(Options,overwrite,no)->
			ansi_format([fg(red)],'Result with profile ~p already exists, not overwritten~n',[ProfileName])
			;
			open(File,update,Supdate),
			ansi_format([fg(red)],'Result with profile ~p already exists, overwritten~n',[ProfileName]),
			results_update(All_results,Result,Updated_results),
			maplist(save_results(Supdate),Updated_results),
			set_end_of_stream(Supdate),
			close(Supdate)
		)
		;
		open(File,append,Sappend),
		save_results(Sappend,Result),
		close(Sappend)
	).

result_name(result(Name,_,_),Name).

results_contain([result(Name,_,_)|_],Name):-!.
results_contain([result(_OtherName,_,_)|Results],Name):-
	results_contain(Results,Name).

%assume the result appear one and only once in the list
results_update([result(Name,_,_)|Rest],result(Name,Categories2,Exception2),[result(Name,Categories2,Exception2)|Rest]).
results_update([result(Name,Categories,Exception)|Rest],result(Name2,Categories2,Exception2),[result(Name,Categories,Exception)|Rest2]):-
	Name\==Name2,
	results_update(Rest,result(Name2,Categories2,Exception2),Rest2).
	

pretty_print_result(S,result(Name,Categories,Exception)):-	
   	format(S,'result(~p,~n',[Name]),
   	print_list(Categories,S,print_category),
   	format(S,'~n,~p).~n~n~n',[Exception]).
   
 print_category(S,categoryRes(Name,Predicates)):-
	format(S,'categoryRes(~p,~n',[Name]),
   	print_list(Predicates,S,print_predicate),
   	format(S,'~n)~n',[]).

print_predicate(S,predicateRes(Name,Set)):-
	format(S,'predicateRes(~p,~n',[Name]),
   	print_list(Set,S,print_clause),
   	format(S,'~n)~n',[]).	

print_clause(S,Clause):-
	format(S,'~p~n',[Clause]).	
	
print_list(List,S,Pred):-
	format(S,'[',[]),
	print_list1(List,S,Pred).
	
print_list1([],S,_Pred):-
	format(S,']',[]).	
print_list1([Last],S,Pred):-
	Call=..[Pred,S,Last],
	call(Call),
	format(S,']',[]).
print_list1([One,Two|More],S,Pred):-
	Call=..[Pred,S,One],
	call(Call),
	format(S,',',[]),
	print_list1([Two|More],S,Pred).
	
	
get_result_file(Entry,ResultFile):-
	atom_concat(Entry,'.results',ResultFile).

reset_file(File):-
	open(File,write,S),
	close(S).	
	





get_files_recursively(Extension,ExcludedExtension,Base_dir,Accum_files,Files):-
	directory_files(Base_dir,Entries),
	delete(Entries,'.',Entries2),
	delete(Entries2,'..',Entries3),
	
	atom_concat(Base_dir,'/',Base_dir_bar),
	maplist(atom_concat(Base_dir_bar),Entries3,Full_entries),
	partition(exists_directory,Full_entries,Directories,Local_files),
	foldl(get_files_recursively(Extension,ExcludedExtension),Directories,Accum_files,Accum_files2),
	include(file_ends_with(Extension),Local_files,Selected_files),
	exclude(file_ends_with(ExcludedExtension),Selected_files,Selected_files2),
	sort(Selected_files2,Selected_files2_sorted),
	append(Selected_files2_sorted,Accum_files2,Files).
	

file_ends_with(Ext,Name):-
	atom_concat(_,Ext,Name).
