
Resource Aware ML, Version 1.3.1, October 2016

Typechecking module ...
  Typecheck successful.
  Stack-based typecheck successful.

Analyzing function size ...

  Trying degree: 1

== size :

  'a list -> int

  Non-zero annotations of the argument:
     11.00  <--  [::(*)]
      3.00  <--  []

  Non-zero annotations of result:

  Simplified bound:
     3.00 + 11.00*M
   where
     M is the number of ::-nodes of the argument

--
  Mode:          upper
  Metric:        steps
  Degree:        1
  Run time:      0.01 seconds
  #Constraints:  29

====

Analyzing function check_lists ...

  Trying degree: 1, 2

== check_lists :

  ['a list list; int] -> bool

  Non-zero annotations of the argument:
     11.00  <--  ([::([::(*)])], *)
     19.00  <--  ([::([])], *)
      3.00  <--  ([], *)

  Non-zero annotations of result:

  Simplified bound:
     3.00 + 11.00*L*M + 19.00*M
   where
     M is the number of ::-nodes of the 1st component of the argument
     L is the maximal number of ::-nodes in the ::-nodes of the 1st component of the argument

--
  Mode:          upper
  Metric:        steps
  Degree:        2
  Run time:      0.06 seconds
  #Constraints:  161

====

Analyzing function check_mat ...

  Trying degree: 1, 2

== check_mat :

  [int; int; 'a list list] -> bool

  Non-zero annotations of the argument:
     11.00  <--  (*, *, [::([::(*)])])
     30.00  <--  (*, *, [::([])])
     18.00  <--  (*, *, [])

  Non-zero annotations of result:

  Simplified bound:
     18.00 + 11.00*L*M + 30.00*M
   where
     M is the number of ::-nodes of the 3rd component of the argument
     L is the maximal number of ::-nodes in the ::-nodes of the 3rd component of the argument

--
  Mode:          upper
  Metric:        steps
  Degree:        2
  Run time:      0.08 seconds
  #Constraints:  262

====

Analyzing function check_matrix ...

  Trying degree: 1, 2

== check_matrix :

  int * int * 'a list list -> bool

  Non-zero annotations of the argument:
     11.00  <--  (*, *, [::([::(*)])])
     30.00  <--  (*, *, [::([])])
     25.00  <--  (*, *, [])

  Non-zero annotations of result:

  Simplified bound:
     25.00 + 11.00*L*M + 30.00*M
   where
     M is the number of ::-nodes of the 3rd component of the argument
     L is the maximal number of ::-nodes in the ::-nodes of the 3rd component of the argument

--
  Mode:          upper
  Metric:        steps
  Degree:        2
  Run time:      0.09 seconds
  #Constraints:  271

====

Analyzing function construct_matrix ...

  Trying degree: 1, 2

== construct_matrix :

  [int; int; 'a list list] -> int * int * 'a list list

  Non-zero annotations of the argument:
     11.00  <--  (*, *, [::([::(*)])])
     30.00  <--  (*, *, [::([])])
     28.00  <--  (*, *, [])

  Non-zero annotations of result:

  Simplified bound:
     28.00 + 11.00*L*M + 30.00*M
   where
     M is the number of ::-nodes of the 3rd component of the argument
     L is the maximal number of ::-nodes in the ::-nodes of the 3rd component of the argument

--
  Mode:          upper
  Metric:        steps
  Degree:        2
  Run time:      0.13 seconds
  #Constraints:  349

====

Analyzing function get_elem ...

  Trying degree: 1

== get_elem :

  ['a list; int] -> 'a

  Non-zero annotations of the argument:
     18.00  <--  ([::(*)], *)
      2.00  <--  ([], *)

  Non-zero annotations of result:

  Simplified bound:
     2.00 + 18.00*M
   where
     M is the number of ::-nodes of the 1st component of the argument

--
  Mode:          upper
  Metric:        steps
  Degree:        1
  Run time:      0.04 seconds
  #Constraints:  41

====

Analyzing function get_elem ...

  Trying degree: 1, 2

== get_elem :

  ['a * 'b * 'c list list; int; int] -> 'c

  Non-zero annotations of the argument:
     18.00  <--  ((*, *, [::([::(*)])]), *, *)
     18.00  <--  ((*, *, [::([])]), *, *)
      9.00  <--  ((*, *, []), *, *)

  Non-zero annotations of result:

  Simplified bound:
     9.00 + 18.00*L*M + 18.00*M
   where
     M is the number of ::-nodes of the 3rd component of the 1st component of the argument
     L is the maximal number of ::-nodes in the ::-nodes of the 3rd component of the 1st component of the argument

--
  Mode:          upper
  Metric:        steps
  Degree:        2
  Run time:      0.10 seconds
  #Constraints:  182

====

Analyzing function op ...

  Trying degree: 1

== op :

  [int; int; int] -> int

  Non-zero annotations of the argument:
     13.00  <--  (*, *, *)

  Non-zero annotations of result:

  Simplified bound:
     13.00
--
  Mode:          upper
  Metric:        steps
  Degree:        1
  Run time:      0.05 seconds
  #Constraints:  27

====

Analyzing function rec_list ...

  Trying degree: 1

== rec_list :

  [int list; int list; int] -> int list

  Non-zero annotations of the argument:
      2.00  <--  ([::(*)], [], *)
     29.00  <--  ([], [::(*)], *)
      3.00  <--  ([], [], *)

  Non-zero annotations of result:

  Simplified bound:
     3.00 + 29.00*L + 2.00*M
   where
     L is the number of ::-nodes of the 2nd component of the argument
     M is the number of ::-nodes of the 1st component of the argument

--
  Mode:          upper
  Metric:        steps
  Degree:        1
  Run time:      0.08 seconds
  #Constraints:  78

====

Analyzing function rec_mat ...

  Trying degree: 1, 2

== rec_mat :

  [int list list; int list list; int] -> int list list

  Non-zero annotations of the argument:
      2.00  <--  ([::([::(*)])], [], *)
     29.00  <--  ([], [::([::(*)])], *)
     21.00  <--  ([::([])], [], *)
      3.00  <--  ([], [], *)

  Non-zero annotations of result:

  Simplified bound:
     3.00 + 2.00*L*M + 21.00*M + 29.00*R*Y
   where
     Y is the number of ::-nodes of the 2nd component of the argument
     R is the maximal number of ::-nodes in the ::-nodes of the 2nd component of the argument
     M is the number of ::-nodes of the 1st component of the argument
     L is the maximal number of ::-nodes in the ::-nodes of the 1st component of the argument

--
  Mode:          upper
  Metric:        steps
  Degree:        2
  Run time:      0.25 seconds
  #Constraints:  501

====

Analyzing function check_sanity ...

  Trying degree: 1, 2

== check_sanity :

  [int * int * 'a list list; int * int * 'b list list] ->
                       bool

  Non-zero annotations of the argument:
     11.00  <--  ((*, *, [::([::(*)])]), (*, *, []))
     11.00  <--  ((*, *, []), (*, *, [::([::(*)])]))
     30.00  <--  ((*, *, [::([])]), (*, *, []))
     30.00  <--  ((*, *, []), (*, *, [::([])]))
     79.00  <--  ((*, *, []), (*, *, []))

  Non-zero annotations of result:

  Simplified bound:
     79.00 + 11.00*L*M + 30.00*M + 11.00*R*Y + 30.00*Y
   where
     Y is the number of ::-nodes of the 3rd component of the 2nd component of the argument
     R is the maximal number of ::-nodes in the ::-nodes of the 3rd component of the 2nd component of the argument
     M is the number of ::-nodes of the 3rd component of the 1st component of the argument
     L is the maximal number of ::-nodes in the ::-nodes of the 3rd component of the 1st component of the argument

--
  Mode:          upper
  Metric:        steps
  Degree:        2
  Run time:      0.33 seconds
  #Constraints:  681

====

Analyzing function plus ...

  Trying degree: 1, 2

== plus :

  [int * int * int list list; int * int * int list list] ->
               int * int * int list list

  Non-zero annotations of the argument:
     53.00  <--  ((*, *, [::([::(*)])]), (*, *, []))
     11.00  <--  ((*, *, []), (*, *, [::([::(*)])]))
     81.00  <--  ((*, *, [::([])]), (*, *, []))
     30.00  <--  ((*, *, []), (*, *, [::([])]))
    130.00  <--  ((*, *, []), (*, *, []))

  Non-zero annotations of result:

  Simplified bound:
     130.00 + 53.00*L*M + 81.00*M + 11.00*R*Y + 30.00*Y
   where
     Y is the number of ::-nodes of the 3rd component of the 2nd component of the argument
     R is the maximal number of ::-nodes in the ::-nodes of the 3rd component of the 2nd component of the argument
     M is the number of ::-nodes of the 3rd component of the 1st component of the argument
     L is the maximal number of ::-nodes in the ::-nodes of the 3rd component of the 1st component of the argument

--
  Mode:          upper
  Metric:        steps
  Degree:        2
  Run time:      1.61 seconds
  #Constraints:  1891

====

Analyzing function minus ...

  Trying degree: 1, 2

== minus :

  [int * int * int list list; int * int * int list list] ->
                int * int * int list list

  Non-zero annotations of the argument:
     53.00  <--  ((*, *, [::([::(*)])]), (*, *, []))
     11.00  <--  ((*, *, []), (*, *, [::([::(*)])]))
     81.00  <--  ((*, *, [::([])]), (*, *, []))
     30.00  <--  ((*, *, []), (*, *, [::([])]))
    130.00  <--  ((*, *, []), (*, *, []))

  Non-zero annotations of result:

  Simplified bound:
     130.00 + 53.00*L*M + 81.00*M + 11.00*R*Y + 30.00*Y
   where
     Y is the number of ::-nodes of the 3rd component of the 2nd component of the argument
     R is the maximal number of ::-nodes in the ::-nodes of the 3rd component of the 2nd component of the argument
     M is the number of ::-nodes of the 3rd component of the 1st component of the argument
     L is the maximal number of ::-nodes in the ::-nodes of the 3rd component of the 1st component of the argument

--
  Mode:          upper
  Metric:        steps
  Degree:        2
  Run time:      3.31 seconds
  #Constraints:  1891

====

Analyzing function append ...

  Trying degree: 1

== append :

  ['a list; 'a] -> 'a list

  Non-zero annotations of the argument:
     11.00  <--  ([::(*)], *)
      6.00  <--  ([], *)

  Non-zero annotations of result:

  Simplified bound:
     6.00 + 11.00*M
   where
     M is the number of ::-nodes of the 1st component of the argument

--
  Mode:          upper
  Metric:        steps
  Degree:        1
  Run time:      1.63 seconds
  #Constraints:  34

====

Analyzing function append_row ...

  Trying degree: 1, 2

== append_row :

  ['a list list; 'a list] -> 'a list list

  Non-zero annotations of the argument:
     11.00  <--  ([::([::(*)])], [])
     22.00  <--  ([], [::(*)])
      3.00  <--  ([], [])

  Non-zero annotations of result:

  Simplified bound:
     3.00 + 11.00*L*M + 22.00*Y
   where
     Y is the number of ::-nodes of the 2nd component of the argument
     M is the number of ::-nodes of the 1st component of the argument
     L is the maximal number of ::-nodes in the ::-nodes of the 1st component of the argument

--
  Mode:          upper
  Metric:        steps
  Degree:        2
  Run time:      1.97 seconds
  #Constraints:  479

====

Analyzing function transpose_helper ...

  Trying degree: 1, 2, 3

== transpose_helper :

  ['a list list; 'a list list] -> 'a list list

  Non-zero annotations of the argument:
     11.00  <--  ([::([::(*)]); ::([])], [])
     11.00  <--  ([::([])], [::([::(*)])])
     22.00  <--  ([::([::(*)])], [])
     14.00  <--  ([::([])], [])
      3.00  <--  ([], [])

  Non-zero annotations of result:

  Simplified bound:
     3.00 + 16.50*L*M + 5.50*L*M^2 + 14.00*M
                               + 11.00*M*R*Y
   where
     Y is the number of ::-nodes of the 2nd component of the argument
     R is the maximal number of ::-nodes in the ::-nodes of the 2nd component of the argument
     M is the number of ::-nodes of the 1st component of the argument
     L is the maximal number of ::-nodes in the ::-nodes of the 1st component of the argument

--
  Mode:          upper
  Metric:        steps
  Degree:        3
  Run time:      1.26 seconds
  #Constraints:  2625

====

Analyzing function transpose ...

  Trying degree: 1, 2, 3

== transpose :

  'a list list -> 'a list list

  Non-zero annotations of the argument:
     11.00  <--  [::([::(*)]); ::([])]
     22.00  <--  [::([::(*)])]
     14.00  <--  [::([])]
      7.00  <--  []

  Non-zero annotations of result:

  Simplified bound:
     7.00 + 16.50*L*M + 5.50*L*M^2 + 14.00*M
   where
     M is the number of ::-nodes of the argument
     L is the maximal number of ::-nodes in the ::-nodes of the argument

--
  Mode:          upper
  Metric:        steps
  Degree:        3
  Run time:      1.27 seconds
  #Constraints:  2631

====

Analyzing function reverse_helper ...

  Trying degree: 1

== reverse_helper :

  ['a list; 'a list] -> 'a list

  Non-zero annotations of the argument:
     11.00  <--  ([::(*)], [])
      3.00  <--  ([], [])

  Non-zero annotations of result:

  Simplified bound:
     3.00 + 11.00*M
   where
     M is the number of ::-nodes of the 1st component of the argument

--
  Mode:          upper
  Metric:        steps
  Degree:        1
  Run time:      0.60 seconds
  #Constraints:  35

====

Analyzing function reverse ...

  Trying degree: 1

== reverse :

  'a list -> 'a list

  Non-zero annotations of the argument:
     11.00  <--  [::(*)]
      7.00  <--  []

  Non-zero annotations of result:

  Simplified bound:
     7.00 + 11.00*M
   where
     M is the number of ::-nodes of the argument

--
  Mode:          upper
  Metric:        steps
  Degree:        1
  Run time:      0.60 seconds
  #Constraints:  41

====

Analyzing function reverse_rows_helper ...

  Trying degree: 1, 2

== reverse_rows_helper :

  ['a list list; 'a list list] -> 'a list list

  Non-zero annotations of the argument:
     11.00  <--  ([::([::(*)])], [])
     20.00  <--  ([::([])], [])
      3.00  <--  ([], [])

  Non-zero annotations of result:

  Simplified bound:
     3.00 + 11.00*L*M + 20.00*M
   where
     M is the number of ::-nodes of the 1st component of the argument
     L is the maximal number of ::-nodes in the ::-nodes of the 1st component of the argument

--
  Mode:          upper
  Metric:        steps
  Degree:        2
  Run time:      0.70 seconds
  #Constraints:  263

====

Analyzing function reverse_rows ...

  Trying degree: 1, 2

== reverse_rows :

  'a list list -> 'a list list

  Non-zero annotations of the argument:
     11.00  <--  [::([::(*)])]
     31.00  <--  [::([])]
     16.00  <--  []

  Non-zero annotations of result:

  Simplified bound:
     16.00 + 11.00*L*M + 31.00*M
   where
     M is the number of ::-nodes of the argument
     L is the maximal number of ::-nodes in the ::-nodes of the argument

--
  Mode:          upper
  Metric:        steps
  Degree:        2
  Run time:      0.75 seconds
  #Constraints:  377

====

Analyzing function append_start ...

  Trying degree: 1, 2

== append_start :

  ['a list list; 'a list] -> 'a list list

  Non-zero annotations of the argument:
     11.00  <--  ([::([::(*)])], [])
     31.00  <--  ([::([])], [])
     16.00  <--  ([], [::(*)])
     21.00  <--  ([], [])

  Non-zero annotations of result:

  Simplified bound:
     21.00 + 11.00*L*M + 31.00*M + 16.00*Y
   where
     Y is the number of ::-nodes of the 2nd component of the argument
     M is the number of ::-nodes of the 1st component of the argument
     L is the maximal number of ::-nodes in the ::-nodes of the 1st component of the argument

--
  Mode:          upper
  Metric:        steps
  Degree:        2
  Run time:      1.48 seconds
  #Constraints:  1003

====

Analyzing function new_transpose_helper ...

  Trying degree: 1, 2, 3

== new_transpose_helper :

  ['a list list; 'a list list] -> 'a list list

  Non-zero annotations of the argument:
     42.00  <--  ([::([::(*)]); ::([])], [])
     11.00  <--  ([::([])], [::([::(*)])])
     16.00  <--  ([::([::(*)])], [])
     31.00  <--  ([::([])], [::([])])
     32.00  <--  ([::([])], [])
      3.00  <--  ([], [])

  Non-zero annotations of result:

  Simplified bound:
     3.00 - 5.00*L*M + 21.00*L*M^2 + 32.00*M
                               + 11.00*M*R*Y + 31.00*M*Y
   where
     Y is the number of ::-nodes of the 2nd component of the argument
     R is the maximal number of ::-nodes in the ::-nodes of the 2nd component of the argument
     M is the number of ::-nodes of the 1st component of the argument
     L is the maximal number of ::-nodes in the ::-nodes of the 1st component of the argument

--
  Mode:          upper
  Metric:        steps
  Degree:        3
  Run time:      6.58 seconds
  #Constraints:  5254

====

Analyzing function new_transpose ...

  Trying degree: 1, 2, 3

== new_transpose :

  'a list list -> 'a list list

  Non-zero annotations of the argument:
     42.00  <--  [::([::(*)]); ::([])]
     58.00  <--  [::([::(*)])]
     32.00  <--  [::([])]
     25.00  <--  []

  Non-zero annotations of result:

  Simplified bound:
     25.00 + 37.00*L*M + 21.00*L*M^2 + 32.00*M
   where
     M is the number of ::-nodes of the argument
     L is the maximal number of ::-nodes in the ::-nodes of the argument

--
  Mode:          upper
  Metric:        steps
  Degree:        3
  Run time:      2.62 seconds
  #Constraints:  6147

====

Analyzing function prod ...

  Trying degree: 1

== prod :

  [int list; int list] -> int

  Non-zero annotations of the argument:
      2.00  <--  ([::(*)], [])
     16.00  <--  ([], [::(*)])
      3.00  <--  ([], [])

  Non-zero annotations of result:

  Simplified bound:
     3.00 + 16.00*L + 2.00*M
   where
     L is the number of ::-nodes of the 2nd component of the argument
     M is the number of ::-nodes of the 1st component of the argument

--
  Mode:          upper
  Metric:        steps
  Degree:        1
  Run time:      0.96 seconds
  #Constraints:  51

====

Analyzing function prod_mat ...

  Trying degree: 1, 2

== prod_mat :

  [int list; int list list] -> int list

  Non-zero annotations of the argument:
     18.00  <--  ([::(*)], [::([])])
     17.00  <--  ([], [::([])])
      3.00  <--  ([], [])

  Non-zero annotations of result:

  Simplified bound:
     3.00 + 17.00*L + 18.00*L*M
   where
     L is the number of ::-nodes of the 2nd component of the argument
     M is the number of ::-nodes of the 1st component of the argument

--
  Mode:          upper
  Metric:        steps
  Degree:        2
  Run time:      1.08 seconds
  #Constraints:  295

====

Analyzing function mat_mult ...

  Trying degree: 1, 2, 3, 4

== mat_mult :

  [int list list; int list list] -> int list list

  Non-zero annotations of the argument:
     11.00  <--  ([::([])], [::([::(*)]); ::([])])
     53.00  <--  ([::([])], [::([::(*)])])
     11.00  <--  ([], [::([::(*)]); ::([])])
     14.00  <--  ([::([])], [::([])])
     53.00  <--  ([], [::([::(*)])])
     28.00  <--  ([::([])], [])
     14.00  <--  ([], [::([])])
     14.00  <--  ([], [])

  Non-zero annotations of result:

  Simplified bound:
     14.00 + 28.00*M + 47.50*M*R*Y + 5.50*M*R*Y^2
                               + 14.00*M*Y + 47.50*R*Y + 5.50*R*Y^2 + 14.00*Y
   where
     Y is the number of ::-nodes of the 2nd component of the argument
     R is the maximal number of ::-nodes in the ::-nodes of the 2nd component of the argument
     M is the number of ::-nodes of the 1st component of the argument

--
  Mode:          upper
  Metric:        steps
  Degree:        4
  Run time:      16.15 seconds
  #Constraints:  31400

====

Analyzing function lineMult ...

  Trying degree: 1

== lineMult :

  [int; int list; int list] -> int list

  Non-zero annotations of the argument:
     22.00  <--  (*, [::(*)], [])
      3.00  <--  (*, [], [])

  Non-zero annotations of result:

  Simplified bound:
     3.00 + 22.00*M
   where
     M is the number of ::-nodes of the 2nd component of the argument

--
  Mode:          upper
  Metric:        steps
  Degree:        1
  Run time:      1.58 seconds
  #Constraints:  78

====

Analyzing function computeLine ...

  Trying degree: 1, 2

== computeLine :

  [int list; int list list; int list] -> int list

  Non-zero annotations of the argument:
     22.00  <--  ([], [::([::(*)])], [])
     18.00  <--  ([::(*)], [], [])
      3.00  <--  ([], [], [])

  Non-zero annotations of result:

  Simplified bound:
     3.00 + 22.00*L*Y + 18.00*M
   where
     L is the number of ::-nodes of the 2nd component of the argument
     Y is the maximal number of ::-nodes in the ::-nodes of the 2nd component of the argument
     M is the number of ::-nodes of the 1st component of the argument

--
  Mode:          upper
  Metric:        steps
  Degree:        2
  Run time:      4.36 seconds
  #Constraints:  480

====

Analyzing function mat_mult_jan ...

  Trying degree: 1, 2, 3

== mat_mult_jan :

  [int list list; int list list] -> int list list

  Non-zero annotations of the argument:
     22.00  <--  ([::([])], [::([::(*)])])
     18.00  <--  ([::([::(*)])], [])
     18.00  <--  ([::([])], [])
      3.00  <--  ([], [])

  Non-zero annotations of result:

  Simplified bound:
     3.00 + 18.00*L*M + 18.00*M + 22.00*M*R*Y
   where
     Y is the number of ::-nodes of the 2nd component of the argument
     R is the maximal number of ::-nodes in the ::-nodes of the 2nd component of the argument
     M is the number of ::-nodes of the 1st component of the argument
     L is the maximal number of ::-nodes in the ::-nodes of the 1st component of the argument

--
  Mode:          upper
  Metric:        steps
  Degree:        3
  Run time:      4.60 seconds
  #Constraints:  3451

====

Analyzing function check_mult_sanity ...

  Trying degree: 1, 2

== check_mult_sanity :

  [int * int * 'a list list;
                            int * int * 'b list list] -> bool

  Non-zero annotations of the argument:
     11.00  <--  ((*, *, [::([::(*)])]), (*, *, []))
     11.00  <--  ((*, *, []), (*, *, [::([::(*)])]))
     30.00  <--  ((*, *, [::([])]), (*, *, []))
     30.00  <--  ((*, *, []), (*, *, [::([])]))
     71.00  <--  ((*, *, []), (*, *, []))

  Non-zero annotations of result:

  Simplified bound:
     71.00 + 11.00*L*M + 30.00*M + 11.00*R*Y + 30.00*Y
   where
     Y is the number of ::-nodes of the 3rd component of the 2nd component of the argument
     R is the maximal number of ::-nodes in the ::-nodes of the 3rd component of the 2nd component of the argument
     M is the number of ::-nodes of the 3rd component of the 1st component of the argument
     L is the maximal number of ::-nodes in the ::-nodes of the 3rd component of the 1st component of the argument

--
  Mode:          upper
  Metric:        steps
  Degree:        2
  Run time:      1.68 seconds
  #Constraints:  665

====

Analyzing function mult ...

  Trying degree: 1, 2, 3

== mult :

  [int * int * int list list; int * int * int list list] ->
               int * int * int list list

  Non-zero annotations of the argument:
     27.00  <--  ((*, *, [::([])]), (*, *, [::([::(*)])]))
     13.00  <--  ((*, *, [::([::(*)])]), (*, *, []))
     16.00  <--  ((*, *, [::([])]), (*, *, [::([])]))
     11.00  <--  ((*, *, []), (*, *, [::([::(*)])]))
     78.00  <--  ((*, *, [::([])]), (*, *, []))
     30.00  <--  ((*, *, []), (*, *, [::([])]))
    121.00  <--  ((*, *, []), (*, *, []))

  Non-zero annotations of result:

  Simplified bound:
     121.00 + 13.00*L*M + 78.00*M + 27.00*M*R*Y
                               + 16.00*M*Y + 11.00*R*Y + 30.00*Y
   where
     Y is the number of ::-nodes of the 3rd component of the 2nd component of the argument
     R is the maximal number of ::-nodes in the ::-nodes of the 3rd component of the 2nd component of the argument
     M is the number of ::-nodes of the 3rd component of the 1st component of the argument
     L is the maximal number of ::-nodes in the ::-nodes of the 3rd component of the 1st component of the argument

--
  Mode:          upper
  Metric:        steps
  Degree:        3
  Run time:      8.66 seconds
  #Constraints:  7084

====

Analyzing function evaluate ...

  Trying degree: 1, 2, 3, 4, 5, 6

  A bound for evaluate could not be derived. The linear program is infeasible.

--
  Mode:          upper
  Metric:        steps
  Degree:        6
  Run time:      5.57 seconds
  #Constraints:  8

====

Analyzing function del ...

  Trying degree: 1

== del :

  ['a list; int] -> 'a list

  Non-zero annotations of the argument:
     21.00  <--  ([::(*)], *)
      2.00  <--  ([], *)

  Non-zero annotations of result:

  Simplified bound:
     2.00 + 21.00*M
   where
     M is the number of ::-nodes of the 1st component of the argument

--
  Mode:          upper
  Metric:        steps
  Degree:        1
  Run time:      2.04 seconds
  #Constraints:  48

====

Analyzing function submat ...

  Trying degree: 1, 2

== submat :

  ['a list list; int; int] -> 'a list list

  Non-zero annotations of the argument:
     21.00  <--  ([::([::(*)])], *, *)
     19.00  <--  ([::([])], *, *)
      3.00  <--  ([], *, *)

  Non-zero annotations of result:

  Simplified bound:
     3.00 + 21.00*L*M + 19.00*M
   where
     M is the number of ::-nodes of the 1st component of the argument
     L is the maximal number of ::-nodes in the ::-nodes of the 1st component of the argument

--
  Mode:          upper
  Metric:        steps
  Degree:        2
  Run time:      2.28 seconds
  #Constraints:  412

====

Analyzing function remFirstRow ...

  Trying degree: 1

== remFirstRow :

  'a list -> 'a list

  Non-zero annotations of the argument:
      3.00  <--  []

  Non-zero annotations of result:

  Simplified bound:
     3.00
--
  Mode:          upper
  Metric:        steps
  Degree:        1
  Run time:      4.00 seconds
  #Constraints:  12

====

