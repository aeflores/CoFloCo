
Resource Aware ML, Version 1.3.1, October 2016

Typechecking module ...
  Typecheck successful.
  Stack-based typecheck successful.

Analyzing function eval2 ...

  Trying degree: 1

== eval2 :

  [int; bool; int; bool; bool_expr] -> bool

  Non-zero annotations of the argument:
     14.00  <--  (*, *, *, *, [Not(*)])
     38.00  <--  (*, *, *, *, [And(*)])
     38.00  <--  (*, *, *, *, [Or(*)])
     17.00  <--  (*, *, *, *, [])

  Non-zero annotations of result:

  Simplified bound:
     17.00 + 38.00*K + 38.00*L + 14.00*M
   where
     L is the number of Or-nodes of the 5th component of the argument
     K is the number of And-nodes of the 5th component of the argument
     M is the number of Not-nodes of the 5th component of the argument

--
  Mode:          upper
  Metric:        steps
  Degree:        1
  Run time:      0.06 seconds
  #Constraints:  139

====

Analyzing function table2 ...

  Trying degree: 1

== table2 :

  [int; int; bool_expr] -> (bool * bool * bool) list

  Non-zero annotations of the argument:
     56.00  <--  (*, *, [Not(*)])
    152.00  <--  (*, *, [And(*)])
    152.00  <--  (*, *, [Or(*)])
    117.00  <--  (*, *, [])

  Non-zero annotations of result:

  Simplified bound:
     117.00 + 152.00*K + 152.00*L + 56.00*M
   where
     L is the number of Or-nodes of the 3rd component of the argument
     K is the number of And-nodes of the 3rd component of the argument
     M is the number of Not-nodes of the 3rd component of the argument

--
  Mode:          upper
  Metric:        steps
  Degree:        1
  Run time:      0.21 seconds
  #Constraints:  626

====

Analyzing function assoc ...

  Trying degree: 1

== assoc :

  [int; (int * 'a) list] -> 'a

  Non-zero annotations of the argument:
     16.00  <--  (*, [::(*, *)])
      2.00  <--  (*, [])

  Non-zero annotations of result:

  Simplified bound:
     2.00 + 16.00*M
   where
     M is the number of ::-nodes of the 2nd component of the argument

--
  Mode:          upper
  Metric:        steps
  Degree:        1
  Run time:      0.08 seconds
  #Constraints:  37

====

Analyzing function rev ...

  Trying degree: 1

== rev :

  'a list -> 'a list

  Non-zero annotations of the argument:
     11.00  <--  [::(*)]
      9.00  <--  []

  Non-zero annotations of result:

  Simplified bound:
     9.00 + 11.00*M
   where
     M is the number of ::-nodes of the argument

--
  Mode:          upper
  Metric:        steps
  Degree:        1
  Run time:      0.08 seconds
  #Constraints:  42

====

Analyzing function concat ...

  Trying degree: 1

== concat :

  ['a list; 'a list] -> 'a list

  Non-zero annotations of the argument:
     11.00  <--  ([::(*)], [])
      3.00  <--  ([], [])

  Non-zero annotations of result:

  Simplified bound:
     3.00 + 11.00*M
   where
     M is the number of ::-nodes of the 1st component of the argument

--
  Mode:          upper
  Metric:        steps
  Degree:        1
  Run time:      0.08 seconds
  #Constraints:  35

====

Analyzing function eval ...

  Trying degree: 1, 2

== eval :

  [(int * bool) list; bool_expr] -> bool

  Non-zero annotations of the argument:
     16.00  <--  ([::(*, *)], [And(*)])
     16.00  <--  ([::(*, *)], [Or(*)])
     16.00  <--  ([::(*, *)], [])
     11.00  <--  ([], [Not(*)])
     20.00  <--  ([], [And(*)])
     20.00  <--  ([], [Or(*)])
     10.00  <--  ([], [])

  Non-zero annotations of result:
      5.00  <--  *

  Simplified bound:
     10.00 + 11.00*L + 16.00*M + 16.00*M*X + 16.00*M*Y
                               + 20.00*X + 20.00*Y
   where
     Y is the number of Or-nodes of the 2nd component of the argument
     X is the number of And-nodes of the 2nd component of the argument
     L is the number of Not-nodes of the 2nd component of the argument
     M is the number of ::-nodes of the 1st component of the argument

--
  Mode:          upper
  Metric:        steps
  Degree:        2
  Run time:      0.52 seconds
  #Constraints:  1864

====

Analyzing function table_make ...

  Trying degree: 1, 2, 3, 