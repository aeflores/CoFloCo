
Resource Aware ML, Version 1.3.1, October 2016

Typechecking module ...
  Typecheck successful.
  Stack-based typecheck successful.

Analyzing function last ...

  Trying degree: 1

== last :

  'a list -> 'a option

  Non-zero annotations of the argument:
      9.00  <--  [::(*)]
      3.00  <--  []

  Non-zero annotations of result:

  Simplified bound:
     3.00 + 9.00*M
   where
     M is the number of ::-nodes of the argument

--
  Mode:          upper
  Metric:        steps
  Degree:        1
  Run time:      0.03 seconds
  #Constraints:  41

====

Analyzing function last_two ...

  Trying degree: 1

== last_two :

  'a list -> ('a * 'a) option

  Non-zero annotations of the argument:
     11.00  <--  [::(*)]
      3.00  <--  []

  Non-zero annotations of result:

  Simplified bound:
     3.00 + 11.00*M
   where
     M is the number of ::-nodes of the argument

--
  Mode:          upper
  Metric:        steps
  Degree:        1
  Run time:      0.05 seconds
  #Constraints:  58

====

Analyzing function at ...

  Trying degree: 1

== at :

  [int; 'a list] -> 'a option

  Non-zero annotations of the argument:
     18.00  <--  (*, [::(*)])
      3.00  <--  (*, [])

  Non-zero annotations of result:

  Simplified bound:
     3.00 + 18.00*M
   where
     M is the number of ::-nodes of the 2nd component of the argument

--
  Mode:          upper
  Metric:        steps
  Degree:        1
  Run time:      0.05 seconds
  #Constraints:  49

====

Analyzing function length ...

  Trying degree: 1

== length :

  'a list -> int

  Non-zero annotations of the argument:
     12.00  <--  [::(*)]
      9.00  <--  []

  Non-zero annotations of result:

  Simplified bound:
     9.00 + 12.00*M
   where
     M is the number of ::-nodes of the argument

--
  Mode:          upper
  Metric:        steps
  Degree:        1
  Run time:      0.05 seconds
  #Constraints:  37

====

Analyzing function rev ...

  Trying degree: 1

== rev :

  'a list -> 'a list

  Non-zero annotations of the argument:
     11.00  <--  [::(*)]
      9.00  <--  []

  Non-zero annotations of result:

  Simplified bound:
     9.00 + 11.00*M
   where
     M is the number of ::-nodes of the argument

--
  Mode:          upper
  Metric:        steps
  Degree:        1
  Run time:      0.06 seconds
  #Constraints:  42

====

Analyzing function eq_lists ...

  Trying degree: 1

== eq_lists :

  [int list; int list] -> bool

  Non-zero annotations of the argument:
     17.00  <--  ([::(*)], [])
      1.00  <--  ([], [::(*)])
      5.00  <--  ([], [])

  Non-zero annotations of result:

  Simplified bound:
     5.00 + 1.00*L + 17.00*M
   where
     L is the number of ::-nodes of the 2nd component of the argument
     M is the number of ::-nodes of the 1st component of the argument

--
  Mode:          upper
  Metric:        steps
  Degree:        1
  Run time:      0.08 seconds
  #Constraints:  62

====

Analyzing function is_palindrome ...

  Trying degree: 1

== is_palindrome :

  int list -> bool

  Non-zero annotations of the argument:
     29.00  <--  [::(*)]
     20.00  <--  []

  Non-zero annotations of result:

  Simplified bound:
     20.00 + 29.00*M
   where
     M is the number of ::-nodes of the argument

--
  Mode:          upper
  Metric:        steps
  Degree:        1
  Run time:      0.11 seconds
  #Constraints:  115

====

Analyzing function compress ...

  Trying degree: 1

== compress :

  int list -> int list

  Non-zero annotations of the argument:
     18.00  <--  [::(*)]
      3.00  <--  []

  Non-zero annotations of result:

  Simplified bound:
     3.00 + 18.00*M
   where
     M is the number of ::-nodes of the argument

--
  Mode:          upper
  Metric:        steps
  Degree:        1
  Run time:      0.11 seconds
  #Constraints:  64

====

Analyzing function pack ...

  Trying degree: 1

== pack :

  int list -> int list list

  Non-zero annotations of the argument:
     34.00  <--  [::(*)]
     21.00  <--  []

  Non-zero annotations of result:

  Simplified bound:
     21.00 + 34.00*M
   where
     M is the number of ::-nodes of the argument

--
  Mode:          upper
  Metric:        steps
  Degree:        1
  Run time:      0.24 seconds
  #Constraints:  154

====

Analyzing function encode ...

  Trying degree: 1

== encode :

  int list -> (int * int) list

  Non-zero annotations of the argument:
     37.00  <--  [::(*)]
     21.00  <--  []

  Non-zero annotations of result:

  Simplified bound:
     21.00 + 37.00*M
   where
     M is the number of ::-nodes of the argument

--
  Mode:          upper
  Metric:        steps
  Degree:        1
  Run time:      0.33 seconds
  #Constraints:  151

====

Analyzing function duplicate ...

  Trying degree: 1

== duplicate :

  'a list -> 'a list

  Non-zero annotations of the argument:
     13.00  <--  [::(*)]
      3.00  <--  []

  Non-zero annotations of result:

  Simplified bound:
     3.00 + 13.00*M
   where
     M is the number of ::-nodes of the argument

--
  Mode:          upper
  Metric:        steps
  Degree:        1
  Run time:      0.29 seconds
  #Constraints:  33

====

Analyzing function replicate ...

  Trying degree: 1, 2, 3, 4, 5, 6

  A bound for replicate could not be derived. The linear program is infeasible.

--
  Mode:          upper
  Metric:        steps
  Degree:        6
  Run time:      4.01 seconds
  #Constraints:  1164

====

Analyzing function drop ...

  Trying degree: 1

== drop :

  ['a list; int] -> 'a list

  Non-zero annotations of the argument:
     21.00  <--  ([::(*)], *)
      9.00  <--  ([], *)

  Non-zero annotations of result:

  Simplified bound:
     9.00 + 21.00*M
   where
     M is the number of ::-nodes of the 1st component of the argument

--
  Mode:          upper
  Metric:        steps
  Degree:        1
  Run time:      0.42 seconds
  #Constraints:  63

====

Analyzing function split ...

  Trying degree: 1

== split :

  ['a list; int] -> 'a list * 'a list

  Non-zero annotations of the argument:
     33.00  <--  ([::(*)], *)
     23.00  <--  ([], *)

  Non-zero annotations of result:

  Simplified bound:
     23.00 + 33.00*M
   where
     M is the number of ::-nodes of the 1st component of the argument

--
  Mode:          upper
  Metric:        steps
  Degree:        1
  Run time:      0.63 seconds
  #Constraints:  160

====

Analyzing function slice ...

  Trying degree: 1

== slice :

  ['a list; int; int] -> 'a list

  Non-zero annotations of the argument:
     21.00  <--  ([::(*)], *, *)
     37.00  <--  ([], *, *)

  Non-zero annotations of result:

  Simplified bound:
     37.00 + 21.00*M
   where
     M is the number of ::-nodes of the 1st component of the argument

--
  Mode:          upper
  Metric:        steps
  Degree:        1
  Run time:      0.73 seconds
  #Constraints:  123

====

Analyzing function concat ...

  Trying degree: 1

== concat :

  ['a list; 'a list] -> 'a list

  Non-zero annotations of the argument:
     11.00  <--  ([::(*)], [])
      3.00  <--  ([], [])

  Non-zero annotations of result:

  Simplified bound:
     3.00 + 11.00*M
   where
     M is the number of ::-nodes of the 1st component of the argument

--
  Mode:          upper
  Metric:        steps
  Degree:        1
  Run time:      0.71 seconds
  #Constraints:  35

====

Analyzing function rotate ...

  Trying degree: 1

== rotate :

  ['a list; int] -> 'a list

  Non-zero annotations of the argument:
     45.00  <--  ([::(*)], *)
     74.00  <--  ([], *)

  Non-zero annotations of result:

  Simplified bound:
     74.00 + 45.00*M
   where
     M is the number of ::-nodes of the 1st component of the argument

--
  Mode:          upper
  Metric:        steps
  Degree:        1
  Run time:      1.12 seconds
  #Constraints:  294

====

Analyzing function removeAt ...

  Trying degree: 1

== removeAt :

  [int; 'a list] -> 'a list

  Non-zero annotations of the argument:
     21.00  <--  (*, [::(*)])
      3.00  <--  (*, [])

  Non-zero annotations of result:

  Simplified bound:
     3.00 + 21.00*M
   where
     M is the number of ::-nodes of the 2nd component of the argument

--
  Mode:          upper
  Metric:        steps
  Degree:        1
  Run time:      0.62 seconds
  #Constraints:  49

====

Analyzing function insertAt ...

  Trying degree: 1

== insertAt :

  ['a; int; 'a list] -> 'a list

  Non-zero annotations of the argument:
     22.00  <--  (*, *, [::(*)])
      3.00  <--  (*, *, [])

  Non-zero annotations of result:

  Simplified bound:
     3.00 + 22.00*M
   where
     M is the number of ::-nodes of the 3rd component of the argument

--
  Mode:          upper
  Metric:        steps
  Degree:        1
  Run time:      0.35 seconds
  #Constraints:  58

====

Analyzing function minusminus ...

  Trying degree: 1, 2, 3, 4, 5, 6

  A bound for minusminus could not be derived. The linear program is infeasible.

--
  Mode:          upper
  Metric:        steps
  Degree:        6
  Run time:      0.81 seconds
  #Constraints:  443

====

Analyzing function random ...

  Trying degree: 1

== random :

  int -> int

  Non-zero annotations of the argument:
      5.00  <--  *

  Non-zero annotations of result:

  Simplified bound:
     5.00
--
  Mode:          upper
  Metric:        steps
  Degree:        1
  Run time:      0.37 seconds
  #Constraints:  8

====

Analyzing function min ...

  Trying degree: 1

== min :

  [int; int] -> int

  Non-zero annotations of the argument:
      9.00  <--  (*, *)

  Non-zero annotations of result:

  Simplified bound:
     9.00
--
  Mode:          upper
  Metric:        steps
  Degree:        1
  Run time:      0.38 seconds
  #Constraints:  15

====

Analyzing function rand_select ...

  Trying degree: 1, 2

== rand_select :

  ['a list; int] -> 'a list

  Non-zero annotations of the argument:
     33.00  <--  ([::(*); ::(*)], *)
     73.00  <--  ([::(*)], *)
     61.00  <--  ([], *)

  Non-zero annotations of result:

  Simplified bound:
     61.00 + 56.50*M + 16.50*M^2
   where
     M is the number of ::-nodes of the 1st component of the argument

--
  Mode:          upper
  Metric:        steps
  Degree:        2
  Run time:      0.90 seconds
  #Constraints:  607

====

Analyzing function lotto_select ...

  Trying degree: 1, 2, 3, 4, 5, 6

  A bound for lotto_select could not be derived. The linear program is infeasible.

--
  Mode:          upper
  Metric:        steps
  Degree:        6
  Run time:      6.37 seconds
  #Constraints:  4160

====

