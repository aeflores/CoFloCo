
Resource Aware ML, Version 1.3.1, October 2016

Typechecking module ...
  Typecheck successful.
  Stack-based typecheck successful.

Analyzing function bitToInt' ...

  Trying degree: 1

== bitToInt' :

  [int list; int] -> int

  Non-zero annotations of the argument:
     20.00  <--  ([::(*)], *)
      3.00  <--  ([], *)

  Non-zero annotations of result:

  Simplified bound:
     3.00 + 20.00*M
   where
     M is the number of ::-nodes of the 1st component of the argument

--
  Mode:          upper
  Metric:        steps
  Degree:        1
  Run time:      0.02 seconds
  #Constraints:  42

====

Analyzing function bitToInt ...

  Trying degree: 1

== bitToInt :

  int list -> int

  Non-zero annotations of the argument:
     20.00  <--  [::(*)]
      7.00  <--  []

  Non-zero annotations of result:

  Simplified bound:
     7.00 + 20.00*M
   where
     M is the number of ::-nodes of the argument

--
  Mode:          upper
  Metric:        steps
  Degree:        1
  Run time:      0.02 seconds
  #Constraints:  48

====

Analyzing function sum ...

  Trying degree: 1

== sum :

  [int; int; int] -> int * int

  Non-zero annotations of the argument:
     33.00  <--  (*, *, *)

  Non-zero annotations of result:

  Simplified bound:
     33.00
--
  Mode:          upper
  Metric:        steps
  Degree:        1
  Run time:      0.02 seconds
  #Constraints:  59

====

Analyzing function add' ...

  Trying degree: 1

== add' :

  [int list; int list; int] -> int list

  Non-zero annotations of the argument:
      2.00  <--  ([::(*)], [], *)
     51.00  <--  ([], [::(*)], *)
      3.00  <--  ([], [], *)

  Non-zero annotations of result:

  Simplified bound:
     3.00 + 51.00*L + 2.00*M
   where
     L is the number of ::-nodes of the 2nd component of the argument
     M is the number of ::-nodes of the 1st component of the argument

--
  Mode:          upper
  Metric:        steps
  Degree:        1
  Run time:      0.04 seconds
  #Constraints:  112

====

Analyzing function add ...

  Trying degree: 1

== add :

  [int list; int list] -> int list

  Non-zero annotations of the argument:
      2.00  <--  ([::(*)], [])
     51.00  <--  ([], [::(*)])
      8.00  <--  ([], [])

  Non-zero annotations of result:

  Simplified bound:
     8.00 + 51.00*L + 2.00*M
   where
     L is the number of ::-nodes of the 2nd component of the argument
     M is the number of ::-nodes of the 1st component of the argument

--
  Mode:          upper
  Metric:        steps
  Degree:        1
  Run time:      0.05 seconds
  #Constraints:  119

====

Analyzing function mult ...

  Trying degree: 1, 2

== mult :

  [int list; int list] -> int list

  Non-zero annotations of the argument:
     53.00  <--  ([::(*)], [::(*)])
     30.00  <--  ([::(*)], [])
      3.00  <--  ([], [])

  Non-zero annotations of result:

  Simplified bound:
     3.00 + 53.00*L*M + 30.00*M
   where
     L is the number of ::-nodes of the 2nd component of the argument
     M is the number of ::-nodes of the 1st component of the argument

--
  Mode:          upper
  Metric:        steps
  Degree:        2
  Run time:      0.20 seconds
  #Constraints:  477

====

Analyzing function diff ...

  Trying degree: 1

== diff :

  [int; int; int] -> int * int

  Non-zero annotations of the argument:
     31.00  <--  (*, *, *)

  Non-zero annotations of result:

  Simplified bound:
     31.00
--
  Mode:          upper
  Metric:        steps
  Degree:        1
  Run time:      0.05 seconds
  #Constraints:  47

====

Analyzing function sub' ...

  Trying degree: 1

== sub' :

  [int list; int list; int] -> int list * int

  Non-zero annotations of the argument:
      2.00  <--  ([::(*)], [], *)
     59.00  <--  ([], [::(*)], *)
      5.00  <--  ([], [], *)

  Non-zero annotations of result:

  Simplified bound:
     5.00 + 59.00*L + 2.00*M
   where
     L is the number of ::-nodes of the 2nd component of the argument
     M is the number of ::-nodes of the 1st component of the argument

--
  Mode:          upper
  Metric:        steps
  Degree:        1
  Run time:      0.11 seconds
  #Constraints:  127

====

Analyzing function sub ...

  Trying degree: 1

== sub :

  [int list; int list] -> int list

  Non-zero annotations of the argument:
      2.00  <--  ([::(*)], [])
     59.00  <--  ([], [::(*)])
     14.00  <--  ([], [])

  Non-zero annotations of result:

  Simplified bound:
     14.00 + 59.00*L + 2.00*M
   where
     L is the number of ::-nodes of the 2nd component of the argument
     M is the number of ::-nodes of the 1st component of the argument

--
  Mode:          upper
  Metric:        steps
  Degree:        1
  Run time:      0.11 seconds
  #Constraints:  138

====

Analyzing function compare ...

  Trying degree: 1

== compare :

  [int list; int list] -> int

  Non-zero annotations of the argument:
      2.00  <--  ([::(*)], [])
     28.00  <--  ([], [::(*)])
      3.00  <--  ([], [])

  Non-zero annotations of result:

  Simplified bound:
     3.00 + 28.00*L + 2.00*M
   where
     L is the number of ::-nodes of the 2nd component of the argument
     M is the number of ::-nodes of the 1st component of the argument

--
  Mode:          upper
  Metric:        steps
  Degree:        1
  Run time:      0.11 seconds
  #Constraints:  80

====

Analyzing function leq ...

  Trying degree: 1

== leq :

  [int list; int list] -> bool

  Non-zero annotations of the argument:
      2.00  <--  ([::(*)], [])
     28.00  <--  ([], [::(*)])
     13.00  <--  ([], [])

  Non-zero annotations of result:

  Simplified bound:
     13.00 + 28.00*L + 2.00*M
   where
     L is the number of ::-nodes of the 2nd component of the argument
     M is the number of ::-nodes of the 1st component of the argument

--
  Mode:          upper
  Metric:        steps
  Degree:        1
  Run time:      0.11 seconds
  #Constraints:  94

====

