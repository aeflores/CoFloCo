/* * * * * * * * * * *
Translated to ABS
 * * * * * * * * * * *
 *
 * * *  Use Cases  * *
 *
 * File:
 *   examples/quicksort_mutual.raml
 *
 * 
 * Description:
 *   A mutually recursive implementation of the quick sort algorithm as
 *   given in the article 'Dependent types for program termination
 *   verification' by Hongwei Xi (Logic in Computer Science, 2001).
 *   
 *   My experiments indicate that RAML computes a tight bound on the
 *   number of evaluation steps that are used by the function qs.
 *   
 *   It is interesting that the inputs that produce the worst-case behavior
 *   are not reversely sorted lists [-1,-2,-3,-4,-5,-6] as usual.  The
 *   reason is that it makes a difference for functional implementations of
 *   quick sort whether the first or second recursive call receives a
 *   longer input list.  Because of the function append, the worst-case
 *   behavior emerges if the first argument of append is as long as
 *   possible.  As a result, worst-case inputs have the form
 *   [-1,-3,-5,-6,-4,-2].
 */


module Quicksort_mutual;

def List<A> append<A>(List<A> l1,List<A> l2) =
	case l1 {
	Nil => l2;
	Cons(x,xs) => Cons(x,append( xs, l2));
	};



def List<Int> part(Int y,List<Int> l,List<Int> r,List<Int> xs) =
	case xs {
	Nil =>  append(qs(l), Cons(y,qs(r)));
	Cons(x,xsp) =>
		if x < y then part(y,Cons(x,l),r,xsp)
		else part(y, l, Cons(x,r), xsp);
		};

 
def List<Int>  qs(List<Int> l) =
	case l {
	Nil => Nil;
	Cons(x,xs) =>  part( x,Nil,Nil,xs);
	};


{}