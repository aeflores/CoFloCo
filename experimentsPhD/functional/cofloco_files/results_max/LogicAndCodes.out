
Abs program loaded in 18 ms.

Rule based representation generated in 8 ms.

Rule based representation stored in /tmp/costabs/rbr.rbr

RBR properties stored in /tmp/costabs/rbr.properties

Class invariants generated and loaded in 0 ms.

Abstract compilation performed in 78 ms.

Cost relation system stored in /tmp/costabs/crs.crs

Generated 51 equations 
entry('eval2'(A,B,C,D,E,F,G):[]).
entry('table2'(A,B,C,D,E,F,G):[]).
entry('rev'(A,B,C,D,E,F,G,H,I,J,K,L):[]).
entry('concat'(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X):[]).
entry('assoc'(A,B,C,D,E,F):[]).
entry('eval'(A,B,C,D,E,F,G):[]).
entry('table_make'(A,B,C,D,E,F,G,H,I,J,K,L,M,N):[]).
input_output_vars('and_op'(A,B,C),[A,B],[C]).
input_output_vars('assoc'(A,B,C,D,E,F),[A,B,C,D,E],[F]).
input_output_vars('aux_rev'(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R),[A,B,C,D,E,F,G,H,I,J,K,L],[M,N,O,P,Q,R]).
input_output_vars('case_0'(A,B,C,D,E,F,G),[A,B,C,D,E,F],[G]).
input_output_vars('case_1'(A,B,C,D,E,F,G,H),[A,B,C,D,E,F,G],[H]).
input_output_vars('case_2'(A,B,C,D,E,F,G,H),[A,B,C,D,E,F,G],[H]).
input_output_vars('case_3'(A,B,C,D,E,F),[A,B,C,D,E],[F]).
input_output_vars('case_4'(A,B,C,D,E,F,G,H,I,J,K,L),[A,B,C,D,E,F,G,H,I,J,K],[L]).
input_output_vars('case_5'(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R),[A,B,C,D,E,F,G,H,I,J,K,L],[M,N,O,P,Q,R]).
input_output_vars('case_6'(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X),[A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P],[Q,R,S,T,U,V,W,X]).
input_output_vars('case_7'(A,B,C,D,E,F,G),[A,B,C,D,E,F],[G]).
input_output_vars('case_8'(A,B,C,D,E,F,G,H,I,J,K,L,M,N),[A,B,C,D,E,F,G,H],[I,J,K,L,M,N]).
input_output_vars('concat'(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X),[A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P],[Q,R,S,T,U,V,W,X]).
input_output_vars('eq'(A,B,C),[A,B],[C]).
input_output_vars('eval'(A,B,C,D,E,F,G),[A,B,C,D,E,F],[G]).
input_output_vars('eval2'(A,B,C,D,E,F,G),[A,B,C,D,E,F],[G]).
input_output_vars('geq'(A,B,C),[A,B],[C]).
input_output_vars('gt'(A,B,C),[A,B],[C]).
input_output_vars('leq'(A,B,C),[A,B],[C]).
input_output_vars('lt'(A,B,C),[A,B],[C]).
input_output_vars('maxNorm'(A,B,C),[A,B],[C]).
input_output_vars('neg'(A,B),[A],[B]).
input_output_vars('neq'(A,B,C),[A,B],[C]).
input_output_vars('or'(A,B,C),[A,B],[C]).
input_output_vars('rev'(A,B,C,D,E,F,G,H,I,J,K,L),[A,B,C,D,E,F],[G,H,I,J,K,L]).
input_output_vars('table2'(A,B,C,D,E,F,G),[A,B,C,D],[E,F,G]).
input_output_vars('table_make'(A,B,C,D,E,F,G,H,I,J,K,L,M,N),[A,B,C,D,E,F,G,H],[I,J,K,L,M,N]).
eq('eq',[A,B,C],0,[],[A=B,C=1,A>=0,B>=0,C>=0]).
eq('eq',[A,B,C],0,[],[A>=B+1,C=0,A>=0,B>=0,C>=0]).
eq('eq',[A,B,C],0,[],[B>=A+1,C=0,A>=0,B>=0,C>=0]).
eq('neq',[A,B,C],0,[],[A=B,C=0,A>=0,B>=0,C>=0]).
eq('neq',[A,B,C],0,[],[A>=B+1,C=1,A>=0,B>=0,C>=0]).
eq('neq',[A,B,C],0,[],[B>=A+1,C=1,A>=0,B>=0,C>=0]).
eq('lt',[A,B,C],0,[],[B-A>=1,C=1,A>=0,B>=0,C>=0]).
eq('lt',[A,B,C],0,[],[B=<A,C=0,A>=0,B>=0,C>=0]).
eq('leq',[A,B,C],0,[],[A=<B,C=1,A>=0,B>=0,C>=0]).
eq('leq',[A,B,C],0,[],[A-B>=1,C=0,A>=0,B>=0,C>=0]).
eq('gt',[A,B,C],0,[],[A-B>=1,C=1,A>=0,B>=0,C>=0]).
eq('gt',[A,B,C],0,[],[A=<B,C=0,A>=0,B>=0,C>=0]).
eq('geq',[A,B,C],0,[],[B=<A,C=1,A>=0,B>=0,C>=0]).
eq('geq',[A,B,C],0,[],[B-A>=1,C=0,A>=0,B>=0,C>=0]).
eq('neg',[A,B],0,[],[A=0,B=1,A>=0,B>=0]).
eq('neg',[A,B],0,[],[A=1,B=0,A>=0,B>=0]).
eq('and_op',[A,B,C],0,[],[A=0,C=0,A>=0,B>=0,C>=0]).
eq('and_op',[A,B,C],0,[],[A=1,C=B,A>=0,B>=0,C>=0]).
eq('or',[A,B,C],0,[],[A=1,C=1,A>=0,B>=0,C>=0]).
eq('or',[A,B,C],0,[],[A=0,C=B,A>=0,B>=0,C>=0]).
eq('maxNorm',[A,B,A],0,[],[A>=1+B,A>=0,B>=0,A>=0]).
eq('maxNorm',[A,B,B],0,[],[A=<B,A>=0,B>=0,B>=0]).
eq('case_1',[A,B,C,D,E,F,G,B],1,[],[G=A,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,B>=0]).
eq('case_2',[A,B,C,D,E,F,G,D],1,[],[G=C,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,D>=0]).
eq('case_2',[A,B,C,D,E,F,G,H],2,[],[G>=C+1,H=0,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0]).
eq('case_1',[A,B,C,D,E,F,G,H],2,['case_2'(A,B,C,D,E,F,G,H)],[G>=A+1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0]).
eq('case_0',[A,B,C,D,E,F,G],2,['case_1'(A,B,C,D,E,F,H,G)],[F=1,E=H,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0]).
eq('case_0',[A,B,C,D,E,F,G],4,['eval2'(A,B,C,D,H,I,J),'neg'(J,G)],[F=I+1,E=H,I>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0]).
eq('case_0',[A,B,C,D,E,F,G],6,['eval2'(A,B,C,D,H,I,J),'eval2'(A,B,C,D,K,L,M),'and_op'(J,M,G)],[E>=H,E>=K,F=L+I+1,L>=1,I>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0]).
eq('case_0',[A,B,C,D,E,F,G],7,['eval2'(A,B,C,D,H,I,J),'eval2'(A,B,C,D,K,L,M),'or'(J,M,G)],[E>=H,E>=K,F=L+I+1,L>=1,I>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0]).
eq('eval2',[A,B,C,D,E,F,G],1,['case_0'(A,B,C,D,E,F,G)],[A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0]).
eq('table2',[A,B,C,D,E,F,G],29,['eval2'(A,H,B,I,C,D,J),'eval2'(A,K,B,L,C,D,M),'eval2'(A,N,B,O,C,D,P),'eval2'(A,Q,B,R,C,D,S),'maxNorm'(T,U,V),'maxNorm'(W,V,X),'maxNorm'(Y,X,Z),'maxNorm'(A1,Z,E)],[B1=1,C1=1,H=1,I=1,D1>=B1,D1>=C1,D1>=J,A1=1,J>=0,C1>=0,B1>=0,E1=1,F1=0,K=1,L=0,G1>=E1,G1>=F1,G1>=M,Y=1,M>=0,F1>=0,E1>=0,H1=0,I1=1,N=0,O=1,J1>=H1,J1>=I1,J1>=P,W=1,P>=0,I1>=0,H1>=0,K1=0,L1=0,Q=0,R=0,M1>=K1,M1>=L1,M1>=S,T=1,S>=0,L1>=0,K1>=0,N1=0,O1=1,U=0,P1>=M1,P1>=N1,Q1=O1+1,O1>=1,T>=1,R1>=J1,R1>=P1,S1=Q1+1,Q1>=1,W>=1,T1>=G1,T1>=R1,U1=S1+1,S1>=1,Y>=1,G>=D1,G>=T1,F=U1+1,U1>=1,A1>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0]).
eq('case_4',[A,B,C,D,E,F,G,H,I,J,K,G],1,[],[F=A,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,G>=0]).
eq('case_4',[A,B,C,D,E,F,G,H,I,J,K,L],2,['assoc'(A,H,I,J,K,L)],[F>=A+1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0]).
eq('case_3',[A,B,C,D,E,F],2,['case_4'(A,B,C,D,E,G,H,I,J,K,L,F)],[E>=L,E>=H,D>=K,D>=G,B>=1,B>=I,C=J+1,J>=1,H>=0,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0]).
eq('assoc',[A,B,C,D,E,F],1,['case_3'(A,B,C,D,E,F)],[A>=0,B>=0,C>=0,D>=0,E>=0,F>=0]).
eq('case_5',[A,B,C,D,E,F,G,H,I,J,K,L,A,B,C,D,E,F],1,[],[L=0,K=1,J=0,H=1,G=0,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0]).
eq('case_5',[A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R],4,['maxNorm'(S,F,T),'maxNorm'(U,A,V),'aux_rev'(V,W,X,Y,Z,T,A1,B1,C1,D1,E1,F1,M,N,O,P,Q,R)],[L>=S,L>=F1,J>=G1,J>=D1,I>=H1,I>=C1,G>=U,G>=A1,K=E1+1,H=B1+1,E1>=1,B1>=1,S>=1,U>=1,Y>=G1,Y>=D,X>=H1,X>=C,Z=E+1,W=B+1,E>=1,B>=1,S>=1,U>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0,M>=0,N>=0,O>=0,P>=0,Q>=0,R>=0]).
eq('aux_rev',[A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R],1,['case_5'(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R)],[A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0,M>=0,N>=0,O>=0,P>=0,Q>=0,R>=0]).
eq('rev',[A,B,C,D,E,F,G,H,I,J,K,L],2,['aux_rev'(M,N,O,P,Q,R,A,B,C,D,E,F,G,H,I,J,K,L)],[R=0,Q=1,P=0,N=1,M=0,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0]).
eq('case_6',[A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,I,J,K,L,M,N,O,P],1,[],[H=0,G=1,F=0,D=0,C=1,B=0,A=0,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0,M>=0,N>=0,O>=0,P>=0,I>=0,J>=0,K>=0,L>=0,M>=0,N>=0,O>=0,P>=0]).
eq('case_6',[A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X],4,['concat'(Y,Z,A1,B1,C1,D1,E1,F1,I,J,K,L,M,N,O,P,G1,H1,I1,J1,K1,L1,M1,N1),'maxNorm'(O1,N1,X),'maxNorm'(P1,J1,T),'maxNorm'(Q1,H1,R),'maxNorm'(R1,G1,Q)],[H>=O1,H>=F1,F>=S1,F>=D1,E>=T1,E>=C1,D>=P1,D>=B1,B>=Q1,B>=Z,A>=R1,A>=Y,G=E1+1,C=A1+1,E1>=1,A1>=1,O1>=1,R1>=1,V>=S1,V>=L1,U>=T1,U>=K1,W=M1+1,S=I1+1,M1>=1,I1>=1,O1>=1,R1>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0,M>=0,N>=0,O>=0,P>=0,Q>=0,R>=0,S>=0,T>=0,U>=0,V>=0,W>=0,X>=0]).
eq('concat',[A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X],1,['case_6'(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X)],[A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0,M>=0,N>=0,O>=0,P>=0,Q>=0,R>=0,S>=0,T>=0,U>=0,V>=0,W>=0,X>=0]).
eq('case_7',[A,B,C,D,E,F,G],2,['assoc'(H,A,B,C,D,G)],[F=1,E=H,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0]).
eq('case_7',[A,B,C,D,E,F,G],4,['eval'(A,B,C,D,H,I,J),'neg'(J,G)],[F=I+1,E=H,I>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0]).
eq('case_7',[A,B,C,D,E,F,G],6,['eval'(A,B,C,D,H,I,J),'eval'(A,B,C,D,K,L,M),'and_op'(J,M,G)],[E>=H,E>=K,F=L+I+1,L>=1,I>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0]).
eq('case_7',[A,B,C,D,E,F,G],7,['eval'(A,B,C,D,H,I,J),'eval'(A,B,C,D,K,L,M),'or'(J,M,G)],[E>=H,E>=K,F=L+I+1,L>=1,I>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0]).
eq('eval',[A,B,C,D,E,F,G],1,['case_7'(A,B,C,D,E,F,G)],[A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0]).
eq('case_8',[A,B,C,D,E,F,G,H,I,J,K,L,M,N],6,['rev'(A,B,C,D,O,P,Q,R,S,T,U,V),'eval'(A,B,C,D,G,H,W),'maxNorm'(X,Y,L),'maxNorm'(Z,A1,J),'maxNorm'(B1,C1,I)],[E=1,D1>=T,D1>=W,E1=S,X=R,Z=Q,B1=1,W>=0,R>=1,F1=0,Y=0,G1=1,A1=0,C1=0,N>=D1,N>=F1,M>=E1,M>=H1,K=G1+1,G1>=1,B1>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0,M>=0,N>=0]).
eq('case_8',[A,B,C,D,E,F,G,H,I,J,K,L,M,N],11,['maxNorm'(O,A,P),'table_make'(P,Q,R,S,T,U,G,H,V,W,X,Y,Z,A1),'maxNorm'(B1,A,C1),'table_make'(C1,D1,E1,F1,T,U,G,H,G1,H1,I1,J1,K1,L1),'concat'(V,W,X,Y,Z,A1,M1,N1,G1,H1,I1,J1,K1,L1,O1,P1,I,J,K,L,M,N,Q1,R1)],[F>=S1,F>=U,E=T+1,T>=1,T1=1,U1=T1,V1=S1,O=1,T1>=0,S>=U1,S>=D,R>=V1,R>=C,Q=B+1,B>=1,O>=1,W1=0,X1=W1,Y1=S1,B1=1,W1>=0,F1>=X1,F1>=D,E1>=Y1,E1>=C,D1=B+1,B>=1,B1>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0,M>=0,N>=0]).
eq('table_make',[A,B,C,D,E,F,G,H,I,J,K,L,M,N],1,['case_8'(A,B,C,D,E,F,G,H,I,J,K,L,M,N)],[A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0,M>=0,N>=0]).

Preprocessing Cost Relations
=====================================

#### Computed strongly connected components 
0. recursive  : [assoc/6,case_3/6,case_4/12]
1. non_recursive  : [maxNorm/3]
2. recursive [non_tail] : [case_6/24,concat/24]
3. non_recursive  : [and_op/3]
4. non_recursive  : [neg/2]
5. non_recursive  : [or/3]
6. recursive [non_tail,multiple] : [case_7/7,eval/7]
7. non_recursive  : [case_2/8]
8. non_recursive  : [case_1/8]
9. recursive [non_tail,multiple] : [case_0/7,eval2/7]
10. recursive  : [aux_rev/18,case_5/18]
11. non_recursive  : [rev/12]
12. non_recursive  : [table2/7]
13. recursive [non_tail,multiple] : [case_8/14,table_make/14]
Warning: the following predicates are never called:[eq/3,geq/3,gt/3,leq/3,lt/3,neq/3]

#### Obtained direct recursion through partial evaluation 
0. SCC is partially evaluated into assoc/6
1. SCC is partially evaluated into maxNorm/3
2. SCC is partially evaluated into concat/24
3. SCC is partially evaluated into and_op/3
4. SCC is partially evaluated into neg/2
5. SCC is partially evaluated into or/3
6. SCC is partially evaluated into eval/7
7. SCC is partially evaluated into case_2/8
8. SCC is partially evaluated into case_1/8
9. SCC is partially evaluated into eval2/7
10. SCC is partially evaluated into aux_rev/18
11. SCC is partially evaluated into rev/12
12. SCC is partially evaluated into table2/7
13. SCC is partially evaluated into table_make/14

Control-Flow Refinement of Cost Relations
=====================================

### Specialization of cost equations assoc/6 
* CE 10 is refined into CE [31] 
* CE 9 is refined into CE [32] 


#### Refined cost equations assoc/6 
* CE 31: assoc(A,B,C,D,E,F) = 4
     [E>=F,D>=A,F>=0,C>=2,B>=1,A>=0] 
* CE 32: assoc(A,B,C,D,E,F) = 5+ assoc(A,G,H,I,J,F)
     [E>=J,D>=I,B>=G,D>=A+1,J>=0,I>=0,H>=1,G>=0,F>=0,B>=1,A>=0,H+1=C] 

### Cost equations --> "Loop" of assoc/6 
* CEs [32] --> Loop 29 
* CEs [31] --> Loop 30 

#### Loops of assoc/6 
* Loop 29: assoc(A,B,C,D,E,F)->  assoc(A,A',B',C',D',F)
                  [E>=D',D>=C',B>=A',D>=A+1,D'>=0,C'>=0,B'>=1,A'>=0,F>=0,B>=1,A>=0,B'+1=C] 
* Loop 30: assoc(A,B,C,D,E,F) [E>=F,D>=A,F>=0,C>=2,B>=1,A>=0] 

### Ranking functions of CR assoc(A,B,C,D,E,F) 
* RF of phase [29]: [C-1]

#### Partial ranking functions of CR assoc(A,B,C,D,E,F) 
* Partial RF of phase [29]:
  - RF of loop [29:1]:
    C-1

Discarded unfeasible chain [[29]]...(Non-terminating chain proved terminating)

### Resulting Chains:assoc(A,B,C,D,E,F) 
* [[29],30]
* [30]


### Merging Chains  assoc/6 into  External patterns of execution 
* [[30],[30,[29]]] --> 1 


### Specialization of cost equations maxNorm/3 
* CE 26 is refined into CE [33] 
* CE 25 is refined into CE [34] 


#### Refined cost equations maxNorm/3 
* CE 33: maxNorm(A,B,B) = 0
     [B>=A,A>=0] 
* CE 34: maxNorm(A,B,A) = 0
     [A>=B+1,B>=0] 

### Cost equations --> "Loop" of maxNorm/3 
* CEs [33] --> Loop 31 
* CEs [34] --> Loop 32 

#### Loops of maxNorm/3 
* Loop 31: maxNorm(A,B,B) [B>=A,A>=0] 
* Loop 32: maxNorm(A,B,A) [A>=B+1,B>=0] 

### Ranking functions of CR maxNorm(A,B,C) 

#### Partial ranking functions of CR maxNorm(A,B,C) 


### Resulting Chains:maxNorm(A,B,C) 
* [32]
* [31]


### Merging Chains  maxNorm/3 into  External patterns of execution 
* [[32]] --> 1 
* [[31]] --> 2 


### Specialization of cost equations concat/24 
* CE 8 is refined into CE [35] 
* CE 7 is refined into CE [36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51] 


#### Refined cost equations concat/24 
* CE 35: concat(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,I,J,K,L,M,N,O,P) = 2
     [P>=0,O>=0,N>=0,M>=0,L>=0,K>=0,J>=0,I>=0,E>=0,H=0,G=1,F=0,D=0,C=1,B=0,A=0] 
* CE 36: concat(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X) = 5+ concat(Y,Z,A1,B1,C1,D1,E1,F1,I,J,K,L,M,N,O,P,G1,H1,I1,J1,K1,L1,M1,N1)+ maxNorm(X,N1,X):1+ maxNorm(T,J1,T):1+ maxNorm(R,H1,R):1+ maxNorm(Q,G1,Q):1
     [V>=L1,U>=K1,H>=F1,F>=D1,E>=C1,D>=B1,B>=Z,A>=Y,A>=Q,Q>=G1+1,B>=R,R>=H1+1,D>=T,T>=J1+1,H>=X,X>=N1+1,M1>=1,I1>=1,E1>=1,A1>=1,G1>=0,H1>=0,J1>=0,N1>=0,V>=0,U>=0,P>=0,O>=0,N>=0,M>=0,L>=0,K>=0,J>=0,I>=0,F>=0,E>=0,M1+1=W,I1+1=S,E1+1=G,A1+1=C] 
* CE 37: concat(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X) = 5+ concat(Y,Z,A1,B1,C1,D1,E1,F1,I,J,K,L,M,N,O,P,Q,G1,H1,I1,J1,K1,L1,M1)+ maxNorm(X,M1,X):1+ maxNorm(T,I1,T):1+ maxNorm(R,G1,R):1+ maxNorm(N1,Q,Q):2
     [V>=K1,U>=J1,H>=F1,F>=D1,E>=C1,D>=B1,B>=Z,A>=Y,Q>=N1,A>=N1,B>=R,R>=G1+1,D>=T,T>=I1+1,H>=X,X>=M1+1,L1>=1,H1>=1,E1>=1,A1>=1,N1>=1,G1>=0,I1>=0,M1>=0,V>=0,U>=0,P>=0,O>=0,N>=0,M>=0,L>=0,K>=0,J>=0,I>=0,F>=0,E>=0,L1+1=W,H1+1=S,E1+1=G,A1+1=C] 
* CE 38: concat(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X) = 5+ concat(Y,Z,A1,B1,C1,D1,E1,F1,I,J,K,L,M,N,O,P,G1,R,H1,I1,J1,K1,L1,M1)+ maxNorm(X,M1,X):1+ maxNorm(T,I1,T):1+ maxNorm(N1,R,R):2+ maxNorm(Q,G1,Q):1
     [V>=K1,U>=J1,H>=F1,F>=D1,E>=C1,D>=B1,B>=Z,A>=Y,A>=Q,Q>=G1+1,R>=N1,B>=N1,D>=T,T>=I1+1,H>=X,X>=M1+1,L1>=1,H1>=1,E1>=1,A1>=1,G1>=0,N1>=0,I1>=0,M1>=0,V>=0,U>=0,P>=0,O>=0,N>=0,M>=0,L>=0,K>=0,J>=0,I>=0,F>=0,E>=0,L1+1=W,H1+1=S,E1+1=G,A1+1=C] 
* CE 39: concat(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X) = 5+ concat(Y,Z,A1,B1,C1,D1,E1,F1,I,J,K,L,M,N,O,P,Q,R,G1,H1,I1,J1,K1,L1)+ maxNorm(X,L1,X):1+ maxNorm(T,H1,T):1+ maxNorm(M1,R,R):2+ maxNorm(N1,Q,Q):2
     [V>=J1,U>=I1,H>=F1,F>=D1,E>=C1,D>=B1,B>=Z,A>=Y,Q>=N1,A>=N1,R>=M1,B>=M1,D>=T,T>=H1+1,H>=X,X>=L1+1,K1>=1,G1>=1,E1>=1,A1>=1,N1>=1,M1>=0,H1>=0,L1>=0,V>=0,U>=0,P>=0,O>=0,N>=0,M>=0,L>=0,K>=0,J>=0,I>=0,F>=0,E>=0,K1+1=W,G1+1=S,E1+1=G,A1+1=C] 
* CE 40: concat(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X) = 5+ concat(Y,Z,A1,B1,C1,D1,E1,F1,I,J,K,L,M,N,O,P,G1,H1,I1,T,J1,K1,L1,M1)+ maxNorm(X,M1,X):1+ maxNorm(N1,T,T):2+ maxNorm(R,H1,R):1+ maxNorm(Q,G1,Q):1
     [V>=K1,U>=J1,H>=F1,F>=D1,E>=C1,D>=B1,B>=Z,A>=Y,A>=Q,Q>=G1+1,B>=R,R>=H1+1,T>=N1,D>=N1,H>=X,X>=M1+1,L1>=1,I1>=1,E1>=1,A1>=1,G1>=0,H1>=0,N1>=0,M1>=0,V>=0,U>=0,P>=0,O>=0,N>=0,M>=0,L>=0,K>=0,J>=0,I>=0,F>=0,E>=0,L1+1=W,I1+1=S,E1+1=G,A1+1=C] 
* CE 41: concat(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X) = 5+ concat(Y,Z,A1,B1,C1,D1,E1,F1,I,J,K,L,M,N,O,P,Q,G1,H1,T,I1,J1,K1,L1)+ maxNorm(X,L1,X):1+ maxNorm(M1,T,T):2+ maxNorm(R,G1,R):1+ maxNorm(N1,Q,Q):2
     [V>=J1,U>=I1,H>=F1,F>=D1,E>=C1,D>=B1,B>=Z,A>=Y,Q>=N1,A>=N1,B>=R,R>=G1+1,T>=M1,D>=M1,H>=X,X>=L1+1,K1>=1,H1>=1,E1>=1,A1>=1,N1>=1,G1>=0,M1>=0,L1>=0,V>=0,U>=0,P>=0,O>=0,N>=0,M>=0,L>=0,K>=0,J>=0,I>=0,F>=0,E>=0,K1+1=W,H1+1=S,E1+1=G,A1+1=C] 
* CE 42: concat(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X) = 5+ concat(Y,Z,A1,B1,C1,D1,E1,F1,I,J,K,L,M,N,O,P,G1,R,H1,T,I1,J1,K1,L1)+ maxNorm(X,L1,X):1+ maxNorm(M1,T,T):2+ maxNorm(N1,R,R):2+ maxNorm(Q,G1,Q):1
     [V>=J1,U>=I1,H>=F1,F>=D1,E>=C1,D>=B1,B>=Z,A>=Y,A>=Q,Q>=G1+1,R>=N1,B>=N1,T>=M1,D>=M1,H>=X,X>=L1+1,K1>=1,H1>=1,E1>=1,A1>=1,G1>=0,N1>=0,M1>=0,L1>=0,V>=0,U>=0,P>=0,O>=0,N>=0,M>=0,L>=0,K>=0,J>=0,I>=0,F>=0,E>=0,K1+1=W,H1+1=S,E1+1=G,A1+1=C] 
* CE 43: concat(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X) = 5+ concat(Y,Z,A1,B1,C1,D1,E1,F1,I,J,K,L,M,N,O,P,Q,R,G1,T,H1,I1,J1,K1)+ maxNorm(X,K1,X):1+ maxNorm(L1,T,T):2+ maxNorm(M1,R,R):2+ maxNorm(N1,Q,Q):2
     [V>=I1,U>=H1,H>=F1,F>=D1,E>=C1,D>=B1,B>=Z,A>=Y,Q>=N1,A>=N1,R>=M1,B>=M1,T>=L1,D>=L1,H>=X,X>=K1+1,J1>=1,G1>=1,E1>=1,A1>=1,N1>=1,M1>=0,L1>=0,K1>=0,V>=0,U>=0,P>=0,O>=0,N>=0,M>=0,L>=0,K>=0,J>=0,I>=0,F>=0,E>=0,J1+1=W,G1+1=S,E1+1=G,A1+1=C] 
* CE 44: concat(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X) = 5+ concat(Y,Z,A1,B1,C1,D1,E1,F1,I,J,K,L,M,N,O,P,G1,H1,I1,J1,K1,L1,M1,X)+ maxNorm(N1,X,X):2+ maxNorm(T,J1,T):1+ maxNorm(R,H1,R):1+ maxNorm(Q,G1,Q):1
     [V>=L1,U>=K1,H>=F1,F>=D1,E>=C1,D>=B1,B>=Z,A>=Y,A>=Q,Q>=G1+1,B>=R,R>=H1+1,D>=T,T>=J1+1,X>=N1,H>=N1,M1>=1,I1>=1,E1>=1,A1>=1,G1>=0,H1>=0,J1>=0,N1>=1,V>=0,U>=0,P>=0,O>=0,N>=0,M>=0,L>=0,K>=0,J>=0,I>=0,F>=0,E>=0,M1+1=W,I1+1=S,E1+1=G,A1+1=C] 
* CE 45: concat(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X) = 5+ concat(Y,Z,A1,B1,C1,D1,E1,F1,I,J,K,L,M,N,O,P,Q,G1,H1,I1,J1,K1,L1,X)+ maxNorm(M1,X,X):2+ maxNorm(T,I1,T):1+ maxNorm(R,G1,R):1+ maxNorm(N1,Q,Q):2
     [V>=K1,U>=J1,H>=F1,F>=D1,E>=C1,D>=B1,B>=Z,A>=Y,Q>=N1,A>=N1,B>=R,R>=G1+1,D>=T,T>=I1+1,X>=M1,H>=M1,L1>=1,H1>=1,E1>=1,A1>=1,N1>=1,G1>=0,I1>=0,M1>=1,V>=0,U>=0,P>=0,O>=0,N>=0,M>=0,L>=0,K>=0,J>=0,I>=0,F>=0,E>=0,L1+1=W,H1+1=S,E1+1=G,A1+1=C] 
* CE 46: concat(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X) = 5+ concat(Y,Z,A1,B1,C1,D1,E1,F1,I,J,K,L,M,N,O,P,G1,R,H1,I1,J1,K1,L1,X)+ maxNorm(M1,X,X):2+ maxNorm(T,I1,T):1+ maxNorm(N1,R,R):2+ maxNorm(Q,G1,Q):1
     [V>=K1,U>=J1,H>=F1,F>=D1,E>=C1,D>=B1,B>=Z,A>=Y,A>=Q,Q>=G1+1,R>=N1,B>=N1,D>=T,T>=I1+1,X>=M1,H>=M1,L1>=1,H1>=1,E1>=1,A1>=1,G1>=0,N1>=0,I1>=0,M1>=1,V>=0,U>=0,P>=0,O>=0,N>=0,M>=0,L>=0,K>=0,J>=0,I>=0,F>=0,E>=0,L1+1=W,H1+1=S,E1+1=G,A1+1=C] 
* CE 47: concat(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X) = 5+ concat(Y,Z,A1,B1,C1,D1,E1,F1,I,J,K,L,M,N,O,P,Q,R,G1,H1,I1,J1,K1,X)+ maxNorm(L1,X,X):2+ maxNorm(T,H1,T):1+ maxNorm(M1,R,R):2+ maxNorm(N1,Q,Q):2
     [V>=J1,U>=I1,H>=F1,F>=D1,E>=C1,D>=B1,B>=Z,A>=Y,Q>=N1,A>=N1,R>=M1,B>=M1,D>=T,T>=H1+1,X>=L1,H>=L1,K1>=1,G1>=1,E1>=1,A1>=1,N1>=1,M1>=0,H1>=0,L1>=1,V>=0,U>=0,P>=0,O>=0,N>=0,M>=0,L>=0,K>=0,J>=0,I>=0,F>=0,E>=0,K1+1=W,G1+1=S,E1+1=G,A1+1=C] 
* CE 48: concat(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X) = 5+ concat(Y,Z,A1,B1,C1,D1,E1,F1,I,J,K,L,M,N,O,P,G1,H1,I1,T,J1,K1,L1,X)+ maxNorm(M1,X,X):2+ maxNorm(N1,T,T):2+ maxNorm(R,H1,R):1+ maxNorm(Q,G1,Q):1
     [V>=K1,U>=J1,H>=F1,F>=D1,E>=C1,D>=B1,B>=Z,A>=Y,A>=Q,Q>=G1+1,B>=R,R>=H1+1,T>=N1,D>=N1,X>=M1,H>=M1,L1>=1,I1>=1,E1>=1,A1>=1,G1>=0,H1>=0,N1>=0,M1>=1,V>=0,U>=0,P>=0,O>=0,N>=0,M>=0,L>=0,K>=0,J>=0,I>=0,F>=0,E>=0,L1+1=W,I1+1=S,E1+1=G,A1+1=C] 
* CE 49: concat(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X) = 5+ concat(Y,Z,A1,B1,C1,D1,E1,F1,I,J,K,L,M,N,O,P,Q,G1,H1,T,I1,J1,K1,X)+ maxNorm(L1,X,X):2+ maxNorm(M1,T,T):2+ maxNorm(R,G1,R):1+ maxNorm(N1,Q,Q):2
     [V>=J1,U>=I1,H>=F1,F>=D1,E>=C1,D>=B1,B>=Z,A>=Y,Q>=N1,A>=N1,B>=R,R>=G1+1,T>=M1,D>=M1,X>=L1,H>=L1,K1>=1,H1>=1,E1>=1,A1>=1,N1>=1,G1>=0,M1>=0,L1>=1,V>=0,U>=0,P>=0,O>=0,N>=0,M>=0,L>=0,K>=0,J>=0,I>=0,F>=0,E>=0,K1+1=W,H1+1=S,E1+1=G,A1+1=C] 
* CE 50: concat(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X) = 5+ concat(Y,Z,A1,B1,C1,D1,E1,F1,I,J,K,L,M,N,O,P,G1,R,H1,T,I1,J1,K1,X)+ maxNorm(L1,X,X):2+ maxNorm(M1,T,T):2+ maxNorm(N1,R,R):2+ maxNorm(Q,G1,Q):1
     [V>=J1,U>=I1,H>=F1,F>=D1,E>=C1,D>=B1,B>=Z,A>=Y,A>=Q,Q>=G1+1,R>=N1,B>=N1,T>=M1,D>=M1,X>=L1,H>=L1,K1>=1,H1>=1,E1>=1,A1>=1,G1>=0,N1>=0,M1>=0,L1>=1,V>=0,U>=0,P>=0,O>=0,N>=0,M>=0,L>=0,K>=0,J>=0,I>=0,F>=0,E>=0,K1+1=W,H1+1=S,E1+1=G,A1+1=C] 
* CE 51: concat(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X) = 5+ concat(Y,Z,A1,B1,C1,D1,E1,F1,I,J,K,L,M,N,O,P,Q,R,G1,T,H1,I1,J1,X)+ maxNorm(K1,X,X):2+ maxNorm(L1,T,T):2+ maxNorm(M1,R,R):2+ maxNorm(N1,Q,Q):2
     [V>=I1,U>=H1,H>=F1,F>=D1,E>=C1,D>=B1,B>=Z,A>=Y,Q>=N1,A>=N1,R>=M1,B>=M1,T>=L1,D>=L1,X>=K1,H>=K1,J1>=1,G1>=1,E1>=1,A1>=1,N1>=1,M1>=0,L1>=0,K1>=1,V>=0,U>=0,P>=0,O>=0,N>=0,M>=0,L>=0,K>=0,J>=0,I>=0,F>=0,E>=0,J1+1=W,G1+1=S,E1+1=G,A1+1=C] 

### Cost equations --> "Loop" of concat/24 
* CEs [36] --> Loop 33 
* CEs [44] --> Loop 34 
* CEs [40] --> Loop 35 
* CEs [48] --> Loop 36 
* CEs [38] --> Loop 37 
* CEs [46] --> Loop 38 
* CEs [42] --> Loop 39 
* CEs [50] --> Loop 40 
* CEs [37] --> Loop 41 
* CEs [45] --> Loop 42 
* CEs [41] --> Loop 43 
* CEs [49] --> Loop 44 
* CEs [39] --> Loop 45 
* CEs [47] --> Loop 46 
* CEs [43] --> Loop 47 
* CEs [51] --> Loop 48 
* CEs [35] --> Loop 49 

#### Loops of concat/24 
* Loop 33: concat(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X)->  concat(A',B',C',D',E',F',G',H',I,J,K,L,M,N,O,P,I',J',K',L',M',N',O',P')
                  [X>=P'+1,V>=N',U>=M',T>=L'+1,R>=J'+1,Q>=I'+1,H>=H',F>=F',E>=E',D>=D',B>=B',A>=A',H>=X,D>=T,B>=R,A>=Q,P'>=0,L'>=0,J'>=0,I'>=0,W>=2,V>=0,U>=0,S>=2,P>=0,O>=0,N>=0,M>=0,L>=0,K>=0,J>=0,I>=0,G>=2,F>=0,E>=0,C>=2,W=O'+1,S=K'+1,G=G'+1,C=C'+1] 
* Loop 34: concat(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X)->  concat(A',B',C',D',E',F',G',H',I,J,K,L,M,N,O,P,I',J',K',L',M',N',O',X)
                  [V>=N',U>=M',T>=L'+1,R>=J'+1,Q>=I'+1,H>=H',F>=F',E>=E',D>=D',B>=B',A>=A',D>=T,B>=R,A>=Q,L'>=0,J'>=0,I'>=0,X>=1,W>=2,V>=0,U>=0,S>=2,P>=0,O>=0,N>=0,M>=0,L>=0,K>=0,J>=0,I>=0,H>=1,G>=2,F>=0,E>=0,C>=2,W=O'+1,S=K'+1,G=G'+1,C=C'+1] 
* Loop 35: concat(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X)->  concat(A',B',C',D',E',F',G',H',I,J,K,L,M,N,O,P,I',J',K',T,L',M',N',O')
                  [X>=O'+1,V>=M',U>=L',R>=J'+1,Q>=I'+1,H>=H',F>=F',E>=E',D>=D',B>=B',A>=A',H>=X,B>=R,A>=Q,O'>=0,J'>=0,I'>=0,W>=2,V>=0,U>=0,T>=0,S>=2,P>=0,O>=0,N>=0,M>=0,L>=0,K>=0,J>=0,I>=0,G>=2,F>=0,E>=0,D>=0,C>=2,W=N'+1,S=K'+1,G=G'+1,C=C'+1] 
* Loop 36: concat(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X)->  concat(A',B',C',D',E',F',G',H',I,J,K,L,M,N,O,P,I',J',K',T,L',M',N',X)
                  [V>=M',U>=L',R>=J'+1,Q>=I'+1,H>=H',F>=F',E>=E',D>=D',B>=B',A>=A',B>=R,A>=Q,J'>=0,I'>=0,X>=1,W>=2,V>=0,U>=0,T>=0,S>=2,P>=0,O>=0,N>=0,M>=0,L>=0,K>=0,J>=0,I>=0,H>=1,G>=2,F>=0,E>=0,D>=0,C>=2,W=N'+1,S=K'+1,G=G'+1,C=C'+1] 
* Loop 37: concat(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X)->  concat(A',B',C',D',E',F',G',H',I,J,K,L,M,N,O,P,I',R,J',K',L',M',N',O')
                  [X>=O'+1,V>=M',U>=L',T>=K'+1,Q>=I'+1,H>=H',F>=F',E>=E',D>=D',B>=B',A>=A',H>=X,D>=T,A>=Q,O'>=0,K'>=0,I'>=0,W>=2,V>=0,U>=0,S>=2,R>=0,P>=0,O>=0,N>=0,M>=0,L>=0,K>=0,J>=0,I>=0,G>=2,F>=0,E>=0,C>=2,B>=0,W=N'+1,S=J'+1,G=G'+1,C=C'+1] 
* Loop 38: concat(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X)->  concat(A',B',C',D',E',F',G',H',I,J,K,L,M,N,O,P,I',R,J',K',L',M',N',X)
                  [V>=M',U>=L',T>=K'+1,Q>=I'+1,H>=H',F>=F',E>=E',D>=D',B>=B',A>=A',D>=T,A>=Q,K'>=0,I'>=0,X>=1,W>=2,V>=0,U>=0,S>=2,R>=0,P>=0,O>=0,N>=0,M>=0,L>=0,K>=0,J>=0,I>=0,H>=1,G>=2,F>=0,E>=0,C>=2,B>=0,W=N'+1,S=J'+1,G=G'+1,C=C'+1] 
* Loop 39: concat(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X)->  concat(A',B',C',D',E',F',G',H',I,J,K,L,M,N,O,P,I',R,J',T,K',L',M',N')
                  [X>=N'+1,V>=L',U>=K',Q>=I'+1,H>=H',F>=F',E>=E',D>=D',B>=B',A>=A',H>=X,A>=Q,N'>=0,I'>=0,W>=2,V>=0,U>=0,T>=0,S>=2,R>=0,P>=0,O>=0,N>=0,M>=0,L>=0,K>=0,J>=0,I>=0,G>=2,F>=0,E>=0,D>=0,C>=2,B>=0,W=M'+1,S=J'+1,G=G'+1,C=C'+1] 
* Loop 40: concat(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X)->  concat(A',B',C',D',E',F',G',H',I,J,K,L,M,N,O,P,I',R,J',T,K',L',M',X)
                  [V>=L',U>=K',Q>=I'+1,H>=H',F>=F',E>=E',D>=D',B>=B',A>=A',A>=Q,I'>=0,X>=1,W>=2,V>=0,U>=0,T>=0,S>=2,R>=0,P>=0,O>=0,N>=0,M>=0,L>=0,K>=0,J>=0,I>=0,H>=1,G>=2,F>=0,E>=0,D>=0,C>=2,B>=0,W=M'+1,S=J'+1,G=G'+1,C=C'+1] 
* Loop 41: concat(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X)->  concat(A',B',C',D',E',F',G',H',I,J,K,L,M,N,O,P,Q,I',J',K',L',M',N',O')
                  [X>=O'+1,V>=M',U>=L',T>=K'+1,R>=I'+1,H>=H',F>=F',E>=E',D>=D',B>=B',A>=A',H>=X,D>=T,B>=R,O'>=0,K'>=0,I'>=0,W>=2,V>=0,U>=0,S>=2,Q>=1,P>=0,O>=0,N>=0,M>=0,L>=0,K>=0,J>=0,I>=0,G>=2,F>=0,E>=0,C>=2,A>=1,W=N'+1,S=J'+1,G=G'+1,C=C'+1] 
* Loop 42: concat(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X)->  concat(A',B',C',D',E',F',G',H',I,J,K,L,M,N,O,P,Q,I',J',K',L',M',N',X)
                  [V>=M',U>=L',T>=K'+1,R>=I'+1,H>=H',F>=F',E>=E',D>=D',B>=B',A>=A',D>=T,B>=R,K'>=0,I'>=0,X>=1,W>=2,V>=0,U>=0,S>=2,Q>=1,P>=0,O>=0,N>=0,M>=0,L>=0,K>=0,J>=0,I>=0,H>=1,G>=2,F>=0,E>=0,C>=2,A>=1,W=N'+1,S=J'+1,G=G'+1,C=C'+1] 
* Loop 43: concat(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X)->  concat(A',B',C',D',E',F',G',H',I,J,K,L,M,N,O,P,Q,I',J',T,K',L',M',N')
                  [X>=N'+1,V>=L',U>=K',R>=I'+1,H>=H',F>=F',E>=E',D>=D',B>=B',A>=A',H>=X,B>=R,N'>=0,I'>=0,W>=2,V>=0,U>=0,T>=0,S>=2,Q>=1,P>=0,O>=0,N>=0,M>=0,L>=0,K>=0,J>=0,I>=0,G>=2,F>=0,E>=0,D>=0,C>=2,A>=1,W=M'+1,S=J'+1,G=G'+1,C=C'+1] 
* Loop 44: concat(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X)->  concat(A',B',C',D',E',F',G',H',I,J,K,L,M,N,O,P,Q,I',J',T,K',L',M',X)
                  [V>=L',U>=K',R>=I'+1,H>=H',F>=F',E>=E',D>=D',B>=B',A>=A',B>=R,I'>=0,X>=1,W>=2,V>=0,U>=0,T>=0,S>=2,Q>=1,P>=0,O>=0,N>=0,M>=0,L>=0,K>=0,J>=0,I>=0,H>=1,G>=2,F>=0,E>=0,D>=0,C>=2,A>=1,W=M'+1,S=J'+1,G=G'+1,C=C'+1] 
* Loop 45: concat(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X)->  concat(A',B',C',D',E',F',G',H',I,J,K,L,M,N,O,P,Q,R,I',J',K',L',M',N')
                  [X>=N'+1,V>=L',U>=K',T>=J'+1,H>=H',F>=F',E>=E',D>=D',B>=B',A>=A',H>=X,D>=T,N'>=0,J'>=0,W>=2,V>=0,U>=0,S>=2,R>=0,Q>=1,P>=0,O>=0,N>=0,M>=0,L>=0,K>=0,J>=0,I>=0,G>=2,F>=0,E>=0,C>=2,B>=0,A>=1,W=M'+1,S=I'+1,G=G'+1,C=C'+1] 
* Loop 46: concat(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X)->  concat(A',B',C',D',E',F',G',H',I,J,K,L,M,N,O,P,Q,R,I',J',K',L',M',X)
                  [V>=L',U>=K',T>=J'+1,H>=H',F>=F',E>=E',D>=D',B>=B',A>=A',D>=T,J'>=0,X>=1,W>=2,V>=0,U>=0,S>=2,R>=0,Q>=1,P>=0,O>=0,N>=0,M>=0,L>=0,K>=0,J>=0,I>=0,H>=1,G>=2,F>=0,E>=0,C>=2,B>=0,A>=1,W=M'+1,S=I'+1,G=G'+1,C=C'+1] 
* Loop 47: concat(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X)->  concat(A',B',C',D',E',F',G',H',I,J,K,L,M,N,O,P,Q,R,I',T,J',K',L',M')
                  [X>=M'+1,V>=K',U>=J',H>=H',F>=F',E>=E',D>=D',B>=B',A>=A',H>=X,M'>=0,W>=2,V>=0,U>=0,T>=0,S>=2,R>=0,Q>=1,P>=0,O>=0,N>=0,M>=0,L>=0,K>=0,J>=0,I>=0,G>=2,F>=0,E>=0,D>=0,C>=2,B>=0,A>=1,W=L'+1,S=I'+1,G=G'+1,C=C'+1] 
* Loop 48: concat(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X)->  concat(A',B',C',D',E',F',G',H',I,J,K,L,M,N,O,P,Q,R,I',T,J',K',L',X)
                  [V>=K',U>=J',H>=H',F>=F',E>=E',D>=D',B>=B',A>=A',X>=1,W>=2,V>=0,U>=0,T>=0,S>=2,R>=0,Q>=1,P>=0,O>=0,N>=0,M>=0,L>=0,K>=0,J>=0,I>=0,H>=1,G>=2,F>=0,E>=0,D>=0,C>=2,B>=0,A>=1,W=L'+1,S=I'+1,G=G'+1,C=C'+1] 
* Loop 49: concat(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,I,J,K,L,M,N,O,P) [P>=0,O>=0,N>=0,M>=0,L>=0,K>=0,J>=0,I>=0,E>=0,H=0,G=1,F=0,D=0,C=1,B=0,A=0] 

### Ranking functions of CR concat(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X) 
* RF of phase [33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48]: [C-1,G-1]

#### Partial ranking functions of CR concat(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X) 
* Partial RF of phase [33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48]:
  - RF of loop [33:1,34:1,35:1,36:1,37:1,38:1,39:1,40:1,41:1,42:1,43:1,44:1,45:1,46:1,47:1,48:1]:
    C-1
    G-1

Discarded unfeasible chain [[33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48]]...(Non-terminating chain proved terminating)

### Resulting Chains:concat(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X) 
* [[33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48],49]
* [49]


### Merging Chains  concat/24 into  External patterns of execution 
* [[49]] --> 1 
* [[49,[33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48]]] --> 2 


### Specialization of cost equations and_op/3 
* CE 20 is refined into CE [52] 
* CE 19 is refined into CE [53] 


#### Refined cost equations and_op/3 
* CE 52: and_op(A,B,B) = 0
     [B>=0,A=1] 
* CE 53: and_op(A,B,C) = 0
     [B>=0,C=0,A=0] 

### Cost equations --> "Loop" of and_op/3 
* CEs [52] --> Loop 50 
* CEs [53] --> Loop 51 

#### Loops of and_op/3 
* Loop 50: and_op(A,B,B) [B>=0,A=1] 
* Loop 51: and_op(A,B,C) [B>=0,C=0,A=0] 

### Ranking functions of CR and_op(A,B,C) 

#### Partial ranking functions of CR and_op(A,B,C) 


### Resulting Chains:and_op(A,B,C) 
* [51]
* [50]


### Merging Chains  and_op/3 into  External patterns of execution 
* [[51]] --> 1 
* [[50]] --> 2 


### Specialization of cost equations neg/2 
* CE 22 is refined into CE [54] 
* CE 21 is refined into CE [55] 


#### Refined cost equations neg/2 
* CE 54: neg(A,B) = 0
     [B=0,A=1] 
* CE 55: neg(A,B) = 0
     [B=1,A=0] 

### Cost equations --> "Loop" of neg/2 
* CEs [54] --> Loop 52 
* CEs [55] --> Loop 53 

#### Loops of neg/2 
* Loop 52: neg(A,B) [B=0,A=1] 
* Loop 53: neg(A,B) [B=1,A=0] 

### Ranking functions of CR neg(A,B) 

#### Partial ranking functions of CR neg(A,B) 


### Resulting Chains:neg(A,B) 
* [53]
* [52]


### Merging Chains  neg/2 into  External patterns of execution 
* [[53]] --> 1 
* [[52]] --> 2 


### Specialization of cost equations or/3 
* CE 17 is refined into CE [56] 
* CE 18 is refined into CE [57] 


#### Refined cost equations or/3 
* CE 56: or(A,B,C) = 0
     [B>=0,C=1,A=1] 
* CE 57: or(A,B,B) = 0
     [B>=0,A=0] 

### Cost equations --> "Loop" of or/3 
* CEs [56] --> Loop 54 
* CEs [57] --> Loop 55 

#### Loops of or/3 
* Loop 54: or(A,B,C) [B>=0,C=1,A=1] 
* Loop 55: or(A,B,B) [B>=0,A=0] 

### Ranking functions of CR or(A,B,C) 

#### Partial ranking functions of CR or(A,B,C) 


### Resulting Chains:or(A,B,C) 
* [55]
* [54]


### Merging Chains  or/3 into  External patterns of execution 
* [[55]] --> 1 
* [[54]] --> 2 


### Specialization of cost equations eval/7 
* CE 14 is refined into CE [58] 
* CE 13 is refined into CE [59,60] 
* CE 11 is refined into CE [61,62] 
* CE 12 is refined into CE [63,64] 


#### Refined cost equations eval/7 
* CE 58: eval(A,B,C,D,E,F,G) = 3+ assoc(E,A,B,C,D,G):1
     [D>=G,C>=E,G>=0,B>=2,A>=1,E>=0,F=1] 
* CE 59: eval(A,B,C,D,E,F,G) = 5+ eval(A,B,C,D,E,H,I)+ neg(J,K):1
     [H>=1,E>=0,D>=0,C>=0,B>=0,A>=0,H+1=F,I=0,K=1,J=0,G=1] 
* CE 60: eval(A,B,C,D,E,F,G) = 5+ eval(A,B,C,D,E,H,I)+ neg(J,K):2
     [H>=1,E>=0,D>=0,C>=0,B>=0,A>=0,H+1=F,I=1,K=0,J=1,G=0] 
* CE 61: eval(A,B,C,D,E,F,G) = 8+ eval(A,B,C,D,H,I,J)+ eval(A,B,C,D,K,L,G)+ or(M,G,G):1
     [E>=K,E>=H,L>=1,I>=1,G>=0,E>=0,D>=0,C>=0,B>=0,A>=0,I+L+1=F,J=0,M=0] 
* CE 62: eval(A,B,C,D,E,F,G) = 8+ eval(A,B,C,D,H,I,J)+ eval(A,B,C,D,K,L,M)+ or(N,M,O):2
     [E>=K,E>=H,L>=1,I>=1,M>=0,E>=0,D>=0,C>=0,B>=0,A>=0,I+L+1=F,J=1,O=1,N=1,G=1] 
* CE 63: eval(A,B,C,D,E,F,G) = 7+ eval(A,B,C,D,H,I,J)+ eval(A,B,C,D,K,L,M)+ and_op(N,M,O):1
     [E>=K,E>=H,L>=1,I>=1,M>=0,E>=0,D>=0,C>=0,B>=0,A>=0,I+L+1=F,J=0,O=0,N=0,G=0] 
* CE 64: eval(A,B,C,D,E,F,G) = 7+ eval(A,B,C,D,H,I,J)+ eval(A,B,C,D,K,L,G)+ and_op(M,G,G):2
     [E>=K,E>=H,L>=1,I>=1,G>=0,E>=0,D>=0,C>=0,B>=0,A>=0,I+L+1=F,J=1,M=1] 

### Cost equations --> "Loop" of eval/7 
* CEs [64] --> Loop 56 
* CEs [61] --> Loop 57 
* CEs [62] --> Loop 58 
* CEs [63] --> Loop 59 
* CEs [59] --> Loop 60 
* CEs [60] --> Loop 61 
* CEs [58] --> Loop 62 

#### Loops of eval/7 
* Loop 56: eval(A,B,C,D,E,F,G)->  eval(A,B,C,D,A',B',C')  eval(A,B,C,D,A'2,B'2,G)
                  [E>=A'2,F>=B'+2,E>=A',B'>=1,G>=0,E>=0,D>=0,C>=0,B>=0,A>=0,B'+B'2+1=F,C'=1] 
* Loop 57: eval(A,B,C,D,E,F,G)->  eval(A,B,C,D,A',B',C')  eval(A,B,C,D,A'2,B'2,G)
                  [E>=A'2,F>=B'+2,E>=A',B'>=1,G>=0,E>=0,D>=0,C>=0,B>=0,A>=0,B'+B'2+1=F,C'=0] 
* Loop 58: eval(A,B,C,D,E,F,G)->  eval(A,B,C,D,A',B',C')  eval(A,B,C,D,A'2,B'2,C'2)
                  [E>=A'2,F>=B'+2,E>=A',C'2>=0,B'>=1,E>=0,D>=0,C>=0,B>=0,A>=0,B'+B'2+1=F,C'=1,G=1] 
* Loop 59: eval(A,B,C,D,E,F,G)->  eval(A,B,C,D,A',B',C')  eval(A,B,C,D,A'2,B'2,C'2)
                  [E>=A'2,F>=B'+2,E>=A',C'2>=0,B'>=1,E>=0,D>=0,C>=0,B>=0,A>=0,B'+B'2+1=F,C'=0,G=0] 
* Loop 60: eval(A,B,C,D,E,F,G)->  eval(A,B,C,D,E,A',B')
                  [F>=2,E>=0,D>=0,C>=0,B>=0,A>=0,F=A'+1,B'=0,G=1] 
* Loop 61: eval(A,B,C,D,E,F,G)->  eval(A,B,C,D,E,A',B')
                  [F>=2,E>=0,D>=0,C>=0,B>=0,A>=0,F=A'+1,B'=1,G=0] 
* Loop 62: eval(A,B,C,D,E,F,G) [D>=G,C>=E,G>=0,E>=0,B>=2,A>=1,F=1] 

### Ranking functions of CR eval(A,B,C,D,E,F,G) 
* RF of phase [56,57,58,59,60,61]: [F-1]

#### Partial ranking functions of CR eval(A,B,C,D,E,F,G) 
* Partial RF of phase [56,57,58,59,60,61]:
  - RF of loop [56:1,56:2,57:1,57:2,58:1,58:2,59:1,59:2]:
    F/2-1
  - RF of loop [60:1,61:1]:
    F-1

Discarded unfeasible chain [multiple([56,57,58,59,60,61],[[],[62]])]...(Non-terminating chain proved terminating)
Remaining chain: [multiple([56,57,58,59,60,61],[[62]])]

### Resulting Chains:eval(A,B,C,D,E,F,G) 
* [62]
* [multiple([56,57,58,59,60,61],[[62]])]


### Merging Chains  eval/7 into  External patterns of execution 
* [[62]] --> 1 
* [[multiple([56,57,58,59,60,61],[[62]])]] --> 2 


### Specialization of cost equations case_2/8 
* CE 29 is refined into CE [65] 
* CE 30 is refined into CE [66] 


#### Refined cost equations case_2/8 
* CE 65: case_2(A,B,C,D,C,E,C,D) = 1
     [C>=A+1,D>=0,B>=0,A>=0,E=1] 
* CE 66: case_2(A,B,C,D,E,F,E,G) = 2
     [E>=C+1,E>=A+1,D>=0,C>=0,B>=0,A>=0,G=0,F=1] 

### Cost equations --> "Loop" of case_2/8 
* CEs [65] --> Loop 63 
* CEs [66] --> Loop 64 

#### Loops of case_2/8 
* Loop 63: case_2(A,B,C,D,C,E,C,D) [C>=A+1,D>=0,B>=0,A>=0,E=1] 
* Loop 64: case_2(A,B,C,D,E,F,E,G) [E>=C+1,E>=A+1,D>=0,C>=0,B>=0,A>=0,G=0,F=1] 

### Ranking functions of CR case_2(A,B,C,D,E,F,G,H) 

#### Partial ranking functions of CR case_2(A,B,C,D,E,F,G,H) 


### Resulting Chains:case_2(A,B,C,D,E,F,G,H) 
* [64]
* [63]


### Merging Chains  case_2/8 into  External patterns of execution 
* [[64]] --> 1 
* [[63]] --> 2 


### Specialization of cost equations case_1/8 
* CE 24 is refined into CE [67,68] 
* CE 23 is refined into CE [69] 


#### Refined cost equations case_1/8 
* CE 67: case_1(A,B,C,D,E,F,E,G) = 2+ case_2(A,B,C,D,E,H,E,I):1
     [E>=C+1,E>=A+1,D>=0,C>=0,B>=0,A>=0,I=0,H=1,G=0,F=1] 
* CE 68: case_1(A,B,C,D,C,E,C,D) = 2+ case_2(A,B,C,D,C,F,C,D):2
     [C>=A+1,D>=0,B>=0,A>=0,F=1,E=1] 
* CE 69: case_1(A,B,C,D,A,E,A,B) = 1
     [A>=0,D>=0,C>=0,B>=0,E=1] 

### Cost equations --> "Loop" of case_1/8 
* CEs [68] --> Loop 65 
* CEs [69] --> Loop 66 
* CEs [67] --> Loop 67 

#### Loops of case_1/8 
* Loop 65: case_1(A,B,C,D,C,E,C,D) [C>=A+1,D>=0,B>=0,A>=0,E=1] 
* Loop 66: case_1(A,B,C,D,A,E,A,B) [D>=0,C>=0,B>=0,A>=0,E=1] 
* Loop 67: case_1(A,B,C,D,E,F,E,G) [E>=C+1,E>=A+1,D>=0,C>=0,B>=0,A>=0,G=0,F=1] 

### Ranking functions of CR case_1(A,B,C,D,E,F,G,H) 

#### Partial ranking functions of CR case_1(A,B,C,D,E,F,G,H) 


### Resulting Chains:case_1(A,B,C,D,E,F,G,H) 
* [67]
* [66]
* [65]


### Merging Chains  case_1/8 into  External patterns of execution 
* [[67]] --> 1 
* [[66]] --> 2 
* [[65]] --> 3 


### Specialization of cost equations eval2/7 
* CE 4 is refined into CE [70,71,72] 
* CE 3 is refined into CE [73,74] 
* CE 1 is refined into CE [75,76] 
* CE 2 is refined into CE [77,78] 


#### Refined cost equations eval2/7 
* CE 70: eval2(A,B,C,D,E,F,G) = 3+ case_1(A,B,C,D,E,H,E,I):1
     [E>=C+1,E>=A+1,D>=0,C>=0,B>=0,A>=0,I=0,H=1,G=0,F=1] 
* CE 71: eval2(A,B,C,D,A,E,B) = 3+ case_1(A,B,C,D,A,F,A,B):2
     [B>=0,A>=0,D>=0,C>=0,F=1,E=1] 
* CE 72: eval2(A,B,C,D,C,E,D) = 3+ case_1(A,B,C,D,C,F,C,D):3
     [C>=A+1,D>=0,B>=0,A>=0,F=1,E=1] 
* CE 73: eval2(A,B,C,D,E,F,G) = 5+ eval2(A,B,C,D,E,H,I)+ neg(J,K):1
     [H>=1,E>=0,D>=0,C>=0,B>=0,A>=0,H+1=F,I=0,K=1,J=0,G=1] 
* CE 74: eval2(A,B,C,D,E,F,G) = 5+ eval2(A,B,C,D,E,H,I)+ neg(J,K):2
     [H>=1,E>=0,D>=0,C>=0,B>=0,A>=0,H+1=F,I=1,K=0,J=1,G=0] 
* CE 75: eval2(A,B,C,D,E,F,G) = 8+ eval2(A,B,C,D,H,I,J)+ eval2(A,B,C,D,K,L,G)+ or(M,G,G):1
     [E>=K,E>=H,L>=1,I>=1,G>=0,E>=0,D>=0,C>=0,B>=0,A>=0,I+L+1=F,J=0,M=0] 
* CE 76: eval2(A,B,C,D,E,F,G) = 8+ eval2(A,B,C,D,H,I,J)+ eval2(A,B,C,D,K,L,M)+ or(N,M,O):2
     [E>=K,E>=H,L>=1,I>=1,M>=0,E>=0,D>=0,C>=0,B>=0,A>=0,I+L+1=F,J=1,O=1,N=1,G=1] 
* CE 77: eval2(A,B,C,D,E,F,G) = 7+ eval2(A,B,C,D,H,I,J)+ eval2(A,B,C,D,K,L,M)+ and_op(N,M,O):1
     [E>=K,E>=H,L>=1,I>=1,M>=0,E>=0,D>=0,C>=0,B>=0,A>=0,I+L+1=F,J=0,O=0,N=0,G=0] 
* CE 78: eval2(A,B,C,D,E,F,G) = 7+ eval2(A,B,C,D,H,I,J)+ eval2(A,B,C,D,K,L,G)+ and_op(M,G,G):2
     [E>=K,E>=H,L>=1,I>=1,G>=0,E>=0,D>=0,C>=0,B>=0,A>=0,I+L+1=F,J=1,M=1] 

### Cost equations --> "Loop" of eval2/7 
* CEs [78] --> Loop 68 
* CEs [75] --> Loop 69 
* CEs [76] --> Loop 70 
* CEs [77] --> Loop 71 
* CEs [73] --> Loop 72 
* CEs [74] --> Loop 73 
* CEs [72] --> Loop 74 
* CEs [71] --> Loop 75 
* CEs [70] --> Loop 76 

#### Loops of eval2/7 
* Loop 68: eval2(A,B,C,D,E,F,G)->  eval2(A,B,C,D,A',B',C')  eval2(A,B,C,D,A'2,B'2,G)
                  [E>=A'2,F>=B'+2,E>=A',B'>=1,G>=0,E>=0,D>=0,C>=0,B>=0,A>=0,B'+B'2+1=F,C'=1] 
* Loop 69: eval2(A,B,C,D,E,F,G)->  eval2(A,B,C,D,A',B',C')  eval2(A,B,C,D,A'2,B'2,G)
                  [E>=A'2,F>=B'+2,E>=A',B'>=1,G>=0,E>=0,D>=0,C>=0,B>=0,A>=0,B'+B'2+1=F,C'=0] 
* Loop 70: eval2(A,B,C,D,E,F,G)->  eval2(A,B,C,D,A',B',C')  eval2(A,B,C,D,A'2,B'2,C'2)
                  [E>=A'2,F>=B'+2,E>=A',C'2>=0,B'>=1,E>=0,D>=0,C>=0,B>=0,A>=0,B'+B'2+1=F,C'=1,G=1] 
* Loop 71: eval2(A,B,C,D,E,F,G)->  eval2(A,B,C,D,A',B',C')  eval2(A,B,C,D,A'2,B'2,C'2)
                  [E>=A'2,F>=B'+2,E>=A',C'2>=0,B'>=1,E>=0,D>=0,C>=0,B>=0,A>=0,B'+B'2+1=F,C'=0,G=0] 
* Loop 72: eval2(A,B,C,D,E,F,G)->  eval2(A,B,C,D,E,A',B')
                  [F>=2,E>=0,D>=0,C>=0,B>=0,A>=0,F=A'+1,B'=0,G=1] 
* Loop 73: eval2(A,B,C,D,E,F,G)->  eval2(A,B,C,D,E,A',B')
                  [F>=2,E>=0,D>=0,C>=0,B>=0,A>=0,F=A'+1,B'=1,G=0] 
* Loop 74: eval2(A,B,C,D,C,E,D) [C>=A+1,D>=0,B>=0,A>=0,E=1] 
* Loop 75: eval2(A,B,C,D,A,E,B) [D>=0,C>=0,B>=0,A>=0,E=1] 
* Loop 76: eval2(A,B,C,D,E,F,G) [E>=C+1,E>=A+1,D>=0,C>=0,B>=0,A>=0,G=0,F=1] 

### Ranking functions of CR eval2(A,B,C,D,E,F,G) 
* RF of phase [68,69,70,71,72,73]: [F-1]

#### Partial ranking functions of CR eval2(A,B,C,D,E,F,G) 
* Partial RF of phase [68,69,70,71,72,73]:
  - RF of loop [68:1,68:2,69:1,69:2,70:1,70:2,71:1,71:2]:
    F/2-1
  - RF of loop [72:1,73:1]:
    F-1

Discarded unfeasible chain [multiple([68,69,70,71,72,73],[[],[76],[75],[74]])]...(Non-terminating chain proved terminating)
Remaining chain: [multiple([68,69,70,71,72,73],[[76],[75],[74]])]

### Resulting Chains:eval2(A,B,C,D,E,F,G) 
* [76]
* [75]
* [74]
* [multiple([68,69,70,71,72,73],[[76],[75],[74]])]


### Merging Chains  eval2/7 into  External patterns of execution 
* [[76]] --> 1 
* [[75]] --> 2 
* [[74]] --> 3 
* [[multiple([68,69,70,71,72,73],[[76],[75],[74]])]] --> 4 


### Specialization of cost equations aux_rev/18 
* CE 28 is refined into CE [79] 
* CE 27 is refined into CE [80,81,82,83] 


#### Refined cost equations aux_rev/18 
* CE 79: aux_rev(A,B,C,D,B,E,F,G,H,I,J,K,A,B,C,D,B,E) = 2
     [H>=0,E>=0,B>=1,D>=0,C>=0,A>=0,K=0,J=1,I=0,G=1,F=0] 
* CE 80: aux_rev(A,B,C,D,B,E,F,G,H,I,J,K,L,M,N,O,P,Q) = 5+ maxNorm(R,E,R):1+ maxNorm(S,A,S):1+ aux_rev(S,T,U,V,W,R,X,Y,Z,A1,B1,C1,L,M,N,O,P,Q)
     [K>=C1,I>=A1,H>=Z,F>=X,F>=S,S>=A+1,K>=R,R>=E+1,V>=D,U>=C,B1>=1,Y>=1,A>=0,E>=0,Q>=0,P>=0,O>=0,N>=0,M>=0,L>=0,I>=0,H>=0,B>=1,D>=0,C>=0,B+1=W,B+1=T,B1+1=J,Y+1=G] 
* CE 81: aux_rev(A,B,C,D,B,E,F,G,H,I,J,K,L,M,N,O,P,Q) = 5+ maxNorm(R,E,R):1+ maxNorm(S,A,A):2+ aux_rev(A,T,U,V,W,R,X,Y,Z,A1,B1,C1,L,M,N,O,P,Q)
     [K>=C1,I>=A1,H>=Z,F>=X,A>=S,F>=S,K>=R,R>=E+1,V>=D,U>=C,B1>=1,Y>=1,S>=1,E>=0,Q>=0,P>=0,O>=0,N>=0,M>=0,L>=0,I>=0,H>=0,B>=1,D>=0,C>=0,B+1=W,B+1=T,B1+1=J,Y+1=G] 
* CE 82: aux_rev(A,B,C,D,B,E,F,G,H,I,J,K,L,M,N,O,P,Q) = 5+ maxNorm(R,E,E):2+ maxNorm(S,A,S):1+ aux_rev(S,T,U,V,W,E,X,Y,Z,A1,B1,C1,L,M,N,O,P,Q)
     [K>=C1,I>=A1,H>=Z,F>=X,F>=S,S>=A+1,E>=R,K>=R,V>=D,U>=C,B1>=1,Y>=1,A>=0,R>=1,Q>=0,P>=0,O>=0,N>=0,M>=0,L>=0,I>=0,H>=0,B>=1,D>=0,C>=0,B+1=W,B+1=T,B1+1=J,Y+1=G] 
* CE 83: aux_rev(A,B,C,D,B,E,F,G,H,I,J,K,L,M,N,O,P,Q) = 5+ maxNorm(R,E,E):2+ maxNorm(S,A,A):2+ aux_rev(A,T,U,V,W,E,X,Y,Z,A1,B1,C1,L,M,N,O,P,Q)
     [K>=C1,I>=A1,H>=Z,F>=X,A>=S,F>=S,E>=R,K>=R,V>=D,U>=C,B1>=1,Y>=1,S>=1,R>=1,Q>=0,P>=0,O>=0,N>=0,M>=0,L>=0,I>=0,H>=0,B>=1,D>=0,C>=0,B+1=W,B+1=T,B1+1=J,Y+1=G] 

### Cost equations --> "Loop" of aux_rev/18 
* CEs [80] --> Loop 77 
* CEs [82] --> Loop 78 
* CEs [81] --> Loop 79 
* CEs [83] --> Loop 80 
* CEs [79] --> Loop 81 

#### Loops of aux_rev/18 
* Loop 77: aux_rev(A,B,C,D,B,E,F,G,H,I,J,K,L,M,N,O,P,Q)->  aux_rev(A',B',C',D',E',F',G',H',I',J',K',L',L,M,N,O,P,Q)
                  [K>=L',I>=J',H>=I',F>=G',K>=F',F>=A',F'>=E+1,D'>=D,C'>=C,A'>=A+1,Q>=0,P>=0,O>=0,N>=0,M>=0,L>=0,J>=2,I>=0,H>=0,G>=2,E>=0,D>=0,C>=0,B>=1,A>=0,J=K'+1,G=H'+1,B+1=E',B+1=B'] 
* Loop 78: aux_rev(A,B,C,D,B,E,F,G,H,I,J,K,L,M,N,O,P,Q)->  aux_rev(A',B',C',D',E',E,F',G',H',I',J',K',L,M,N,O,P,Q)
                  [K>=K',I>=I',H>=H',F>=F',F>=A',D'>=D,C'>=C,A'>=A+1,Q>=0,P>=0,O>=0,N>=0,M>=0,L>=0,K>=1,J>=2,I>=0,H>=0,G>=2,E>=1,D>=0,C>=0,B>=1,A>=0,J=J'+1,G=G'+1,B+1=E',B+1=B'] 
* Loop 79: aux_rev(A,B,C,D,B,E,F,G,H,I,J,K,L,M,N,O,P,Q)->  aux_rev(A,A',B',C',D',E',F',G',H',I',J',K',L,M,N,O,P,Q)
                  [K>=K',I>=I',H>=H',F>=F',K>=E',E'>=E+1,C'>=D,B'>=C,Q>=0,P>=0,O>=0,N>=0,M>=0,L>=0,J>=2,I>=0,H>=0,G>=2,F>=1,E>=0,D>=0,C>=0,B>=1,A>=1,J=J'+1,G=G'+1,B+1=D',B+1=A'] 
* Loop 80: aux_rev(A,B,C,D,B,E,F,G,H,I,J,K,L,M,N,O,P,Q)->  aux_rev(A,A',B',C',D',E,E',F',G',H',I',J',L,M,N,O,P,Q)
                  [K>=J',I>=H',H>=G',F>=E',C'>=D,B'>=C,Q>=0,P>=0,O>=0,N>=0,M>=0,L>=0,K>=1,J>=2,I>=0,H>=0,G>=2,F>=1,E>=1,D>=0,C>=0,B>=1,A>=1,J=I'+1,G=F'+1,B+1=D',B+1=A'] 
* Loop 81: aux_rev(A,B,C,D,B,E,F,G,H,I,J,K,A,B,C,D,B,E) [H>=0,E>=0,D>=0,C>=0,B>=1,A>=0,K=0,J=1,I=0,G=1,F=0] 

### Ranking functions of CR aux_rev(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R) 
* RF of phase [77,78,79,80]: [H-1,K-1]

#### Partial ranking functions of CR aux_rev(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R) 
* Partial RF of phase [77,78,79,80]:
  - RF of loop [77:1,78:1]:
    -A+G
  - RF of loop [77:1,78:1,79:1,80:1]:
    H-1
    K-1
  - RF of loop [77:1,79:1]:
    -F+L

Discarded unfeasible chain [[77,78,79,80]]...(Non-terminating chain proved terminating)

### Resulting Chains:aux_rev(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R) 
* [[77,78,79,80],81]
* [81]


### Merging Chains  aux_rev/18 into  External patterns of execution 
* [[81]] --> 1 
* [[81,[77,78,79,80]]] --> 2 


### Specialization of cost equations rev/12 
* CE 6 is refined into CE [84,85] 


#### Refined cost equations rev/12 
* CE 84: rev(A,B,C,D,E,F,G,H,I,J,K,L) = 2+ aux_rev(M,N,I,O,P,Q,R,S,C,T,U,V,W,X,I,Y,Z,A1):1
     [I>=0,C>=0,A1=0,Z=1,Y=0,X=1,W=0,V=0,U=1,T=0,S=1,R=0,Q=0,P=1,O=0,N=1,M=0,L=0,K=1,J=0,H=1,G=0,F=0,E=1,D=0,B=1,A=0] 
* CE 85: rev(A,B,C,D,B,E,F,B,G,H,B,I) = 2+ aux_rev(J,K,L,M,N,O,A,B,C,D,B,E,F,B,G,H,B,I):2
     [G>=L,I>=1,H>=0,F>=1,E>=1,B>=2,D>=0,C>=0,A>=1,L>=0,O=0,N=1,M=0,K=1,J=0] 

### Cost equations --> "Loop" of rev/12 
* CEs [85] --> Loop 82 
* CEs [84] --> Loop 83 

#### Loops of rev/12 
* Loop 82: rev(A,B,C,D,B,E,F,B,G,H,B,I) [I>=1,H>=0,G>=0,F>=1,E>=1,D>=0,C>=0,B>=2,A>=1] 
* Loop 83: rev(A,B,C,D,E,F,G,H,I,J,K,L) [I>=0,C>=0,L=0,K=1,J=0,H=1,G=0,F=0,E=1,D=0,B=1,A=0] 

### Ranking functions of CR rev(A,B,C,D,E,F,G,H,I,J,K,L) 

#### Partial ranking functions of CR rev(A,B,C,D,E,F,G,H,I,J,K,L) 


### Resulting Chains:rev(A,B,C,D,E,F,G,H,I,J,K,L) 
* [83]
* [82]


### Merging Chains  rev/12 into  External patterns of execution 
* [[83]] --> 1 
* [[82]] --> 2 


### Specialization of cost equations table2/7 
* CE 5 is refined into CE [86,87,88,89] 


#### Refined cost equations table2/7 
* CE 86: table2(A,B,C,D,E,F,G) = 29+ eval2(A,H,B,I,C,J,K):1+ eval2(A,L,B,M,C,N,O):1+ eval2(A,P,B,Q,C,R,S):1+ eval2(A,T,B,U,C,V,W):1+ maxNorm(X,Y,Z):1+ maxNorm(A1,B1,C1):2+ maxNorm(D1,E1,F1):2+ maxNorm(G1,H1,I1):2
     [C>=B+1,C>=A+1,B>=0,A>=0,G>=1,I1=1,H1=1,G1=1,F1=1,E1=1,D1=1,C1=1,B1=1,A1=1,Z=1,Y=0,X=1,W=0,V=1,U=0,T=0,S=0,R=1,Q=1,P=0,O=0,N=1,M=0,L=1,K=0,J=1,I=1,H=1,F=5,E=1,D=1] 
* CE 87: table2(A,B,A,C,D,E,F) = 29+ eval2(A,G,B,H,A,I,J):2+ eval2(A,K,B,L,A,M,N):2+ eval2(A,O,B,P,A,Q,R):2+ eval2(A,S,B,T,A,U,V):2+ maxNorm(W,X,Y):1+ maxNorm(Z,A1,B1):2+ maxNorm(C1,D1,E1):2+ maxNorm(F1,G1,H1):2
     [A>=0,B>=0,F>=1,H1=1,G1=1,F1=1,E1=1,D1=1,C1=1,B1=1,A1=1,Z=1,Y=1,X=0,W=1,V=0,U=1,T=0,S=0,R=0,Q=1,P=1,O=0,N=1,M=1,L=0,K=1,J=1,I=1,H=1,G=1,E=5,D=1,C=1] 
* CE 88: table2(A,B,B,C,D,E,F) = 29+ eval2(A,G,B,H,B,I,J):3+ eval2(A,K,B,L,B,M,N):3+ eval2(A,O,B,P,B,Q,R):3+ eval2(A,S,B,T,B,U,V):3+ maxNorm(W,X,Y):1+ maxNorm(Z,A1,B1):2+ maxNorm(C1,D1,E1):2+ maxNorm(F1,G1,H1):2
     [B>=A+1,A>=0,F>=1,H1=1,G1=1,F1=1,E1=1,D1=1,C1=1,B1=1,A1=1,Z=1,Y=1,X=0,W=1,V=0,U=1,T=0,S=0,R=1,Q=1,P=1,O=0,N=0,M=1,L=0,K=1,J=1,I=1,H=1,G=1,E=5,D=1,C=1] 
* CE 89: table2(A,B,C,D,E,F,G) = 29+ eval2(A,H,B,I,C,D,J):4+ eval2(A,K,B,L,C,D,M):4+ eval2(A,N,B,O,C,D,P):4+ eval2(A,Q,B,R,C,D,S):4+ maxNorm(T,U,V):1+ maxNorm(W,X,Y):2+ maxNorm(Z,A1,B1):2+ maxNorm(C1,D1,E1):2
     [D+S>=3,D>=S+1,G>=S,C>=A,D>=P,G>=P,D>=M,G>=M,D+1>=J,G>=J,S>=0,B>=0,A>=0,P>=0,M>=0,J>=0,G>=1,E1=1,D1=1,C1=1,B1=1,A1=1,Z=1,Y=1,X=1,W=1,V=1,U=0,T=1,R=0,Q=0,O=1,N=0,L=0,K=1,I=1,H=1,F=5,E=1] 

### Cost equations --> "Loop" of table2/7 
* CEs [89] --> Loop 84 
* CEs [86] --> Loop 85 
* CEs [88] --> Loop 86 
* CEs [87] --> Loop 87 

#### Loops of table2/7 
* Loop 84: table2(A,B,C,D,E,F,G) [C>=A,G>=1,D>=2,B>=0,A>=0,F=5,E=1] 
* Loop 85: table2(A,B,C,D,E,F,G) [C>=B+1,C>=A+1,G>=1,B>=0,A>=0,F=5,E=1,D=1] 
* Loop 86: table2(A,B,B,C,D,E,F) [B>=A+1,F>=1,A>=0,E=5,D=1,C=1] 
* Loop 87: table2(A,B,A,C,D,E,F) [F>=1,B>=0,A>=0,E=5,D=1,C=1] 

### Ranking functions of CR table2(A,B,C,D,E,F,G) 

#### Partial ranking functions of CR table2(A,B,C,D,E,F,G) 


### Resulting Chains:table2(A,B,C,D,E,F,G) 
* [87]
* [86]
* [85]
* [84]


### Merging Chains  table2/7 into  External patterns of execution 
* [[87]] --> 1 
* [[86]] --> 2 
* [[85]] --> 3 
* [[84]] --> 4 


### Specialization of cost equations table_make/14 
* CE 16 is refined into CE [90,91] 
* CE 15 is refined into CE [92,93,94,95] 


#### Refined cost equations table_make/14 
* CE 90: table_make(A,B,C,D,E,F,G,H,I,J,K,B,L,M) = 7+ rev(A,B,C,D,B,N,J,B,O,P,B,Q):2+ eval(A,B,C,D,G,R,S):1+ maxNorm(B,T,B):1+ maxNorm(J,U,J):1+ maxNorm(V,W,X):1
     [D>=S,M>=S,C>=G,M>=P,L>=O,J>=1,B>=2,S>=0,G>=0,A>=1,Q>=1,P>=0,O>=0,N>=1,F>=0,X=1,W=0,V=1,U=0,T=0,R=1,K=2,I=1,H=1,E=1] 
* CE 91: table_make(A,B,C,D,E,F,G,H,I,J,K,B,L,M) = 7+ rev(A,B,C,D,B,N,J,B,O,P,B,Q):2+ eval(A,B,C,D,G,H,R):2+ maxNorm(B,S,B):1+ maxNorm(J,T,J):1+ maxNorm(U,V,W):1
     [D+H+R>=3,D+H>=R+1,M>=R,M>=P,L>=O,J>=1,B>=2,R>=0,H>=2,G>=0,D>=0,C>=0,A>=1,Q>=1,P>=0,O>=0,N>=1,F>=0,W=1,V=0,U=1,T=0,S=0,K=2,I=1,E=1] 
* CE 92: table_make(A,B,C,D,E,F,G,H,I,J,K,L,M,N) = 12+ maxNorm(O,P,Q):1+ table_make(R,S,T,U,V,W,G,H,X,Y,Z,A1,B1,C1)+ maxNorm(D1,E1,F1):1+ table_make(G1,H1,I1,J1,V,W,G,H,I,J,K,L,M,N)+ concat(K1,L1,M1,N1,B1,O1,P1,Q1,I,J,K,L,M,N,R1,S1,I,J,K,L,M,N,R1,S1):1
     [F>=W,J1>=D,U>=D,I1>=C,T>=C,V>=1,U>=1,S1>=0,R1>=0,N>=0,M>=0,L>=0,K>=0,J>=0,I>=0,B1>=0,H>=0,G>=0,F>=0,D>=0,C>=0,B>=1,B+1=H1,B+1=S,V+1=E,G1=1,C1=0,A1=0,Z=1,Y=0,X=0,R=1,Q1=0,P1=1,O1=0,N1=0,M1=1,L1=0,K1=0,F1=1,E1=0,D1=1,Q=1,P=0,O=1,A=0] 
* CE 93: table_make(A,B,C,D,E,F,G,H,I,J,K,L,M,N) = 12+ maxNorm(O,P,Q):1+ table_make(R,S,T,U,V,W,G,H,X,Y,Z,A1,B1,C1)+ maxNorm(D1,E1,F1):1+ table_make(G1,H1,I1,J1,V,W,G,H,K1,L1,M1,N1,O1,P1)+ concat(X,Y,Z,A1,B1,C1,Z,Q1,K1,L1,R1,N1,O1,P1,S1,T1,I,J,K,L,M,N,U1,V1):2
     [Q1+T1>=V1,A1+N1>=L,Y+L1>=J,X+K1>=I,F>=W,V1>=T1,N>=P1,M>=O1,L>=N1,J>=L1,I>=K1,U1>=Z,K>=Z,J1>=D,U>=D,I1>=C,T>=C,V>=1,U>=1,V1>=1,I>=1,T1>=0,P1>=0,O1>=0,N1>=0,L1>=0,K1>=0,Q1>=1,Z>=2,C1>=0,B1>=0,X>=1,H>=0,G>=0,F>=0,D>=0,C>=0,B>=1,Z+S1=U1+1,Z+M1=K+1,Z+R1=K+1,B+1=H1,B+1=S,V+1=E,G1=1,R=1,F1=1,E1=0,D1=1,Q=1,P=0,O=1,A=0] 
* CE 94: table_make(A,B,C,D,E,F,G,H,I,J,K,L,M,N) = 12+ maxNorm(O,A,A):2+ table_make(A,P,Q,R,S,T,G,H,U,V,W,X,Y,Z)+ maxNorm(A1,A,A):2+ table_make(A,B1,C1,D1,S,T,G,H,I,J,K,L,M,N)+ concat(E1,F1,G1,H1,Y,I1,J1,K1,I,J,K,L,M,N,L1,M1,I,J,K,L,M,N,L1,M1):1
     [F>=T,D1>=D,R>=D,C1>=C,Q>=C,S>=1,R>=1,M1>=0,L1>=0,N>=0,M>=0,L>=0,K>=0,J>=0,I>=0,Y>=0,A>=1,H>=0,G>=0,F>=0,D>=0,C>=0,B>=1,B+1=B1,B+1=P,S+1=E,Z=0,X=0,W=1,V=0,U=0,K1=0,J1=1,I1=0,H1=0,G1=1,F1=0,E1=0,A1=1,O=1] 
* CE 95: table_make(A,B,C,D,E,F,G,H,I,J,K,L,M,N) = 12+ maxNorm(O,A,A):2+ table_make(A,P,Q,R,S,T,G,H,U,V,W,X,Y,Z)+ maxNorm(A1,A,A):2+ table_make(A,B1,C1,D1,S,T,G,H,E1,F1,G1,H1,I1,J1)+ concat(U,V,W,X,Y,Z,W,K1,E1,F1,L1,H1,I1,J1,M1,N1,I,J,K,L,M,N,O1,P1):2
     [K1+N1>=P1,X+H1>=L,V+F1>=J,U+E1>=I,F>=T,P1>=N1,N>=J1,M>=I1,L>=H1,J>=F1,I>=E1,O1>=W,K>=W,D1>=D,R>=D,C1>=C,Q>=C,S>=1,R>=1,P1>=1,I>=1,N1>=0,J1>=0,I1>=0,H1>=0,F1>=0,E1>=0,K1>=1,W>=2,Z>=0,Y>=0,U>=1,A>=1,H>=0,G>=0,F>=0,D>=0,C>=0,B>=1,W+M1=O1+1,W+G1=K+1,W+L1=K+1,B+1=B1,B+1=P,S+1=E,A1=1,O=1] 

### Cost equations --> "Loop" of table_make/14 
* CEs [95] --> Loop 88 
* CEs [94] --> Loop 89 
* CEs [93] --> Loop 90 
* CEs [92] --> Loop 91 
* CEs [91] --> Loop 92 
* CEs [90] --> Loop 93 

#### Loops of table_make/14 
* Loop 88: table_make(A,B,C,D,E,F,G,H,I,J,K,L,M,N)->  table_make(A,A',B',C',D',E',G,H,F',G',H',I',J',K')  table_make(A,A'2,B'2,C'2,D'2,E',G,H,E'2,F'2,G'2,H'2,I'2,J'2)
                  [I'+H'2>=L,G'+F'2>=J,F'+E'2>=I,N>=J'2,M>=I'2,L>=H'2,J>=F'2,I>=E'2,K>=H',F>=E',C'2>=D,C'>=D,B'2>=C,B'>=C,J'2>=0,I'2>=0,H'2>=0,F'2>=0,E'2>=0,K'>=0,J'>=0,H'>=2,F'>=1,C'>=1,I>=1,H>=0,G>=0,F>=0,E>=2,D>=0,C>=0,B>=1,A>=1,H'+G'2=K+1,E=D'2+1,B+1=A'2,E=D'+1,B+1=A'] 
* Loop 89: table_make(A,B,C,D,E,F,G,H,I,J,K,L,M,N)->  table_make(A,A',B',C',D',E',G,H,F',G',H',I',J',K')  table_make(A,A'2,B'2,C'2,D'2,E',G,H,I,J,K,L,M,N)
                  [F>=E',C'2>=D,C'>=D,B'2>=C,B'>=C,J'>=0,C'>=1,N>=0,M>=0,L>=0,K>=0,J>=0,I>=0,H>=0,G>=0,F>=0,E>=2,D>=0,C>=0,B>=1,A>=1,E=D'2+1,B+1=A'2,E=D'+1,B+1=A',K'=0,I'=0,H'=1,G'=0,F'=0] 
* Loop 90: table_make(A,B,C,D,E,F,G,H,I,J,K,L,M,N)->  table_make(A',B',C',D',E',F',G,H,G',H',I',J',K',L')  table_make(A'2,B'2,C'2,D'2,E'2,F',G,H,F'2,G'2,H'2,I'2,J'2,K'2)
                  [J'+I'2>=L,H'+G'2>=J,G'+F'2>=I,N>=K'2,M>=J'2,L>=I'2,J>=G'2,I>=F'2,K>=I',F>=F',D'2>=D,D'>=D,C'2>=C,C'>=C,K'2>=0,J'2>=0,I'2>=0,G'2>=0,F'2>=0,L'>=0,K'>=0,I'>=2,G'>=1,D'>=1,I>=1,H>=0,G>=0,F>=0,E>=2,D>=0,C>=0,B>=1,I'+H'2=K+1,E=E'2+1,B+1=B'2,E=E'+1,B+1=B',A'2=1,A'=1,A=0] 
* Loop 91: table_make(A,B,C,D,E,F,G,H,I,J,K,L,M,N)->  table_make(A',B',C',D',E',F',G,H,G',H',I',J',K',L')  table_make(A'2,B'2,C'2,D'2,E'2,F',G,H,I,J,K,L,M,N)
                  [F>=F',D'2>=D,D'>=D,C'2>=C,C'>=C,K'>=0,D'>=1,N>=0,M>=0,L>=0,K>=0,J>=0,I>=0,H>=0,G>=0,F>=0,E>=2,D>=0,C>=0,B>=1,E=E'2+1,B+1=B'2,E=E'+1,B+1=B',A'2=1,L'=0,J'=0,I'=1,H'=0,G'=0,A'=1,A=0] 
* Loop 92: table_make(A,B,C,D,E,F,G,H,I,J,K,B,L,M) [D+H+M>=3,M>=0,L>=0,J>=1,H>=2,G>=0,F>=0,D>=0,C>=0,B>=2,A>=1,K=2,I=1,E=1] 
* Loop 93: table_make(A,B,C,D,E,F,G,H,I,J,K,B,L,M) [C>=G,M>=0,L>=0,J>=1,G>=0,F>=0,D>=0,B>=2,A>=1,K=2,I=1,H=1,E=1] 

### Ranking functions of CR table_make(A,B,C,D,E,F,G,H,I,J,K,L,M,N) 
* RF of phase [88,89]: [E-1]

#### Partial ranking functions of CR table_make(A,B,C,D,E,F,G,H,I,J,K,L,M,N) 
* Partial RF of phase [88,89]:
  - RF of loop [88:1,88:2,89:1,89:2]:
    E-1

Discarded unfeasible chain [multiple([88,89],[[],[93],[92]])]...(Non-terminating chain proved terminating)
Remaining chain: [multiple([88,89],[[93],[92]])]
Discarded unfeasible chain [multiple(91,[[multiple([88,89],[[],[93],[92]])],[93],[92]])](Non-terminating chain proved terminating)
Remaining chain: [multiple(91,[[multiple([88,89],[[93],[92]])],[93],[92]])]
Discarded unfeasible chain [multiple(90,[[multiple([88,89],[[],[93],[92]])],[93],[92]])](Non-terminating chain proved terminating)
Remaining chain: [multiple(90,[[multiple([88,89],[[93],[92]])],[93],[92]])]

### Resulting Chains:table_make(A,B,C,D,E,F,G,H,I,J,K,L,M,N) 
* [93]
* [92]
* [multiple([88,89],[[93],[92]])]
* [multiple(90,[[multiple([88,89],[[93],[92]])],[93],[92]])]


### Merging Chains  table_make/14 into  External patterns of execution 
* [[multiple(90,[[multiple([88,89],[[93],[92]])],[93],[92]])]] --> 1 
* [[93]] --> 2 
* [[92]] --> 3 
* [[multiple([88,89],[[93],[92]])]] --> 4 


Computing Bounds
=====================================

#### Simplifying cost structure of CE 31 

#### Computing cost of phase [29] 

#### Simplifying cost structure of CE 32 

#### Cost of loops [29] 

 * loop 29:assoc(A,B,C,D,E,F) -> [assoc(A',B',C',D',E',F')] 
5
##### Pending set assoc(A,B,C,D,E,F)
* Psum in Loop 29: [it(29)=<1]

###### Computing sum for it(29)=<1  in Loop 29 
   - Applying inductive sum strategy 
     - head Candidate: C-1 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(29)=<C-1,it(29)=<C-1,it(29)=<C-C',it(29)=<C-C'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [29] 

#### Simplifying cost structure of phase [29] 

#### Cost of phase [29]:assoc(A,B,C,D,E,F) -> [assoc(A',B',C',D',E',F')] 
5*it(29)+0
  Such that:it(29) =< C
it(29) =< C-C'

#### Simplifying cost structure of chain [[29],30] 
 * Renamed intermediate variables: 
[ (ch([[29],30]),it(29))>>s(1)]

#### Cost of chains of assoc(A,B,C,D,E,F):
* Chain [[29],30]: 5*it(29)+4
  Such that:it(29) =< C

  with precondition: [A>=0,B>=1,C>=3,F>=0,D>=A+1,E>=F] 

* Chain [30]: 4
  with precondition: [A>=0,B>=1,C>=2,F>=0,D>=A,E>=F] 


#### Simplifying cost structure of CE 34 

#### Simplifying cost structure of CE 33 

#### Cost of chains of maxNorm(A,B,C):
* Chain [32]: 0
  with precondition: [A=C,B>=0,A>=B+1] 

* Chain [31]: 0
  with precondition: [B=C,A>=0,B>=A] 


#### Simplifying cost structure of CE 35 

#### Computing cost of phase [33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48] 

#### Simplifying cost structure of CE 36 

#### Simplifying cost structure of CE 44 

#### Simplifying cost structure of CE 40 

#### Simplifying cost structure of CE 48 

#### Simplifying cost structure of CE 38 

#### Simplifying cost structure of CE 46 

#### Simplifying cost structure of CE 42 

#### Simplifying cost structure of CE 50 

#### Simplifying cost structure of CE 37 

#### Simplifying cost structure of CE 45 

#### Simplifying cost structure of CE 41 

#### Simplifying cost structure of CE 49 

#### Simplifying cost structure of CE 39 

#### Simplifying cost structure of CE 47 

#### Simplifying cost structure of CE 43 

#### Simplifying cost structure of CE 51 

#### Cost of loops [33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48] 

 * loop 33:concat(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X) -> [concat(A',B',C',D',E',F',G',H',I',J',K',L',M',N',O',P',Q',R',S',T',U',V',W',X')] 
5
 * loop 34:concat(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X) -> [concat(A',B',C',D',E',F',G',H',I',J',K',L',M',N',O',P',Q',R',S',T',U',V',W',X')] 
5
 * loop 35:concat(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X) -> [concat(A',B',C',D',E',F',G',H',I',J',K',L',M',N',O',P',Q',R',S',T',U',V',W',X')] 
5
 * loop 36:concat(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X) -> [concat(A',B',C',D',E',F',G',H',I',J',K',L',M',N',O',P',Q',R',S',T',U',V',W',X')] 
5
 * loop 37:concat(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X) -> [concat(A',B',C',D',E',F',G',H',I',J',K',L',M',N',O',P',Q',R',S',T',U',V',W',X')] 
5
 * loop 38:concat(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X) -> [concat(A',B',C',D',E',F',G',H',I',J',K',L',M',N',O',P',Q',R',S',T',U',V',W',X')] 
5
 * loop 39:concat(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X) -> [concat(A',B',C',D',E',F',G',H',I',J',K',L',M',N',O',P',Q',R',S',T',U',V',W',X')] 
5
 * loop 40:concat(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X) -> [concat(A',B',C',D',E',F',G',H',I',J',K',L',M',N',O',P',Q',R',S',T',U',V',W',X')] 
5
 * loop 41:concat(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X) -> [concat(A',B',C',D',E',F',G',H',I',J',K',L',M',N',O',P',Q',R',S',T',U',V',W',X')] 
5
 * loop 42:concat(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X) -> [concat(A',B',C',D',E',F',G',H',I',J',K',L',M',N',O',P',Q',R',S',T',U',V',W',X')] 
5
 * loop 43:concat(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X) -> [concat(A',B',C',D',E',F',G',H',I',J',K',L',M',N',O',P',Q',R',S',T',U',V',W',X')] 
5
 * loop 44:concat(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X) -> [concat(A',B',C',D',E',F',G',H',I',J',K',L',M',N',O',P',Q',R',S',T',U',V',W',X')] 
5
 * loop 45:concat(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X) -> [concat(A',B',C',D',E',F',G',H',I',J',K',L',M',N',O',P',Q',R',S',T',U',V',W',X')] 
5
 * loop 46:concat(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X) -> [concat(A',B',C',D',E',F',G',H',I',J',K',L',M',N',O',P',Q',R',S',T',U',V',W',X')] 
5
 * loop 47:concat(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X) -> [concat(A',B',C',D',E',F',G',H',I',J',K',L',M',N',O',P',Q',R',S',T',U',V',W',X')] 
5
 * loop 48:concat(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X) -> [concat(A',B',C',D',E',F',G',H',I',J',K',L',M',N',O',P',Q',R',S',T',U',V',W',X')] 
5
##### Pending set concat(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X)
* Psum in Loop 33: [it(33)=<1]
* Psum in Loop 34: [it(34)=<1]
* Psum in Loop 35: [it(35)=<1]
* Psum in Loop 36: [it(36)=<1]
* Psum in Loop 37: [it(37)=<1]
* Psum in Loop 38: [it(38)=<1]
* Psum in Loop 39: [it(39)=<1]
* Psum in Loop 40: [it(40)=<1]
* Psum in Loop 41: [it(41)=<1]
* Psum in Loop 42: [it(42)=<1]
* Psum in Loop 43: [it(43)=<1]
* Psum in Loop 44: [it(44)=<1]
* Psum in Loop 45: [it(45)=<1]
* Psum in Loop 46: [it(46)=<1]
* Psum in Loop 47: [it(47)=<1]
* Psum in Loop 48: [it(48)=<1]

###### Computing sum for it(33)=<1  in Loop 33 
   - Applying inductive sum strategy 
     - head Candidate: G-1 
       - Loop 34 is collaborative and bounds [it(34)] 
       - Loop 35 is collaborative and bounds [it(35)] 
       - Loop 36 is collaborative and bounds [it(36)] 
       - Loop 37 is collaborative and bounds [it(37)] 
       - Loop 38 is collaborative and bounds [it(38)] 
       - Loop 39 is collaborative and bounds [it(39)] 
       - Loop 40 is collaborative and bounds [it(40)] 
       - Loop 41 is collaborative and bounds [it(41)] 
       - Loop 42 is collaborative and bounds [it(42)] 
       - Loop 43 is collaborative and bounds [it(43)] 
       - Loop 44 is collaborative and bounds [it(44)] 
       - Loop 45 is collaborative and bounds [it(45)] 
       - Loop 46 is collaborative and bounds [it(46)] 
       - Loop 47 is collaborative and bounds [it(47)] 
       - Loop 48 is collaborative and bounds [it(48)] 
     - head Candidate: C-1 
       - Loop 34 is collaborative and bounds [it(34)] 
       - Loop 35 is collaborative and bounds [it(35)] 
       - Loop 36 is collaborative and bounds [it(36)] 
       - Loop 37 is collaborative and bounds [it(37)] 
       - Loop 38 is collaborative and bounds [it(38)] 
       - Loop 39 is collaborative and bounds [it(39)] 
       - Loop 40 is collaborative and bounds [it(40)] 
       - Loop 41 is collaborative and bounds [it(41)] 
       - Loop 42 is collaborative and bounds [it(42)] 
       - Loop 43 is collaborative and bounds [it(43)] 
       - Loop 44 is collaborative and bounds [it(44)] 
       - Loop 45 is collaborative and bounds [it(45)] 
       - Loop 46 is collaborative and bounds [it(46)] 
       - Loop 47 is collaborative and bounds [it(47)] 
       - Loop 48 is collaborative and bounds [it(48)] 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: G-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: G-1 
       - Loop 34 is collaborative and bounds [it(34)] 
       - Loop 35 is collaborative and bounds [it(35)] 
       - Loop 36 is collaborative and bounds [it(36)] 
       - Loop 37 is collaborative and bounds [it(37)] 
       - Loop 38 is collaborative and bounds [it(38)] 
       - Loop 39 is collaborative and bounds [it(39)] 
       - Loop 40 is collaborative and bounds [it(40)] 
       - Loop 41 is collaborative and bounds [it(41)] 
       - Loop 42 is collaborative and bounds [it(42)] 
       - Loop 43 is collaborative and bounds [it(43)] 
       - Loop 44 is collaborative and bounds [it(44)] 
       - Loop 45 is collaborative and bounds [it(45)] 
       - Loop 46 is collaborative and bounds [it(46)] 
       - Loop 47 is collaborative and bounds [it(47)] 
       - Loop 48 is collaborative and bounds [it(48)] 
     - tail Candidate: C-1 
       - Loop 34 is collaborative and bounds [it(34)] 
       - Loop 35 is collaborative and bounds [it(35)] 
       - Loop 36 is collaborative and bounds [it(36)] 
       - Loop 37 is collaborative and bounds [it(37)] 
       - Loop 38 is collaborative and bounds [it(38)] 
       - Loop 39 is collaborative and bounds [it(39)] 
       - Loop 40 is collaborative and bounds [it(40)] 
       - Loop 41 is collaborative and bounds [it(41)] 
       - Loop 42 is collaborative and bounds [it(42)] 
       - Loop 43 is collaborative and bounds [it(43)] 
       - Loop 44 is collaborative and bounds [it(44)] 
       - Loop 45 is collaborative and bounds [it(45)] 
       - Loop 46 is collaborative and bounds [it(46)] 
       - Loop 47 is collaborative and bounds [it(47)] 
       - Loop 48 is collaborative and bounds [it(48)] 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: G-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<G-1,it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<C-1,it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<C-1,it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<G-1,it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<G-G',it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<C-C',it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<C-C',it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<G-G'] 

##### Pending set A
* Psum in Loop 34: [it(34)=<1]
* Psum in Loop 35: [it(35)=<1]
* Psum in Loop 36: [it(36)=<1]
* Psum in Loop 37: [it(37)=<1]
* Psum in Loop 38: [it(38)=<1]
* Psum in Loop 39: [it(39)=<1]
* Psum in Loop 40: [it(40)=<1]
* Psum in Loop 41: [it(41)=<1]
* Psum in Loop 42: [it(42)=<1]
* Psum in Loop 43: [it(43)=<1]
* Psum in Loop 44: [it(44)=<1]
* Psum in Loop 45: [it(45)=<1]
* Psum in Loop 46: [it(46)=<1]
* Psum in Loop 47: [it(47)=<1]
* Psum in Loop 48: [it(48)=<1]

###### Computing sum for it(34)=<1  in Loop 34 
   - Applying inductive sum strategy 
     - head Candidate: G-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: G-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: G-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: G-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<G-1,it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<C-1,it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<C-1,it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<G-1,it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<G-G',it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<C-C',it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<C-C',it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<G-G'] 

##### Pending set A
* Psum in Loop 35: [it(35)=<1]
* Psum in Loop 36: [it(36)=<1]
* Psum in Loop 37: [it(37)=<1]
* Psum in Loop 38: [it(38)=<1]
* Psum in Loop 39: [it(39)=<1]
* Psum in Loop 40: [it(40)=<1]
* Psum in Loop 41: [it(41)=<1]
* Psum in Loop 42: [it(42)=<1]
* Psum in Loop 43: [it(43)=<1]
* Psum in Loop 44: [it(44)=<1]
* Psum in Loop 45: [it(45)=<1]
* Psum in Loop 46: [it(46)=<1]
* Psum in Loop 47: [it(47)=<1]
* Psum in Loop 48: [it(48)=<1]

###### Computing sum for it(35)=<1  in Loop 35 
   - Applying inductive sum strategy 
     - head Candidate: G-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: G-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: G-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: G-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<G-1,it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<C-1,it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<C-1,it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<G-1,it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<G-G',it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<C-C',it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<C-C',it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<G-G'] 

##### Pending set A
* Psum in Loop 36: [it(36)=<1]
* Psum in Loop 37: [it(37)=<1]
* Psum in Loop 38: [it(38)=<1]
* Psum in Loop 39: [it(39)=<1]
* Psum in Loop 40: [it(40)=<1]
* Psum in Loop 41: [it(41)=<1]
* Psum in Loop 42: [it(42)=<1]
* Psum in Loop 43: [it(43)=<1]
* Psum in Loop 44: [it(44)=<1]
* Psum in Loop 45: [it(45)=<1]
* Psum in Loop 46: [it(46)=<1]
* Psum in Loop 47: [it(47)=<1]
* Psum in Loop 48: [it(48)=<1]

###### Computing sum for it(36)=<1  in Loop 36 
   - Applying inductive sum strategy 
     - head Candidate: G-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: G-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: G-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: G-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<G-1,it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<C-1,it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<C-1,it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<G-1,it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<G-G',it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<C-C',it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<C-C',it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<G-G'] 

##### Pending set A
* Psum in Loop 37: [it(37)=<1]
* Psum in Loop 38: [it(38)=<1]
* Psum in Loop 39: [it(39)=<1]
* Psum in Loop 40: [it(40)=<1]
* Psum in Loop 41: [it(41)=<1]
* Psum in Loop 42: [it(42)=<1]
* Psum in Loop 43: [it(43)=<1]
* Psum in Loop 44: [it(44)=<1]
* Psum in Loop 45: [it(45)=<1]
* Psum in Loop 46: [it(46)=<1]
* Psum in Loop 47: [it(47)=<1]
* Psum in Loop 48: [it(48)=<1]

###### Computing sum for it(37)=<1  in Loop 37 
   - Applying inductive sum strategy 
     - head Candidate: G-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: G-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: G-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: G-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<G-1,it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<C-1,it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<C-1,it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<G-1,it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<G-G',it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<C-C',it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<C-C',it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<G-G'] 

##### Pending set A
* Psum in Loop 38: [it(38)=<1]
* Psum in Loop 39: [it(39)=<1]
* Psum in Loop 40: [it(40)=<1]
* Psum in Loop 41: [it(41)=<1]
* Psum in Loop 42: [it(42)=<1]
* Psum in Loop 43: [it(43)=<1]
* Psum in Loop 44: [it(44)=<1]
* Psum in Loop 45: [it(45)=<1]
* Psum in Loop 46: [it(46)=<1]
* Psum in Loop 47: [it(47)=<1]
* Psum in Loop 48: [it(48)=<1]

###### Computing sum for it(38)=<1  in Loop 38 
   - Applying inductive sum strategy 
     - head Candidate: G-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: G-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: G-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: G-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<G-1,it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<C-1,it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<C-1,it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<G-1,it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<G-G',it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<C-C',it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<C-C',it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<G-G'] 

##### Pending set A
* Psum in Loop 39: [it(39)=<1]
* Psum in Loop 40: [it(40)=<1]
* Psum in Loop 41: [it(41)=<1]
* Psum in Loop 42: [it(42)=<1]
* Psum in Loop 43: [it(43)=<1]
* Psum in Loop 44: [it(44)=<1]
* Psum in Loop 45: [it(45)=<1]
* Psum in Loop 46: [it(46)=<1]
* Psum in Loop 47: [it(47)=<1]
* Psum in Loop 48: [it(48)=<1]

###### Computing sum for it(39)=<1  in Loop 39 
   - Applying inductive sum strategy 
     - head Candidate: G-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: G-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: G-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: G-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<G-1,it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<C-1,it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<C-1,it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<G-1,it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<G-G',it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<C-C',it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<C-C',it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<G-G'] 

##### Pending set A
* Psum in Loop 40: [it(40)=<1]
* Psum in Loop 41: [it(41)=<1]
* Psum in Loop 42: [it(42)=<1]
* Psum in Loop 43: [it(43)=<1]
* Psum in Loop 44: [it(44)=<1]
* Psum in Loop 45: [it(45)=<1]
* Psum in Loop 46: [it(46)=<1]
* Psum in Loop 47: [it(47)=<1]
* Psum in Loop 48: [it(48)=<1]

###### Computing sum for it(40)=<1  in Loop 40 
   - Applying inductive sum strategy 
     - head Candidate: G-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: G-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: G-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: G-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<G-1,it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<C-1,it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<C-1,it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<G-1,it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<G-G',it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<C-C',it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<C-C',it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<G-G'] 

##### Pending set A
* Psum in Loop 41: [it(41)=<1]
* Psum in Loop 42: [it(42)=<1]
* Psum in Loop 43: [it(43)=<1]
* Psum in Loop 44: [it(44)=<1]
* Psum in Loop 45: [it(45)=<1]
* Psum in Loop 46: [it(46)=<1]
* Psum in Loop 47: [it(47)=<1]
* Psum in Loop 48: [it(48)=<1]

###### Computing sum for it(41)=<1  in Loop 41 
   - Applying inductive sum strategy 
     - head Candidate: G-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: G-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: G-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: G-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<G-1,it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<C-1,it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<C-1,it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<G-1,it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<G-G',it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<C-C',it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<C-C',it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<G-G'] 

##### Pending set A
* Psum in Loop 42: [it(42)=<1]
* Psum in Loop 43: [it(43)=<1]
* Psum in Loop 44: [it(44)=<1]
* Psum in Loop 45: [it(45)=<1]
* Psum in Loop 46: [it(46)=<1]
* Psum in Loop 47: [it(47)=<1]
* Psum in Loop 48: [it(48)=<1]

###### Computing sum for it(42)=<1  in Loop 42 
   - Applying inductive sum strategy 
     - head Candidate: G-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: G-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: G-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: G-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<G-1,it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<C-1,it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<C-1,it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<G-1,it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<G-G',it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<C-C',it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<C-C',it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<G-G'] 

##### Pending set A
* Psum in Loop 43: [it(43)=<1]
* Psum in Loop 44: [it(44)=<1]
* Psum in Loop 45: [it(45)=<1]
* Psum in Loop 46: [it(46)=<1]
* Psum in Loop 47: [it(47)=<1]
* Psum in Loop 48: [it(48)=<1]

###### Computing sum for it(43)=<1  in Loop 43 
   - Applying inductive sum strategy 
     - head Candidate: G-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: G-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: G-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: G-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<G-1,it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<C-1,it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<C-1,it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<G-1,it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<G-G',it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<C-C',it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<C-C',it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<G-G'] 

##### Pending set A
* Psum in Loop 44: [it(44)=<1]
* Psum in Loop 45: [it(45)=<1]
* Psum in Loop 46: [it(46)=<1]
* Psum in Loop 47: [it(47)=<1]
* Psum in Loop 48: [it(48)=<1]

###### Computing sum for it(44)=<1  in Loop 44 
   - Applying inductive sum strategy 
     - head Candidate: G-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: G-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: G-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: G-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<G-1,it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<C-1,it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<C-1,it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<G-1,it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<G-G',it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<C-C',it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<C-C',it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<G-G'] 

##### Pending set A
* Psum in Loop 45: [it(45)=<1]
* Psum in Loop 46: [it(46)=<1]
* Psum in Loop 47: [it(47)=<1]
* Psum in Loop 48: [it(48)=<1]

###### Computing sum for it(45)=<1  in Loop 45 
   - Applying inductive sum strategy 
     - head Candidate: G-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: G-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: G-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: G-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<G-1,it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<C-1,it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<C-1,it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<G-1,it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<G-G',it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<C-C',it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<C-C',it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<G-G'] 

##### Pending set A
* Psum in Loop 46: [it(46)=<1]
* Psum in Loop 47: [it(47)=<1]
* Psum in Loop 48: [it(48)=<1]

###### Computing sum for it(46)=<1  in Loop 46 
   - Applying inductive sum strategy 
     - head Candidate: G-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: G-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: G-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: G-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<G-1,it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<C-1,it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<C-1,it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<G-1,it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<G-G',it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<C-C',it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<C-C',it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<G-G'] 

##### Pending set A
* Psum in Loop 47: [it(47)=<1]
* Psum in Loop 48: [it(48)=<1]

###### Computing sum for it(47)=<1  in Loop 47 
   - Applying inductive sum strategy 
     - head Candidate: G-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: G-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: G-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: G-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<G-1,it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<C-1,it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<C-1,it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<G-1,it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<G-G',it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<C-C',it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<C-C',it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<G-G'] 

##### Pending set A
* Psum in Loop 48: [it(48)=<1]

###### Computing sum for it(48)=<1  in Loop 48 
   - Applying inductive sum strategy 
     - head Candidate: G-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: G-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: G-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: G-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<G-1,it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<C-1,it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<C-1,it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<G-1,it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<G-G',it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<C-C',it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<C-C',it(33)+it(34)+it(35)+it(36)+it(37)+it(38)+it(39)+it(40)+it(41)+it(42)+it(43)+it(44)+it(45)+it(46)+it(47)+it(48)=<G-G'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48] 

#### Simplifying cost structure of phase [33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48] 
 * Joined equivalent variables [it(33),it(34),it(35),it(36),it(37),it(38),it(39),it(40),it(41),it(42),it(43),it(44),it(45),it(46),it(47),it(48)] into it(33)

#### Cost of phase [33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48]:concat(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X) -> [concat(A',B',C',D',E',F',G',H',I',J',K',L',M',N',O',P',Q',R',S',T',U',V',W',X')] 
80*it(33)+0
  Such that:aux(1) =< C
aux(2) =< C-C'
aux(3) =< G
aux(4) =< G-G'
it(33) =< aux(1)
it(33) =< aux(2)
it(33) =< aux(3)
it(33) =< aux(4)

#### Simplifying cost structure of chain [[33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48],49] 
 * Joined equivalent variables [aux(5),aux(1),aux(2),aux(3),aux(4)] into aux(5)

#### Cost of chains of concat(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X):
* Chain [[33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48],49]: 80*it(33)+2
  Such that:aux(5) =< G
it(33) =< aux(5)

  with precondition: [C=G,C+K=S+1,C+O=W+1,A>=1,C>=2,E>=0,F>=0,H>=1,I>=0,J>=0,K>=1,L>=0,M>=0,N>=0,O>=1,P>=0,Q>=1,X>=1,Q>=I,R>=J,T>=L,U>=M,V>=N,X>=P,A+I>=Q,B+J>=R,D+L>=T,H+P>=X] 

* Chain [49]: 2
  with precondition: [A=0,B=0,C=1,D=0,F=0,G=1,H=0,I=Q,J=R,K=S,L=T,M=U,N=V,O=W,P=X,E>=0,I>=0,J>=0,K>=0,L>=0,M>=0,N>=0,O>=0,P>=0] 


#### Simplifying cost structure of CE 53 

#### Simplifying cost structure of CE 52 

#### Cost of chains of and_op(A,B,C):
* Chain [51]: 0
  with precondition: [A=0,C=0,B>=0] 

* Chain [50]: 0
  with precondition: [A=1,C=B,C>=0] 


#### Simplifying cost structure of CE 55 

#### Simplifying cost structure of CE 54 

#### Cost of chains of neg(A,B):
* Chain [53]: 0
  with precondition: [A=0,B=1] 

* Chain [52]: 0
  with precondition: [A=1,B=0] 


#### Simplifying cost structure of CE 57 

#### Simplifying cost structure of CE 56 

#### Cost of chains of or(A,B,C):
* Chain [55]: 0
  with precondition: [A=0,C=B,C>=0] 

* Chain [54]: 0
  with precondition: [A=1,C=1,B>=0] 

 * Renamed intermediate variables: 
[ (eq(58,1),s(1))>>s(2)]

#### Simplifying cost structure of CE 58 

#### Computing cost of chain [multiple([56,57,58,59,60,61],[[62]])] with multiple recursion

#### Simplifying cost structure of CE 64 

#### Simplifying cost structure of CE 61 

#### Simplifying cost structure of CE 62 

#### Simplifying cost structure of CE 63 

#### Simplifying cost structure of CE 59 

#### Simplifying cost structure of CE 60 

#### Cost of loops [56,57,58,59,60,61] 

 * loop 56:eval(A,B,C,D,E,F,G) -> [eval(A',B',C',D',E',F',G'),eval(A'2,B'2,C'2,D'2,E'2,F'2,G'2)] 
7
 * loop 57:eval(A,B,C,D,E,F,G) -> [eval(A',B',C',D',E',F',G'),eval(A'2,B'2,C'2,D'2,E'2,F'2,G'2)] 
8
 * loop 58:eval(A,B,C,D,E,F,G) -> [eval(A',B',C',D',E',F',G'),eval(A'2,B'2,C'2,D'2,E'2,F'2,G'2)] 
8
 * loop 59:eval(A,B,C,D,E,F,G) -> [eval(A',B',C',D',E',F',G'),eval(A'2,B'2,C'2,D'2,E'2,F'2,G'2)] 
7
 * loop 60:eval(A,B,C,D,E,F,G) -> [eval(A',B',C',D',E',F',G')] 
5
 * loop 61:eval(A,B,C,D,E,F,G) -> [eval(A',B',C',D',E',F',G')] 
5
##### Pending set eval(A,B,C,D,E,F,G)
* Psum in Loop 56: [it(56)=<1]
* Psum in Loop 57: [it(57)=<1]
* Psum in Loop 58: [it(58)=<1]
* Psum in Loop 59: [it(59)=<1]
* Psum in Loop 60: [it(60)=<1]
* Psum in Loop 61: [it(61)=<1]
* Psum in Chain-Tail [62]: [it([62])=<1,s(3)=<B]

###### Computing sum for it(56)=<1  in Loop 56 
   - Applying inductive sum strategy 
     - head Candidate: F/2-1/2 
       - Loop 57 is collaborative and bounds [it(57)] 
       - Loop 58 is collaborative and bounds [it(58)] 
       - Loop 59 is collaborative and bounds [it(59)] 
       - Loop 60 is collaborative
       - Loop 61 is collaborative
       - Chain-Tail [62] is collaborative
     - tail Candidate: F/2-1/2 
       - Loop 57 is collaborative and bounds [it(57)] 
       - Loop 58 is collaborative and bounds [it(58)] 
       - Loop 59 is collaborative and bounds [it(59)] 
       - Loop 60 is collaborative
       - Loop 61 is collaborative
       - Chain-Tail [62] is collaborative
 * Adding constraints: [it(56)+it(57)+it(58)+it(59)=<F/2-1/2,it(56)+it(57)+it(58)+it(59)=<F/2-1/2] 

##### Pending set A
* Psum in Loop 57: [it(57)=<1]
* Psum in Loop 58: [it(58)=<1]
* Psum in Loop 59: [it(59)=<1]
* Psum in Loop 60: [it(60)=<1]
* Psum in Loop 61: [it(61)=<1]
* Psum in Chain-Tail [62]: [it([62])=<1,s(3)=<B]

###### Computing sum for it(57)=<1  in Loop 57 
   - Applying inductive sum strategy 
     - head Candidate: F/2-1/2 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: F/2-1/2 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(56)+it(57)+it(58)+it(59)=<F/2-1/2,it(56)+it(57)+it(58)+it(59)=<F/2-1/2] 

##### Pending set A
* Psum in Loop 58: [it(58)=<1]
* Psum in Loop 59: [it(59)=<1]
* Psum in Loop 60: [it(60)=<1]
* Psum in Loop 61: [it(61)=<1]
* Psum in Chain-Tail [62]: [it([62])=<1,s(3)=<B]

###### Computing sum for it(58)=<1  in Loop 58 
   - Applying inductive sum strategy 
     - head Candidate: F/2-1/2 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: F/2-1/2 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(56)+it(57)+it(58)+it(59)=<F/2-1/2,it(56)+it(57)+it(58)+it(59)=<F/2-1/2] 

##### Pending set A
* Psum in Loop 59: [it(59)=<1]
* Psum in Loop 60: [it(60)=<1]
* Psum in Loop 61: [it(61)=<1]
* Psum in Chain-Tail [62]: [it([62])=<1,s(3)=<B]

###### Computing sum for it(59)=<1  in Loop 59 
   - Applying inductive sum strategy 
     - head Candidate: F/2-1/2 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: F/2-1/2 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(56)+it(57)+it(58)+it(59)=<F/2-1/2,it(56)+it(57)+it(58)+it(59)=<F/2-1/2] 

##### Pending set A
* Psum in Loop 60: [it(60)=<1]
* Psum in Loop 61: [it(61)=<1]
* Psum in Chain-Tail [62]: [it([62])=<1,s(3)=<B]

###### Computing sum for it(60)=<1  in Loop 60 
   - Applying inductive sum strategy 
     - head Candidate: F-1 
       - Loop 56 is collaborative
       - Loop 57 is collaborative
       - Loop 58 is collaborative
       - Loop 59 is collaborative
       - Loop 61 is collaborative and bounds [it(61)] 
       - Chain-Tail [62] is collaborative
     - head Candidate: F-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: F-1 
       - Loop 56 is collaborative
       - Loop 57 is collaborative
       - Loop 58 is collaborative
       - Loop 59 is collaborative
       - Loop 61 is collaborative and bounds [it(61)] 
       - Chain-Tail [62] is collaborative
     - tail Candidate: F-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(60)+it(61)=<F-1,it(60)+it(61)=<F-1,it(60)+it(61)=<F-1,it(60)+it(61)=<F-1] 

##### Pending set A
* Psum in Loop 61: [it(61)=<1]
* Psum in Chain-Tail [62]: [it([62])=<1,s(3)=<B]

###### Computing sum for it(61)=<1  in Loop 61 
   - Applying inductive sum strategy 
     - head Candidate: F-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: F-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: F-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: F-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(60)+it(61)=<F-1,it(60)+it(61)=<F-1,it(60)+it(61)=<F-1,it(60)+it(61)=<F-1] 

##### Pending set A
* Psum in Chain-Tail [62]: [it([62])=<1,s(3)=<B]

###### Computing sum for it([62])=<1  in Chain-Tail [62] 
   - Applying inductive sum strategy 
     - head Candidate: F/2+1/2 
       - Loop 56 is collaborative
       - Loop 57 is collaborative
       - Loop 58 is collaborative
       - Loop 59 is collaborative
       - Loop 60 is collaborative
       - Loop 61 is collaborative
     - tail Candidate: F/2+1/2 
       - Loop 56 is collaborative
       - Loop 57 is collaborative
       - Loop 58 is collaborative
       - Loop 59 is collaborative
       - Loop 60 is collaborative
       - Loop 61 is collaborative
 * Adding constraints: [it([62])=<F/2+1/2,it([62])=<F/2+1/2] 

##### Pending set A
* Psum in Chain-Tail [62]: [s(3)=<B]

###### Computing sum for s(3)=<B  in Chain-Tail [62] 
   - Applying inductive sum strategy 
     - head Candidate: B 
       - Loop 56 has a reset to  [2*B]
       - Loop 57 has a reset to  [2*B]
       - Loop 58 has a reset to  [2*B]
       - Loop 59 has a reset to  [2*B]
       - Loop 60 is collaborative
       - Loop 61 is collaborative
     - tail Candidate: B 
       - Loop 56 has undefined behavior 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(11)=<B] 
 * Adding constraints: [s(3)=<it([62])*aux(11),s(3)=<aux(9)+aux(8)+aux(7)+aux(6)+aux(10),aux(10)=<B] 

##### Pending set eval(A,B,C,D,E,F,G)
* Pmax/min: [aux(11)=<B]
* Psum in Loop 56: [aux(6)=<2*B]
* Psum in Loop 57: [aux(7)=<2*B]
* Psum in Loop 58: [aux(8)=<2*B]
* Psum in Loop 59: [aux(9)=<2*B]

###### Computing max_min for aux(11)=<B  
   - Found a solution using transitive invariants 
 * Adding constraints:[aux(11)=<B] 

##### Pending set eval(A,B,C,D,E,F,G)
* Psum in Loop 56: [aux(6)=<2*B]
* Psum in Loop 57: [aux(7)=<2*B]
* Psum in Loop 58: [aux(8)=<2*B]
* Psum in Loop 59: [aux(9)=<2*B]

###### Computing sum for aux(6)=<2*B  in Loop 56 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(12)=<2*B] 
 * Adding constraints: [aux(6)=<it(56)*aux(12)] 

##### Pending set eval(A,B,C,D,E,F,G)
* Pmax/min: [aux(12)=<2*B]
* Psum in Loop 57: [aux(7)=<2*B]
* Psum in Loop 58: [aux(8)=<2*B]
* Psum in Loop 59: [aux(9)=<2*B]

###### Computing max_min for aux(12)=<2*B  
   - Found a solution using cacheing 
 * Adding constraints:[aux(12)=<aux(11)*2] 

##### Pending set eval(A,B,C,D,E,F,G)
* Psum in Loop 57: [aux(7)=<2*B]
* Psum in Loop 58: [aux(8)=<2*B]
* Psum in Loop 59: [aux(9)=<2*B]

###### Computing sum for aux(7)=<2*B  in Loop 57 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(13)=<2*B] 
 * Adding constraints: [aux(7)=<it(57)*aux(13)] 

##### Pending set eval(A,B,C,D,E,F,G)
* Pmax/min: [aux(13)=<2*B]
* Psum in Loop 58: [aux(8)=<2*B]
* Psum in Loop 59: [aux(9)=<2*B]

###### Computing max_min for aux(13)=<2*B  
   - Found a solution using cacheing 
 * Adding constraints:[aux(13)=<aux(11)*2] 

##### Pending set eval(A,B,C,D,E,F,G)
* Psum in Loop 58: [aux(8)=<2*B]
* Psum in Loop 59: [aux(9)=<2*B]

###### Computing sum for aux(8)=<2*B  in Loop 58 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(14)=<2*B] 
 * Adding constraints: [aux(8)=<it(58)*aux(14)] 

##### Pending set eval(A,B,C,D,E,F,G)
* Pmax/min: [aux(14)=<2*B]
* Psum in Loop 59: [aux(9)=<2*B]

###### Computing max_min for aux(14)=<2*B  
   - Found a solution using cacheing 
 * Adding constraints:[aux(14)=<aux(11)*2] 

##### Pending set eval(A,B,C,D,E,F,G)
* Psum in Loop 59: [aux(9)=<2*B]

###### Computing sum for aux(9)=<2*B  in Loop 59 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(15)=<2*B] 
 * Adding constraints: [aux(9)=<it(59)*aux(15)] 

##### Pending set eval(A,B,C,D,E,F,G)
* Pmax/min: [aux(15)=<2*B]

###### Computing max_min for aux(15)=<2*B  
   - Found a solution using cacheing 
 * Adding constraints:[aux(15)=<aux(11)*2] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [56,57,58,59,60,61,[62]] 

#### Simplifying cost structure of phase [56,57,58,59,60,61,[62]] 
 * Joined equivalent variables [aux(16),aux(10),aux(11)] into aux(16)
 * Joined equivalent variables [aux(12),aux(13),aux(14),aux(15)] into aux(12)
 * Joined equivalent variables [it(60),it(61)] into it(60)
 * Joined equivalent variables [it(56),it(57),it(58),it(59)] into it(56)
 * Joined equivalent variables [aux(6),aux(7),aux(8),aux(9)] into aux(6)

#### Cost of phase [56,57,58,59,60,61]:eval(A,B,C,D,E,F,G) -> [] 
30*it(56)+10*it(60)+7*it([62])+5*s(3)+0
  Such that:it([62]) =< F/2+1/2
aux(16) =< B
aux(17) =< F
aux(18) =< F/2
it(60) =< aux(17)
it(56) =< aux(18)
aux(12) =< aux(16)*2
s(3) =< it([62])*aux(16)
aux(6) =< it(56)*aux(12)
s(3) =< aux(6)+aux(6)+aux(6)+aux(6)+aux(16)

#### Cost of chains of eval(A,B,C,D,E,F,G):
* Chain [62]: 5*s(2)+7
  Such that:s(2) =< B

  with precondition: [F=1,A>=1,B>=2,E>=0,G>=0,C>=E,D>=G] 

* Chain [multiple([56,57,58,59,60,61],[[62]])]: 30*it(56)+10*it(60)+7*it([62])+5*s(3)+0
  Such that:it([62]) =< F/2+1/2
aux(16) =< B
aux(17) =< F
aux(18) =< F/2
it(60) =< aux(17)
it(56) =< aux(18)
aux(12) =< aux(16)*2
s(3) =< it([62])*aux(16)
aux(6) =< it(56)*aux(12)
s(3) =< aux(6)+aux(6)+aux(6)+aux(6)+aux(16)

  with precondition: [A>=1,B>=2,C>=0,D>=0,E>=0,F>=2,G>=0,D+F>=G+1,D+F+G>=3] 


#### Simplifying cost structure of CE 66 

#### Simplifying cost structure of CE 65 

#### Cost of chains of case_2(A,B,C,D,E,F,G,H):
* Chain [64]: 2
  with precondition: [F=1,H=0,G=E,A>=0,B>=0,C>=0,D>=0,G>=A+1,G>=C+1] 

* Chain [63]: 1
  with precondition: [F=1,E=C,E=G,D=H,A>=0,B>=0,D>=0,E>=A+1] 


#### Simplifying cost structure of CE 67 

#### Simplifying cost structure of CE 69 

#### Simplifying cost structure of CE 68 

#### Cost of chains of case_1(A,B,C,D,E,F,G,H):
* Chain [67]: 4
  with precondition: [F=1,H=0,G=E,A>=0,B>=0,C>=0,D>=0,G>=A+1,G>=C+1] 

* Chain [66]: 1
  with precondition: [F=1,E=A,E=G,B=H,B>=0,C>=0,D>=0,E>=0] 

* Chain [65]: 3
  with precondition: [F=1,E=C,E=G,D=H,A>=0,B>=0,D>=0,E>=A+1] 


#### Simplifying cost structure of CE 70 

#### Simplifying cost structure of CE 71 

#### Simplifying cost structure of CE 72 

#### Computing cost of chain [multiple([68,69,70,71,72,73],[[76],[75],[74]])] with multiple recursion

#### Simplifying cost structure of CE 78 

#### Simplifying cost structure of CE 75 

#### Simplifying cost structure of CE 76 

#### Simplifying cost structure of CE 77 

#### Simplifying cost structure of CE 73 

#### Simplifying cost structure of CE 74 

#### Cost of loops [68,69,70,71,72,73] 

 * loop 68:eval2(A,B,C,D,E,F,G) -> [eval2(A',B',C',D',E',F',G'),eval2(A'2,B'2,C'2,D'2,E'2,F'2,G'2)] 
7
 * loop 69:eval2(A,B,C,D,E,F,G) -> [eval2(A',B',C',D',E',F',G'),eval2(A'2,B'2,C'2,D'2,E'2,F'2,G'2)] 
8
 * loop 70:eval2(A,B,C,D,E,F,G) -> [eval2(A',B',C',D',E',F',G'),eval2(A'2,B'2,C'2,D'2,E'2,F'2,G'2)] 
8
 * loop 71:eval2(A,B,C,D,E,F,G) -> [eval2(A',B',C',D',E',F',G'),eval2(A'2,B'2,C'2,D'2,E'2,F'2,G'2)] 
7
 * loop 72:eval2(A,B,C,D,E,F,G) -> [eval2(A',B',C',D',E',F',G')] 
5
 * loop 73:eval2(A,B,C,D,E,F,G) -> [eval2(A',B',C',D',E',F',G')] 
5
##### Pending set eval2(A,B,C,D,E,F,G)
* Psum in Loop 68: [it(68)=<1]
* Psum in Loop 69: [it(69)=<1]
* Psum in Loop 70: [it(70)=<1]
* Psum in Loop 71: [it(71)=<1]
* Psum in Loop 72: [it(72)=<1]
* Psum in Loop 73: [it(73)=<1]
* Psum in Chain-Tail [74]: [it([74])=<1]
* Psum in Chain-Tail [75]: [it([75])=<1]
* Psum in Chain-Tail [76]: [it([76])=<1]

###### Computing sum for it(68)=<1  in Loop 68 
   - Applying inductive sum strategy 
     - head Candidate: F/2-1/2 
       - Loop 69 is collaborative and bounds [it(69)] 
       - Loop 70 is collaborative and bounds [it(70)] 
       - Loop 71 is collaborative and bounds [it(71)] 
       - Loop 72 is collaborative
       - Loop 73 is collaborative
       - Chain-Tail [76] is collaborative
       - Chain-Tail [75] is collaborative
       - Chain-Tail [74] is collaborative
     - tail Candidate: F/2-1/2 
       - Loop 69 is collaborative and bounds [it(69)] 
       - Loop 70 is collaborative and bounds [it(70)] 
       - Loop 71 is collaborative and bounds [it(71)] 
       - Loop 72 is collaborative
       - Loop 73 is collaborative
       - Chain-Tail [76] is collaborative
       - Chain-Tail [75] is collaborative
       - Chain-Tail [74] is collaborative
 * Adding constraints: [it(68)+it(69)+it(70)+it(71)=<F/2-1/2,it(68)+it(69)+it(70)+it(71)=<F/2-1/2] 

##### Pending set A
* Psum in Loop 69: [it(69)=<1]
* Psum in Loop 70: [it(70)=<1]
* Psum in Loop 71: [it(71)=<1]
* Psum in Loop 72: [it(72)=<1]
* Psum in Loop 73: [it(73)=<1]
* Psum in Chain-Tail [74]: [it([74])=<1]
* Psum in Chain-Tail [75]: [it([75])=<1]
* Psum in Chain-Tail [76]: [it([76])=<1]

###### Computing sum for it(69)=<1  in Loop 69 
   - Applying inductive sum strategy 
     - head Candidate: F/2-1/2 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: F/2-1/2 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(68)+it(69)+it(70)+it(71)=<F/2-1/2,it(68)+it(69)+it(70)+it(71)=<F/2-1/2] 

##### Pending set A
* Psum in Loop 70: [it(70)=<1]
* Psum in Loop 71: [it(71)=<1]
* Psum in Loop 72: [it(72)=<1]
* Psum in Loop 73: [it(73)=<1]
* Psum in Chain-Tail [74]: [it([74])=<1]
* Psum in Chain-Tail [75]: [it([75])=<1]
* Psum in Chain-Tail [76]: [it([76])=<1]

###### Computing sum for it(70)=<1  in Loop 70 
   - Applying inductive sum strategy 
     - head Candidate: F/2-1/2 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: F/2-1/2 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(68)+it(69)+it(70)+it(71)=<F/2-1/2,it(68)+it(69)+it(70)+it(71)=<F/2-1/2] 

##### Pending set A
* Psum in Loop 71: [it(71)=<1]
* Psum in Loop 72: [it(72)=<1]
* Psum in Loop 73: [it(73)=<1]
* Psum in Chain-Tail [74]: [it([74])=<1]
* Psum in Chain-Tail [75]: [it([75])=<1]
* Psum in Chain-Tail [76]: [it([76])=<1]

###### Computing sum for it(71)=<1  in Loop 71 
   - Applying inductive sum strategy 
     - head Candidate: F/2-1/2 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: F/2-1/2 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(68)+it(69)+it(70)+it(71)=<F/2-1/2,it(68)+it(69)+it(70)+it(71)=<F/2-1/2] 

##### Pending set A
* Psum in Loop 72: [it(72)=<1]
* Psum in Loop 73: [it(73)=<1]
* Psum in Chain-Tail [74]: [it([74])=<1]
* Psum in Chain-Tail [75]: [it([75])=<1]
* Psum in Chain-Tail [76]: [it([76])=<1]

###### Computing sum for it(72)=<1  in Loop 72 
   - Applying inductive sum strategy 
     - head Candidate: F-1 
       - Loop 68 is collaborative
       - Loop 69 is collaborative
       - Loop 70 is collaborative
       - Loop 71 is collaborative
       - Loop 73 is collaborative and bounds [it(73)] 
       - Chain-Tail [76] is collaborative
       - Chain-Tail [75] is collaborative
       - Chain-Tail [74] is collaborative
     - head Candidate: F-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: F-1 
       - Loop 68 is collaborative
       - Loop 69 is collaborative
       - Loop 70 is collaborative
       - Loop 71 is collaborative
       - Loop 73 is collaborative and bounds [it(73)] 
       - Chain-Tail [76] is collaborative
       - Chain-Tail [75] is collaborative
       - Chain-Tail [74] is collaborative
     - tail Candidate: F-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(72)+it(73)=<F-1,it(72)+it(73)=<F-1,it(72)+it(73)=<F-1,it(72)+it(73)=<F-1] 

##### Pending set A
* Psum in Loop 73: [it(73)=<1]
* Psum in Chain-Tail [74]: [it([74])=<1]
* Psum in Chain-Tail [75]: [it([75])=<1]
* Psum in Chain-Tail [76]: [it([76])=<1]

###### Computing sum for it(73)=<1  in Loop 73 
   - Applying inductive sum strategy 
     - head Candidate: F-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: F-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: F-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: F-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(72)+it(73)=<F-1,it(72)+it(73)=<F-1,it(72)+it(73)=<F-1,it(72)+it(73)=<F-1] 

##### Pending set A
* Psum in Chain-Tail [74]: [it([74])=<1]
* Psum in Chain-Tail [75]: [it([75])=<1]
* Psum in Chain-Tail [76]: [it([76])=<1]

###### Computing sum for it([74])=<1  in Chain-Tail [74] 
   - Applying inductive sum strategy 
     - head Candidate: F/2+1/2 
       - Loop 68 is collaborative
       - Loop 69 is collaborative
       - Loop 70 is collaborative
       - Loop 71 is collaborative
       - Loop 72 is collaborative
       - Loop 73 is collaborative
       - Chain-Tail [76] is collaborative and bounds [it([76])] 
       - Chain-Tail [75] is collaborative and bounds [it([75])] 
     - tail Candidate: F/2+1/2 
       - Loop 68 is collaborative
       - Loop 69 is collaborative
       - Loop 70 is collaborative
       - Loop 71 is collaborative
       - Loop 72 is collaborative
       - Loop 73 is collaborative
       - Chain-Tail [76] is collaborative and bounds [it([76])] 
       - Chain-Tail [75] is collaborative and bounds [it([75])] 
 * Adding constraints: [it([74])+it([75])+it([76])=<F/2+1/2,it([74])+it([75])+it([76])=<F/2+1/2] 

##### Pending set A
* Psum in Chain-Tail [75]: [it([75])=<1]
* Psum in Chain-Tail [76]: [it([76])=<1]

###### Computing sum for it([75])=<1  in Chain-Tail [75] 
   - Applying inductive sum strategy 
     - head Candidate: F/2+1/2 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: F/2+1/2 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it([74])+it([75])+it([76])=<F/2+1/2,it([74])+it([75])+it([76])=<F/2+1/2] 

##### Pending set A
* Psum in Chain-Tail [76]: [it([76])=<1]

###### Computing sum for it([76])=<1  in Chain-Tail [76] 
   - Applying inductive sum strategy 
     - head Candidate: F/2+1/2 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: F/2+1/2 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it([74])+it([75])+it([76])=<F/2+1/2,it([74])+it([75])+it([76])=<F/2+1/2] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [68,69,70,71,72,73,[76],[75],[74]] 

#### Simplifying cost structure of phase [68,69,70,71,72,73,[76],[75],[74]] 
 * Joined equivalent variables [it(72),it(73)] into it(72)
 * Joined equivalent variables [it(68),it(69),it(70),it(71)] into it(68)
 * Joined equivalent variables [it([74]),it([75]),it([76])] into it([74])

#### Cost of phase [68,69,70,71,72,73]:eval2(A,B,C,D,E,F,G) -> [] 
30*it(68)+10*it(72)+17*it([74])+0
  Such that:aux(19) =< F
aux(20) =< F/2
aux(21) =< F/2+1/2
it(72) =< aux(19)
it(68) =< aux(20)
it([74]) =< aux(21)

#### Cost of chains of eval2(A,B,C,D,E,F,G):
* Chain [76]: 7
  with precondition: [F=1,G=0,A>=0,B>=0,C>=0,D>=0,E>=A+1,E>=C+1] 

* Chain [75]: 4
  with precondition: [F=1,A=E,B=G,A>=0,B>=0,C>=0,D>=0] 

* Chain [74]: 6
  with precondition: [F=1,C=E,D=G,A>=0,B>=0,D>=0,C>=A+1] 

* Chain [multiple([68,69,70,71,72,73],[[76],[75],[74]])]: 30*it(68)+10*it(72)+17*it([74])+0
  Such that:aux(19) =< F
aux(20) =< F/2
aux(21) =< F/2+1/2
it(72) =< aux(19)
it(68) =< aux(20)
it([74]) =< aux(21)

  with precondition: [A>=0,B>=0,C>=0,D>=0,F>=2,G>=0,E>=A,B+D+F>=G+1,B+D+F+G>=3] 


#### Simplifying cost structure of CE 79 

#### Computing cost of phase [77,78,79,80] 

#### Simplifying cost structure of CE 80 

#### Simplifying cost structure of CE 82 

#### Simplifying cost structure of CE 81 

#### Simplifying cost structure of CE 83 

#### Cost of loops [77,78,79,80] 

 * loop 77:aux_rev(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R) -> [aux_rev(A',B',C',D',E',F',G',H',I',J',K',L',M',N',O',P',Q',R')] 
5
 * loop 78:aux_rev(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R) -> [aux_rev(A',B',C',D',E',F',G',H',I',J',K',L',M',N',O',P',Q',R')] 
5
 * loop 79:aux_rev(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R) -> [aux_rev(A',B',C',D',E',F',G',H',I',J',K',L',M',N',O',P',Q',R')] 
5
 * loop 80:aux_rev(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R) -> [aux_rev(A',B',C',D',E',F',G',H',I',J',K',L',M',N',O',P',Q',R')] 
5
##### Pending set aux_rev(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R)
* Psum in Loop 77: [it(77)=<1]
* Psum in Loop 78: [it(78)=<1]
* Psum in Loop 79: [it(79)=<1]
* Psum in Loop 80: [it(80)=<1]

###### Computing sum for it(77)=<1  in Loop 77 
   - Applying inductive sum strategy 
     - head Candidate: K-1 
       - Loop 78 is collaborative and bounds [it(78)] 
       - Loop 79 is collaborative and bounds [it(79)] 
       - Loop 80 is collaborative and bounds [it(80)] 
     - head Candidate: H-1 
       - Loop 78 is collaborative and bounds [it(78)] 
       - Loop 79 is collaborative and bounds [it(79)] 
       - Loop 80 is collaborative and bounds [it(80)] 
     - head Candidate: H-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: K-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: -A+G 
       - Loop 78 is collaborative and bounds [it(78)] 
       - Loop 79 is collaborative
       - Loop 80 is collaborative
     - head Candidate: -F+L 
       - Loop 78 is collaborative
       - Loop 79 is collaborative and bounds [it(79)] 
       - Loop 80 is collaborative
     - tail Candidate: K-1 
       - Loop 78 is collaborative and bounds [it(78)] 
       - Loop 79 is collaborative and bounds [it(79)] 
       - Loop 80 is collaborative and bounds [it(80)] 
     - tail Candidate: H-1 
       - Loop 78 is collaborative and bounds [it(78)] 
       - Loop 79 is collaborative and bounds [it(79)] 
       - Loop 80 is collaborative and bounds [it(80)] 
     - tail Candidate: H-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: K-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: -A+G 
       - Loop 78 is collaborative and bounds [it(78)] 
       - Loop 79 is collaborative
       - Loop 80 is collaborative
     - tail Candidate: -F+L 
       - Loop 78 is collaborative
       - Loop 79 is collaborative and bounds [it(79)] 
       - Loop 80 is collaborative
 * Adding constraints: [it(77)+it(78)+it(79)+it(80)=<K-1,it(77)+it(78)+it(79)+it(80)=<H-1,it(77)+it(78)+it(79)+it(80)=<H-1,it(77)+it(78)+it(79)+it(80)=<K-1,it(77)+it(78)=< -A+G,it(77)+it(79)=< -F+L,it(77)+it(78)+it(79)+it(80)=<K-K',it(77)+it(78)+it(79)+it(80)=<H-H',it(77)+it(78)+it(79)+it(80)=<H-H',it(77)+it(78)+it(79)+it(80)=<K-K',it(77)+it(78)=< -A+G+A'-G',it(77)+it(79)=< -F+L+F'-L'] 

##### Pending set A
* Psum in Loop 78: [it(78)=<1]
* Psum in Loop 79: [it(79)=<1]
* Psum in Loop 80: [it(80)=<1]

###### Computing sum for it(78)=<1  in Loop 78 
   - Applying inductive sum strategy 
     - head Candidate: K-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: H-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: H-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: K-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: -A+G 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: K-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: H-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: H-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: K-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: -A+G 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(77)+it(78)+it(79)+it(80)=<K-1,it(77)+it(78)+it(79)+it(80)=<H-1,it(77)+it(78)+it(79)+it(80)=<H-1,it(77)+it(78)+it(79)+it(80)=<K-1,it(77)+it(78)=< -A+G,it(77)+it(78)+it(79)+it(80)=<K-K',it(77)+it(78)+it(79)+it(80)=<H-H',it(77)+it(78)+it(79)+it(80)=<H-H',it(77)+it(78)+it(79)+it(80)=<K-K',it(77)+it(78)=< -A+G+A'-G'] 

##### Pending set A
* Psum in Loop 79: [it(79)=<1]
* Psum in Loop 80: [it(80)=<1]

###### Computing sum for it(79)=<1  in Loop 79 
   - Applying inductive sum strategy 
     - head Candidate: K-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: H-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: H-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: K-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: -F+L 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: K-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: H-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: H-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: K-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: -F+L 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(77)+it(78)+it(79)+it(80)=<K-1,it(77)+it(78)+it(79)+it(80)=<H-1,it(77)+it(78)+it(79)+it(80)=<H-1,it(77)+it(78)+it(79)+it(80)=<K-1,it(77)+it(79)=< -F+L,it(77)+it(78)+it(79)+it(80)=<K-K',it(77)+it(78)+it(79)+it(80)=<H-H',it(77)+it(78)+it(79)+it(80)=<H-H',it(77)+it(78)+it(79)+it(80)=<K-K',it(77)+it(79)=< -F+L+F'-L'] 

##### Pending set A
* Psum in Loop 80: [it(80)=<1]

###### Computing sum for it(80)=<1  in Loop 80 
   - Applying inductive sum strategy 
     - head Candidate: K-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: H-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: H-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: K-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: K-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: H-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: H-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: K-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(77)+it(78)+it(79)+it(80)=<K-1,it(77)+it(78)+it(79)+it(80)=<H-1,it(77)+it(78)+it(79)+it(80)=<H-1,it(77)+it(78)+it(79)+it(80)=<K-1,it(77)+it(78)+it(79)+it(80)=<K-K',it(77)+it(78)+it(79)+it(80)=<H-H',it(77)+it(78)+it(79)+it(80)=<H-H',it(77)+it(78)+it(79)+it(80)=<K-K'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [77,78,79,80] 

#### Simplifying cost structure of phase [77,78,79,80] 

#### Cost of phase [77,78,79,80]:aux_rev(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R) -> [aux_rev(A',B',C',D',E',F',G',H',I',J',K',L',M',N',O',P',Q',R')] 
5*it(77)+5*it(78)+5*it(79)+5*it(80)+0
  Such that:aux(22) =< -A+G
aux(23) =< -A+G+A'-G'
aux(24) =< -F+L
aux(25) =< -F+L+F'-L'
aux(26) =< H
aux(27) =< H-H'
aux(28) =< K
aux(29) =< K-K'
it(77) =< aux(22)
it(78) =< aux(22)
it(77) =< aux(23)
it(78) =< aux(23)
it(77) =< aux(24)
it(79) =< aux(24)
it(77) =< aux(25)
it(79) =< aux(25)
it(77) =< aux(26)
it(78) =< aux(26)
it(79) =< aux(26)
it(80) =< aux(26)
it(77) =< aux(27)
it(78) =< aux(27)
it(79) =< aux(27)
it(80) =< aux(27)
it(77) =< aux(28)
it(78) =< aux(28)
it(79) =< aux(28)
it(80) =< aux(28)
it(77) =< aux(29)
it(78) =< aux(29)
it(79) =< aux(29)
it(80) =< aux(29)

#### Simplifying cost structure of chain [[77,78,79,80],81] 
 * Joined equivalent variables [aux(30),aux(27),aux(29)] into aux(30)
 * Joined equivalent variables [aux(31),aux(26),aux(28)] into aux(31)

#### Cost of chains of aux_rev(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R):
* Chain [[77,78,79,80],81]: 5*it(77)+5*it(78)+5*it(79)+5*it(80)+2
  Such that:aux(22) =< -A+G
aux(23) =< -A+G+M
aux(24) =< -F+L
aux(25) =< -F+L+R
aux(30) =< -E+Q
aux(31) =< -E+Q+1
it(77) =< aux(22)
it(78) =< aux(22)
it(77) =< aux(23)
it(78) =< aux(23)
it(77) =< aux(24)
it(79) =< aux(24)
it(77) =< aux(25)
it(79) =< aux(25)
it(77) =< aux(31)
it(78) =< aux(31)
it(79) =< aux(31)
it(80) =< aux(31)
it(77) =< aux(30)
it(78) =< aux(30)
it(79) =< aux(30)
it(80) =< aux(30)

  with precondition: [B=E,H=K,B+H=N+1,B+H=Q+1,A>=0,B>=1,C>=0,D>=0,F>=0,G>=1,H>=2,I>=0,J>=0,L>=1,M>=1,R>=1,M>=A,O>=C,P>=D,R>=F] 

* Chain [81]: 2
  with precondition: [G=0,H=1,J=0,K=1,L=0,M=A,E=B,O=C,P=D,R=F,E=N,E=Q,E>=1,I>=0,M>=0,O>=0,P>=0,R>=0] 


#### Simplifying cost structure of CE 84 
 * Renamed intermediate variables: 
[ (eq(85,1),aux(22))>>s(4), (eq(85,1),aux(23))>>s(5), (eq(85,1),aux(24))>>s(6), (eq(85,1),aux(25))>>s(7), (eq(85,1),aux(30))>>s(8), (eq(85,1),aux(31))>>s(9), (eq(85,1),it(77))>>s(10), (eq(85,1),it(78))>>s(11), (eq(85,1),it(79))>>s(12), (eq(85,1),it(80))>>s(13)]

#### Simplifying cost structure of CE 85 
 * Joined equivalent variables [aux(32),s(8),s(9)] into aux(32)

#### Cost of chains of rev(A,B,C,D,E,F,G,H,I,J,K,L):
* Chain [83]: 4
  with precondition: [A=0,B=1,D=0,E=1,F=0,G=0,H=1,J=0,K=1,L=0,C>=0,I>=0] 

* Chain [82]: 5*s(10)+5*s(11)+5*s(12)+5*s(13)+4
  Such that:s(4) =< A
s(6) =< F
aux(32) =< E
s(10) =< s(4)
s(11) =< s(4)
s(10) =< s(6)
s(12) =< s(6)
s(10) =< aux(32)
s(11) =< aux(32)
s(12) =< aux(32)
s(13) =< aux(32)

  with precondition: [B=E,B=H,B=K,A>=1,B>=2,C>=0,D>=0,F>=1,G>=1,I>=0,J>=0,L>=1] 


#### Simplifying cost structure of CE 87 

#### Simplifying cost structure of CE 88 

#### Simplifying cost structure of CE 86 
 * Renamed intermediate variables: 
[ (eq(89,1),aux(19))>>s(14), (eq(89,1),aux(20))>>s(15), (eq(89,1),aux(21))>>s(16), (eq(89,1),it(72))>>s(17), (eq(89,1),it(68))>>s(18), (eq(89,1),it([74]))>>s(19)]
 * Renamed intermediate variables: 
[ (eq(89,2),aux(19))>>s(20), (eq(89,2),aux(20))>>s(21), (eq(89,2),aux(21))>>s(22), (eq(89,2),it(72))>>s(23), (eq(89,2),it(68))>>s(24), (eq(89,2),it([74]))>>s(25)]
 * Renamed intermediate variables: 
[ (eq(89,3),aux(19))>>s(26), (eq(89,3),aux(20))>>s(27), (eq(89,3),aux(21))>>s(28), (eq(89,3),it(72))>>s(29), (eq(89,3),it(68))>>s(30), (eq(89,3),it([74]))>>s(31)]
 * Renamed intermediate variables: 
[ (eq(89,4),aux(19))>>s(32), (eq(89,4),aux(20))>>s(33), (eq(89,4),aux(21))>>s(34), (eq(89,4),it(72))>>s(35), (eq(89,4),it(68))>>s(36), (eq(89,4),it([74]))>>s(37)]

#### Simplifying cost structure of CE 89 
 * Joined equivalent variables [aux(33),s(14),s(20),s(26),s(32)] into aux(33)
 * Joined equivalent variables [aux(34),s(15),s(21),s(27),s(33)] into aux(34)
 * Joined equivalent variables [aux(35),s(16),s(22),s(28),s(34)] into aux(35)
 * Joined equivalent variables [s(17),s(23),s(29),s(35)] into s(17)
 * Joined equivalent variables [s(18),s(24),s(30),s(36)] into s(18)
 * Joined equivalent variables [s(19),s(25),s(31),s(37)] into s(19)

#### Cost of chains of table2(A,B,C,D,E,F,G):
* Chain [87]: 45
  with precondition: [D=1,E=1,F=5,A=C,A>=0,B>=0,G>=1] 

* Chain [86]: 53
  with precondition: [D=1,E=1,F=5,B=C,A>=0,G>=1,B>=A+1] 

* Chain [85]: 57
  with precondition: [D=1,E=1,F=5,A>=0,B>=0,G>=1,C>=A+1,C>=B+1] 

* Chain [84]: 40*s(17)+120*s(18)+68*s(19)+29
  Such that:aux(33) =< D
aux(34) =< D/2
aux(35) =< D/2+1/2
s(17) =< aux(33)
s(18) =< aux(34)
s(19) =< aux(35)

  with precondition: [E=1,F=5,A>=0,B>=0,D>=2,G>=1,C>=A] 

 * Renamed intermediate variables: 
[ (eq(90,1),s(4))>>s(38), (eq(90,1),s(6))>>s(39), (eq(90,1),aux(32))>>s(40), (eq(90,1),s(10))>>s(41), (eq(90,1),s(11))>>s(42), (eq(90,1),s(12))>>s(43), (eq(90,1),s(13))>>s(44)]
 * Renamed intermediate variables: 
[ (eq(90,2),s(2))>>s(45)]

#### Simplifying cost structure of CE 90 
 * Joined equivalent variables [aux(36),s(40)] into aux(36)
 * Joined equivalent variables [s(44),s(45)] into s(44)
 * Renamed intermediate variables: 
[ (eq(91,1),s(4))>>s(46), (eq(91,1),s(6))>>s(47), (eq(91,1),aux(32))>>s(48), (eq(91,1),s(10))>>s(49), (eq(91,1),s(11))>>s(50), (eq(91,1),s(12))>>s(51), (eq(91,1),s(13))>>s(52)]
 * Renamed intermediate variables: 
[ (eq(91,2),it([62]))>>s(53), (eq(91,2),aux(16))>>s(54), (eq(91,2),aux(17))>>s(55), (eq(91,2),aux(18))>>s(56), (eq(91,2),it(60))>>s(57), (eq(91,2),it(56))>>s(58), (eq(91,2),aux(12))>>s(59), (eq(91,2),s(3))>>s(60), (eq(91,2),aux(6))>>s(61)]

#### Simplifying cost structure of CE 91 
 * Joined equivalent variables [aux(37),s(48),s(54)] into aux(37)

#### Computing cost of chain [multiple([88,89],[[93],[92]])] with multiple recursion
 * The following loops are unfeasible in this instance of the phase [88,89] : [89] 
 * Renamed intermediate variables: 
[ (eq(95,3),aux(5))>>s(62), (eq(95,3),it(33))>>s(63)]

#### Simplifying cost structure of CE 95 
 * Renamed intermediate variables: 
[ (it(88),s(63))>>s(64)]

#### Cost of loops [88] 

 * loop 88:table_make(A,B,C,D,E,F,G,H,I,J,K,L,M,N) -> [table_make(A',B',C',D',E',F',G',H',I',J',K',L',M',N'),table_make(A'2,B'2,C'2,D'2,E'2,F'2,G'2,H'2,I'2,J'2,K'2,L'2,M'2,N'2)] 
80*s(64)+14
Unbounded itvars
s(64) :  it(88),s(63)

##### Pending set table_make(A,B,C,D,E,F,G,H,I,J,K,L,M,N)
* Pmax/min: [aux(37)=<B]
* Psum in Loop 88: [it(88)=<1]
* Psum in Chain-Tail [92]: [it([92])=<1,s(81)=<A,s(80)=<B,s(84)=<H,s(83)=<H/2,s(76)=<H/2+1/2]
* Psum in Chain-Tail [93]: [it([93])=<1,s(71)=<A,s(70)=<B]

###### Computing max_min for aux(37)=<B  
   - Found a solution using transitive invariants 
 * Adding constraints:[aux(37)=<B+E-2] 

##### Pending set table_make(A,B,C,D,E,F,G,H,I,J,K,L,M,N)
* Psum in Loop 88: [it(88)=<1]
* Psum in Chain-Tail [92]: [it([92])=<1,s(81)=<A,s(80)=<B,s(84)=<H,s(83)=<H/2,s(76)=<H/2+1/2]
* Psum in Chain-Tail [93]: [it([93])=<1,s(71)=<A,s(70)=<B]

###### Computing sum for it(88)=<1  in Loop 88 
   - Applying inductive sum strategy 
   - No strategy succeeded 
 * Adding constraints: [] 

##### Pending set table_make(A,B,C,D,E,F,G,H,I,J,K,L,M,N)
* Psum in Chain-Tail [92]: [it([92])=<1,s(81)=<A,s(80)=<B,s(84)=<H,s(83)=<H/2,s(76)=<H/2+1/2]
* Psum in Chain-Tail [93]: [it([93])=<1,s(71)=<A,s(70)=<B]

###### Computing sum for it([92])=<1  in Chain-Tail [92] 
   - Applying inductive sum strategy 
     - head Candidate: 1 
       - Loop 88 adds a constant 1/1 
       - Chain-Tail [93] is collaborative and bounds [it([93])] 
     - tail Candidate: 1 
       - Loop 88 adds a constant 1/1 
       - Chain-Tail [93] is collaborative and bounds [it([93])] 
 * Adding constraints: [it([92])+it([93])=<it(88)+aux(38),it([92])+it([93])=<it(88)+aux(39),aux(38)=<1,aux(39)=<1] 

##### Pending set table_make(A,B,C,D,E,F,G,H,I,J,K,L,M,N)
* Psum in Chain-Tail [92]: [s(81)=<A,s(80)=<B,s(84)=<H,s(83)=<H/2,s(76)=<H/2+1/2]
* Psum in Chain-Tail [93]: [it([93])=<1,s(71)=<A,s(70)=<B]

###### Computing sum for s(81)=<A  in Chain-Tail [92] 
   - Applying inductive sum strategy 
     - head Candidate: A 
       - Loop 88 has a reset to  [2*A]
       - Chain-Tail [93] is collaborative and bounds [it([93])] 
     - tail Candidate: A 
       - Loop 88 has undefined behavior 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(42)=<A] 
 * Adding constraints: [s(81)=<it([92])*aux(42),it([93])+s(81)=<aux(40)+aux(41),aux(41)=<A] 

##### Pending set table_make(A,B,C,D,E,F,G,H,I,J,K,L,M,N)
* Pmax/min: [aux(42)=<A]
* Psum in Loop 88: [aux(40)=<2*A]
* Psum in Chain-Tail [92]: [s(80)=<B,s(84)=<H,s(83)=<H/2,s(76)=<H/2+1/2]
* Psum in Chain-Tail [93]: [s(71)=<A,s(70)=<B]

###### Computing max_min for aux(42)=<A  
   - Found a solution using transitive invariants 
 * Adding constraints:[aux(42)=<A] 

##### Pending set table_make(A,B,C,D,E,F,G,H,I,J,K,L,M,N)
* Psum in Loop 88: [aux(40)=<2*A]
* Psum in Chain-Tail [92]: [s(80)=<B,s(84)=<H,s(83)=<H/2,s(76)=<H/2+1/2]
* Psum in Chain-Tail [93]: [s(71)=<A,s(70)=<B]

###### Computing sum for aux(40)=<2*A  in Loop 88 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(43)=<2*A] 
 * Adding constraints: [aux(40)=<it(88)*aux(43)] 

##### Pending set table_make(A,B,C,D,E,F,G,H,I,J,K,L,M,N)
* Pmax/min: [aux(43)=<2*A]
* Psum in Chain-Tail [92]: [s(80)=<B,s(84)=<H,s(83)=<H/2,s(76)=<H/2+1/2]
* Psum in Chain-Tail [93]: [s(71)=<A,s(70)=<B]

###### Computing max_min for aux(43)=<2*A  
   - Found a solution using cacheing 
 * Adding constraints:[aux(43)=<aux(42)*2] 

##### Pending set table_make(A,B,C,D,E,F,G,H,I,J,K,L,M,N)
* Psum in Chain-Tail [92]: [s(80)=<B,s(84)=<H,s(83)=<H/2,s(76)=<H/2+1/2]
* Psum in Chain-Tail [93]: [s(71)=<A,s(70)=<B]

###### Computing sum for s(80)=<B  in Chain-Tail [92] 
   - Applying inductive sum strategy 
     - head Candidate: B 
       - Loop 88 adds an expression [-E+L'+3,-E+L'2+3]
       - Chain-Tail [93] is collaborative and bounds [s(70)] 
     - tail Candidate: B 
       - Loop 88 adds an expression [-E+L'+3,-E+L'2+3]
       - Chain-Tail [93] is collaborative and bounds [s(70)] 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(48)=<B] 
 * Adding constraints: [s(80)=<it([92])*aux(48),s(70)+s(80)=<aux(44)+aux(45),s(70)+s(80)=<aux(46)+aux(47),aux(45)=<B,aux(47)=<B] 

##### Pending set table_make(A,B,C,D,E,F,G,H,I,J,K,L,M,N)
* Pmax/min: [aux(48)=<B]
* Psum in Loop 88: [aux(44)=< -E+L'+3,aux(46)=< -E+L'+3,aux(44)=< -E+L'2+3,aux(46)=< -E+L'2+3]
* Psum in Chain-Tail [92]: [s(84)=<H,s(83)=<H/2,s(76)=<H/2+1/2]
* Psum in Chain-Tail [93]: [s(71)=<A,s(70)=<B]

###### Computing max_min for aux(48)=<B  
   - Found a solution using cacheing 
 * Adding constraints:[aux(48)=<aux(37)] 

##### Pending set table_make(A,B,C,D,E,F,G,H,I,J,K,L,M,N)
* Psum in Loop 88: [aux(44)=< -E+L'+3,aux(46)=< -E+L'+3,aux(44)=< -E+L'2+3,aux(46)=< -E+L'2+3]
* Psum in Chain-Tail [92]: [s(84)=<H,s(83)=<H/2,s(76)=<H/2+1/2]
* Psum in Chain-Tail [93]: [s(71)=<A,s(70)=<B]

###### Computing sum for aux(44)=< -E+L'+3  in Loop 88 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [] 
 * Adding constraints: [aux(44)=<it(88)*aux(49)] 

##### Pending set table_make(A,B,C,D,E,F,G,H,I,J,K,L,M,N)
* Psum in Loop 88: [aux(46)=< -E+L'+3,aux(44)=< -E+L'2+3,aux(46)=< -E+L'2+3]
* Psum in Chain-Tail [92]: [s(84)=<H,s(83)=<H/2,s(76)=<H/2+1/2]
* Psum in Chain-Tail [93]: [s(71)=<A,s(70)=<B]

###### Computing sum for aux(46)=< -E+L'+3  in Loop 88 
   - Found a solution using cacheing 
 * Adding constraints: [aux(46)=<aux(50),aux(50)=<it(88)*aux(49)] 

##### Pending set table_make(A,B,C,D,E,F,G,H,I,J,K,L,M,N)
* Psum in Loop 88: [aux(44)=< -E+L'2+3,aux(46)=< -E+L'2+3]
* Psum in Chain-Tail [92]: [s(84)=<H,s(83)=<H/2,s(76)=<H/2+1/2]
* Psum in Chain-Tail [93]: [s(71)=<A,s(70)=<B]

###### Computing sum for aux(44)=< -E+L'2+3  in Loop 88 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [] 
 * Adding constraints: [aux(44)=<it(88)*aux(51)] 

##### Pending set table_make(A,B,C,D,E,F,G,H,I,J,K,L,M,N)
* Psum in Loop 88: [aux(46)=< -E+L'2+3]
* Psum in Chain-Tail [92]: [s(84)=<H,s(83)=<H/2,s(76)=<H/2+1/2]
* Psum in Chain-Tail [93]: [s(71)=<A,s(70)=<B]

###### Computing sum for aux(46)=< -E+L'2+3  in Loop 88 
   - Found a solution using cacheing 
 * Adding constraints: [aux(46)=<aux(52),aux(52)=<it(88)*aux(51)] 

##### Pending set table_make(A,B,C,D,E,F,G,H,I,J,K,L,M,N)
* Psum in Chain-Tail [92]: [s(84)=<H,s(83)=<H/2,s(76)=<H/2+1/2]
* Psum in Chain-Tail [93]: [s(71)=<A,s(70)=<B]

###### Computing sum for s(84)=<H  in Chain-Tail [92] 
   - Applying inductive sum strategy 
     - head Candidate: H 
       - Loop 88 has a reset to  [2*H]
       - Chain-Tail [93] is collaborative
     - tail Candidate: H 
       - Loop 88 has undefined behavior 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(55)=<H] 
 * Adding constraints: [s(84)=<it([92])*aux(55),s(84)=<aux(53)+aux(54),aux(54)=<H] 

##### Pending set table_make(A,B,C,D,E,F,G,H,I,J,K,L,M,N)
* Pmax/min: [aux(55)=<H]
* Psum in Loop 88: [aux(53)=<2*H]
* Psum in Chain-Tail [92]: [s(83)=<H/2,s(76)=<H/2+1/2]
* Psum in Chain-Tail [93]: [s(71)=<A,s(70)=<B]

###### Computing max_min for aux(55)=<H  
   - Found a solution using transitive invariants 
 * Adding constraints:[aux(55)=<H] 

##### Pending set table_make(A,B,C,D,E,F,G,H,I,J,K,L,M,N)
* Psum in Loop 88: [aux(53)=<2*H]
* Psum in Chain-Tail [92]: [s(83)=<H/2,s(76)=<H/2+1/2]
* Psum in Chain-Tail [93]: [s(71)=<A,s(70)=<B]

###### Computing sum for aux(53)=<2*H  in Loop 88 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(56)=<2*H] 
 * Adding constraints: [aux(53)=<it(88)*aux(56)] 

##### Pending set table_make(A,B,C,D,E,F,G,H,I,J,K,L,M,N)
* Pmax/min: [aux(56)=<2*H]
* Psum in Chain-Tail [92]: [s(83)=<H/2,s(76)=<H/2+1/2]
* Psum in Chain-Tail [93]: [s(71)=<A,s(70)=<B]

###### Computing max_min for aux(56)=<2*H  
   - Found a solution using cacheing 
 * Adding constraints:[aux(56)=<aux(55)*2] 

##### Pending set table_make(A,B,C,D,E,F,G,H,I,J,K,L,M,N)
* Psum in Chain-Tail [92]: [s(83)=<H/2,s(76)=<H/2+1/2]
* Psum in Chain-Tail [93]: [s(71)=<A,s(70)=<B]

###### Computing sum for s(83)=<H/2  in Chain-Tail [92] 
   - Found a solution using cacheing 
 * Adding constraints: [s(83)=<aux(57)* (1/2),aux(57)=<it([92])*aux(55),aux(57)=<aux(53)+aux(54)] 

##### Pending set table_make(A,B,C,D,E,F,G,H,I,J,K,L,M,N)
* Psum in Chain-Tail [92]: [s(76)=<H/2+1/2]
* Psum in Chain-Tail [93]: [s(71)=<A,s(70)=<B]

###### Computing sum for s(76)=<H/2+1/2  in Chain-Tail [92] 
   - Applying inductive sum strategy 
     - head Candidate: H/2+1/2 
       - Loop 88 has a reset to  [H+1]
       - Chain-Tail [93] is collaborative
     - tail Candidate: H/2+1/2 
       - Loop 88 has undefined behavior 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(60)=<H/2+1/2] 
 * Adding constraints: [s(76)=<it([92])*aux(60),s(76)=<aux(58)+aux(59),aux(59)=<H/2+1/2] 

##### Pending set table_make(A,B,C,D,E,F,G,H,I,J,K,L,M,N)
* Pmax/min: [aux(60)=<H/2+1/2]
* Psum in Loop 88: [aux(58)=<H+1]
* Psum in Chain-Tail [93]: [s(71)=<A,s(70)=<B]

###### Computing max_min for aux(60)=<H/2+1/2  
   - Found a solution using cacheing 
 * Adding constraints:[aux(60)=<aux(55)* (1/2)+1/2] 

##### Pending set table_make(A,B,C,D,E,F,G,H,I,J,K,L,M,N)
* Psum in Loop 88: [aux(58)=<H+1]
* Psum in Chain-Tail [93]: [s(71)=<A,s(70)=<B]

###### Computing sum for aux(58)=<H+1  in Loop 88 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(61)=<H+1] 
 * Adding constraints: [aux(58)=<it(88)*aux(61)] 

##### Pending set table_make(A,B,C,D,E,F,G,H,I,J,K,L,M,N)
* Pmax/min: [aux(61)=<H+1]
* Psum in Chain-Tail [93]: [s(71)=<A,s(70)=<B]

###### Computing max_min for aux(61)=<H+1  
   - Found a solution using cacheing 
 * Adding constraints:[aux(61)=<aux(55)+1] 

##### Pending set table_make(A,B,C,D,E,F,G,H,I,J,K,L,M,N)
* Psum in Chain-Tail [93]: [s(71)=<A,s(70)=<B]

###### Computing sum for s(71)=<A  in Chain-Tail [93] 
   - Applying inductive sum strategy 
     - head Candidate: A 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A 
       - We failed to classify this candidate before 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(63)=<A] 
 * Adding constraints: [s(71)=<it([93])*aux(63),s(71)+s(81)=<aux(40)+aux(62),aux(62)=<A] 

##### Pending set table_make(A,B,C,D,E,F,G,H,I,J,K,L,M,N)
* Pmax/min: [aux(63)=<A]
* Psum in Chain-Tail [93]: [s(70)=<B]

###### Computing max_min for aux(63)=<A  
   - Found a solution using cacheing 
 * Adding constraints:[aux(63)=<aux(42)] 

##### Pending set table_make(A,B,C,D,E,F,G,H,I,J,K,L,M,N)
* Psum in Chain-Tail [93]: [s(70)=<B]

###### Computing sum for s(70)=<B  in Chain-Tail [93] 
   - Applying inductive sum strategy 
     - head Candidate: B 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B 
       - The candidate was classified before. We reuse its previous classification 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(66)=<B] 
 * Adding constraints: [s(70)=<it([93])*aux(66),s(70)+s(80)=<aux(44)+aux(64),s(70)+s(80)=<aux(46)+aux(65),aux(64)=<B,aux(65)=<B] 

##### Pending set table_make(A,B,C,D,E,F,G,H,I,J,K,L,M,N)
* Pmax/min: [aux(66)=<B]

###### Computing max_min for aux(66)=<B  
   - Found a solution using cacheing 
 * Adding constraints:[aux(66)=<aux(37)] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [88,[93],[92]] 

#### Simplifying cost structure of phase [88,[93],[92]] 
 * Joined equivalent variables [aux(67),aux(38),aux(39)] into aux(67)
 * Joined equivalent variables [aux(68),aux(41),aux(42),aux(62)] into aux(68)
 * Joined equivalent variables [aux(69),aux(45),aux(47),aux(64),aux(65)] into aux(69)
 * Joined equivalent variables [aux(70),aux(54),aux(55)] into aux(70)
 * Joined equivalent variables [aux(48),aux(66)] into aux(48)
 * Joined equivalent variables [aux(57),s(84)] into aux(57)
 * Joined equivalent variables [it(88),s(65)] into it(88)
 * Joined equivalent variables [s(68),s(69)] into s(68)
 * Joined equivalent variables [s(66),s(67)] into s(66)
 * Joined equivalent variables [s(74),s(75)] into s(74)
 * Joined equivalent variables [s(72),s(73)] into s(72)

#### Cost of phase [88,89]:table_make(A,B,C,D,E,F,G,H,I,J,K,L,M,N) -> [] 
94*it(88)+11*it([92])+18*it([93])+10*s(66)+15*s(68)+10*s(72)+10*s(74)+7*s(76)+10*s(77)+30*s(78)+5*s(79)+0
Unbounded itvars
it(88) :  it(88)
it([92]) :  it([92])
it([93]) :  it([93])
s(66) :  sum([93]),s(41)
s(68) :  sum([93]),s(43)
s(72) :  sum([92]),s(49)
s(74) :  sum([92]),s(51)
s(76) :  sum([92]),s(53)
s(77) :  sum([92]),s(57)
s(78) :  sum([92]),s(58)
s(79) :  sum([92]),s(60)
 * Joined equivalent variables [aux(71),s(38),s(46)] into aux(71)
 * Joined equivalent variables [aux(72),aux(36),aux(37)] into aux(72)
 * Joined equivalent variables [it(88),it([92]),it([93]),s(66),s(68),s(72),s(74),s(76),s(77),s(78),s(79)] into it(88)
 * Joined equivalent variables [s(43),s(44)] into s(43)
 * Joined equivalent variables [s(41),s(42)] into s(41)
 * Joined equivalent variables [s(51),s(52)] into s(51)
 * Joined equivalent variables [s(49),s(50)] into s(49)
 * Joined equivalent variables [s(41),s(49)] into s(41)
 * Joined equivalent variables [s(43),s(51)] into s(43)
 * Renamed intermediate variables: 
[ (eq(93,3),aux(5))>>s(85), (eq(93,3),it(33))>>s(86)]

#### Simplifying cost structure of CE 93 

#### Simplifying cost structure of chain [multiple(90,[[multiple([88,89],[[93],[92]])],[93],[92]])] 
 * Joined equivalent variables [it(88),s(86)] into it(88)

#### Cost of chains of table_make(A,B,C,D,E,F,G,H,I,J,K,L,M,N):
* Chain [93]: 5*s(41)+5*s(42)+5*s(43)+10*s(44)+18
  Such that:s(38) =< A
aux(36) =< B
s(44) =< aux(36)
s(41) =< s(38)
s(42) =< s(38)
s(41) =< aux(36)
s(42) =< aux(36)
s(43) =< aux(36)

  with precondition: [E=1,H=1,I=1,K=2,B=L,A>=1,B>=2,D>=0,F>=0,G>=0,J>=1,M>=0,N>=0,C>=G] 

* Chain [92]: 5*s(49)+5*s(50)+5*s(51)+5*s(52)+7*s(53)+10*s(57)+30*s(58)+5*s(60)+11
  Such that:s(46) =< A
s(55) =< H
s(56) =< H/2
s(53) =< H/2+1/2
aux(37) =< B
s(57) =< s(55)
s(58) =< s(56)
s(59) =< aux(37)*2
s(60) =< s(53)*aux(37)
s(61) =< s(58)*s(59)
s(60) =< s(61)+s(61)+s(61)+s(61)+aux(37)
s(49) =< s(46)
s(50) =< s(46)
s(49) =< aux(37)
s(50) =< aux(37)
s(51) =< aux(37)
s(52) =< aux(37)

  with precondition: [E=1,I=1,K=2,B=L,A>=1,B>=2,C>=0,D>=0,F>=0,G>=0,H>=2,J>=1,M>=0,N>=0,D+H+N>=3] 

* Chain [multiple([88,89],[[93],[92]])]: 94*it(88)+11*it([92])+18*it([93])+10*s(66)+15*s(68)+10*s(72)+10*s(74)+7*s(76)+10*s(77)+30*s(78)+5*s(79)+0
Unbounded itvars
it(88) :  it(88)
it([92]) :  it([92])
it([93]) :  it([93])
s(66) :  sum([93]),s(41)
s(68) :  sum([93]),s(43)
s(72) :  sum([92]),s(49)
s(74) :  sum([92]),s(51)
s(76) :  sum([92]),s(53)
s(77) :  sum([92]),s(57)
s(78) :  sum([92]),s(58)
s(79) :  sum([92]),s(60)

  with precondition: [A>=1,B>=1,C>=0,D>=0,E>=2,F>=0,G>=0,H>=1,I>=1,J>=1,M>=0,N>=0,K+7>=4*E,K+1>=2*E,K>=I+1,L+1>=B+E] 

* Chain [multiple(90,[[multiple([88,89],[[93],[92]])],[93],[92]])]: 300*it(88)+20*s(41)+25*s(43)+7*s(53)+10*s(57)+30*s(58)+5*s(60)+50
  Such that:aux(71) =< 1
aux(72) =< B+1
s(55) =< H
s(56) =< H/2
s(53) =< H/2+1/2
s(43) =< aux(72)
s(41) =< aux(71)
s(41) =< aux(72)
s(57) =< s(55)
s(58) =< s(56)
s(59) =< aux(72)*2
s(60) =< s(53)*aux(72)
s(61) =< s(58)*s(59)
s(60) =< s(61)+s(61)+s(61)+s(61)+aux(72)

Unbounded itvars
it(88) :  it(88)

  with precondition: [A=0,B>=1,C>=0,D>=0,E>=2,F>=0,G>=0,H>=1,I>=1,J>=1,M>=0,N>=0,K+23>=8*E,K+7>=4*E,K+1>=2*E,K>=I+1,L+1>=B+E] 


Closed-form bounds of eval2(A,B,C,D,E,F,G): 
-------------------------------------
* Chain [76] with precondition: [F=1,G=0,A>=0,B>=0,C>=0,D>=0,E>=A+1,E>=C+1] 
    - Upper bound: 7 
    - Complexity: constant 
* Chain [75] with precondition: [F=1,A=E,B=G,A>=0,B>=0,C>=0,D>=0] 
    - Upper bound: 4 
    - Complexity: constant 
* Chain [74] with precondition: [F=1,C=E,D=G,A>=0,B>=0,D>=0,C>=A+1] 
    - Upper bound: 6 
    - Complexity: constant 
* Chain [multiple([68,69,70,71,72,73],[[76],[75],[74]])] with precondition: [A>=0,B>=0,C>=0,D>=0,F>=2,G>=0,E>=A,B+D+F>=G+1,B+D+F+G>=3] 
    - Upper bound: 67/2*F+17/2 
    - Complexity: n 

### Maximum cost of eval2(A,B,C,D,E,F,G): 67/2*F+17/2 
Asymptotic class: n 

Closed-form bounds of table2(A,B,C,D,E,F,G): 
-------------------------------------
* Chain [87] with precondition: [D=1,E=1,F=5,A=C,A>=0,B>=0,G>=1] 
    - Upper bound: 45 
    - Complexity: constant 
* Chain [86] with precondition: [D=1,E=1,F=5,B=C,A>=0,G>=1,B>=A+1] 
    - Upper bound: 53 
    - Complexity: constant 
* Chain [85] with precondition: [D=1,E=1,F=5,A>=0,B>=0,G>=1,C>=A+1,C>=B+1] 
    - Upper bound: 57 
    - Complexity: constant 
* Chain [84] with precondition: [E=1,F=5,A>=0,B>=0,D>=2,G>=1,C>=A] 
    - Upper bound: 134*D+63 
    - Complexity: n 

### Maximum cost of table2(A,B,C,D,E,F,G): 134*D+63 
Asymptotic class: n 

Closed-form bounds of rev(A,B,C,D,E,F,G,H,I,J,K,L): 
-------------------------------------
* Chain [83] with precondition: [A=0,B=1,D=0,E=1,F=0,G=0,H=1,J=0,K=1,L=0,C>=0,I>=0] 
    - Upper bound: 4 
    - Complexity: constant 
* Chain [82] with precondition: [B=E,B=H,B=K,A>=1,B>=2,C>=0,D>=0,F>=1,G>=1,I>=0,J>=0,L>=1] 
    - Upper bound: 10*A+5*E+5*F+4 
    - Complexity: n 

### Maximum cost of rev(A,B,C,D,E,F,G,H,I,J,K,L): 10*A+5*E+5*F+4 
Asymptotic class: n 

Closed-form bounds of concat(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X): 
-------------------------------------
* Chain [[33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48],49] with precondition: [C=G,C+K=S+1,C+O=W+1,A>=1,C>=2,E>=0,F>=0,H>=1,I>=0,J>=0,K>=1,L>=0,M>=0,N>=0,O>=1,P>=0,Q>=1,X>=1,Q>=I,R>=J,T>=L,U>=M,V>=N,X>=P,A+I>=Q,B+J>=R,D+L>=T,H+P>=X] 
    - Upper bound: 80*G+2 
    - Complexity: n 
* Chain [49] with precondition: [A=0,B=0,C=1,D=0,F=0,G=1,H=0,I=Q,J=R,K=S,L=T,M=U,N=V,O=W,P=X,E>=0,I>=0,J>=0,K>=0,L>=0,M>=0,N>=0,O>=0,P>=0] 
    - Upper bound: 2 
    - Complexity: constant 

### Maximum cost of concat(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X): 80*G+2 
Asymptotic class: n 

Closed-form bounds of assoc(A,B,C,D,E,F): 
-------------------------------------
* Chain [[29],30] with precondition: [A>=0,B>=1,C>=3,F>=0,D>=A+1,E>=F] 
    - Upper bound: 5*C+4 
    - Complexity: n 
* Chain [30] with precondition: [A>=0,B>=1,C>=2,F>=0,D>=A,E>=F] 
    - Upper bound: 4 
    - Complexity: constant 

### Maximum cost of assoc(A,B,C,D,E,F): 5*C+4 
Asymptotic class: n 

Closed-form bounds of eval(A,B,C,D,E,F,G): 
-------------------------------------
* Chain [62] with precondition: [F=1,A>=1,B>=2,E>=0,G>=0,C>=E,D>=G] 
    - Upper bound: 5*B+7 
    - Complexity: n 
* Chain [multiple([56,57,58,59,60,61],[[62]])] with precondition: [A>=1,B>=2,C>=0,D>=0,E>=0,F>=2,G>=0,D+F>=G+1,D+F+G>=3] 
    - Upper bound: 7/2*F+7/2+ ((F/2+1/2)* (5*B)+10*F)+15*F 
    - Complexity: n^2 

### Maximum cost of eval(A,B,C,D,E,F,G): max([5*B+7,7/2*F+7/2+ ((F/2+1/2)* (5*B)+10*F)+15*F]) 
Asymptotic class: n^2 
 * Joined equivalent variables [s(43),s(44)] into s(43)
 * Joined equivalent variables [s(41),s(42)] into s(41)
 * Joined equivalent variables [s(51),s(52)] into s(51)
 * Joined equivalent variables [s(49),s(50)] into s(49)
 * Joined equivalent variables [it(88),it([92]),it([93]),s(66),s(68),s(72),s(74),s(76),s(77),s(78),s(79)] into it(88)

Closed-form bounds of table_make(A,B,C,D,E,F,G,H,I,J,K,L,M,N): 
-------------------------------------
* Chain [93] with precondition: [E=1,H=1,I=1,K=2,B=L,A>=1,B>=2,D>=0,F>=0,G>=0,J>=1,M>=0,N>=0,C>=G] 
    - Upper bound: 10*A+15*B+18 
    - Complexity: n 
* Chain [92] with precondition: [E=1,I=1,K=2,B=L,A>=1,B>=2,C>=0,D>=0,F>=0,G>=0,H>=2,J>=1,M>=0,N>=0,D+H+N>=3] 
    - Upper bound: 10*A+10*B+11+ (H/2+1/2)* (5*B)+10*H+ (7/2*H+7/2)+15*H 
    - Complexity: n^2 
* Chain [multiple([88,89],[[93],[92]])] with precondition: [A>=1,B>=1,C>=0,D>=0,E>=2,F>=0,G>=0,H>=1,I>=1,J>=1,M>=0,N>=0,K+7>=4*E,K+1>=2*E,K>=I+1,L+1>=B+E] 
    - Upper bound: inf 
    - Complexity: infinity 
* Chain [multiple(90,[[multiple([88,89],[[93],[92]])],[93],[92]])] with precondition: [A=0,B>=1,C>=0,D>=0,E>=2,F>=0,G>=0,H>=1,I>=1,J>=1,M>=0,N>=0,K+23>=8*E,K+7>=4*E,K+1>=2*E,K>=I+1,L+1>=B+E] 
    - Upper bound: inf 
    - Complexity: infinity 

### Maximum cost of table_make(A,B,C,D,E,F,G,H,I,J,K,L,M,N): inf 
Asymptotic class: infinity 
* Total analysis performed in 12497 ms.


Cost relation system solved by CoFloCo in 12508 ms.

Method eval2 terminates?: YES

 - a_1: size of a wrt. Rat
 - val_a_1: size of val_a wrt. Bool
 - b_1: size of b wrt. Rat
 - val_b_1: size of val_b wrt. Bool
 - exp_1: size of exp wrt. Rat
 - exp_2: size of exp wrt. Bool_expr
UB for eval2(a_1,val_a_1,b_1,val_b_1,exp_1,exp_2) = 67/2*exp_2+17/2

Method table2 terminates?: YES

 - a_1: size of a wrt. Rat
 - b_1: size of b wrt. Rat
 - expr_1: size of expr wrt. Rat
 - expr_2: size of expr wrt. Bool_expr
UB for table2(a_1,b_1,expr_1,expr_2) = 134*expr_2+63

Method rev terminates?: YES

 - l_1: size of l wrt. Pair<Rat, Bool>
 - l_2: size of l wrt. List<Pair<Rat, Bool>>
 - l_3: size of l wrt. Rat
 - l_4: size of l wrt. Bool
 - l_5: size of l wrt. List<A>
 - l_6: size of l wrt. A
UB for rev(l_1,l_2,l_3,l_4,l_5,l_6) = 10*l_1+5*l_5+5*l_6+4

Method concat terminates?: YES

 - l1_1: size of l1 wrt. Pair<List<Pair<Rat, Bool>>, Bool>
 - l1_2: size of l1 wrt. Pair<Rat, Bool>
 - l1_3: size of l1 wrt. List<Pair<List<Pair<Rat, Bool>>, Bool>>
 - l1_4: size of l1 wrt. List<Pair<Rat, Bool>>
 - l1_5: size of l1 wrt. Rat
 - l1_6: size of l1 wrt. Bool
 - l1_7: size of l1 wrt. List<A>
 - l1_8: size of l1 wrt. A
 - l2_1: size of l2 wrt. Pair<List<Pair<Rat, Bool>>, Bool>
 - l2_2: size of l2 wrt. Pair<Rat, Bool>
 - l2_3: size of l2 wrt. List<Pair<List<Pair<Rat, Bool>>, Bool>>
 - l2_4: size of l2 wrt. List<Pair<Rat, Bool>>
 - l2_5: size of l2 wrt. Rat
 - l2_6: size of l2 wrt. Bool
 - l2_7: size of l2 wrt. List<A>
 - l2_8: size of l2 wrt. A
UB for concat(l1_1,l1_2,l1_3,l1_4,l1_5,l1_6,l1_7,l1_8,l2_1,l2_2,l2_3,l2_4,l2_5,l2_6,l2_7,l2_8) = 80*l1_7+2

Method assoc terminates?: YES

 - k_1: size of k wrt. Rat
 - l_1: size of l wrt. Pair<Rat, Bool>
 - l_2: size of l wrt. List<Pair<Rat, Bool>>
 - l_3: size of l wrt. Rat
 - l_4: size of l wrt. Bool
UB for assoc(k_1,l_1,l_2,l_3,l_4) = 5*l_2+4

Method eval terminates?: YES

 - val_vars_1: size of val_vars wrt. Pair<Rat, Bool>
 - val_vars_2: size of val_vars wrt. List<Pair<Rat, Bool>>
 - val_vars_3: size of val_vars wrt. Rat
 - val_vars_4: size of val_vars wrt. Bool
 - exp_1: size of exp wrt. Rat
 - exp_2: size of exp wrt. Bool_expr
UB for eval(val_vars_1,val_vars_2,val_vars_3,val_vars_4,exp_1,exp_2) = max([5*val_vars_2+7,7/2*exp_2+7/2+ ((exp_2/2+1/2)* (5*val_vars_2)+10*exp_2)+15*exp_2])

Method table_make terminates?: YES

 - val_vars_1: size of val_vars wrt. Pair<Rat, Bool>
 - val_vars_2: size of val_vars wrt. List<Pair<Rat, Bool>>
 - val_vars_3: size of val_vars wrt. Rat
 - val_vars_4: size of val_vars wrt. Bool
 - vars_1: size of vars wrt. List<Rat>
 - vars_2: size of vars wrt. Rat
 - expr_1: size of expr wrt. Rat
 - expr_2: size of expr wrt. Bool_expr
UB for table_make(val_vars_1,val_vars_2,val_vars_3,val_vars_4,vars_1,vars_2,expr_1,expr_2) = inf
