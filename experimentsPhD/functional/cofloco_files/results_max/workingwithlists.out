
Abs program loaded in 12 ms.

Rule based representation generated in 8 ms.

Rule based representation stored in /tmp/costabs/rbr.rbr

RBR properties stored in /tmp/costabs/rbr.properties

Class invariants generated and loaded in 0 ms.

Abstract compilation performed in 70 ms.

Cost relation system stored in /tmp/costabs/crs.crs

Generated 152 equations 
entry('last'(A,B,C,D):[]).
entry('last_two'(A,B,C,D,E):[]).
entry('at'(A,B,C,D,E):[]).
entry('lengthL'(A,B,C,D,E,F):[]).
entry('rev'(A,B,C,D,E,F,G,H):[]).
entry('eq_lists'(A,B,C,D,E):[]).
entry('is_palindrome'(A,B,C):[]).
entry('compress'(A,B,C,D):[]).
entry('pack'(A,B,C,D,E):[]).
entry('encode'(A,B,C,D,E):[]).
entry('duplicate'(A,B,C,D):[]).
entry('replicate'(A,B,C,D,E):[]).
entry('drop'(A,B,C,D,E):[]).
entry('split'(A,B,C,D,E,F):[]).
entry('slice'(A,B,C,D,E,F):[]).
entry('concat'(A,B,C,D,E,F,G,H,I,J,K,L):[]).
entry('rotate'(A,B,C,D,E):[]).
entry('removeAt'(A,B,C,D,E):[]).
entry('insertAt'(A,B,C,D,E,F):[]).
entry('minusminus'(A,B,C,D):[]).
entry('randomL'(A,B):[]).
entry('minL'(A,B,C):[]).
entry('rand_select'(A,B,C,D,E):[]).
entry('lotto_select'(A,B,C,D):[]).
input_output_vars('and_op'(A,B,C),[A,B],[C]).
input_output_vars('at'(A,B,C,D,E),[A,B,C],[D,E]).
input_output_vars('aux_length'(A,B,C,D,E,F,G,H),[A,B,C,D,E,F],[G,H]).
input_output_vars('aux_rev'(A,B,C,D,E,F,G,H,I,J,K,L),[A,B,C,D,E,F,G,H],[I,J,K,L]).
input_output_vars('case_0'(A,B,C,D),[A,B],[C,D]).
input_output_vars('case_1'(A,B,C,D,E,F,G),[A,B,C,D,E],[F,G]).
input_output_vars('case_10'(A,B,C,D,E),[A,B,C,D],[E]).
input_output_vars('case_11'(A,B,C,D,E,F,G,H),[A,B,C,D,E,F,G],[H]).
input_output_vars('case_12'(A,B,C,D),[A,B],[C,D]).
input_output_vars('case_13'(A,B,C,D,E,F,G),[A,B,C,D,E],[F,G]).
input_output_vars('case_14'(A,B,C,D,E,F,G,H,I,J),[A,B,C,D,E,F,G,H],[I,J]).
input_output_vars('case_15'(A,B,C,D,E,F,G,H,I,J),[A,B,C,D,E,F,G],[H,I,J]).
input_output_vars('case_16'(A,B,C,D,E,F,G,H,I,J,K,L,M),[A,B,C,D,E,F,G,H,I,J],[K,L,M]).
input_output_vars('case_17'(A,B,C,D,E,F,G,H,I,J,K,L,M,N),[A,B,C,D,E,F,G,H,I,J,K],[L,M,N]).
input_output_vars('case_18'(A,B,C,D,E,F,G,H,I),[A,B,C,D,E,F],[G,H,I]).
input_output_vars('case_19'(A,B,C,D,E,F,G,H,I,J,K,L),[A,B,C,D,E,F,G,H,I],[J,K,L]).
input_output_vars('case_2'(A,B,C,D,E),[A,B],[C,D,E]).
input_output_vars('case_20'(A,B,C,D,E,F,G,H,I,J,K,L,M),[A,B,C,D,E,F,G,H,I,J],[K,L,M]).
input_output_vars('case_21'(A,B,C,D),[A,B],[C,D]).
input_output_vars('case_22'(A,B,C,D,E,F,G),[A,B,C,D,E],[F,G]).
input_output_vars('case_23'(A,B,C,D,E,F,G),[A,B,C,D,E],[F,G]).
input_output_vars('case_24'(A,B,C,D,E,F),[A,B,C,D],[E,F]).
input_output_vars('case_25'(A,B,C,D,E,F,G,H,I),[A,B,C,D,E,F,G],[H,I]).
input_output_vars('case_26'(A,B,C,D,E,F,G,H),[A,B,C,D,E],[F,G,H]).
input_output_vars('case_27'(A,B,C,D,E,F,G,H,I,J,K,L),[A,B,C,D,E,F,G,H,I],[J,K,L]).
input_output_vars('case_28'(A,B,C,D,E),[A,B,C],[D,E]).
input_output_vars('case_29'(A,B,C,D,E,F,G,H,I),[A,B,C,D,E,F,G],[H,I]).
input_output_vars('case_3'(A,B,C,D,E,F,G,H),[A,B,C,D,E],[F,G,H]).
input_output_vars('case_30'(A,B,C,D,E),[A,B,C],[D,E]).
input_output_vars('case_31'(A,B,C,D,E,F,G,H,I),[A,B,C,D,E,F,G],[H,I]).
input_output_vars('case_32'(A,B,C,D,E,F,G,H,I,J,K,L),[A,B,C,D,E,F,G,H],[I,J,K,L]).
input_output_vars('case_33'(A,B,C,D,E,F),[A,B,C,D,E],[F]).
input_output_vars('case_34'(A,B,C,D,E,F,G,H),[A,B,C,D,E,F],[G,H]).
input_output_vars('case_35'(A,B,C,D,E,F,G,H,I,J,K),[A,B,C,D,E,F,G,H,I],[J,K]).
input_output_vars('case_36'(A,B,C,D,E),[A,B,C],[D,E]).
input_output_vars('case_37'(A,B,C,D,E,F,G,H,I),[A,B,C,D,E,F,G],[H,I]).
input_output_vars('case_38'(A,B,C,D,E,F),[A,B,C,D],[E,F]).
input_output_vars('case_39'(A,B,C,D,E,F,G,H,I,J),[A,B,C,D,E,F,G,H],[I,J]).
input_output_vars('case_4'(A,B,C,D,E,F,G,H,I,J,K),[A,B,C,D,E,F,G,H],[I,J,K]).
input_output_vars('case_40'(A,B,C,D),[A,B],[C,D]).
input_output_vars('case_41'(A,B,C,D),[A,B],[C,D]).
input_output_vars('case_42'(A,B,C),[A,B],[C]).
input_output_vars('case_43'(A,B,C,D,E,F,G,H),[A,B,C,D,E],[F,G,H]).
input_output_vars('case_44'(A,B,C,D,E,F,G,H,I,J,K,L),[A,B,C,D,E,F,G,H,I],[J,K,L]).
input_output_vars('case_45'(A,B,C,D,E,F,G,H,I),[A,B,C,D,E,F,G],[H,I]).
input_output_vars('case_46'(A,B,C,D,E,F,G,H,I,J,K,L),[A,B,C,D,E,F,G,H,I,J],[K,L]).
input_output_vars('case_5'(A,B,C,D,E),[A,B,C],[D,E]).
input_output_vars('case_6'(A,B,C,D,E,F,G,H,I),[A,B,C,D,E,F,G],[H,I]).
input_output_vars('case_7'(A,B,C,D,E,F,G,H),[A,B,C,D,E,F],[G,H]).
input_output_vars('case_8'(A,B,C,D,E,F,G,H,I,J,K,L),[A,B,C,D,E,F,G,H],[I,J,K,L]).
input_output_vars('case_9'(A,B,C,D,E),[A,B,C,D],[E]).
input_output_vars('compress'(A,B,C,D),[A,B],[C,D]).
input_output_vars('concat'(A,B,C,D,E,F,G,H,I,J,K,L),[A,B,C,D,E,F,G,H],[I,J,K,L]).
input_output_vars('drop'(A,B,C,D,E),[A,B,C],[D,E]).
input_output_vars('drop_aux'(A,B,C,D,E,F),[A,B,C,D],[E,F]).
input_output_vars('drop_slice'(A,B,C,D,E),[A,B,C],[D,E]).
input_output_vars('duplicate'(A,B,C,D),[A,B],[C,D]).
input_output_vars('encode'(A,B,C,D,E),[A,B],[C,D,E]).
input_output_vars('encode_aux'(A,B,C,D,E,F,G,H,I),[A,B,C,D,E,F],[G,H,I]).
input_output_vars('eq'(A,B,C),[A,B],[C]).
input_output_vars('eq_lists'(A,B,C,D,E),[A,B,C,D],[E]).
input_output_vars('geq'(A,B,C),[A,B],[C]).
input_output_vars('gt'(A,B,C),[A,B],[C]).
input_output_vars('insertAt'(A,B,C,D,E,F),[A,B,C,D],[E,F]).
input_output_vars('is_palindrome'(A,B,C),[A,B],[C]).
input_output_vars('last'(A,B,C,D),[A,B],[C,D]).
input_output_vars('last_two'(A,B,C,D,E),[A,B],[C,D,E]).
input_output_vars('lengthL'(A,B,C,D,E,F),[A,B,C,D],[E,F]).
input_output_vars('leq'(A,B,C),[A,B],[C]).
input_output_vars('lotto_select'(A,B,C,D),[A,B],[C,D]).
input_output_vars('lt'(A,B,C),[A,B],[C]).
input_output_vars('maxNorm'(A,B,C),[A,B],[C]).
input_output_vars('minL'(A,B,C),[A,B],[C]).
input_output_vars('minusminus'(A,B,C,D),[A,B],[C,D]).
input_output_vars('minusminus_aux'(A,B,C,D),[A,B],[C,D]).
input_output_vars('neg'(A,B),[A],[B]).
input_output_vars('neq'(A,B,C),[A,B],[C]).
input_output_vars('or'(A,B,C),[A,B],[C]).
input_output_vars('pack'(A,B,C,D,E),[A,B],[C,D,E]).
input_output_vars('pack_aux'(A,B,C,D,E,F,G,H,I,J),[A,B,C,D,E,F,G],[H,I,J]).
input_output_vars('prepend'(A,B,C,D,E,F),[A,B,C,D],[E,F]).
input_output_vars('rand_select'(A,B,C,D,E),[A,B,C],[D,E]).
input_output_vars('rand_select_aux'(A,B,C,D,E,F,G,H),[A,B,C,D,E,F],[G,H]).
input_output_vars('rand_select_extract'(A,B,C,D,E,F,G,H),[A,B,C,D,E],[F,G,H]).
input_output_vars('rand_select_extract_rand'(A,B,C,D,E,F),[A,B,C],[D,E,F]).
input_output_vars('randomL'(A,B),[A],[B]).
input_output_vars('removeAt'(A,B,C,D,E),[A,B,C],[D,E]).
input_output_vars('replicate'(A,B,C,D,E),[A,B,C],[D,E]).
input_output_vars('replicate_aux'(A,B,C,D,E,F,G),[A,B,C,D,E],[F,G]).
input_output_vars('rev'(A,B,C,D,E,F,G,H),[A,B,C,D],[E,F,G,H]).
input_output_vars('rotate'(A,B,C,D,E),[A,B,C],[D,E]).
input_output_vars('slice'(A,B,C,D,E,F),[A,B,C,D],[E,F]).
input_output_vars('split'(A,B,C,D,E,F),[A,B,C],[D,E,F]).
input_output_vars('split_aux'(A,B,C,D,E,F,G,H),[A,B,C,D,E],[F,G,H]).
input_output_vars('take_slice'(A,B,C,D,E),[A,B,C],[D,E]).
eq('eq',[A,B,C],0,[],[A=B,C=1,A>=0,B>=0,C>=0]).
eq('eq',[A,B,C],0,[],[A>=B+1,C=0,A>=0,B>=0,C>=0]).
eq('eq',[A,B,C],0,[],[B>=A+1,C=0,A>=0,B>=0,C>=0]).
eq('neq',[A,B,C],0,[],[A=B,C=0,A>=0,B>=0,C>=0]).
eq('neq',[A,B,C],0,[],[A>=B+1,C=1,A>=0,B>=0,C>=0]).
eq('neq',[A,B,C],0,[],[B>=A+1,C=1,A>=0,B>=0,C>=0]).
eq('lt',[A,B,C],0,[],[B-A>=1,C=1,A>=0,B>=0,C>=0]).
eq('lt',[A,B,C],0,[],[B=<A,C=0,A>=0,B>=0,C>=0]).
eq('leq',[A,B,C],0,[],[A=<B,C=1,A>=0,B>=0,C>=0]).
eq('leq',[A,B,C],0,[],[A-B>=1,C=0,A>=0,B>=0,C>=0]).
eq('gt',[A,B,C],0,[],[A-B>=1,C=1,A>=0,B>=0,C>=0]).
eq('gt',[A,B,C],0,[],[A=<B,C=0,A>=0,B>=0,C>=0]).
eq('geq',[A,B,C],0,[],[B=<A,C=1,A>=0,B>=0,C>=0]).
eq('geq',[A,B,C],0,[],[B-A>=1,C=0,A>=0,B>=0,C>=0]).
eq('neg',[A,B],0,[],[A=0,B=1,A>=0,B>=0]).
eq('neg',[A,B],0,[],[A=1,B=0,A>=0,B>=0]).
eq('and_op',[A,B,C],0,[],[A=0,C=0,A>=0,B>=0,C>=0]).
eq('and_op',[A,B,C],0,[],[A=1,C=B,A>=0,B>=0,C>=0]).
eq('or',[A,B,C],0,[],[A=1,C=1,A>=0,B>=0,C>=0]).
eq('or',[A,B,C],0,[],[A=0,C=B,A>=0,B>=0,C>=0]).
eq('maxNorm',[A,B,A],0,[],[A>=1+B,A>=0,B>=0,A>=0]).
eq('maxNorm',[A,B,B],0,[],[A=<B,A>=0,B>=0,B>=0]).
eq('case_0',[A,B,C,D],2,[],[B=0,A=1,D=0,C=1,A>=0,B>=0,C>=0,D>=0]).
eq('case_1',[A,B,C,D,E,F,G],2,[],[E=0,D=1,G=C,F=1,C>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0]).
eq('case_1',[A,B,C,D,E,F,G],3,['last'(D,E,F,G)],[E>=H,E>=H,H>=1,D=I+1,I>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0]).
eq('case_0',[A,B,C,D],3,['case_1'(A,B,E,F,G,C,D)],[B>=E,B>=G,A=F+1,F>=1,E>=1,A>=0,B>=0,C>=0,D>=0]).
eq('last',[A,B,C,D],1,['case_0'(A,B,C,D)],[A>=0,B>=0,C>=0,D>=0]).
eq('case_2',[A,B,C,D,E],2,[],[B=0,A=1,E=0,D=1,C=0,A>=0,B>=0,C>=0,D>=0,E>=0]).
eq('case_3',[A,B,C,D,E,F,G,H],2,[],[E=0,D=1,H=0,G=1,F=0,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0]).
eq('case_4',[A,B,C,D,E,F,G,H,I,J,K],3,['maxNorm'(C,F,L)],[H=0,G=1,M=1,F>=1,C>=1,K=L,J=1,I=M,M>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0]).
eq('case_4',[A,B,C,D,E,F,G,H,I,J,K],3,['last_two'(D,E,I,J,K)],[H>=L,H>=L,L>=1,G=M+1,M>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0]).
eq('case_3',[A,B,C,D,E,F,G,H],3,['case_4'(A,B,C,D,E,I,J,K,F,G,H)],[E>=I,E>=K,D=J+1,J>=1,I>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0]).
eq('case_2',[A,B,C,D,E],3,['case_3'(A,B,F,G,H,C,D,E)],[B>=F,B>=H,A=G+1,G>=1,F>=1,A>=0,B>=0,C>=0,D>=0,E>=0]).
eq('last_two',[A,B,C,D,E],1,['case_2'(A,B,C,D,E)],[A>=0,B>=0,C>=0,D>=0,E>=0]).
eq('case_5',[A,B,C,D,E],2,[],[C=0,B=1,E=0,D=1,A>=0,B>=0,C>=0,D>=0,E>=0]).
eq('case_6',[A,B,C,D,E,F,G,H,I],2,[],[B=A,I=E,H=1,E>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0]).
eq('case_6',[A,B,C,D,E,F,G,H,I],4,['at'(J,F,G,H,I)],[B>=A+1,K=1,J=B-K,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0]).
eq('case_5',[A,B,C,D,E],4,['case_6'(F,A,B,C,G,H,I,D,E)],[C>=G,C>=I,B=H+1,H>=1,G>=1,F=0,A>=0,B>=0,C>=0,D>=0,E>=0]).
eq('at',[A,B,C,D,E],1,['case_5'(A,B,C,D,E)],[A>=0,B>=0,C>=0,D>=0,E>=0]).
eq('case_7',[A,B,C,D,E,F,E,F],1,[],[D=0,C=1,A=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,E>=0,F>=0]).
eq('case_7',[A,B,C,D,E,F,G,H],5,['aux_length'(I,J,K,L,M,N,G,H)],[D>=O,D>=L,B>=P,B>=J,O>=1,C=K+1,A=I+1,K>=1,I>=1,Q=1,R=1,N=F+Q,M=E+R,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0]).
eq('aux_length',[A,B,C,D,E,F,G,H],1,['case_7'(A,B,C,D,E,F,G,H)],[A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0]).
eq('lengthL',[A,B,C,D,E,F],2,['aux_length'(A,B,C,D,G,H,E,F)],[H=0,G=0,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0]).
eq('case_8',[A,B,C,D,E,F,G,H,A,B,C,D],1,[],[H=0,G=1,E=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,A>=0,B>=0,C>=0,D>=0]).
eq('case_8',[A,B,C,D,E,F,G,H,I,J,K,L],4,['maxNorm'(M,D,N),'aux_rev'(O,P,Q,N,R,S,T,U,I,J,K,L)],[H>=M,H>=U,F>=V,F>=S,G=T+1,E=R+1,T>=1,R>=1,M>=1,P>=V,P>=B,Q=C+1,O=A+1,C>=1,A>=1,M>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0]).
eq('aux_rev',[A,B,C,D,E,F,G,H,I,J,K,L],1,['case_8'(A,B,C,D,E,F,G,H,I,J,K,L)],[A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0]).
eq('rev',[A,B,C,D,E,F,G,H],2,['aux_rev'(I,J,K,L,A,B,C,D,E,F,G,H)],[L=0,K=1,I=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0]).
eq('case_10',[A,B,C,D,E],2,[],[C=1,E=1,A>=0,B>=0,C>=0,D>=0,E>=0]).
eq('case_10',[A,B,C,D,E],3,[],[D>=F,D>=F,C=G+1,G>=1,E=0,A>=0,B>=0,C>=0,D>=0,E>=0]).
eq('case_9',[A,B,C,D,E],2,['case_10'(A,B,C,D,E)],[A=1,A>=0,B>=0,C>=0,D>=0,E>=0]).
eq('case_11',[A,B,C,D,E,F,G,H],2,[],[C=1,H=0,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0]).
eq('case_11',[A,B,C,D,E,F,G,H],5,['eq'(E,I,J),'eq_lists'(F,G,K,L,M),'and_op'(J,M,H)],[D>=I,D>=L,C=K+1,K>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0]).
eq('case_9',[A,B,C,D,E],3,['case_11'(A,B,C,D,F,G,H,E)],[B>=F,B>=H,A=G+1,G>=1,A>=0,B>=0,C>=0,D>=0,E>=0]).
eq('eq_lists',[A,B,C,D,E],1,['case_9'(A,B,C,D,E)],[A>=0,B>=0,C>=0,D>=0,E>=0]).
eq('is_palindrome',[A,B,C],2,['rev'(A,B,D,E,F,G,H,I),'eq_lists'(A,B,F,G,C)],[A>=0,B>=0,C>=0]).
eq('case_12',[A,B,C,D],2,[],[A=1,C=1,A>=0,B>=0,C>=0,D>=0]).
eq('case_13',[A,B,C,D,E,F,G],3,[],[D=1,H=1,G>=C,G>=I,F=H+1,H>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0]).
eq('case_14',[A,B,C,D,E,F,G,H,I,J],3,['compress'(K,L,I,J)],[C=F,L>=F,L>=H,K=G+1,G>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0]).
eq('case_14',[A,B,C,D,E,F,G,H,I,J],4,['compress'(K,L,M,N)],[C>=F+1,L>=F,L>=H,K=G+1,G>=1,J>=C,J>=N,I=M+1,M>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0]).
eq('case_13',[A,B,C,D,E,F,G],3,['case_14'(A,B,C,D,E,H,I,J,F,G)],[E>=H,E>=J,D=I+1,I>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0]).
eq('case_12',[A,B,C,D],3,['case_13'(A,B,E,F,G,C,D)],[B>=E,B>=G,A=F+1,F>=1,A>=0,B>=0,C>=0,D>=0]).
eq('compress',[A,B,C,D],1,['case_12'(A,B,C,D)],[A>=0,B>=0,C>=0,D>=0]).
eq('case_15',[A,B,C,D,E,F,G,H,I,J],2,[],[F=1,I=0,H=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0]).
eq('case_16',[A,B,C,D,E,F,G,H,I,J,K,L,M],3,['maxNorm'(N,D,L)],[I=1,O>=H,O>=B,N=A+1,A>=1,M>=O,M>=E,K=C+1,C>=1,N>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0,M>=0]).
eq('case_17',[A,B,C,D,E,F,G,H,I,J,K,L,M,N],3,['pack_aux'(O,P,C,D,E,I,J,L,M,N)],[H=K,P>=H,P>=B,O=A+1,A>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0,M>=0,N>=0]).
eq('case_17',[A,B,C,D,E,F,G,H,I,J,K,L,M,N],5,['maxNorm'(O,D,P),'pack_aux'(Q,R,S,P,T,I,J,L,M,N)],[H>=K+1,Q=1,U>=H,U>=B,O=A+1,A>=1,T>=U,T>=E,S=C+1,C>=1,O>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0,M>=0,N>=0]).
eq('case_16',[A,B,C,D,E,F,G,H,I,J,K,L,M],3,['case_17'(A,B,C,D,E,F,G,H,I,J,N,K,L,M)],[J>=N,J>=O,I=P+1,P>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0,M>=0]).
eq('case_15',[A,B,C,D,E,F,G,H,I,J],3,['case_16'(A,B,C,D,E,F,G,K,L,M,H,I,J)],[G>=K,G>=M,F=L+1,L>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0]).
eq('pack_aux',[A,B,C,D,E,F,G,H,I,J],1,['case_15'(A,B,C,D,E,F,G,H,I,J)],[A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0]).
eq('pack',[A,B,C,D,E],3,['pack_aux'(F,G,H,I,J,A,B,C,D,E)],[F=1,I=0,H=1,A>=0,B>=0,C>=0,D>=0,E>=0]).
eq('case_18',[A,B,C,D,E,F,G,H,I],2,[],[E=1,H=1,G=0,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0]).
eq('case_19',[A,B,C,D,E,F,G,H,I,J,K,L],5,['maxNorm'(M,B,J)],[H=1,N=1,O=A+N,P>=O,P>=G,M=1,L>=P,L>=D,K=C+1,C>=1,M>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0]).
eq('case_20',[A,B,C,D,E,F,G,H,I,J,K,L,M],4,['encode_aux'(N,B,C,D,H,I,K,L,M)],[G=J,O=1,N=A+O,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0,M>=0]).
eq('case_20',[A,B,C,D,E,F,G,H,I,J,K,L,M],7,['maxNorm'(N,B,O),'encode_aux'(P,O,Q,R,H,I,K,L,M)],[G>=J+1,P=0,S=1,T=A+S,U>=T,U>=G,N=1,R>=U,R>=D,Q=C+1,C>=1,N>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0,M>=0]).
eq('case_19',[A,B,C,D,E,F,G,H,I,J,K,L],3,['case_20'(A,B,C,D,E,F,G,H,I,M,J,K,L)],[I>=M,I>=N,H=O+1,O>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0]).
eq('case_18',[A,B,C,D,E,F,G,H,I],3,['case_19'(A,B,C,D,E,F,J,K,L,G,H,I)],[F>=J,F>=L,E=K+1,K>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0]).
eq('encode_aux',[A,B,C,D,E,F,G,H,I],1,['case_18'(A,B,C,D,E,F,G,H,I)],[A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0]).
eq('encode',[A,B,C,D,E],3,['encode_aux'(F,G,H,I,A,B,C,D,E)],[F=0,H=1,G=0,A>=0,B>=0,C>=0,D>=0,E>=0]).
eq('case_21',[A,B,C,D],2,[],[B=0,A=1,D=0,C=1,A>=0,B>=0,C>=0,D>=0]).
eq('case_21',[A,B,C,D],5,['duplicate'(E,F,G,H),'maxNorm'(I,H,J),'maxNorm'(I,J,D)],[B>=I,B>=F,A=E+1,E>=1,I>=1,K=G+1,G>=1,I>=1,C=K+1,K>=1,I>=1,A>=0,B>=0,C>=0,D>=0]).
eq('duplicate',[A,B,C,D],1,['case_21'(A,B,C,D)],[A>=0,B>=0,C>=0,D>=0]).
eq('case_22',[A,B,C,D,E,C,D],1,[],[B=A,A>=0,B>=0,C>=0,D>=0,E>=0,C>=0,D>=0]).
eq('case_22',[A,B,C,D,E,F,G],5,['maxNorm'(E,D,H),'prepend'(I,J,H,E,F,G)],[B>=A+1,K=1,I=B-K,J=C+1,C>=1,E>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0]).
eq('prepend',[A,B,C,D,E,F],2,['case_22'(G,A,B,C,D,E,F)],[G=0,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0]).
eq('case_23',[A,B,C,D,E,A,B],1,[],[D=0,C=1,A>=0,B>=0,C>=0,D>=0,E>=0,A>=0,B>=0]).
eq('case_23',[A,B,C,D,E,F,G],4,['prepend'(E,A,B,H,I,J),'replicate_aux'(I,J,K,L,E,F,G)],[D>=H,D>=L,C=K+1,K>=1,H>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0]).
eq('replicate_aux',[A,B,C,D,E,F,G],1,['case_23'(A,B,C,D,E,F,G)],[A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0]).
eq('replicate',[A,B,C,D,E],3,['rev'(F,G,A,B,H,I,J,K),'replicate_aux'(L,M,J,K,C,D,E)],[M=0,L=1,A>=0,B>=0,C>=0,D>=0,E>=0]).
eq('case_24',[A,B,C,D,E,F],2,[],[D=0,C=1,F=0,E=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0]).
eq('case_25',[A,B,C,D,E,F,G,H,I],3,['drop_aux'(A,J,F,G,H,I)],[B=A,J=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0]).
eq('case_25',[A,B,C,D,E,F,G,H,I],5,['drop_aux'(A,J,F,G,K,L),'maxNorm'(E,L,I)],[B>=A+1,M=1,J=B+M,H=K+1,K>=1,E>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0]).
eq('case_24',[A,B,C,D,E,F],3,['case_25'(A,B,C,D,G,H,I,E,F)],[D>=G,D>=I,C=H+1,H>=1,G>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0]).
eq('drop_aux',[A,B,C,D,E,F],1,['case_24'(A,B,C,D,E,F)],[A>=0,B>=0,C>=0,D>=0,E>=0,F>=0]).
eq('drop',[A,B,C,D,E],2,['drop_aux'(C,F,A,B,D,E)],[F=1,A>=0,B>=0,C>=0,D>=0,E>=0]).
eq('case_26',[A,B,C,D,E,F,G,H],4,['rev'(I,J,B,C,K,L,M,N),'maxNorm'(N,O,H),'maxNorm'(M,P,G)],[E=0,D=1,O=0,P=1,F=1,P>=1,M>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0]).
eq('case_27',[A,B,C,D,E,F,G,H,I,J,K,L],3,['rev'(M,N,C,D,O,P,Q,R),'maxNorm'(R,F,L),'maxNorm'(Q,E,K)],[B=A,J=1,E>=1,Q>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0]).
eq('case_27',[A,B,C,D,E,F,G,H,I,J,K,L],5,['maxNorm'(G,D,M),'split_aux'(N,O,M,H,I,J,K,L)],[B>=A+1,P=1,N=B-P,O=C+1,C>=1,G>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0]).
eq('case_26',[A,B,C,D,E,F,G,H],4,['case_27'(I,A,B,C,D,E,J,K,L,F,G,H)],[E>=J,E>=L,D=K+1,K>=1,J>=1,I=0,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0]).
eq('split_aux',[A,B,C,D,E,F,G,H],1,['case_26'(A,B,C,D,E,F,G,H)],[A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0]).
eq('split',[A,B,C,D,E,F],2,['split_aux'(C,G,H,A,B,D,E,F)],[H=0,G=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0]).
eq('case_28',[A,B,C,D,E],2,[],[C=0,B=1,E=0,D=1,A>=0,B>=0,C>=0,D>=0,E>=0]).
eq('case_29',[A,B,C,D,E,F,G,H,I],2,[],[B=A,I=0,H=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0]).
eq('case_29',[A,B,C,D,E,F,G,H,I],5,['take_slice'(J,F,G,K,L),'maxNorm'(E,L,I)],[B>=A+1,M=1,J=B-M,H=K+1,K>=1,E>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0]).
eq('case_28',[A,B,C,D,E],4,['case_29'(F,A,B,C,G,H,I,D,E)],[C>=G,C>=I,B=H+1,H>=1,G>=1,F=0,A>=0,B>=0,C>=0,D>=0,E>=0]).
eq('take_slice',[A,B,C,D,E],1,['case_28'(A,B,C,D,E)],[A>=0,B>=0,C>=0,D>=0,E>=0]).
eq('case_30',[A,B,C,D,E],2,[],[C=0,B=1,E=0,D=1,A>=0,B>=0,C>=0,D>=0,E>=0]).
eq('case_31',[A,B,C,D,E,F,G,C,D],1,[],[B=A,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,C>=0,D>=0]).
eq('case_31',[A,B,C,D,E,F,G,H,I],4,['drop_slice'(J,F,G,H,I)],[B>=A+1,K=1,J=B-K,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0]).
eq('case_30',[A,B,C,D,E],4,['case_31'(F,A,B,C,G,H,I,D,E)],[C>=G,C>=I,B=H+1,H>=1,G>=1,F=0,A>=0,B>=0,C>=0,D>=0,E>=0]).
eq('drop_slice',[A,B,C,D,E],1,['case_30'(A,B,C,D,E)],[A>=0,B>=0,C>=0,D>=0,E>=0]).
eq('slice',[A,B,C,D,E,F],7,['drop_slice'(G,A,B,H,I),'take_slice'(J,H,I,E,F)],[K=D-C,L=1,J=K+L,M=1,G=C-M,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0]).
eq('case_32',[A,B,C,D,E,F,G,H,E,F,G,H],1,[],[D=0,C=1,A=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,E>=0,F>=0,G>=0,H>=0]).
eq('case_32',[A,B,C,D,E,F,G,H,I,J,K,L],4,['concat'(M,N,O,P,E,F,G,H,Q,R,S,T),'maxNorm'(U,T,L)],[D>=U,D>=P,B>=V,B>=N,C=O+1,A=M+1,O>=1,M>=1,U>=1,J>=V,J>=R,K=S+1,I=Q+1,S>=1,Q>=1,U>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0]).
eq('concat',[A,B,C,D,E,F,G,H,I,J,K,L],1,['case_32'(A,B,C,D,E,F,G,H,I,J,K,L)],[A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0]).
eq('case_33',[A,B,C,D,E,F],2,[],[B=A,F=0,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0]).
eq('case_33',[A,B,C,D,E,F],4,[],[B>=A+1,G=H,I=G+B,F=J,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0]).
eq('case_34',[A,B,C,D,E,F,D,E],1,[],[B=A,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,D>=0,E>=0]).
eq('case_35',[A,B,C,D,E,F,G,H,I,J,K],2,['concat'(L,M,N,O,P,Q,R,S,T,U,J,K)],[C>=S,C>=O,B>=R,B>=N,A=1,N>=1,R>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0]).
eq('case_34',[A,B,C,D,E,F,G,H],5,['split'(D,E,F,I,J,K),'case_35'(L,M,N,A,B,C,D,E,F,O,P)],[B>=A+1,N=K,M=J,L=I,I>=1,H=P,G=O,O>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0]).
eq('rotate',[A,B,C,D,E],9,['lengthL'(F,G,A,B,H,I),'case_33'(J,K,A,B,C,L),'case_34'(M,N,K,A,B,C,O,P)],[K=I,J=0,N=L,M=0,Q=P,R=O,O>=1,E=Q,D=R,R>=1,A>=0,B>=0,C>=0,D>=0,E>=0]).
eq('case_36',[A,B,C,D,E],2,[],[C=0,B=1,E=0,D=1,A>=0,B>=0,C>=0,D>=0,E>=0]).
eq('case_37',[A,B,C,D,E,F,G,F,G],1,[],[B=A,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,F>=0,G>=0]).
eq('case_37',[A,B,C,D,E,F,G,H,I],5,['removeAt'(J,F,G,K,L),'maxNorm'(E,L,I)],[B>=A+1,M=1,J=B-M,H=K+1,K>=1,E>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0]).
eq('case_36',[A,B,C,D,E],4,['case_37'(F,A,B,C,G,H,I,D,E)],[C>=G,C>=I,B=H+1,H>=1,G>=1,F=1,A>=0,B>=0,C>=0,D>=0,E>=0]).
eq('removeAt',[A,B,C,D,E],1,['case_36'(A,B,C,D,E)],[A>=0,B>=0,C>=0,D>=0,E>=0]).
eq('case_38',[A,B,C,D,E,F],2,[],[D=0,C=1,F=0,E=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0]).
eq('case_39',[A,B,C,D,E,F,G,H,I,J],3,['maxNorm'(F,H,K),'maxNorm'(B,K,J)],[C=A,L=G+1,G>=1,F>=1,I=L+1,L>=1,B>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0]).
eq('case_39',[A,B,C,D,E,F,G,H,I,J],5,['insertAt'(B,K,G,H,L,M),'maxNorm'(F,M,J)],[C>=A+1,N=1,K=C-N,I=L+1,L>=1,F>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0]).
eq('case_38',[A,B,C,D,E,F],4,['case_39'(G,A,B,C,D,H,I,J,E,F)],[D>=H,D>=J,C=I+1,I>=1,H>=1,G=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0]).
eq('insertAt',[A,B,C,D,E,F],1,['case_38'(A,B,C,D,E,F)],[A>=0,B>=0,C>=0,D>=0,E>=0,F>=0]).
eq('case_40',[A,B,C,D],2,[],[A>=B+1,C=1,A>=0,B>=0,C>=0,D>=0]).
eq('case_40',[A,B,C,D],5,['minusminus_aux'(E,B,F,G)],[B>=A,H=1,E=A+H,D>=A,D>=G,C=F+1,F>=1,A>=0,B>=0,C>=0,D>=0]).
eq('minusminus_aux',[A,B,C,D],1,['case_40'(A,B,C,D)],[A>=0,B>=0,C>=0,D>=0]).
eq('case_41',[A,B,C,D],3,['minusminus_aux'(B,A,E,F),'rev'(E,F,G,H,C,D,I,J)],[A>=B+1,A>=0,B>=0,C>=0,D>=0]).
eq('case_41',[A,B,C,D],2,['minusminus_aux'(A,B,C,D)],[B>=A,A>=0,B>=0,C>=0,D>=0]).
eq('minusminus',[A,B,C,D],1,['case_41'(A,B,C,D)],[A>=0,B>=0,C>=0,D>=0]).
eq('randomL',[A,B],2,[],[C=1337,B=D,A>=0,B>=0]).
eq('case_42',[A,B,A],1,[],[B>=A+1,A>=0,B>=0,A>=0]).
eq('case_42',[A,B,B],1,[],[A>=B,A>=0,B>=0,B>=0]).
eq('minL',[A,B,C],1,['case_42'(A,B,C)],[A>=0,B>=0,C>=0]).
eq('case_43',[A,B,C,D,E,F,G,H],4,[],[D=1,I=0,J=1,H>=I,H>=K,G=J,F=1,J>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0]).
eq('case_44',[A,B,C,D,E,F,G,H,I,J,K,L],3,['concat'(B,C,M,N,H,I,O,P,Q,R,S,T)],[D=A,L>=G,L>=R,K=Q,J=1,Q>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0]).
eq('case_44',[A,B,C,D,E,F,G,H,I,J,K,L],5,['rand_select_extract'(M,N,O,H,I,J,K,L)],[D>=A+1,N>=G,N>=C,M=B+1,B>=1,P=1,O=D-P,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0]).
eq('case_43',[A,B,C,D,E,F,G,H],4,['case_44'(I,A,B,C,D,E,J,K,L,F,G,H)],[E>=J,E>=L,D=K+1,K>=1,I=0,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0]).
eq('rand_select_extract',[A,B,C,D,E,F,G,H],1,['case_43'(A,B,C,D,E,F,G,H)],[A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0]).
eq('rand_select_extract_rand',[A,B,C,D,E,F],3,['randomL'(C,G),'rand_select_extract'(H,I,G,A,B,D,E,F)],[H=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0]).
eq('case_45',[A,B,C,D,E,F,G,C,D],1,[],[B=A,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,C>=0,D>=0]).
eq('case_46',[A,B,C,D,E,F,G,H,I,J,K,L],7,['rand_select_aux'(M,N,O,P,Q,R,K,L)],[C>=S,C>=Q,B=P,A=1,P>=1,T=1,M=E-T,O>=S,O>=G,N=F+1,F>=1,U=1,R=J-U,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0]).
eq('case_45',[A,B,C,D,E,F,G,H,I],5,['rand_select_extract_rand'(E,F,G,J,K,L),'case_46'(M,N,O,A,B,C,D,E,F,G,P,Q)],[B>=A+1,O=L,N=K,M=J,J>=1,I=Q,H=P,P>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0]).
eq('rand_select_aux',[A,B,C,D,E,F,G,H],2,['case_45'(I,A,B,C,D,E,F,G,H)],[I=0,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0]).
eq('rand_select',[A,B,C,D,E],6,['lengthL'(A,B,F,G,H,I),'minL'(C,J,K),'rand_select_aux'(K,L,M,A,B,J,N,O)],[J=I,L=1,E=O,D=N,N>=1,A>=0,B>=0,C>=0,D>=0,E>=0]).
eq('lotto_select',[A,B,C,D],3,['minusminus'(E,B,F,G),'rand_select'(F,G,A,C,D)],[E=1,A>=0,B>=0,C>=0,D>=0]).

Preprocessing Cost Relations
=====================================

#### Computed strongly connected components 
0. recursive  : [at/5,case_5/5,case_6/9]
1. recursive  : [case_12/4,case_13/7,case_14/10,compress/4]
2. non_recursive  : [maxNorm/3]
3. recursive [non_tail] : [case_32/12,concat/12]
4. recursive [non_tail] : [case_24/6,case_25/9,drop_aux/6]
5. non_recursive  : [drop/5]
6. recursive [non_tail] : [case_21/4,duplicate/4]
7. recursive  : [case_18/9,case_19/12,case_20/13,encode_aux/9]
8. non_recursive  : [encode/5]
9. non_recursive  : [case_10/5]
10. non_recursive  : [and_op/3]
11. non_recursive  : [eq/3]
12. recursive [non_tail] : [case_11/8,case_9/5,eq_lists/5]
13. recursive [non_tail] : [case_38/6,case_39/10,insertAt/6]
14. recursive  : [aux_rev/12,case_8/12]
15. non_recursive  : [rev/8]
16. non_recursive  : [is_palindrome/3]
17. recursive  : [case_0/4,case_1/7,last/4]
18. recursive  : [case_2/5,case_3/8,case_4/11,last_two/5]
19. recursive  : [aux_length/8,case_7/8]
20. non_recursive  : [lengthL/6]
21. recursive  : [case_40/4,minusminus_aux/4]
22. non_recursive  : [case_41/4]
23. non_recursive  : [minusminus/4]
24. non_recursive  : [case_42/3]
25. non_recursive  : [minL/3]
26. recursive  : [case_43/8,case_44/12,rand_select_extract/8]
27. non_recursive  : [randomL/2]
28. non_recursive  : [rand_select_extract_rand/6]
29. recursive  : [case_45/9,case_46/12,rand_select_aux/8]
30. non_recursive  : [rand_select/5]
31. non_recursive  : [lotto_select/4]
32. recursive  : [case_15/10,case_16/13,case_17/14,pack_aux/10]
33. non_recursive  : [pack/5]
34. recursive [non_tail] : [case_36/5,case_37/9,removeAt/5]
35. recursive  : [case_22/7,prepend/6]
36. recursive  : [case_23/7,replicate_aux/7]
37. non_recursive  : [replicate/5]
38. non_recursive  : [case_33/6]
39. non_recursive  : [case_35/11]
40. recursive  : [case_26/8,case_27/12,split_aux/8]
41. non_recursive  : [split/6]
42. non_recursive  : [case_34/8]
43. non_recursive  : [rotate/5]
44. recursive  : [case_30/5,case_31/9,drop_slice/5]
45. recursive [non_tail] : [case_28/5,case_29/9,take_slice/5]
46. non_recursive  : [slice/6]
Warning: the following predicates are never called:[geq/3,gt/3,leq/3,lt/3,neg/2,neq/3,or/3]

#### Obtained direct recursion through partial evaluation 
0. SCC is partially evaluated into at/5
1. SCC is partially evaluated into compress/4
2. SCC is partially evaluated into maxNorm/3
3. SCC is partially evaluated into concat/12
4. SCC is partially evaluated into drop_aux/6
5. SCC is partially evaluated into drop/5
6. SCC is partially evaluated into duplicate/4
7. SCC is partially evaluated into encode_aux/9
8. SCC is partially evaluated into encode/5
9. SCC is partially evaluated into case_10/5
10. SCC is partially evaluated into and_op/3
11. SCC is partially evaluated into eq/3
12. SCC is partially evaluated into eq_lists/5
13. SCC is partially evaluated into insertAt/6
14. SCC is partially evaluated into aux_rev/12
15. SCC is partially evaluated into rev/8
16. SCC is partially evaluated into is_palindrome/3
17. SCC is partially evaluated into last/4
18. SCC is partially evaluated into last_two/5
19. SCC is partially evaluated into aux_length/8
20. SCC is partially evaluated into lengthL/6
21. SCC is partially evaluated into minusminus_aux/4
22. SCC is partially evaluated into case_41/4
23. SCC is partially evaluated into minusminus/4
24. SCC is partially evaluated into case_42/3
25. SCC is partially evaluated into minL/3
26. SCC is partially evaluated into rand_select_extract/8
27. SCC is partially evaluated into randomL/2
28. SCC is partially evaluated into rand_select_extract_rand/6
29. SCC is partially evaluated into rand_select_aux/8
30. SCC is partially evaluated into rand_select/5
31. SCC is partially evaluated into lotto_select/4
32. SCC is partially evaluated into pack_aux/10
33. SCC is partially evaluated into pack/5
34. SCC is partially evaluated into removeAt/5
35. SCC is partially evaluated into prepend/6
36. SCC is partially evaluated into replicate_aux/7
37. SCC is partially evaluated into replicate/5
38. SCC is partially evaluated into case_33/6
39. SCC is completely evaluated into other SCCs
40. SCC is partially evaluated into split_aux/8
41. SCC is partially evaluated into split/6
42. SCC is partially evaluated into case_34/8
43. SCC is partially evaluated into rotate/5
44. SCC is partially evaluated into drop_slice/5
45. SCC is partially evaluated into take_slice/5
46. SCC is partially evaluated into slice/6

Control-Flow Refinement of Cost Relations
=====================================

### Specialization of cost equations at/5 
* CE 10 is refined into CE [96] 
* CE 8 is refined into CE [97] 
* CE 9 is refined into CE [98] 


#### Refined cost equations at/5 
* CE 96: at(A,B,C,D,E) = 9+ at(F,G,H,D,E)
     [C>=H,H>=0,G>=1,F>=0,E>=0,D>=0,C>=1,G+1=B,F+1=A] 
* CE 97: at(A,B,C,D,E) = 3
     [A>=0,E=0,D=1,C=0,B=1] 
* CE 98: at(A,B,C,D,E) = 7
     [C>=E,E>=1,B>=2,D=1,A=0] 

### Cost equations --> "Loop" of at/5 
* CEs [97] --> Loop 96 
* CEs [98] --> Loop 97 
* CEs [96] --> Loop 98 

#### Loops of at/5 
* Loop 96: at(A,B,C,D,E) [A>=0,E=0,D=1,C=0,B=1] 
* Loop 97: at(A,B,C,D,E) [C>=E,E>=1,B>=2,D=1,A=0] 
* Loop 98: at(A,B,C,D,E)->  at(A',B',C',D,E)
                  [C>=C',C'>=0,B'>=1,A'>=0,E>=0,D>=0,C>=1,B'+1=B,A'+1=A] 

### Ranking functions of CR at(A,B,C,D,E) 
* RF of phase [98]: [A,B-1]

#### Partial ranking functions of CR at(A,B,C,D,E) 
* Partial RF of phase [98]:
  - RF of loop [98:1]:
    A
    B-1

Discarded unfeasible chain [[98]]...(Non-terminating chain proved terminating)

### Resulting Chains:at(A,B,C,D,E) 
* [[98],97]
* [[98],96]
* [97]
* [96]


### Merging Chains  at/5 into  External patterns of execution 
* [[97]] --> 1 
* [[96]] --> 2 
* [[96,[98]]] --> 3 
* [[97,[98]]] --> 4 


### Specialization of cost equations compress/4 
* CE 17 is refined into CE [99] 
* CE 20 is refined into CE [100] 
* CE 18 is refined into CE [101] 
* CE 19 is refined into CE [102] 


#### Refined cost equations compress/4 
* CE 99: compress(A,B,C,D) = 7
     [D>=0,B>=0,C=2,A=2] 
* CE 100: compress(A,B,C,D) = 3
     [D>=0,B>=0,C=1,A=1] 
* CE 101: compress(A,B,C,D) = 10+ compress(E,F,C,D)
     [F>=0,E>=2,D>=0,C>=0,B>=0,E+1=A] 
* CE 102: compress(A,B,C,D) = 11+ compress(E,F,G,H)
     [D>=H,G>=1,F>=0,E>=2,D>=1,B>=1,G+1=C,E+1=A] 

### Cost equations --> "Loop" of compress/4 
* CEs [101] --> Loop 99 
* CEs [102] --> Loop 100 
* CEs [99] --> Loop 101 
* CEs [100] --> Loop 102 

#### Loops of compress/4 
* Loop 99: compress(A,B,C,D)->  compress(A',B',C,D)
                  [B'>=0,D>=0,C>=0,B>=0,A>=3,A=A'+1] 
* Loop 100: compress(A,B,C,D)->  compress(A',B',C',D')
                  [D>=D',B'>=0,D>=1,C>=2,B>=1,A>=3,C=C'+1,A=A'+1] 
* Loop 101: compress(A,B,C,D) [D>=0,B>=0,C=2,A=2] 
* Loop 102: compress(A,B,C,D) [D>=0,B>=0,C=1,A=1] 

### Ranking functions of CR compress(A,B,C,D) 
* RF of phase [99,100]: [A-2]

#### Partial ranking functions of CR compress(A,B,C,D) 
* Partial RF of phase [99,100]:
  - RF of loop [99:1,100:1]:
    A-2

Discarded unfeasible chain [[99,100]]...(Non-terminating chain proved terminating)

### Resulting Chains:compress(A,B,C,D) 
* [[99,100],101]
* [102]
* [101]


### Merging Chains  compress/4 into  External patterns of execution 
* [[102]] --> 1 
* [[101]] --> 2 
* [[101,[99,100]]] --> 3 


### Specialization of cost equations maxNorm/3 
* CE 44 is refined into CE [103] 
* CE 43 is refined into CE [104] 


#### Refined cost equations maxNorm/3 
* CE 103: maxNorm(A,B,B) = 0
     [B>=A,A>=0] 
* CE 104: maxNorm(A,B,A) = 0
     [A>=B+1,B>=0] 

### Cost equations --> "Loop" of maxNorm/3 
* CEs [103] --> Loop 103 
* CEs [104] --> Loop 104 

#### Loops of maxNorm/3 
* Loop 103: maxNorm(A,B,B) [B>=A,A>=0] 
* Loop 104: maxNorm(A,B,A) [A>=B+1,B>=0] 

### Ranking functions of CR maxNorm(A,B,C) 

#### Partial ranking functions of CR maxNorm(A,B,C) 


### Resulting Chains:maxNorm(A,B,C) 
* [104]
* [103]


### Merging Chains  maxNorm/3 into  External patterns of execution 
* [[104]] --> 1 
* [[103]] --> 2 


### Specialization of cost equations concat/12 
* CE 30 is refined into CE [105] 
* CE 29 is refined into CE [106,107] 


#### Refined cost equations concat/12 
* CE 105: concat(A,B,C,D,E,F,G,H,E,F,G,H) = 2
     [H>=0,G>=0,F>=0,E>=0,B>=0,D=0,C=1,A=1] 
* CE 106: concat(A,B,C,D,E,F,G,H,I,J,K,L) = 5+ concat(M,N,O,P,E,F,G,H,Q,R,S,T)+ maxNorm(L,T,L):1
     [J>=R,D>=P,B>=N,D>=L,L>=T+1,S>=1,Q>=1,O>=1,M>=1,T>=0,J>=0,H>=0,G>=0,F>=0,E>=0,B>=0,S+1=K,Q+1=I,O+1=C,M+1=A] 
* CE 107: concat(A,B,C,D,E,F,G,H,I,J,K,L) = 5+ concat(M,N,O,P,E,F,G,H,Q,R,S,L)+ maxNorm(T,L,L):2
     [J>=R,D>=P,B>=N,L>=T,D>=T,S>=1,Q>=1,O>=1,M>=1,T>=1,J>=0,H>=0,G>=0,F>=0,E>=0,B>=0,S+1=K,Q+1=I,O+1=C,M+1=A] 

### Cost equations --> "Loop" of concat/12 
* CEs [106] --> Loop 105 
* CEs [107] --> Loop 106 
* CEs [105] --> Loop 107 

#### Loops of concat/12 
* Loop 105: concat(A,B,C,D,E,F,G,H,I,J,K,L)->  concat(A',B',C',D',E,F,G,H,E',F',G',H')
                  [L>=H'+1,J>=F',D>=D',B>=B',D>=L,H'>=0,K>=2,J>=0,I>=2,H>=0,G>=0,F>=0,E>=0,C>=2,B>=0,A>=2,K=G'+1,I=E'+1,C=C'+1,A=A'+1] 
* Loop 106: concat(A,B,C,D,E,F,G,H,I,J,K,L)->  concat(A',B',C',D',E,F,G,H,E',F',G',L)
                  [J>=F',D>=D',B>=B',L>=1,K>=2,J>=0,I>=2,H>=0,G>=0,F>=0,E>=0,D>=1,C>=2,B>=0,A>=2,K=G'+1,I=E'+1,C=C'+1,A=A'+1] 
* Loop 107: concat(A,B,C,D,E,F,G,H,E,F,G,H) [H>=0,G>=0,F>=0,E>=0,B>=0,D=0,C=1,A=1] 

### Ranking functions of CR concat(A,B,C,D,E,F,G,H,I,J,K,L) 
* RF of phase [105,106]: [A-1,C-1]

#### Partial ranking functions of CR concat(A,B,C,D,E,F,G,H,I,J,K,L) 
* Partial RF of phase [105,106]:
  - RF of loop [105:1,106:1]:
    A-1
    C-1

Discarded unfeasible chain [[105,106]]...(Non-terminating chain proved terminating)

### Resulting Chains:concat(A,B,C,D,E,F,G,H,I,J,K,L) 
* [[105,106],107]
* [107]


### Merging Chains  concat/12 into  External patterns of execution 
* [[107]] --> 1 
* [[107,[105,106]]] --> 2 


### Specialization of cost equations drop_aux/6 
* CE 68 is refined into CE [108,109] 
* CE 67 is refined into CE [110] 
* CE 66 is refined into CE [111] 


#### Refined cost equations drop_aux/6 
* CE 108: drop_aux(A,B,C,D,E,F) = 9+ drop_aux(A,G,H,I,J,K)+ maxNorm(F,K,F):1
     [D>=I,D>=F,F>=K+1,B>=A+1,J>=1,I>=0,H>=1,K>=0,A>=0,B+1=G,J+1=E,H+1=C] 
* CE 109: drop_aux(A,B,C,D,E,F) = 9+ drop_aux(A,G,H,I,J,F)+ maxNorm(K,F,F):2
     [D>=I,F>=K,D>=K,B>=A+1,J>=1,I>=0,H>=1,K>=1,A>=0,B+1=G,J+1=E,H+1=C] 
* CE 110: drop_aux(A,B,C,D,E,F) = 7+ drop_aux(G,H,I,J,E,F)
     [D>=J,J>=0,I>=1,F>=0,E>=0,D>=1,I+1=C,H=1,G=1,B=1,A=1] 
* CE 111: drop_aux(A,B,C,D,E,F) = 3
     [B>=1,A>=0,F=0,E=1,D=0,C=1] 

### Cost equations --> "Loop" of drop_aux/6 
* CEs [111] --> Loop 108 
* CEs [108] --> Loop 109 
* CEs [109] --> Loop 110 
* CEs [110] --> Loop 111 

#### Loops of drop_aux/6 
* Loop 108: drop_aux(A,B,C,D,E,F) [B>=1,A>=0,F=0,E=1,D=0,C=1] 
* Loop 109: drop_aux(A,B,C,D,E,F)->  drop_aux(A,A',B',C',D',E')
                  [F>=E'+1,D>=C',D>=F,B>=A+1,E'>=0,C'>=0,E>=2,C>=2,A>=0,E=D'+1,C=B'+1,B+1=A'] 
* Loop 110: drop_aux(A,B,C,D,E,F)->  drop_aux(A,A',B',C',D',F)
                  [D>=C',B>=A+1,C'>=0,F>=1,E>=2,D>=1,C>=2,A>=0,E=D'+1,C=B'+1,B+1=A'] 
* Loop 111: drop_aux(A,B,C,D,E,F)->  drop_aux(A',B',C',D',E,F)
                  [D>=D',D'>=0,F>=0,E>=0,D>=1,C>=2,C=C'+1,B'=1,A'=1,B=1,A=1] 

### Ranking functions of CR drop_aux(A,B,C,D,E,F) 
* RF of phase [109,110]: [C-1]
* RF of phase [111]: [C-1]

#### Partial ranking functions of CR drop_aux(A,B,C,D,E,F) 
* Partial RF of phase [109,110]:
  - RF of loop [109:1,110:1]:
    C-1
* Partial RF of phase [111]:
  - RF of loop [111:1]:
    C-1

Discarded unfeasible chain [[111]]...(Non-terminating chain proved terminating)
Discarded unfeasible chain [[109,110]](Non-terminating chain proved terminating)

### Resulting Chains:drop_aux(A,B,C,D,E,F) 
* [[111],108]
* [[109,110],108]
* [108]


### Merging Chains  drop_aux/6 into  External patterns of execution 
* [[108,[111]]] --> 1 
* [[108]] --> 2 
* [[108,[109,110]]] --> 3 


### Specialization of cost equations drop/5 
* CE 26 is refined into CE [112,113,114] 


#### Refined cost equations drop/5 
* CE 112: drop(A,B,C,D,E) = 2+ drop_aux(F,G,A,B,H,I):1
     [B>=1,A>=2,I=0,H=1,G=1,F=1,E=0,D=1,C=1] 
* CE 113: drop(A,B,C,D,E) = 2+ drop_aux(C,F,G,H,I,J):2
     [C>=0,J=0,I=1,H=0,G=1,F=1,E=0,D=1,B=0,A=1] 
* CE 114: drop(A,B,C,A,D) = 2+ drop_aux(E,F,A,B,A,D):3
     [B>=D,D>=1,A>=2,F=1,E=0,C=0] 

### Cost equations --> "Loop" of drop/5 
* CEs [112] --> Loop 112 
* CEs [114] --> Loop 113 
* CEs [113] --> Loop 114 

#### Loops of drop/5 
* Loop 112: drop(A,B,C,D,E) [B>=1,A>=2,E=0,D=1,C=1] 
* Loop 113: drop(A,B,C,A,D) [B>=D,D>=1,A>=2,C=0] 
* Loop 114: drop(A,B,C,D,E) [C>=0,E=0,D=1,B=0,A=1] 

### Ranking functions of CR drop(A,B,C,D,E) 

#### Partial ranking functions of CR drop(A,B,C,D,E) 


### Resulting Chains:drop(A,B,C,D,E) 
* [114]
* [113]
* [112]


### Merging Chains  drop/5 into  External patterns of execution 
* [[114]] --> 1 
* [[113]] --> 2 
* [[112]] --> 3 


### Specialization of cost equations duplicate/4 
* CE 24 is refined into CE [115] 
* CE 23 is refined into CE [116,117] 


#### Refined cost equations duplicate/4 
* CE 115: duplicate(A,B,C,D) = 3
     [D=0,C=1,B=0,A=1] 
* CE 116: duplicate(A,B,C,D) = 6+ duplicate(E,F,G,H)+ maxNorm(D,H,D):1+ maxNorm(D,D,D):2
     [B>=F,B>=D,D>=H+1,E>=1,H>=0,C>=3,C=G+2,E+1=A] 
* CE 117: duplicate(A,B,C,D) = 6+ duplicate(E,F,G,D)+ maxNorm(H,D,D):2+ maxNorm(H,D,D):2
     [B>=F,D>=H,B>=H,E>=1,H>=1,C>=3,C=G+2,E+1=A] 

### Cost equations --> "Loop" of duplicate/4 
* CEs [116] --> Loop 115 
* CEs [117] --> Loop 116 
* CEs [115] --> Loop 117 

#### Loops of duplicate/4 
* Loop 115: duplicate(A,B,C,D)->  duplicate(A',B',C',D')
                  [D>=D'+1,B>=B',B>=D,D'>=0,C>=3,A>=2,C=C'+2,A=A'+1] 
* Loop 116: duplicate(A,B,C,D)->  duplicate(A',B',C',D)
                  [B>=B',D>=1,C>=3,B>=1,A>=2,C=C'+2,A=A'+1] 
* Loop 117: duplicate(A,B,C,D) [D=0,C=1,B=0,A=1] 

### Ranking functions of CR duplicate(A,B,C,D) 
* RF of phase [115,116]: [A-1]

#### Partial ranking functions of CR duplicate(A,B,C,D) 
* Partial RF of phase [115,116]:
  - RF of loop [115:1,116:1]:
    A-1

Discarded unfeasible chain [[115,116]]...(Non-terminating chain proved terminating)

### Resulting Chains:duplicate(A,B,C,D) 
* [[115,116],117]
* [117]


### Merging Chains  duplicate/4 into  External patterns of execution 
* [[117]] --> 1 
* [[117,[115,116]]] --> 2 


### Specialization of cost equations encode_aux/9 
* CE 60 is refined into CE [118,119] 
* CE 63 is refined into CE [120] 
* CE 61 is refined into CE [121] 
* CE 62 is refined into CE [122,123] 


#### Refined cost equations encode_aux/9 
* CE 118: encode_aux(A,B,C,D,E,F,G,H,I) = 9+ maxNorm(J,K,L):1
     [I>=D,I>=A+1,H>=2,F>=0,D>=0,A>=0,H=C+1,L=1,K=0,J=1,G=1,E=2,B=0] 
* CE 119: encode_aux(A,B,C,D,E,F,B,G,H) = 9+ maxNorm(I,B,B):2
     [H>=D,H>=A+1,B>=1,G>=2,F>=0,D>=0,A>=0,G=C+1,I=1,E=2] 
* CE 120: encode_aux(A,B,C,D,E,F,G,H,I) = 3
     [I>=0,F>=0,D>=0,H=1,G=0,E=1,C=1,B=0,A=0] 
* CE 121: encode_aux(A,B,C,D,E,F,G,H,I) = 11+ encode_aux(J,B,C,D,K,L,G,H,I)
     [F>=L,L>=0,K>=2,I>=0,H>=0,G>=0,D>=0,C>=1,B>=0,A>=0,A+1=J,K+1=E] 
* CE 122: encode_aux(A,B,C,D,E,F,G,H,I) = 14+ maxNorm(J,K,L):1+ encode_aux(M,N,O,P,Q,R,G,H,I)
     [F>=R,P>=D,P>=A+1,R>=0,Q>=2,I>=0,H>=0,G>=0,F>=1,D>=0,C>=1,A>=0,C+1=O,Q+1=E,N=1,M=0,L=1,K=0,J=1,B=0] 
* CE 123: encode_aux(A,B,C,D,E,F,G,H,I) = 14+ maxNorm(J,B,B):2+ encode_aux(K,B,L,M,N,O,G,H,I)
     [F>=O,M>=D,M>=A+1,O>=0,N>=2,B>=1,I>=0,H>=0,G>=0,F>=1,D>=0,C>=1,A>=0,C+1=L,N+1=E,K=0,J=1] 

### Cost equations --> "Loop" of encode_aux/9 
* CEs [121] --> Loop 118 
* CEs [123] --> Loop 119 
* CEs [122] --> Loop 120 
* CEs [119] --> Loop 121 
* CEs [118] --> Loop 122 
* CEs [120] --> Loop 123 

#### Loops of encode_aux/9 
* Loop 118: encode_aux(A,B,C,D,E,F,G,H,I)->  encode_aux(A',B,C,D,B',C',G,H,I)
                  [F>=C',C'>=0,I>=0,H>=0,G>=0,E>=3,D>=0,C>=1,B>=0,A>=0,E=B'+1,A+1=A'] 
* Loop 119: encode_aux(A,B,C,D,E,F,G,H,I)->  encode_aux(A',B,B',C',D',E',G,H,I)
                  [F>=E',C'>=D,C'>=A+1,E'>=0,I>=0,H>=0,G>=0,F>=1,E>=3,D>=0,C>=1,B>=1,A>=0,E=D'+1,C+1=B',A'=0] 
* Loop 120: encode_aux(A,B,C,D,E,F,G,H,I)->  encode_aux(A',B',C',D',E',F',G,H,I)
                  [F>=F',D'>=D,D'>=A+1,F'>=0,I>=0,H>=0,G>=0,F>=1,E>=3,D>=0,C>=1,A>=0,E=E'+1,C+1=C',B'=1,A'=0,B=0] 
* Loop 121: encode_aux(A,B,C,D,E,F,B,G,H) [H>=D,H>=A+1,F>=0,D>=0,C>=1,B>=1,A>=0,C+1=G,E=2] 
* Loop 122: encode_aux(A,B,C,D,E,F,G,H,I) [I>=D,I>=A+1,F>=0,D>=0,C>=1,A>=0,C+1=H,G=1,E=2,B=0] 
* Loop 123: encode_aux(A,B,C,D,E,F,G,H,I) [I>=0,F>=0,D>=0,H=1,G=0,E=1,C=1,B=0,A=0] 

### Ranking functions of CR encode_aux(A,B,C,D,E,F,G,H,I) 
* RF of phase [118,119,120]: [E-2]

#### Partial ranking functions of CR encode_aux(A,B,C,D,E,F,G,H,I) 
* Partial RF of phase [118,119,120]:
  - RF of loop [118:1,119:1,120:1]:
    E-2
  - RF of loop [120:1]:
    -B+1

Discarded unfeasible chain [[118,119,120]]...(Non-terminating chain proved terminating)

### Resulting Chains:encode_aux(A,B,C,D,E,F,G,H,I) 
* [[118,119,120],122]
* [[118,119,120],121]
* [123]
* [122]


### Merging Chains  encode_aux/9 into  External patterns of execution 
* [[123]] --> 1 
* [[122]] --> 2 
* [[122,[118,119,120]]] --> 3 
* [[121,[118,119,120]]] --> 4 


### Specialization of cost equations encode/5 
* CE 22 is refined into CE [124,125,126,127] 


#### Refined cost equations encode/5 
* CE 124: encode(A,B,C,D,E) = 3+ encode_aux(F,G,H,I,J,B,K,L,E):1
     [E>=0,B>=0,I>=0,L=1,K=0,J=1,H=1,G=0,F=0,D=1,C=0,A=1] 
* CE 125: encode(A,B,C,D,E) = 3+ encode_aux(F,G,H,I,J,B,K,L,E):2
     [E>=I,E>=1,B>=0,I>=0,L=2,K=1,J=2,H=1,G=0,F=0,D=2,C=1,A=2] 
* CE 126: encode(A,B,C,D,E) = 3+ encode_aux(F,G,H,I,A,B,J,K,E):3
     [E+1>=A,E>=I,B>=0,A>=3,I>=0,K=2,J=1,H=1,G=0,F=0,D=2,C=1] 
* CE 127: encode(A,B,C,D,E) = 3+ encode_aux(F,G,H,I,A,B,C,D,E):4
     [A>=D,D>=C+2,E>=I,E>=1,C>=1,B>=1,I>=0,H=1,G=0,F=0] 

### Cost equations --> "Loop" of encode/5 
* CEs [127] --> Loop 124 
* CEs [126] --> Loop 125 
* CEs [125] --> Loop 126 
* CEs [124] --> Loop 127 

#### Loops of encode/5 
* Loop 124: encode(A,B,C,D,E) [A>=D,D>=C+2,E>=1,C>=1,B>=1] 
* Loop 125: encode(A,B,C,D,E) [E+1>=A,B>=0,A>=3,D=2,C=1] 
* Loop 126: encode(A,B,C,D,E) [E>=1,B>=0,D=2,C=1,A=2] 
* Loop 127: encode(A,B,C,D,E) [E>=0,B>=0,D=1,C=0,A=1] 

### Ranking functions of CR encode(A,B,C,D,E) 

#### Partial ranking functions of CR encode(A,B,C,D,E) 


### Resulting Chains:encode(A,B,C,D,E) 
* [127]
* [126]
* [125]
* [124]


### Merging Chains  encode/5 into  External patterns of execution 
* [[127]] --> 1 
* [[126]] --> 2 
* [[125]] --> 3 
* [[124]] --> 4 


### Specialization of cost equations case_10/5 
* CE 55 is refined into CE [128] 
* CE 54 is refined into CE [129] 


#### Refined cost equations case_10/5 
* CE 128: case_10(A,B,C,D,E) = 3
     [D>=0,C>=2,B>=0,E=0,A=1] 
* CE 129: case_10(A,B,C,D,E) = 2
     [D>=0,B>=0,E=1,C=1,A=1] 

### Cost equations --> "Loop" of case_10/5 
* CEs [128] --> Loop 128 
* CEs [129] --> Loop 129 

#### Loops of case_10/5 
* Loop 128: case_10(A,B,C,D,E) [D>=0,C>=2,B>=0,E=0,A=1] 
* Loop 129: case_10(A,B,C,D,E) [D>=0,B>=0,E=1,C=1,A=1] 

### Ranking functions of CR case_10(A,B,C,D,E) 

#### Partial ranking functions of CR case_10(A,B,C,D,E) 


### Resulting Chains:case_10(A,B,C,D,E) 
* [129]
* [128]


### Merging Chains  case_10/5 into  External patterns of execution 
* [[129]] --> 1 
* [[128]] --> 2 


### Specialization of cost equations and_op/3 
* CE 53 is refined into CE [130] 
* CE 52 is refined into CE [131] 


#### Refined cost equations and_op/3 
* CE 130: and_op(A,B,B) = 0
     [B>=0,A=1] 
* CE 131: and_op(A,B,C) = 0
     [B>=0,C=0,A=0] 

### Cost equations --> "Loop" of and_op/3 
* CEs [130] --> Loop 130 
* CEs [131] --> Loop 131 

#### Loops of and_op/3 
* Loop 130: and_op(A,B,B) [B>=0,A=1] 
* Loop 131: and_op(A,B,C) [B>=0,C=0,A=0] 

### Ranking functions of CR and_op(A,B,C) 

#### Partial ranking functions of CR and_op(A,B,C) 


### Resulting Chains:and_op(A,B,C) 
* [131]
* [130]


### Merging Chains  and_op/3 into  External patterns of execution 
* [[131]] --> 1 
* [[130]] --> 2 


### Specialization of cost equations eq/3 
* CE 49 is refined into CE [132] 
* CE 50 is refined into CE [133] 
* CE 51 is refined into CE [134] 


#### Refined cost equations eq/3 
* CE 132: eq(A,A,B) = 0
     [A>=0,B=1] 
* CE 133: eq(A,B,C) = 0
     [A>=B+1,B>=0,C=0] 
* CE 134: eq(A,B,C) = 0
     [B>=A+1,A>=0,C=0] 

### Cost equations --> "Loop" of eq/3 
* CEs [132] --> Loop 132 
* CEs [133] --> Loop 133 
* CEs [134] --> Loop 134 

#### Loops of eq/3 
* Loop 132: eq(A,A,B) [A>=0,B=1] 
* Loop 133: eq(A,B,C) [A>=B+1,B>=0,C=0] 
* Loop 134: eq(A,B,C) [B>=A+1,A>=0,C=0] 

### Ranking functions of CR eq(A,B,C) 

#### Partial ranking functions of CR eq(A,B,C) 


### Resulting Chains:eq(A,B,C) 
* [134]
* [133]
* [132]


### Merging Chains  eq/3 into  External patterns of execution 
* [[134]] --> 1 
* [[133]] --> 2 
* [[132]] --> 3 


### Specialization of cost equations eq_lists/5 
* CE 14 is refined into CE [135] 
* CE 15 is refined into CE [136,137] 
* CE 13 is refined into CE [138,139,140] 


#### Refined cost equations eq_lists/5 
* CE 135: eq_lists(A,B,C,D,E) = 6
     [D>=0,B>=0,A>=2,E=0,C=1] 
* CE 136: eq_lists(A,B,C,D,E) = 3+ case_10(F,B,G,D,H):1
     [D>=0,B>=0,H=1,G=1,F=1,E=1,C=1,A=1] 
* CE 137: eq_lists(A,B,C,D,E) = 3+ case_10(F,B,C,D,G):2
     [D>=0,C>=2,B>=0,G=0,F=1,E=0,A=1] 
* CE 138: eq_lists(A,B,C,D,E) = 9+ eq(F,G,H):1+ eq_lists(I,J,K,L,M)+ and_op(N,M,O):1
     [D>=L,B>=J,D>=G,G>=F+1,B>=F,K>=1,J>=0,I>=1,M>=0,F>=0,K+1=C,I+1=A,O=0,N=0,H=0,E=0] 
* CE 139: eq_lists(A,B,C,D,E) = 9+ eq(F,G,H):2+ eq_lists(I,J,K,L,M)+ and_op(N,M,O):1
     [D>=L,B>=J,F>=G+1,D>=G,B>=F,K>=1,J>=0,I>=1,M>=0,G>=0,K+1=C,I+1=A,O=0,N=0,H=0,E=0] 
* CE 140: eq_lists(A,B,C,D,E) = 9+ eq(F,F,G):3+ eq_lists(H,I,J,K,E)+ and_op(L,E,E):2
     [D>=K,B>=I,D>=F,B>=F,J>=1,I>=0,H>=1,E>=0,F>=0,J+1=C,H+1=A,L=1,G=1] 

### Cost equations --> "Loop" of eq_lists/5 
* CEs [140] --> Loop 135 
* CEs [138] --> Loop 136 
* CEs [139] --> Loop 137 
* CEs [135] --> Loop 138 
* CEs [137] --> Loop 139 
* CEs [136] --> Loop 140 

#### Loops of eq_lists/5 
* Loop 135: eq_lists(A,B,C,D,E)->  eq_lists(A',B',C',D',E)
                  [D>=D',B>=B',B'>=0,E>=0,D>=0,C>=2,A>=2,C=C'+1,A=A'+1] 
* Loop 136: eq_lists(A,B,C,D,E)->  eq_lists(A',B',C',D',E')
                  [D>=D',B>=B',E'>=0,B'>=0,D>=1,C>=2,A>=2,C=C'+1,A=A'+1,E=0] 
* Loop 137: eq_lists(A,B,C,D,E)->  eq_lists(A',B',C',D',E')
                  [D>=D',B>=B',E'>=0,B'>=0,D>=0,C>=2,B>=1,A>=2,C=C'+1,A=A'+1,E=0] 
* Loop 138: eq_lists(A,B,C,D,E) [D>=0,B>=0,A>=2,E=0,C=1] 
* Loop 139: eq_lists(A,B,C,D,E) [D>=0,C>=2,B>=0,E=0,A=1] 
* Loop 140: eq_lists(A,B,C,D,E) [D>=0,B>=0,E=1,C=1,A=1] 

### Ranking functions of CR eq_lists(A,B,C,D,E) 
* RF of phase [135,136,137]: [A-1,C-1]

#### Partial ranking functions of CR eq_lists(A,B,C,D,E) 
* Partial RF of phase [135,136,137]:
  - RF of loop [135:1,136:1,137:1]:
    A-1
    C-1

Discarded unfeasible chain [[135,136,137]]...(Non-terminating chain proved terminating)

### Resulting Chains:eq_lists(A,B,C,D,E) 
* [[135,136,137],140]
* [[135,136,137],139]
* [[135,136,137],138]
* [140]
* [139]
* [138]


### Merging Chains  eq_lists/5 into  External patterns of execution 
* [[140]] --> 1 
* [[139]] --> 2 
* [[138]] --> 3 
* [[139,[135,136,137]]] --> 4 
* [[138,[135,136,137]]] --> 5 
* [[140,[135,136,137]]] --> 6 


### Specialization of cost equations insertAt/6 
* CE 37 is refined into CE [141,142] 
* CE 35 is refined into CE [143] 
* CE 36 is refined into CE [144,145,146,147] 


#### Refined cost equations insertAt/6 
* CE 141: insertAt(A,B,C,D,E,F) = 10+ insertAt(A,G,H,I,J,K)+ maxNorm(F,K,F):1
     [D>=I,D>=F,F>=K+1,J>=1,I>=0,H>=1,K>=0,B>=2,A>=0,B=G+1,J+1=E,H+1=C] 
* CE 142: insertAt(A,B,C,D,E,F) = 10+ insertAt(A,G,H,I,J,F)+ maxNorm(K,F,F):2
     [D>=I,F>=K,D>=K,J>=1,I>=0,H>=1,K>=1,B>=2,A>=0,B=G+1,J+1=E,H+1=C] 
* CE 143: insertAt(A,B,C,D,E,F) = 3
     [B>=0,A>=0,F=0,E=1,D=0,C=1] 
* CE 144: insertAt(A,B,C,D,E,A) = 8+ maxNorm(F,G,F):1+ maxNorm(A,F,A):1
     [A>=F+1,D>=F,F>=G+1,G>=0,E>=3,E=C+1,B=1] 
* CE 145: insertAt(A,B,C,D,E,F) = 8+ maxNorm(F,G,F):1+ maxNorm(A,F,F):2
     [D>=F,F>=A,F>=G+1,A>=1,G>=0,E>=3,E=C+1,B=1] 
* CE 146: insertAt(A,B,C,D,E,A) = 8+ maxNorm(F,G,G):2+ maxNorm(A,G,A):1
     [A>=G+1,D>=G,G>=F,F>=1,E>=3,E=C+1,B=1] 
* CE 147: insertAt(A,B,C,D,E,F) = 8+ maxNorm(G,F,F):2+ maxNorm(A,F,F):2
     [D>=F,F>=A,F>=G,A>=1,G>=1,E>=3,E=C+1,B=1] 

### Cost equations --> "Loop" of insertAt/6 
* CEs [143] --> Loop 141 
* CEs [145,147] --> Loop 142 
* CEs [144,146] --> Loop 143 
* CEs [141] --> Loop 144 
* CEs [142] --> Loop 145 

#### Loops of insertAt/6 
* Loop 141: insertAt(A,B,C,D,E,F) [B>=0,A>=0,F=0,E=1,D=0,C=1] 
* Loop 142: insertAt(A,B,C,D,E,F) [D>=F,F>=A,C>=2,A>=1,C+1=E,B=1] 
* Loop 143: insertAt(A,B,C,D,E,A) [D>=1,C>=2,A>=2,C+1=E,B=1] 
* Loop 144: insertAt(A,B,C,D,E,F)->  insertAt(A,A',B',C',D',E')
                  [F>=E'+1,D>=C',D>=F,E'>=0,C'>=0,E>=2,C>=2,B>=2,A>=0,E=D'+1,C=B'+1,B=A'+1] 
* Loop 145: insertAt(A,B,C,D,E,F)->  insertAt(A,A',B',C',D',F)
                  [D>=C',C'>=0,F>=1,E>=2,D>=1,C>=2,B>=2,A>=0,E=D'+1,C=B'+1,B=A'+1] 

### Ranking functions of CR insertAt(A,B,C,D,E,F) 
* RF of phase [144,145]: [B-1,C-1]

#### Partial ranking functions of CR insertAt(A,B,C,D,E,F) 
* Partial RF of phase [144,145]:
  - RF of loop [144:1,145:1]:
    B-1
    C-1

Discarded unfeasible chain [[144,145]]...(Non-terminating chain proved terminating)

### Resulting Chains:insertAt(A,B,C,D,E,F) 
* [[144,145],143]
* [[144,145],142]
* [[144,145],141]
* [143]
* [142]
* [141]


### Merging Chains  insertAt/6 into  External patterns of execution 
* [[143]] --> 1 
* [[142]] --> 2 
* [[141]] --> 3 
* [[142,[144,145]]] --> 4 
* [[143,[144,145]]] --> 5 
* [[141,[144,145]]] --> 6 


### Specialization of cost equations aux_rev/12 
* CE 48 is refined into CE [148] 
* CE 47 is refined into CE [149,150] 


#### Refined cost equations aux_rev/12 
* CE 148: aux_rev(A,B,A,C,D,E,F,G,A,B,A,C) = 2
     [E>=0,C>=0,A>=1,B>=0,G=0,F=1,D=1] 
* CE 149: aux_rev(A,B,A,C,D,E,F,G,H,I,J,K) = 5+ maxNorm(L,C,L):1+ aux_rev(M,N,O,L,P,Q,R,S,H,I,J,K)
     [G>=S,E>=Q,G>=L,L>=C+1,N>=B,R>=1,P>=1,C>=0,K>=0,J>=0,I>=0,H>=0,E>=0,A>=1,B>=0,A+1=O,A+1=M,R+1=F,P+1=D] 
* CE 150: aux_rev(A,B,A,C,D,E,F,G,H,I,J,K) = 5+ maxNorm(L,C,C):2+ aux_rev(M,N,O,C,P,Q,R,S,H,I,J,K)
     [G>=S,E>=Q,C>=L,G>=L,N>=B,R>=1,P>=1,L>=1,K>=0,J>=0,I>=0,H>=0,E>=0,A>=1,B>=0,A+1=O,A+1=M,R+1=F,P+1=D] 

### Cost equations --> "Loop" of aux_rev/12 
* CEs [149] --> Loop 146 
* CEs [150] --> Loop 147 
* CEs [148] --> Loop 148 

#### Loops of aux_rev/12 
* Loop 146: aux_rev(A,B,A,C,D,E,F,G,H,I,J,K)->  aux_rev(A',B',C',D',E',F',G',H',H,I,J,K)
                  [G>=H',E>=F',G>=D',D'>=C+1,B'>=B,K>=0,J>=0,I>=0,H>=0,F>=2,E>=0,D>=2,C>=0,B>=0,A>=1,F=G'+1,D=E'+1,A+1=C',A+1=A'] 
* Loop 147: aux_rev(A,B,A,C,D,E,F,G,H,I,J,K)->  aux_rev(A',B',C',C,D',E',F',G',H,I,J,K)
                  [G>=G',E>=E',B'>=B,K>=0,J>=0,I>=0,H>=0,G>=1,F>=2,E>=0,D>=2,C>=1,B>=0,A>=1,F=F'+1,D=D'+1,A+1=C',A+1=A'] 
* Loop 148: aux_rev(A,B,A,C,D,E,F,G,A,B,A,C) [E>=0,C>=0,B>=0,A>=1,G=0,F=1,D=1] 

### Ranking functions of CR aux_rev(A,B,C,D,E,F,G,H,I,J,K,L) 
* RF of phase [146,147]: [E-1,G-1]

#### Partial ranking functions of CR aux_rev(A,B,C,D,E,F,G,H,I,J,K,L) 
* Partial RF of phase [146,147]:
  - RF of loop [146:1]:
    -D+H
  - RF of loop [146:1,147:1]:
    E-1
    G-1

Discarded unfeasible chain [[146,147]]...(Non-terminating chain proved terminating)

### Resulting Chains:aux_rev(A,B,C,D,E,F,G,H,I,J,K,L) 
* [[146,147],148]
* [148]


### Merging Chains  aux_rev/12 into  External patterns of execution 
* [[148]] --> 1 
* [[148,[146,147]]] --> 2 


### Specialization of cost equations rev/8 
* CE 12 is refined into CE [151,152] 


#### Refined cost equations rev/8 
* CE 151: rev(A,B,C,D,E,F,G,H) = 2+ aux_rev(I,F,J,K,L,B,M,N,O,F,P,Q):1
     [F>=0,B>=0,Q=0,P=1,O=1,N=0,M=1,L=1,K=0,J=1,I=1,H=0,G=1,E=1,D=0,C=1,A=1] 
* CE 152: rev(A,B,A,C,A,D,A,E) = 2+ aux_rev(F,G,H,I,A,B,A,C,A,D,A,E):2
     [D>=G,E>=1,C>=1,A>=2,B>=0,G>=0,I=0,H=1,F=1] 

### Cost equations --> "Loop" of rev/8 
* CEs [152] --> Loop 149 
* CEs [151] --> Loop 150 

#### Loops of rev/8 
* Loop 149: rev(A,B,A,C,A,D,A,E) [E>=1,D>=0,C>=1,B>=0,A>=2] 
* Loop 150: rev(A,B,C,D,E,F,G,H) [F>=0,B>=0,H=0,G=1,E=1,D=0,C=1,A=1] 

### Ranking functions of CR rev(A,B,C,D,E,F,G,H) 

#### Partial ranking functions of CR rev(A,B,C,D,E,F,G,H) 


### Resulting Chains:rev(A,B,C,D,E,F,G,H) 
* [150]
* [149]


### Merging Chains  rev/8 into  External patterns of execution 
* [[150]] --> 1 
* [[149]] --> 2 


### Specialization of cost equations is_palindrome/3 
* CE 16 is refined into CE [153,154] 


#### Refined cost equations is_palindrome/3 
* CE 153: is_palindrome(A,B,C) = 2+ rev(D,B,E,F,G,H,I,J):1+ eq_lists(K,B,L,H,M):1
     [H>=0,B>=0,M=1,L=1,K=1,J=0,I=1,G=1,F=0,E=1,D=1,C=1,A=1] 
* CE 154: is_palindrome(A,B,C) = 2+ rev(A,B,A,D,A,E,A,F):2+ eq_lists(A,B,A,E,C):6
     [B+C+E>=1,C>=0,E>=0,A>=2,B>=0,F>=1,D>=1,1>=C] 

### Cost equations --> "Loop" of is_palindrome/3 
* CEs [154] --> Loop 151 
* CEs [153] --> Loop 152 

#### Loops of is_palindrome/3 
* Loop 151: is_palindrome(A,B,C) [C>=0,B>=0,A>=2,1>=C] 
* Loop 152: is_palindrome(A,B,C) [B>=0,C=1,A=1] 

### Ranking functions of CR is_palindrome(A,B,C) 

#### Partial ranking functions of CR is_palindrome(A,B,C) 


### Resulting Chains:is_palindrome(A,B,C) 
* [152]
* [151]


### Merging Chains  is_palindrome/3 into  External patterns of execution 
* [[152]] --> 1 
* [[151]] --> 2 


### Specialization of cost equations last/4 
* CE 3 is refined into CE [155] 
* CE 2 is refined into CE [156] 
* CE 1 is refined into CE [157] 


#### Refined cost equations last/4 
* CE 155: last(A,B,C,D) = 7+ last(E,F,C,D)
     [B>=F,F>=1,D>=0,C>=0,A>=3,A=E+1] 
* CE 156: last(A,B,C,D) = 6
     [B>=D,D>=1,C=1,A=2] 
* CE 157: last(A,B,C,D) = 3
     [D=0,C=1,B=0,A=1] 

### Cost equations --> "Loop" of last/4 
* CEs [156] --> Loop 153 
* CEs [157] --> Loop 154 
* CEs [155] --> Loop 155 

#### Loops of last/4 
* Loop 153: last(A,B,C,D) [B>=D,D>=1,C=1,A=2] 
* Loop 154: last(A,B,C,D) [D=0,C=1,B=0,A=1] 
* Loop 155: last(A,B,C,D)->  last(A',B',C,D)
                  [B>=B',B'>=1,D>=0,C>=0,A>=3,A=A'+1] 

### Ranking functions of CR last(A,B,C,D) 
* RF of phase [155]: [A-2]

#### Partial ranking functions of CR last(A,B,C,D) 
* Partial RF of phase [155]:
  - RF of loop [155:1]:
    A-2

Discarded unfeasible chain [[155]]...(Non-terminating chain proved terminating)

### Resulting Chains:last(A,B,C,D) 
* [[155],153]
* [154]
* [153]


### Merging Chains  last/4 into  External patterns of execution 
* [[154]] --> 1 
* [[153]] --> 2 
* [[153,[155]]] --> 3 


### Specialization of cost equations last_two/5 
* CE 5 is refined into CE [158,159] 
* CE 4 is refined into CE [160] 
* CE 7 is refined into CE [161] 
* CE 6 is refined into CE [162] 


#### Refined cost equations last_two/5 
* CE 158: last_two(A,B,C,D,E) = 10+ maxNorm(E,F,E):1
     [B>=E,E>=F+1,F>=1,D=1,C=1,A=3] 
* CE 159: last_two(A,B,C,D,E) = 10+ maxNorm(F,E,E):2
     [B>=E,E>=F,F>=1,D=1,C=1,A=3] 
* CE 160: last_two(A,B,C,D,E) = 6
     [B>=1,E=0,D=1,C=0,A=2] 
* CE 161: last_two(A,B,C,D,E) = 3
     [E=0,D=1,C=0,B=0,A=1] 
* CE 162: last_two(A,B,C,D,E) = 10+ last_two(F,G,C,D,E)
     [B>=G,G>=1,F>=3,E>=0,D>=0,C>=0,F+1=A] 

### Cost equations --> "Loop" of last_two/5 
* CEs [162] --> Loop 156 
* CEs [158,159] --> Loop 157 
* CEs [160] --> Loop 158 
* CEs [161] --> Loop 159 

#### Loops of last_two/5 
* Loop 156: last_two(A,B,C,D,E)->  last_two(A',B',C,D,E)
                  [B>=B',B'>=1,A'>=3,E>=0,D>=0,C>=0,A'+1=A] 
* Loop 157: last_two(A,B,C,D,E) [B>=E,E>=1,D=1,C=1,A=3] 
* Loop 158: last_two(A,B,C,D,E) [B>=1,E=0,D=1,C=0,A=2] 
* Loop 159: last_two(A,B,C,D,E) [E=0,D=1,C=0,B=0,A=1] 

### Ranking functions of CR last_two(A,B,C,D,E) 
* RF of phase [156]: [A-3]

#### Partial ranking functions of CR last_two(A,B,C,D,E) 
* Partial RF of phase [156]:
  - RF of loop [156:1]:
    A-3

Discarded unfeasible chain [[156]]...(Non-terminating chain proved terminating)

### Resulting Chains:last_two(A,B,C,D,E) 
* [[156],157]
* [159]
* [158]
* [157]


### Merging Chains  last_two/5 into  External patterns of execution 
* [[159]] --> 1 
* [[158]] --> 2 
* [[157]] --> 3 
* [[157,[156]]] --> 4 


### Specialization of cost equations aux_length/8 
* CE 46 is refined into CE [163] 
* CE 45 is refined into CE [164] 


#### Refined cost equations aux_length/8 
* CE 163: aux_length(A,B,C,D,E,E,E,E) = 2
     [E>=0,B>=0,D=0,C=1,A=1] 
* CE 164: aux_length(A,B,C,D,E,E,F,G) = 6+ aux_length(H,I,J,K,L,M,F,G)
     [D>=K,B>=I,J>=1,H>=1,G>=0,F>=0,E>=0,D>=1,B>=0,E+1=M,E+1=L,J+1=C,H+1=A] 

### Cost equations --> "Loop" of aux_length/8 
* CEs [164] --> Loop 160 
* CEs [163] --> Loop 161 

#### Loops of aux_length/8 
* Loop 160: aux_length(A,B,C,D,E,E,F,G)->  aux_length(A',B',C',D',E',F',F,G)
                  [D>=D',B>=B',C'>=1,A'>=1,G>=0,F>=0,E>=0,D>=1,B>=0,E+1=F',E+1=E',C'+1=C,A'+1=A] 
* Loop 161: aux_length(A,B,C,D,E,E,E,E) [E>=0,B>=0,D=0,C=1,A=1] 

### Ranking functions of CR aux_length(A,B,C,D,E,F,G,H) 
* RF of phase [160]: [A-1,C-1]

#### Partial ranking functions of CR aux_length(A,B,C,D,E,F,G,H) 
* Partial RF of phase [160]:
  - RF of loop [160:1]:
    A-1
    C-1

Discarded unfeasible chain [[160]]...(Non-terminating chain proved terminating)

### Resulting Chains:aux_length(A,B,C,D,E,F,G,H) 
* [[160],161]
* [161]


### Merging Chains  aux_length/8 into  External patterns of execution 
* [[161]] --> 1 
* [[161,[160]]] --> 2 


### Specialization of cost equations lengthL/6 
* CE 11 is refined into CE [165,166] 


#### Refined cost equations lengthL/6 
* CE 165: lengthL(A,B,C,D,E,F) = 2+ aux_length(G,B,H,I,J,K,L,M):1
     [B>=0,M=0,L=0,K=0,J=0,I=0,H=1,G=1,F=0,E=0,D=0,C=1,A=1] 
* CE 166: lengthL(A,B,A,C,D,E) = 2+ aux_length(A,B,A,C,F,G,H,I):2
     [C>=1,A>=2,B>=0,A=I+1,A=H+1,A=E+1,A=D+1,G=0,F=0] 

### Cost equations --> "Loop" of lengthL/6 
* CEs [166] --> Loop 162 
* CEs [165] --> Loop 163 

#### Loops of lengthL/6 
* Loop 162: lengthL(A,B,A,C,D,E) [C>=1,B>=0,A>=2,A=E+1,A=D+1] 
* Loop 163: lengthL(A,B,C,D,E,F) [B>=0,F=0,E=0,D=0,C=1,A=1] 

### Ranking functions of CR lengthL(A,B,C,D,E,F) 

#### Partial ranking functions of CR lengthL(A,B,C,D,E,F) 


### Resulting Chains:lengthL(A,B,C,D,E,F) 
* [163]
* [162]


### Merging Chains  lengthL/6 into  External patterns of execution 
* [[163]] --> 1 
* [[162]] --> 2 


### Specialization of cost equations minusminus_aux/4 
* CE 91 is refined into CE [167] 
* CE 90 is refined into CE [168] 


#### Refined cost equations minusminus_aux/4 
* CE 167: minusminus_aux(A,B,C,D) = 3
     [D>=0,A>=1,A=B+1,C=1] 
* CE 168: minusminus_aux(A,B,C,D) = 6+ minusminus_aux(E,B,F,G)
     [D>=G,D>=A,B>=A,F>=1,A>=0,A+1=E,F+1=C] 

### Cost equations --> "Loop" of minusminus_aux/4 
* CEs [168] --> Loop 164 
* CEs [167] --> Loop 165 

#### Loops of minusminus_aux/4 
* Loop 164: minusminus_aux(A,B,C,D)->  minusminus_aux(A',B,B',C')
                  [D>=C',D>=A,B>=A,B'>=1,A>=0,A+1=A',B'+1=C] 
* Loop 165: minusminus_aux(A,B,C,D) [D>=0,A>=1,A=B+1,C=1] 

### Ranking functions of CR minusminus_aux(A,B,C,D) 
* RF of phase [164]: [-A+B+1]

#### Partial ranking functions of CR minusminus_aux(A,B,C,D) 
* Partial RF of phase [164]:
  - RF of loop [164:1]:
    -A+B+1

Discarded unfeasible chain [[164]]...(Non-terminating chain proved terminating)

### Resulting Chains:minusminus_aux(A,B,C,D) 
* [[164],165]


### Merging Chains  minusminus_aux/4 into  External patterns of execution 
* [[165,[164]]] --> 1 


### Specialization of cost equations case_41/4 
* CE 82 is refined into CE [169] 
* CE 83 is refined into CE [170] 


#### Refined cost equations case_41/4 
* CE 169: case_41(A,B,C,D) = 3+ minusminus_aux(B,E,C,F):1+ rev(C,F,C,G,C,D,C,H):2
     [F+2>=B+C,H>=1,D>=0,G>=1,C>=3,B>=0,B+C=E+2,B+C=A+2] 
* CE 170: case_41(A,B,C,D) = 2+ minusminus_aux(A,E,C,D):1
     [D+2>=A+C,C>=2,A>=0,A+C=E+2,A+C=B+2] 

### Cost equations --> "Loop" of case_41/4 
* CEs [169] --> Loop 166 
* CEs [170] --> Loop 167 

#### Loops of case_41/4 
* Loop 166: case_41(A,B,C,D) [A>=B+1,D>=0,B>=0,A+2=B+C] 
* Loop 167: case_41(A,B,C,D) [D>=B,B>=A,A>=0,A+C=B+2] 

### Ranking functions of CR case_41(A,B,C,D) 

#### Partial ranking functions of CR case_41(A,B,C,D) 


### Resulting Chains:case_41(A,B,C,D) 
* [167]
* [166]


### Merging Chains  case_41/4 into  External patterns of execution 
* [[166]] --> 1 
* [[167]] --> 2 


### Specialization of cost equations minusminus/4 
* CE 38 is refined into CE [171,172] 


#### Refined cost equations minusminus/4 
* CE 171: minusminus(A,B,C,D) = 1+ case_41(E,B,C,D):1
     [D>=0,C>=3,B>=0,B+C=E+2,B+C=A+2] 
* CE 172: minusminus(A,B,C,D) = 1+ case_41(A,B,E,D):2
     [D>=B,B>=A,A>=0,B+2=A+E,B+2=A+C] 

### Cost equations --> "Loop" of minusminus/4 
* CEs [171] --> Loop 168 
* CEs [172] --> Loop 169 

#### Loops of minusminus/4 
* Loop 168: minusminus(A,B,C,D) [A>=B+1,D>=0,B>=0,A+2=B+C] 
* Loop 169: minusminus(A,B,C,D) [D>=B,B>=A,A>=0,A+C=B+2] 

### Ranking functions of CR minusminus(A,B,C,D) 

#### Partial ranking functions of CR minusminus(A,B,C,D) 


### Resulting Chains:minusminus(A,B,C,D) 
* [169]
* [168]


### Merging Chains  minusminus/4 into  External patterns of execution 
* [[169]] --> 1 
* [[168]] --> 2 


### Specialization of cost equations case_42/3 
* CE 85 is refined into CE [173] 
* CE 84 is refined into CE [174] 


#### Refined cost equations case_42/3 
* CE 173: case_42(A,B,B) = 1
     [A>=B,B>=0] 
* CE 174: case_42(A,B,A) = 1
     [B>=A+1,A>=0] 

### Cost equations --> "Loop" of case_42/3 
* CEs [173] --> Loop 170 
* CEs [174] --> Loop 171 

#### Loops of case_42/3 
* Loop 170: case_42(A,B,B) [A>=B,B>=0] 
* Loop 171: case_42(A,B,A) [B>=A+1,A>=0] 

### Ranking functions of CR case_42(A,B,C) 

#### Partial ranking functions of CR case_42(A,B,C) 


### Resulting Chains:case_42(A,B,C) 
* [171]
* [170]


### Merging Chains  case_42/3 into  External patterns of execution 
* [[171]] --> 1 
* [[170]] --> 2 


### Specialization of cost equations minL/3 
* CE 40 is refined into CE [175,176] 


#### Refined cost equations minL/3 
* CE 175: minL(A,B,A) = 1+ case_42(A,B,A):1
     [B>=A+1,A>=0] 
* CE 176: minL(A,B,B) = 1+ case_42(A,B,B):2
     [A>=B,B>=0] 

### Cost equations --> "Loop" of minL/3 
* CEs [176] --> Loop 172 
* CEs [175] --> Loop 173 

#### Loops of minL/3 
* Loop 172: minL(A,B,B) [A>=B,B>=0] 
* Loop 173: minL(A,B,A) [B>=A+1,A>=0] 

### Ranking functions of CR minL(A,B,C) 

#### Partial ranking functions of CR minL(A,B,C) 


### Resulting Chains:minL(A,B,C) 
* [173]
* [172]


### Merging Chains  minL/3 into  External patterns of execution 
* [[173]] --> 1 
* [[172]] --> 2 


### Specialization of cost equations rand_select_extract/8 
* CE 95 is refined into CE [177] 
* CE 93 is refined into CE [178] 
* CE 94 is refined into CE [179,180] 


#### Refined cost equations rand_select_extract/8 
* CE 177: rand_select_extract(A,B,C,D,E,F,G,H) = 10+ rand_select_extract(I,J,K,L,M,N,G,H)
     [E>=M,J>=B,M>=0,L>=1,K>=0,H>=0,G>=1,B>=0,A>=1,A+1=I,L+1=D,K+1=C,N=1,F=1] 
* CE 178: rand_select_extract(A,B,C,D,E,F,G,H) = 5
     [H>=0,E>=0,C>=0,B>=0,A>=1,G=1,F=1,D=1] 
* CE 179: rand_select_extract(A,B,C,D,E,F,G,H) = 8+ concat(I,B,J,K,G,L,M,N,G,L,M,N):1
     [H>=L,E>=L,N>=0,M>=0,L>=0,G>=1,B>=0,G+1=D,K=0,J=1,I=1,F=1,C=0,A=1] 
* CE 180: rand_select_extract(A,B,C,D,E,F,G,H) = 8+ concat(A,B,A,I,J,K,L,M,G,N,O,P):2
     [I+M>=P,H>=N,P>=M,N>=K,E>=K,O>=A,G>=A,P>=1,M>=0,K>=0,I>=1,A>=2,B>=0,A+L=O+1,A+J=G+1,A+D=G+2,F=1,C=0] 

### Cost equations --> "Loop" of rand_select_extract/8 
* CEs [178] --> Loop 174 
* CEs [180] --> Loop 175 
* CEs [179] --> Loop 176 
* CEs [177] --> Loop 177 

#### Loops of rand_select_extract/8 
* Loop 174: rand_select_extract(A,B,C,D,E,F,G,H) [H>=0,E>=0,C>=0,B>=0,A>=1,G=1,F=1,D=1] 
* Loop 175: rand_select_extract(A,B,C,D,E,F,G,H) [H>=0,E>=0,D>=2,B>=0,A>=2,A+D=G+2,F=1,C=0] 
* Loop 176: rand_select_extract(A,B,C,D,E,F,G,H) [H>=0,E>=0,D>=2,B>=0,D=G+1,F=1,C=0,A=1] 
* Loop 177: rand_select_extract(A,B,C,D,E,F,G,H)->  rand_select_extract(A',B',C',D',E',F',G,H)
                  [E>=E',B'>=B,E'>=0,D'>=1,C'>=0,H>=0,G>=1,B>=0,A>=1,A+1=A',D'+1=D,C'+1=C,F'=1,F=1] 

### Ranking functions of CR rand_select_extract(A,B,C,D,E,F,G,H) 
* RF of phase [177]: [C,D-1]

#### Partial ranking functions of CR rand_select_extract(A,B,C,D,E,F,G,H) 
* Partial RF of phase [177]:
  - RF of loop [177:1]:
    C
    D-1

Discarded unfeasible chain [[177]]...(Non-terminating chain proved terminating)

### Resulting Chains:rand_select_extract(A,B,C,D,E,F,G,H) 
* [[177],175]
* [[177],174]
* [176]
* [174]


### Merging Chains  rand_select_extract/8 into  External patterns of execution 
* [[176]] --> 1 
* [[174]] --> 2 
* [[174,[177]]] --> 3 
* [[175,[177]]] --> 4 


### Specialization of cost equations randomL/2 
* CE 39 is refined into CE [181] 


#### Refined cost equations randomL/2 
* CE 181: randomL(A,B) = 2
     [B>=0,A>=0] 

### Cost equations --> "Loop" of randomL/2 
* CEs [181] --> Loop 178 

#### Loops of randomL/2 
* Loop 178: randomL(A,B) [B>=0,A>=0] 

### Ranking functions of CR randomL(A,B) 

#### Partial ranking functions of CR randomL(A,B) 


### Resulting Chains:randomL(A,B) 
* [178]


### Merging Chains  randomL/2 into  External patterns of execution 
* [[178]] --> 1 


### Specialization of cost equations rand_select_extract_rand/6 
* CE 92 is refined into CE [182,183,184,185] 


#### Refined cost equations rand_select_extract_rand/6 
* CE 182: rand_select_extract_rand(A,B,C,D,E,F) = 3+ randomL(C,G):1+ rand_select_extract(H,I,J,K,B,L,E,F):1
     [F>=0,E>=1,B>=0,I>=0,C>=0,E+1=K,E+1=A,L=1,J=0,H=1,G=0,D=1] 
* CE 183: rand_select_extract_rand(A,B,C,D,E,F) = 3+ randomL(C,G):1+ rand_select_extract(H,I,G,J,B,K,L,F):2
     [F>=0,B>=0,G>=0,I>=0,C>=0,L=1,K=1,J=1,H=1,E=1,D=1,A=1] 
* CE 184: rand_select_extract_rand(A,B,C,D,E,F) = 3+ randomL(C,G):1+ rand_select_extract(H,I,G,A,B,J,K,F):3
     [G+1>=A,F>=0,B>=0,A>=2,I>=0,C>=0,K=1,J=1,H=1,E=1,D=1] 
* CE 185: rand_select_extract_rand(A,B,C,D,E,F) = 3+ randomL(C,G):1+ rand_select_extract(H,I,G,J,B,K,E,F):4
     [E>=G+1,F>=0,B>=0,G>=1,I>=0,C>=0,E+1=J,E+1=A,K=1,H=1,D=1] 

### Cost equations --> "Loop" of rand_select_extract_rand/6 
* CEs [182,185] --> Loop 179 
* CEs [184] --> Loop 180 
* CEs [183] --> Loop 181 

#### Loops of rand_select_extract_rand/6 
* Loop 179: rand_select_extract_rand(A,B,C,D,E,F) [F>=0,C>=0,B>=0,A>=2,A=E+1,D=1] 
* Loop 180: rand_select_extract_rand(A,B,C,D,E,F) [F>=0,C>=0,B>=0,A>=2,E=1,D=1] 
* Loop 181: rand_select_extract_rand(A,B,C,D,E,F) [F>=0,C>=0,B>=0,E=1,D=1,A=1] 

### Ranking functions of CR rand_select_extract_rand(A,B,C,D,E,F) 

#### Partial ranking functions of CR rand_select_extract_rand(A,B,C,D,E,F) 


### Resulting Chains:rand_select_extract_rand(A,B,C,D,E,F) 
* [181]
* [180]
* [179]


### Merging Chains  rand_select_extract_rand/6 into  External patterns of execution 
* [[181]] --> 1 
* [[180]] --> 2 
* [[179]] --> 3 


### Specialization of cost equations rand_select_aux/8 
* CE 87 is refined into CE [186,187,188] 
* CE 86 is refined into CE [189] 


#### Refined cost equations rand_select_aux/8 
* CE 186: rand_select_aux(A,B,C,D,E,F,G,H) = 14+ rand_select_extract_rand(I,E,F,J,K,L):1+ rand_select_aux(M,N,O,P,Q,R,G,H)
     [L>=Q,O>=C,M>=0,L>=0,F>=0,E>=0,H>=0,G>=1,C>=0,B>=1,F=R+1,B+1=N,M+1=A,P=1,K=1,J=1,I=1,D=1] 
* CE 187: rand_select_aux(A,B,C,D,E,F,G,H) = 14+ rand_select_extract_rand(D,E,F,I,J,K):2+ rand_select_aux(L,M,N,O,P,Q,G,H)
     [K>=P,N>=C,L>=0,K>=0,F>=0,E>=0,D>=2,H>=0,G>=1,C>=0,B>=1,F=Q+1,B+1=M,L+1=A,O=1,J=1,I=1] 
* CE 188: rand_select_aux(A,B,C,D,E,F,G,H) = 14+ rand_select_extract_rand(I,E,F,J,K,L):3+ rand_select_aux(M,N,O,K,P,Q,G,H)
     [L>=P,O>=C,M>=0,L>=0,K>=1,F>=0,E>=0,H>=0,G>=1,C>=0,B>=1,F=Q+1,B+1=N,K+1=I,K+1=D,M+1=A,J=1] 
* CE 189: rand_select_aux(A,B,C,D,E,F,B,C) = 3
     [F>=0,E>=0,D>=0,C>=0,B>=1,A=0] 

### Cost equations --> "Loop" of rand_select_aux/8 
* CEs [189] --> Loop 182 
* CEs [188] --> Loop 183 
* CEs [187] --> Loop 184 
* CEs [186] --> Loop 185 

#### Loops of rand_select_aux/8 
* Loop 182: rand_select_aux(A,B,C,D,E,F,B,C) [F>=0,E>=0,D>=0,C>=0,B>=1,A=0] 
* Loop 183: rand_select_aux(A,B,C,D,E,F,G,H)->  rand_select_aux(A',B',C',D',E',F',G,H)
                  [C'>=C,H>=0,G>=1,F>=0,E>=0,D>=2,C>=0,B>=1,A>=1,F=F'+1,D=D'+1,B+1=B',A=A'+1] 
* Loop 184: rand_select_aux(A,B,C,D,E,F,G,H)->  rand_select_aux(A',B',C',D',E',F',G,H)
                  [C'>=C,H>=0,G>=1,F>=0,E>=0,D>=2,C>=0,B>=1,A>=1,F=F'+1,B+1=B',A=A'+1,D'=1] 
* Loop 185: rand_select_aux(A,B,C,D,E,F,G,H)->  rand_select_aux(A',B',C',D',E',F',G,H)
                  [C'>=C,H>=0,G>=1,F>=0,E>=0,C>=0,B>=1,A>=1,F=F'+1,B+1=B',A=A'+1,D'=1,D=1] 

### Ranking functions of CR rand_select_aux(A,B,C,D,E,F,G,H) 
* RF of phase [183]: [A,D-1,F+1]
* RF of phase [185]: [A,F+1]

#### Partial ranking functions of CR rand_select_aux(A,B,C,D,E,F,G,H) 
* Partial RF of phase [183]:
  - RF of loop [183:1]:
    A
    D-1
    F+1
* Partial RF of phase [185]:
  - RF of loop [185:1]:
    A
    F+1

Discarded unfeasible chain [[185]]...(Non-terminating chain proved terminating)
Discarded unfeasible chain [[183]](Non-terminating chain proved terminating)
Discarded unfeasible chain [[183],[185]](Non-terminating chain proved terminating)
Discarded unfeasible chain [[183],184,[185]](Non-terminating chain proved terminating)
Discarded unfeasible chain [184,[185]](Non-terminating chain proved terminating)

### Resulting Chains:rand_select_aux(A,B,C,D,E,F,G,H) 
* [[185],182]
* [[183],[185],182]
* [[183],184,[185],182]
* [[183],184,182]
* [[183],182]
* [184,[185],182]
* [184,182]
* [182]


### Merging Chains  rand_select_aux/8 into  External patterns of execution 
* [[182]] --> 1 
* [[182,184],[182,[183]],[182,184,[183]]] --> 2 
* [[182,[185]]] --> 3 
* [[182,[185],184],[182,[185],184,[183]],[182,[185],[183]]] --> 4 


### Specialization of cost equations rand_select/5 
* CE 41 is refined into CE [190,191,192,193,194,195] 


#### Refined cost equations rand_select/5 
* CE 190: rand_select(A,B,C,D,E) = 6+ lengthL(F,B,G,H,I,J):1+ minL(C,K,L):2+ rand_select_aux(M,N,E,O,B,P,Q,E):1
     [E>=0,B>=0,C>=0,Q=1,P=0,O=1,N=1,M=0,L=0,K=0,J=0,I=0,H=0,G=1,F=1,D=1,A=1] 
* CE 191: rand_select(A,B,C,D,E) = 6+ lengthL(A,B,A,F,G,H):2+ minL(I,J,K):1+ rand_select_aux(L,M,E,A,B,N,O,E):1
     [E>=0,B>=0,A>=2,F>=1,A=N+1,A=J+1,A=H+1,A=G+1,O=1,M=1,L=0,K=0,I=0,D=1,C=0] 
* CE 192: rand_select(A,B,C,D,E) = 6+ lengthL(A,B,A,F,G,H):2+ minL(I,J,K):1+ rand_select_aux(L,M,N,A,B,O,D,E):2
     [A>=D+1,E>=N,D>=2,B>=0,N>=0,F>=1,A=O+1,D=L+1,D=K+1,A=J+1,D=I+1,A=H+1,A=G+1,D=C+1,M=1] 
* CE 193: rand_select(A,B,C,D,E) = 6+ lengthL(A,B,A,F,G,H):2+ minL(I,J,K):1+ rand_select_aux(L,M,N,A,B,O,D,E):4
     [A>=D+1,E>=N,D>=3,B>=0,N>=0,F>=1,A=O+1,D=L+1,D=K+1,A=J+1,D=I+1,A=H+1,A=G+1,D=C+1,M=1] 
* CE 194: rand_select(A,B,C,A,D) = 6+ lengthL(A,B,A,E,F,G):2+ minL(C,H,I):2+ rand_select_aux(J,K,L,A,B,M,A,D):2
     [C+1>=A,D>=L,A>=2,B>=0,L>=0,E>=1,A=M+1,A=J+1,A=I+1,A=H+1,A=G+1,A=F+1,K=1] 
* CE 195: rand_select(A,B,C,A,D) = 6+ lengthL(A,B,A,E,F,G):2+ minL(C,H,I):2+ rand_select_aux(J,K,L,A,B,M,A,D):4
     [C+1>=A,D>=L,A>=3,B>=0,L>=0,E>=1,A=M+1,A=J+1,A=I+1,A=H+1,A=G+1,A=F+1,K=1] 

### Cost equations --> "Loop" of rand_select/5 
* CEs [194,195] --> Loop 186 
* CEs [192,193] --> Loop 187 
* CEs [191] --> Loop 188 
* CEs [190] --> Loop 189 

#### Loops of rand_select/5 
* Loop 186: rand_select(A,B,C,A,D) [C+1>=A,D>=0,B>=0,A>=2] 
* Loop 187: rand_select(A,B,C,D,E) [A>=C+2,E>=0,C>=1,B>=0,C+1=D] 
* Loop 188: rand_select(A,B,C,D,E) [E>=0,B>=0,A>=2,D=1,C=0] 
* Loop 189: rand_select(A,B,C,D,E) [E>=0,C>=0,B>=0,D=1,A=1] 

### Ranking functions of CR rand_select(A,B,C,D,E) 

#### Partial ranking functions of CR rand_select(A,B,C,D,E) 


### Resulting Chains:rand_select(A,B,C,D,E) 
* [189]
* [188]
* [187]
* [186]


### Merging Chains  rand_select/5 into  External patterns of execution 
* [[189]] --> 1 
* [[188]] --> 2 
* [[186]] --> 3 
* [[187]] --> 4 


### Specialization of cost equations lotto_select/4 
* CE 42 is refined into CE [196,197,198,199,200,201] 


#### Refined cost equations lotto_select/4 
* CE 196: lotto_select(A,B,C,D) = 3+ minusminus(E,F,G,H):1+ rand_select(G,H,I,J,D):2
     [H+1>=G,D>=0,G>=2,G=F+1,G=B+1,J=1,I=0,E=1,C=1,A=0] 
* CE 197: lotto_select(A,B,C,D) = 3+ minusminus(E,F,C,G):1+ rand_select(C,G,A,C,D):3
     [A+1>=C,G+1>=C,D>=0,C>=2,C=F+1,C=B+1,E=1] 
* CE 198: lotto_select(A,B,C,D) = 3+ minusminus(E,F,G,H):1+ rand_select(G,H,I,C,D):4
     [G>=C+1,H+1>=G,D>=0,C>=2,C=I+1,G=F+1,G=B+1,C=A+1,E=1] 
* CE 199: lotto_select(A,B,C,D) = 3+ minusminus(E,F,G,H):2+ rand_select(I,H,J,K,D):2
     [D>=0,H>=0,K=1,J=0,I=3,G=3,F=0,E=1,C=1,B=0,A=0] 
* CE 200: lotto_select(A,B,C,D) = 3+ minusminus(E,F,G,H):2+ rand_select(I,H,A,J,D):3
     [D>=0,A>=2,H>=0,J=3,I=3,G=3,F=0,E=1,C=3,B=0] 
* CE 201: lotto_select(A,B,C,D) = 3+ minusminus(E,F,G,H):2+ rand_select(I,H,J,K,D):4
     [D>=0,H>=0,K=2,J=1,I=3,G=3,F=0,E=1,C=2,B=0,A=1] 

### Cost equations --> "Loop" of lotto_select/4 
* CEs [198] --> Loop 190 
* CEs [197] --> Loop 191 
* CEs [200] --> Loop 192 
* CEs [201] --> Loop 193 
* CEs [196] --> Loop 194 
* CEs [199] --> Loop 195 

#### Loops of lotto_select/4 
* Loop 190: lotto_select(A,B,C,D) [B>=A+1,D>=0,A>=1,A+1=C] 
* Loop 191: lotto_select(A,B,C,D) [A>=B,D>=0,B>=1,B+1=C] 
* Loop 192: lotto_select(A,B,C,D) [D>=0,A>=2,C=3,B=0] 
* Loop 193: lotto_select(A,B,C,D) [D>=0,C=2,B=0,A=1] 
* Loop 194: lotto_select(A,B,C,D) [D>=0,B>=1,C=1,A=0] 
* Loop 195: lotto_select(A,B,C,D) [D>=0,C=1,B=0,A=0] 

### Ranking functions of CR lotto_select(A,B,C,D) 

#### Partial ranking functions of CR lotto_select(A,B,C,D) 


### Resulting Chains:lotto_select(A,B,C,D) 
* [195]
* [194]
* [193]
* [192]
* [191]
* [190]


### Merging Chains  lotto_select/4 into  External patterns of execution 
* [[195]] --> 1 
* [[194]] --> 2 
* [[193]] --> 3 
* [[192]] --> 4 
* [[190]] --> 5 
* [[191]] --> 6 


### Specialization of cost equations pack_aux/10 
* CE 56 is refined into CE [202,203] 
* CE 59 is refined into CE [204] 
* CE 57 is refined into CE [205] 
* CE 58 is refined into CE [206,207] 


#### Refined cost equations pack_aux/10 
* CE 202: pack_aux(A,B,C,D,E,F,G,H,I,J) = 7+ maxNorm(I,D,I):1
     [I>=D+1,J>=E,J>=B,I>=2,D>=0,H>=2,G>=0,E>=0,B>=0,H=C+1,I=A+1,F=2] 
* CE 203: pack_aux(A,B,C,D,E,F,G,H,D,I) = 7+ maxNorm(J,D,D):2
     [D>=J,I>=E,I>=B,J>=2,H>=2,G>=0,E>=0,B>=0,H=C+1,J=A+1,F=2] 
* CE 204: pack_aux(A,B,C,D,E,F,G,H,I,J) = 3
     [J>=0,G>=0,E>=0,B>=0,I=0,H=1,F=1,D=0,C=1,A=1] 
* CE 205: pack_aux(A,B,C,D,E,F,G,H,I,J) = 10+ pack_aux(K,L,C,D,E,M,N,H,I,J)
     [G>=N,L>=B,N>=0,M>=2,J>=0,I>=0,H>=0,E>=0,D>=0,C>=1,B>=0,A>=1,A+1=K,M+1=F] 
* CE 206: pack_aux(A,B,C,D,E,F,G,H,I,J) = 12+ maxNorm(K,D,K):1+ pack_aux(L,M,N,K,O,P,Q,H,I,J)
     [G>=Q,K>=D+1,O>=E,O>=B,Q>=0,P>=2,O>=1,K>=2,D>=0,J>=0,I>=0,H>=0,G>=1,E>=0,C>=1,B>=0,C+1=N,P+1=F,K=A+1,L=1] 
* CE 207: pack_aux(A,B,C,D,E,F,G,H,I,J) = 12+ maxNorm(K,D,D):2+ pack_aux(L,M,N,D,O,P,Q,H,I,J)
     [G>=Q,D>=K,O>=E,O>=B,Q>=0,P>=2,O>=1,K>=2,J>=0,I>=0,H>=0,G>=1,E>=0,C>=1,B>=0,C+1=N,P+1=F,K=A+1,L=1] 

### Cost equations --> "Loop" of pack_aux/10 
* CEs [205] --> Loop 196 
* CEs [207] --> Loop 197 
* CEs [206] --> Loop 198 
* CEs [203] --> Loop 199 
* CEs [202] --> Loop 200 
* CEs [204] --> Loop 201 

#### Loops of pack_aux/10 
* Loop 196: pack_aux(A,B,C,D,E,F,G,H,I,J)->  pack_aux(A',B',C,D,E,C',D',H,I,J)
                  [G>=D',B'>=B,D'>=0,J>=0,I>=0,H>=0,F>=3,E>=0,D>=0,C>=1,B>=0,A>=1,F=C'+1,A+1=A'] 
* Loop 197: pack_aux(A,B,C,D,E,F,G,H,I,J)->  pack_aux(A',B',C',D,D',E',F',H,I,J)
                  [G>=F',D'>=E,D'>=B,D>=A+1,F'>=0,D'>=1,J>=0,I>=0,H>=0,G>=1,F>=3,E>=0,C>=1,B>=0,A>=1,F=E'+1,C+1=C',A'=1] 
* Loop 198: pack_aux(A,B,C,D,E,F,G,H,I,J)->  pack_aux(A',B',C',D',E',F',G',H,I,J)
                  [G>=G',E'>=E,A>=D,E'>=B,G'>=0,E'>=1,J>=0,I>=0,H>=0,G>=1,F>=3,E>=0,D>=0,C>=1,B>=0,A>=1,F=F'+1,A+1=D',C+1=C',A'=1] 
* Loop 199: pack_aux(A,B,C,D,E,F,G,H,D,I) [I>=E,I>=B,D>=A+1,G>=0,E>=0,C>=1,B>=0,A>=1,C+1=H,F=2] 
* Loop 200: pack_aux(A,B,C,D,E,F,G,H,I,J) [J>=E,A>=D,J>=B,G>=0,E>=0,D>=0,C>=1,B>=0,A>=1,A+1=I,C+1=H,F=2] 
* Loop 201: pack_aux(A,B,C,D,E,F,G,H,I,J) [J>=0,G>=0,E>=0,B>=0,I=0,H=1,F=1,D=0,C=1,A=1] 

### Ranking functions of CR pack_aux(A,B,C,D,E,F,G,H,I,J) 
* RF of phase [196,197,198]: [F-2]

#### Partial ranking functions of CR pack_aux(A,B,C,D,E,F,G,H,I,J) 
* Partial RF of phase [196,197,198]:
  - RF of loop [196:1,197:1,198:1]:
    F-2
  - RF of loop [198:1]:
    A-D+1 depends on loops [196:1] 

Discarded unfeasible chain [[196,197,198]]...(Non-terminating chain proved terminating)

### Resulting Chains:pack_aux(A,B,C,D,E,F,G,H,I,J) 
* [[196,197,198],200]
* [[196,197,198],199]
* [201]
* [200]


### Merging Chains  pack_aux/10 into  External patterns of execution 
* [[201]] --> 1 
* [[200]] --> 2 
* [[199,[196,197,198]]] --> 3 
* [[200,[196,197,198]]] --> 4 


### Specialization of cost equations pack/5 
* CE 21 is refined into CE [208,209,210,211] 


#### Refined cost equations pack/5 
* CE 208: pack(A,B,C,D,E) = 3+ pack_aux(F,G,H,I,J,K,B,L,M,E):1
     [E>=0,B>=0,J>=0,G>=0,M=0,L=1,K=1,I=0,H=1,F=1,D=0,C=1,A=1] 
* CE 209: pack(A,B,C,D,E) = 3+ pack_aux(F,G,H,I,J,K,B,L,M,E):2
     [E>=J,E>=G,B>=0,J>=0,G>=0,M=2,L=2,K=2,I=0,H=1,F=1,D=2,C=2,A=2] 
* CE 210: pack(A,B,C,D,E) = 3+ pack_aux(F,G,H,I,J,A,B,C,D,E):3
     [A+C>=D+4,A>=C,E>=J,E>=G,E>=1,D>=2,C>=3,B>=1,J>=0,G>=0,I=0,H=1,F=1] 
* CE 211: pack(A,B,C,D,E) = 3+ pack_aux(F,G,H,I,J,A,B,C,D,E):4
     [A+2>=C+D,E>=J,E>=G,D>=3,C>=2,B>=0,J>=0,G>=0,I=0,H=1,F=1] 

### Cost equations --> "Loop" of pack/5 
* CEs [210] --> Loop 202 
* CEs [211] --> Loop 203 
* CEs [209] --> Loop 204 
* CEs [208] --> Loop 205 

#### Loops of pack/5 
* Loop 202: pack(A,B,C,D,E) [A+C>=D+4,A>=C,E>=1,D>=2,C>=3,B>=1] 
* Loop 203: pack(A,B,C,D,E) [A+2>=C+D,E>=0,D>=3,C>=2,B>=0] 
* Loop 204: pack(A,B,C,D,E) [E>=0,B>=0,D=2,C=2,A=2] 
* Loop 205: pack(A,B,C,D,E) [E>=0,B>=0,D=0,C=1,A=1] 

### Ranking functions of CR pack(A,B,C,D,E) 

#### Partial ranking functions of CR pack(A,B,C,D,E) 


### Resulting Chains:pack(A,B,C,D,E) 
* [205]
* [204]
* [203]
* [202]


### Merging Chains  pack/5 into  External patterns of execution 
* [[205]] --> 1 
* [[204]] --> 2 
* [[203]] --> 3 
* [[202]] --> 4 


### Specialization of cost equations removeAt/5 
* CE 34 is refined into CE [212,213] 
* CE 32 is refined into CE [214] 
* CE 33 is refined into CE [215] 


#### Refined cost equations removeAt/5 
* CE 212: removeAt(A,B,C,D,E) = 10+ removeAt(F,G,H,I,J)+ maxNorm(E,J,E):1
     [C>=H,C>=E,E>=J+1,I>=1,H>=0,G>=1,J>=0,A>=2,A=F+1,I+1=D,G+1=B] 
* CE 213: removeAt(A,B,C,D,E) = 10+ removeAt(F,G,H,I,E)+ maxNorm(J,E,E):2
     [C>=H,E>=J,C>=J,I>=1,H>=0,G>=1,J>=1,A>=2,A=F+1,I+1=D,G+1=B] 
* CE 214: removeAt(A,B,C,D,E) = 3
     [A>=0,E=0,D=1,C=0,B=1] 
* CE 215: removeAt(A,B,C,D,E) = 6
     [C>=E,E>=0,D>=1,C>=1,D+1=B,A=1] 

### Cost equations --> "Loop" of removeAt/5 
* CEs [214] --> Loop 206 
* CEs [215] --> Loop 207 
* CEs [212] --> Loop 208 
* CEs [213] --> Loop 209 

#### Loops of removeAt/5 
* Loop 206: removeAt(A,B,C,D,E) [A>=0,E=0,D=1,C=0,B=1] 
* Loop 207: removeAt(A,B,C,D,E) [C>=E,E>=0,C>=1,B>=2,B=D+1,A=1] 
* Loop 208: removeAt(A,B,C,D,E)->  removeAt(A',B',C',D',E')
                  [E>=E'+1,C>=C',C>=E,E'>=0,C'>=0,D>=2,B>=2,A>=2,D=D'+1,B=B'+1,A=A'+1] 
* Loop 209: removeAt(A,B,C,D,E)->  removeAt(A',B',C',D',E)
                  [C>=C',C'>=0,E>=1,D>=2,C>=1,B>=2,A>=2,D=D'+1,B=B'+1,A=A'+1] 

### Ranking functions of CR removeAt(A,B,C,D,E) 
* RF of phase [208,209]: [A-1,B-1]

#### Partial ranking functions of CR removeAt(A,B,C,D,E) 
* Partial RF of phase [208,209]:
  - RF of loop [208:1,209:1]:
    A-1
    B-1

Discarded unfeasible chain [[208,209]]...(Non-terminating chain proved terminating)

### Resulting Chains:removeAt(A,B,C,D,E) 
* [[208,209],207]
* [[208,209],206]
* [207]
* [206]


### Merging Chains  removeAt/5 into  External patterns of execution 
* [[207]] --> 1 
* [[206]] --> 2 
* [[206,[208,209]]] --> 3 
* [[207,[208,209]]] --> 4 


### Specialization of cost equations prepend/6 
* CE 89 is refined into CE [216] 
* CE 88 is refined into CE [217,218] 


#### Refined cost equations prepend/6 
* CE 216: prepend(A,B,C,D,B,C) = 3
     [D>=1,C>=0,B>=0,A=0] 
* CE 217: prepend(A,B,C,D,E,F) = 7+ maxNorm(D,C,D):1+ prepend(G,H,D,D,E,F)
     [D>=C+1,G>=0,C>=0,F>=0,E>=0,B>=1,B+1=H,G+1=A] 
* CE 218: prepend(A,B,C,D,E,F) = 7+ maxNorm(D,C,C):2+ prepend(G,H,C,D,E,F)
     [C>=D,G>=0,D>=1,F>=0,E>=0,B>=1,B+1=H,G+1=A] 

### Cost equations --> "Loop" of prepend/6 
* CEs [217] --> Loop 210 
* CEs [218] --> Loop 211 
* CEs [216] --> Loop 212 

#### Loops of prepend/6 
* Loop 210: prepend(A,B,C,D,E,F)->  prepend(A',B',D,D,E,F)
                  [D>=C+1,F>=0,E>=0,C>=0,B>=1,A>=1,B+1=B',A=A'+1] 
* Loop 211: prepend(A,B,C,D,E,F)->  prepend(A',B',C,D,E,F)
                  [C>=D,F>=0,E>=0,D>=1,B>=1,A>=1,B+1=B',A=A'+1] 
* Loop 212: prepend(A,B,C,D,B,C) [D>=1,C>=0,B>=0,A=0] 

### Ranking functions of CR prepend(A,B,C,D,E,F) 
* RF of phase [211]: [A]

#### Partial ranking functions of CR prepend(A,B,C,D,E,F) 
* Partial RF of phase [211]:
  - RF of loop [211:1]:
    A

Discarded unfeasible chain [[211]]...(Non-terminating chain proved terminating)
Discarded unfeasible chain [210,[211]](Non-terminating chain proved terminating)

### Resulting Chains:prepend(A,B,C,D,E,F) 
* [[211],212]
* [212]
* [210,[211],212]
* [210,212]


### Merging Chains  prepend/6 into  External patterns of execution 
* [[212]] --> 1 
* [[212,210]] --> 2 
* [[212,[211]]] --> 3 
* [[212,[211],210]] --> 4 


### Specialization of cost equations replicate_aux/7 
* CE 65 is refined into CE [219] 
* CE 64 is refined into CE [220,221,222,223] 


#### Refined cost equations replicate_aux/7 
* CE 219: replicate_aux(A,B,C,D,E,A,B) = 2
     [E>=0,B>=0,A>=0,D=0,C=1] 
* CE 220: replicate_aux(A,B,C,D,E,F,G) = 5+ prepend(H,A,B,I,A,B):1+ replicate_aux(A,B,J,K,L,F,G)
     [D>=K,D>=I,J>=1,B>=0,A>=0,I>=1,G>=0,F>=0,J+1=C,L=0,H=0,E=0] 
* CE 221: replicate_aux(A,B,C,D,E,F,G) = 5+ prepend(H,I,B,J,K,J):2+ replicate_aux(K,J,L,M,N,F,G)
     [D>=M,D>=J,J>=B+1,L>=1,K>=2,B>=0,G>=0,F>=0,K=I+1,L+1=C,K=A+1,N=1,H=1,E=1] 
* CE 222: replicate_aux(A,B,C,D,E,F,G) = 5+ prepend(E,H,B,I,J,B):3+ replicate_aux(J,B,K,L,E,F,G)
     [D>=L,B>=I,D>=I,J>=E+1,K>=1,I>=1,E>=1,G>=0,F>=0,J=E+H,J=A+E,K+1=C] 
* CE 223: replicate_aux(A,B,C,D,E,F,G) = 5+ prepend(E,H,B,I,J,I):4+ replicate_aux(J,I,K,L,E,F,G)
     [D>=L,D>=I,I>=B+1,J>=E+1,K>=1,B>=0,E>=2,G>=0,F>=0,J=E+H,J=A+E,K+1=C] 

### Cost equations --> "Loop" of replicate_aux/7 
* CEs [223] --> Loop 213 
* CEs [222] --> Loop 214 
* CEs [221] --> Loop 215 
* CEs [220] --> Loop 216 
* CEs [219] --> Loop 217 

#### Loops of replicate_aux/7 
* Loop 213: replicate_aux(A,B,C,D,E,F,G)->  replicate_aux(A',B',C',D',E,F,G)
                  [D>=D',D>=B',B'>=B+1,G>=0,F>=0,E>=2,C>=2,B>=0,A>=1,A+E=A',C=C'+1] 
* Loop 214: replicate_aux(A,B,C,D,E,F,G)->  replicate_aux(A',B,B',C',E,F,G)
                  [D>=C',G>=0,F>=0,E>=1,D>=1,C>=2,B>=1,A>=1,A+E=A',C=B'+1] 
* Loop 215: replicate_aux(A,B,C,D,E,F,G)->  replicate_aux(A',B',C',D',E',F,G)
                  [D>=D',D>=B',B'>=B+1,G>=0,F>=0,C>=2,B>=0,A>=1,C=C'+1,A+1=A',E'=1,E=1] 
* Loop 216: replicate_aux(A,B,C,D,E,F,G)->  replicate_aux(A,B,A',B',C',F,G)
                  [D>=B',G>=0,F>=0,D>=1,C>=2,B>=0,A>=0,C=A'+1,C'=0,E=0] 
* Loop 217: replicate_aux(A,B,C,D,E,A,B) [E>=0,B>=0,A>=0,D=0,C=1] 

### Ranking functions of CR replicate_aux(A,B,C,D,E,F,G) 
* RF of phase [213,214,215]: [C-1]
* RF of phase [216]: [C-1]

#### Partial ranking functions of CR replicate_aux(A,B,C,D,E,F,G) 
* Partial RF of phase [213,214,215]:
  - RF of loop [213:1,214:1,215:1]:
    C-1
  - RF of loop [213:1,215:1]:
    -B+D
* Partial RF of phase [216]:
  - RF of loop [216:1]:
    C-1

Discarded unfeasible chain [[216]]...(Non-terminating chain proved terminating)
Discarded unfeasible chain [[213,214,215]](Non-terminating chain proved terminating)

### Resulting Chains:replicate_aux(A,B,C,D,E,F,G) 
* [[216],217]
* [[213,214,215],217]
* [217]


### Merging Chains  replicate_aux/7 into  External patterns of execution 
* [[217,[216]]] --> 1 
* [[217]] --> 2 
* [[217,[213,214,215]]] --> 3 


### Specialization of cost equations replicate/5 
* CE 25 is refined into CE [224,225,226] 


#### Refined cost equations replicate/5 
* CE 224: replicate(A,B,C,D,E) = 3+ rev(F,G,H,I,J,K,L,M):1+ replicate_aux(N,O,P,Q,C,R,S):2
     [C>=0,K>=0,G>=0,S=0,R=1,Q=0,P=1,O=0,N=1,M=0,L=1,J=1,I=0,H=1,F=1,E=0,D=1,B=0,A=1] 
* CE 225: replicate(A,B,C,D,E) = 3+ rev(A,F,A,B,A,G,A,H):2+ replicate_aux(I,J,A,H,K,L,M):1
     [H>=1,A>=2,G>=0,B>=1,F>=0,M=0,L=1,K=0,J=0,I=1,E=0,D=1,C=0] 
* CE 226: replicate(A,B,C,D,E) = 3+ rev(A,F,A,B,A,G,A,H):2+ replicate_aux(I,J,A,H,C,D,E):3
     [D+1>=A+C,E>=1,C>=1,H>=1,A>=2,G>=0,B>=1,F>=0,J=0,I=1] 

### Cost equations --> "Loop" of replicate/5 
* CEs [226] --> Loop 218 
* CEs [225] --> Loop 219 
* CEs [224] --> Loop 220 

#### Loops of replicate/5 
* Loop 218: replicate(A,B,C,D,E) [D+1>=A+C,E>=1,C>=1,B>=1,A>=2] 
* Loop 219: replicate(A,B,C,D,E) [B>=1,A>=2,E=0,D=1,C=0] 
* Loop 220: replicate(A,B,C,D,E) [C>=0,E=0,D=1,B=0,A=1] 

### Ranking functions of CR replicate(A,B,C,D,E) 

#### Partial ranking functions of CR replicate(A,B,C,D,E) 


### Resulting Chains:replicate(A,B,C,D,E) 
* [220]
* [219]
* [218]


### Merging Chains  replicate/5 into  External patterns of execution 
* [[220]] --> 1 
* [[219]] --> 2 
* [[218]] --> 3 


### Specialization of cost equations case_33/6 
* CE 79 is refined into CE [227] 
* CE 78 is refined into CE [228] 


#### Refined cost equations case_33/6 
* CE 227: case_33(A,B,C,D,E,F) = 4
     [F>=0,E>=0,D>=0,C>=0,B>=1,A=0] 
* CE 228: case_33(A,B,C,D,E,F) = 2
     [E>=0,D>=0,C>=0,F=0,B=0,A=0] 

### Cost equations --> "Loop" of case_33/6 
* CEs [227] --> Loop 221 
* CEs [228] --> Loop 222 

#### Loops of case_33/6 
* Loop 221: case_33(A,B,C,D,E,F) [F>=0,E>=0,D>=0,C>=0,B>=1,A=0] 
* Loop 222: case_33(A,B,C,D,E,F) [E>=0,D>=0,C>=0,F=0,B=0,A=0] 

### Ranking functions of CR case_33(A,B,C,D,E,F) 

#### Partial ranking functions of CR case_33(A,B,C,D,E,F) 


### Resulting Chains:case_33(A,B,C,D,E,F) 
* [222]
* [221]


### Merging Chains  case_33/6 into  External patterns of execution 
* [[222]] --> 1 
* [[221]] --> 2 


### Specialization of cost equations split_aux/8 
* CE 71 is refined into CE [229,230] 
* CE 69 is refined into CE [231,232] 
* CE 70 is refined into CE [233,234,235,236,237] 


#### Refined cost equations split_aux/8 
* CE 229: split_aux(A,B,C,D,E,F,G,H) = 10+ maxNorm(I,C,I):1+ split_aux(J,K,I,L,M,F,G,H)
     [E>=M,E>=I,I>=C+1,M>=0,L>=1,J>=0,C>=0,H>=0,G>=0,F>=0,B>=1,B+1=K,L+1=D,J+1=A] 
* CE 230: split_aux(A,B,C,D,E,F,G,H) = 10+ maxNorm(I,C,C):2+ split_aux(J,K,C,L,M,F,G,H)
     [E>=M,C>=I,E>=I,M>=0,L>=1,J>=0,I>=1,H>=0,G>=0,F>=0,B>=1,B+1=K,L+1=D,J+1=A] 
* CE 231: split_aux(A,B,C,D,E,F,G,H) = 5+ rev(I,J,K,L,M,N,O,P):1+ maxNorm(Q,R,S):2+ maxNorm(T,U,V):2
     [N>=0,J>=0,A>=0,V=1,U=1,T=1,S=0,R=0,Q=0,P=0,O=1,M=1,L=0,K=1,I=1,H=0,G=1,F=1,E=0,D=1,C=0,B=1] 
* CE 232: split_aux(A,B,C,D,E,F,B,G) = 5+ rev(B,H,B,C,B,I,B,G):2+ maxNorm(G,J,G):1+ maxNorm(B,K,B):1
     [B>=2,G>=1,I>=0,C>=1,H>=0,A>=0,K=1,J=0,F=1,E=0,D=1] 
* CE 233: split_aux(A,B,C,D,E,F,D,E) = 8+ rev(G,H,I,J,K,L,M,N):1+ maxNorm(O,E,E):2+ maxNorm(P,D,D):2
     [D>=2,E>=1,L>=0,H>=0,P=1,O=0,N=0,M=1,K=1,J=0,I=1,G=1,F=1,C=0,B=1,A=0] 
* CE 234: split_aux(A,B,C,D,E,F,B,G) = 8+ rev(B,H,B,C,B,I,B,G):2+ maxNorm(G,E,G):1+ maxNorm(B,D,B):1
     [B>=D+1,G>=E+1,D>=2,E>=1,I>=0,C>=1,H>=0,F=1,A=0] 
* CE 235: split_aux(A,B,C,D,E,F,D,G) = 8+ rev(B,H,B,C,B,I,B,G):2+ maxNorm(G,E,G):1+ maxNorm(B,D,D):2
     [D>=B,G>=E+1,B>=2,E>=1,I>=0,C>=1,H>=0,F=1,A=0] 
* CE 236: split_aux(A,B,C,D,E,F,B,E) = 8+ rev(B,G,B,C,B,H,B,I):2+ maxNorm(I,E,E):2+ maxNorm(B,D,B):1
     [B>=D+1,E>=I,D>=2,I>=1,H>=0,C>=1,G>=0,F=1,A=0] 
* CE 237: split_aux(A,B,C,D,E,F,D,E) = 8+ rev(B,G,B,C,B,H,B,I):2+ maxNorm(I,E,E):2+ maxNorm(B,D,D):2
     [D>=B,E>=I,B>=2,I>=1,H>=0,C>=1,G>=0,F=1,A=0] 

### Cost equations --> "Loop" of split_aux/8 
* CEs [232] --> Loop 223 
* CEs [231] --> Loop 224 
* CEs [235] --> Loop 225 
* CEs [237] --> Loop 226 
* CEs [234] --> Loop 227 
* CEs [236] --> Loop 228 
* CEs [233] --> Loop 229 
* CEs [229] --> Loop 230 
* CEs [230] --> Loop 231 

#### Loops of split_aux/8 
* Loop 223: split_aux(A,B,C,D,E,F,B,G) [G>=1,C>=1,B>=2,A>=0,F=1,E=0,D=1] 
* Loop 224: split_aux(A,B,C,D,E,F,G,H) [A>=0,H=0,G=1,F=1,E=0,D=1,C=0,B=1] 
* Loop 225: split_aux(A,B,C,D,E,F,D,G) [G>=E+1,D>=B,E>=1,C>=1,B>=2,F=1,A=0] 
* Loop 226: split_aux(A,B,C,D,E,F,D,E) [D>=B,E>=1,C>=1,B>=2,F=1,A=0] 
* Loop 227: split_aux(A,B,C,D,E,F,B,G) [G>=E+1,B>=D+1,E>=1,D>=2,C>=1,F=1,A=0] 
* Loop 228: split_aux(A,B,C,D,E,F,B,E) [B>=D+1,E>=1,D>=2,C>=1,F=1,A=0] 
* Loop 229: split_aux(A,B,C,D,E,F,D,E) [E>=1,D>=2,F=1,C=0,B=1,A=0] 
* Loop 230: split_aux(A,B,C,D,E,F,G,H)->  split_aux(A',B',C',D',E',F,G,H)
                  [E>=E',E>=C',C'>=C+1,E'>=0,H>=0,G>=0,F>=0,D>=2,C>=0,B>=1,A>=1,D=D'+1,B+1=B',A=A'+1] 
* Loop 231: split_aux(A,B,C,D,E,F,G,H)->  split_aux(A',B',C,C',D',F,G,H)
                  [E>=D',D'>=0,H>=0,G>=0,F>=0,E>=1,D>=2,C>=1,B>=1,A>=1,D=C'+1,B+1=B',A=A'+1] 

### Ranking functions of CR split_aux(A,B,C,D,E,F,G,H) 
* RF of phase [230,231]: [A,D-1]

#### Partial ranking functions of CR split_aux(A,B,C,D,E,F,G,H) 
* Partial RF of phase [230,231]:
  - RF of loop [230:1]:
    -C+E
  - RF of loop [230:1,231:1]:
    A
    D-1

Discarded unfeasible chain [[230,231]]...(Non-terminating chain proved terminating)

### Resulting Chains:split_aux(A,B,C,D,E,F,G,H) 
* [[230,231],228]
* [[230,231],227]
* [[230,231],226]
* [[230,231],225]
* [[230,231],223]
* [229]
* [224]


### Merging Chains  split_aux/8 into  External patterns of execution 
* [[229]] --> 1 
* [[224]] --> 2 
* [[225,[230,231]]] --> 3 
* [[226,[230,231]]] --> 4 
* [[227,[230,231]]] --> 5 
* [[228,[230,231]]] --> 6 
* [[223,[230,231]]] --> 7 


### Specialization of cost equations split/6 
* CE 27 is refined into CE [238,239,240,241,242,243,244] 


#### Refined cost equations split/6 
* CE 238: split(A,B,C,D,A,B) = 2+ split_aux(E,F,G,A,B,H,A,B):1
     [B>=1,A>=2,H=1,G=0,F=1,E=0,D=1,C=0] 
* CE 239: split(A,B,C,D,E,F) = 2+ split_aux(C,G,H,I,J,K,L,M):2
     [C>=0,M=0,L=1,K=1,J=0,I=1,H=0,G=1,F=0,E=1,D=1,B=0,A=1] 
* CE 240: split(A,B,C,D,E,F) = 2+ split_aux(C,G,H,A,B,I,J,F):3
     [A>=2*C+1,F>=2,B>=1,C>=1,A=C+J,A=C+E,I=1,H=0,G=1,D=1] 
* CE 241: split(A,B,C,D,E,F) = 2+ split_aux(C,G,H,A,B,I,J,F):4
     [B>=F,A>=2*C+1,F>=1,C>=1,A=C+J,A=C+E,I=1,H=0,G=1,D=1] 
* CE 242: split(A,B,C,D,E,F) = 2+ split_aux(G,H,I,A,B,J,E,F):5
     [A>=E+1,2*E>=A+2,F>=2,B>=1,E=G+1,E=C+1,J=1,I=0,H=1,D=1] 
* CE 243: split(A,B,C,D,E,F) = 2+ split_aux(G,H,I,A,B,J,E,F):6
     [B>=F,A>=E+1,2*E>=A+2,F>=1,E=G+1,E=C+1,J=1,I=0,H=1,D=1] 
* CE 244: split(A,B,C,D,A,E) = 2+ split_aux(C,F,G,A,B,H,A,E):7
     [C+1>=A,E>=1,A>=2,B>=1,H=1,G=0,F=1,D=1] 

### Cost equations --> "Loop" of split/6 
* CEs [241] --> Loop 232 
* CEs [240] --> Loop 233 
* CEs [244] --> Loop 234 
* CEs [243] --> Loop 235 
* CEs [242] --> Loop 236 
* CEs [238] --> Loop 237 
* CEs [239] --> Loop 238 

#### Loops of split/6 
* Loop 232: split(A,B,C,D,E,F) [B>=F,A>=2*C+1,F>=1,C>=1,C+E=A,D=1] 
* Loop 233: split(A,B,C,D,E,F) [A>=2*C+1,F>=2,C>=1,B>=1,C+E=A,D=1] 
* Loop 234: split(A,B,C,D,A,E) [C+1>=A,E>=1,B>=1,A>=2,D=1] 
* Loop 235: split(A,B,C,D,E,F) [B>=F,A>=C+2,2*C>=A,F>=1,C+1=E,D=1] 
* Loop 236: split(A,B,C,D,E,F) [A>=C+2,2*C>=A,F>=2,B>=1,C+1=E,D=1] 
* Loop 237: split(A,B,C,D,A,B) [B>=1,A>=2,D=1,C=0] 
* Loop 238: split(A,B,C,D,E,F) [C>=0,F=0,E=1,D=1,B=0,A=1] 

### Ranking functions of CR split(A,B,C,D,E,F) 

#### Partial ranking functions of CR split(A,B,C,D,E,F) 


### Resulting Chains:split(A,B,C,D,E,F) 
* [238]
* [237]
* [236]
* [235]
* [234]
* [233]
* [232]


### Merging Chains  split/6 into  External patterns of execution 
* [[238]] --> 1 
* [[237]] --> 2 
* [[234]] --> 3 
* [[236]] --> 4 
* [[235]] --> 5 
* [[233]] --> 6 
* [[232]] --> 7 


### Specialization of cost equations case_34/8 
* CE 81 is refined into CE [245,246,247,248,249,250,251,252,253,254,255,256,257] 
* CE 80 is refined into CE [258] 


#### Refined cost equations case_34/8 
* CE 245: case_34(A,B,C,D,E,F,G,H) = 7+ split(I,J,F,K,L,M):1+ concat(N,O,P,Q,R,S,T,U,R,S,V,W):1
     [S>=0,R>=0,O>=0,F>=0,C>=0,B>=1,W=0,V=1,U=0,T=1,Q=0,P=1,N=1,M=0,L=1,K=1,J=0,I=1,H=0,G=1,E=0,D=1,A=0] 
* CE 246: case_34(A,B,C,D,E,F,G,H) = 7+ split(D,E,I,J,D,E):2+ concat(K,L,M,N,O,P,G,H,O,P,G,H):1
     [E>=H,D>=G,H>=0,G>=1,P>=0,O>=0,L>=0,E>=1,D>=2,C>=0,B>=1,N=0,M=1,K=1,J=1,I=0,F=0,A=0] 
* CE 247: case_34(A,B,C,D,E,F,G,H) = 7+ split(D,E,I,J,D,E):2+ concat(K,L,K,M,N,O,P,Q,R,S,G,H):2
     [M+Q>=H,D+K>=G+1,H>=Q,E>=Q,S>=O,E>=M,G>=K,R>=K,D>=K,H>=1,Q>=0,O>=0,M>=1,K>=2,L>=0,C>=0,B>=1,K+P=G+1,K+N=R+1,J=1,I=0,F=0,A=0] 
* CE 248: case_34(A,B,C,D,E,F,G,H) = 7+ split(D,E,F,I,D,J):3+ concat(K,L,M,N,O,P,G,H,O,P,G,H):1
     [J>=H,D>=G,F+1>=D,H>=0,G>=1,P>=0,O>=0,L>=0,J>=1,D>=2,E>=1,C>=0,B>=1,N=0,M=1,K=1,I=1,A=0] 
* CE 249: case_34(A,B,C,D,E,F,G,H) = 7+ split(D,E,F,I,D,J):3+ concat(K,L,K,M,N,O,P,Q,R,S,G,H):2
     [M+Q>=H,D+K>=G+1,H>=Q,J>=Q,S>=O,J>=M,G>=K,R>=K,D>=K,F+1>=D,H>=1,Q>=0,O>=0,M>=1,K>=2,L>=0,E>=1,C>=0,B>=1,K+P=G+1,K+N=R+1,I=1,A=0] 
* CE 250: case_34(A,B,C,D,E,F,G,H) = 7+ split(D,E,I,J,K,L):4+ concat(M,N,O,P,Q,R,G,H,Q,R,G,H):1
     [L>=H,K>=G,D>=K+1,2*K>=D+2,H>=0,G>=1,R>=0,Q>=0,N>=0,L>=2,E>=1,C>=0,B>=1,K=I+1,K=F+1,P=0,O=1,M=1,J=1,A=0] 
* CE 251: case_34(A,B,C,D,E,F,G,H) = 7+ split(D,E,I,J,K,L):4+ concat(M,N,M,O,P,Q,R,S,T,U,G,H):2
     [O+S>=H,K+M>=G+1,H>=S,L>=S,U>=Q,L>=O,G>=M,T>=M,K>=M,D>=K+1,2*K>=D+2,H>=1,S>=0,Q>=0,O>=1,M>=2,N>=0,L>=2,E>=1,C>=0,B>=1,M+R=G+1,M+P=T+1,K=I+1,K=F+1,J=1,A=0] 
* CE 252: case_34(A,B,C,D,E,F,G,H) = 7+ split(D,E,I,J,K,L):5+ concat(M,N,O,P,Q,R,G,H,Q,R,G,H):1
     [L>=H,K>=G,E>=L,D>=K+1,2*K>=D+2,H>=0,G>=1,R>=0,Q>=0,N>=0,L>=1,C>=0,B>=1,K=I+1,K=F+1,P=0,O=1,M=1,J=1,A=0] 
* CE 253: case_34(A,B,C,D,E,F,G,H) = 7+ split(D,E,I,J,K,L):5+ concat(M,N,M,O,P,Q,R,S,T,U,G,H):2
     [O+S>=H,K+M>=G+1,H>=S,L>=S,U>=Q,L>=O,G>=M,T>=M,K>=M,E>=L,D>=K+1,2*K>=D+2,H>=1,S>=0,Q>=0,O>=1,M>=2,N>=0,C>=0,B>=1,M+R=G+1,M+P=T+1,K=I+1,K=F+1,J=1,A=0] 
* CE 254: case_34(A,B,C,D,E,F,G,H) = 7+ split(I,E,F,J,K,L):6+ concat(M,N,O,P,Q,R,G,H,Q,R,G,H):1
     [L>=H,K>=G,K>=F+1,H>=0,G>=1,R>=0,Q>=0,N>=0,L>=2,F>=1,E>=1,C>=0,B>=1,F+K=I,F+K=D,P=0,O=1,M=1,J=1,A=0] 
* CE 255: case_34(A,B,C,D,E,F,G,H) = 7+ split(I,E,F,J,K,L):6+ concat(M,N,M,O,P,Q,R,S,T,U,G,H):2
     [O+S>=H,K+M>=G+1,H>=S,L>=S,U>=Q,L>=O,G>=M,T>=M,K>=M,K>=F+1,H>=1,S>=0,Q>=0,O>=1,M>=2,N>=0,L>=2,F>=1,E>=1,C>=0,B>=1,M+R=G+1,M+P=T+1,F+K=I,F+K=D,J=1,A=0] 
* CE 256: case_34(A,B,C,D,E,F,G,H) = 7+ split(I,E,F,J,K,L):7+ concat(M,N,O,P,Q,R,G,H,Q,R,G,H):1
     [L>=H,K>=G,E>=L,K>=F+1,H>=0,G>=1,R>=0,Q>=0,N>=0,L>=1,F>=1,C>=0,B>=1,F+K=I,F+K=D,P=0,O=1,M=1,J=1,A=0] 
* CE 257: case_34(A,B,C,D,E,F,G,H) = 7+ split(I,E,F,J,K,L):7+ concat(M,N,M,O,P,Q,R,S,T,U,G,H):2
     [O+S>=H,K+M>=G+1,H>=S,L>=S,U>=Q,L>=O,G>=M,T>=M,K>=M,E>=L,K>=F+1,H>=1,S>=0,Q>=0,O>=1,M>=2,N>=0,F>=1,C>=0,B>=1,M+R=G+1,M+P=T+1,F+K=I,F+K=D,J=1,A=0] 
* CE 258: case_34(A,B,C,D,E,F,D,E) = 1
     [F>=0,E>=0,D>=1,C>=0,B=0,A=0] 

### Cost equations --> "Loop" of case_34/8 
* CEs [251,253] --> Loop 239 
* CEs [250,252] --> Loop 240 
* CEs [255,257] --> Loop 241 
* CEs [254,256] --> Loop 242 
* CEs [249] --> Loop 243 
* CEs [248] --> Loop 244 
* CEs [247] --> Loop 245 
* CEs [246] --> Loop 246 
* CEs [245] --> Loop 247 
* CEs [258] --> Loop 248 

#### Loops of case_34/8 
* Loop 239: case_34(A,B,C,D,E,F,G,H) [2*F+1>=G,D>=F+2,2*F>=D,H>=1,G>=2,E>=1,C>=0,B>=1,A=0] 
* Loop 240: case_34(A,B,C,D,E,F,G,H) [F+1>=G,D>=F+2,2*F>=D,H>=0,G>=1,E>=1,C>=0,B>=1,A=0] 
* Loop 241: case_34(A,B,C,D,E,F,G,H) [2*D>=2*F+G+1,D>=2*F+1,H>=1,G>=2,F>=1,E>=1,C>=0,B>=1,A=0] 
* Loop 242: case_34(A,B,C,D,E,F,G,H) [D>=F+G,D>=2*F+1,H>=0,G>=1,F>=1,E>=1,C>=0,B>=1,A=0] 
* Loop 243: case_34(A,B,C,D,E,F,G,H) [2*D>=G+1,F+1>=D,H>=1,G>=2,E>=1,D>=2,C>=0,B>=1,A=0] 
* Loop 244: case_34(A,B,C,D,E,F,G,H) [D>=G,F+1>=D,H>=0,G>=1,E>=1,D>=2,C>=0,B>=1,A=0] 
* Loop 245: case_34(A,B,C,D,E,F,G,H) [2*E>=H,2*D>=G+1,H>=1,G>=2,E>=1,D>=2,C>=0,B>=1,F=0,A=0] 
* Loop 246: case_34(A,B,C,D,E,F,G,H) [E>=H,D>=G,H>=0,G>=1,E>=1,D>=2,C>=0,B>=1,F=0,A=0] 
* Loop 247: case_34(A,B,C,D,E,F,G,H) [F>=0,C>=0,B>=1,H=0,G=1,E=0,D=1,A=0] 
* Loop 248: case_34(A,B,C,D,E,F,D,E) [F>=0,E>=0,D>=1,C>=0,B=0,A=0] 

### Ranking functions of CR case_34(A,B,C,D,E,F,G,H) 

#### Partial ranking functions of CR case_34(A,B,C,D,E,F,G,H) 


### Resulting Chains:case_34(A,B,C,D,E,F,G,H) 
* [248]
* [247]
* [246]
* [245]
* [244]
* [243]
* [242]
* [241]
* [240]
* [239]


### Merging Chains  case_34/8 into  External patterns of execution 
* [[248]] --> 1 
* [[247]] --> 2 
* [[246]] --> 3 
* [[245]] --> 4 
* [[244]] --> 5 
* [[243]] --> 6 
* [[242]] --> 7 
* [[241]] --> 8 
* [[240]] --> 9 
* [[239]] --> 10 


### Specialization of cost equations rotate/5 
* CE 31 is refined into CE [259,260,261,262,263,264,265,266,267,268] 


#### Refined cost equations rotate/5 
* CE 259: rotate(A,B,C,D,E) = 9+ lengthL(F,G,H,I,J,K):1+ case_33(L,M,N,O,C,P):1+ case_34(Q,R,S,T,U,C,V,W):1
     [C>=0,G>=0,W=0,V=1,U=0,T=1,S=0,R=0,Q=0,P=0,O=0,N=1,M=0,L=0,K=0,J=0,I=0,H=1,F=1,E=0,D=1,B=0,A=1] 
* CE 260: rotate(A,B,C,A,B) = 9+ lengthL(A,D,A,B,E,F):2+ case_33(G,H,A,B,C,I):2+ case_34(J,K,L,A,B,C,A,B):1
     [B>=1,A>=2,C>=0,D>=0,A=L+1,A=H+1,A=F+1,A=E+1,K=0,J=0,I=0,G=0] 
* CE 261: rotate(A,B,C,D,E) = 9+ lengthL(F,G,H,B,I,I):2+ case_33(J,I,K,B,L,M):2+ case_34(N,M,I,O,B,P,D,E):3
     [B>=E,I+1>=D,E>=0,D>=1,B>=1,I>=1,M>=1,G>=0,I+1=O,I+1=K,I+1=H,I+1=F,I+1=A,P=0,N=0,L=0,J=0,C=0] 
* CE 262: rotate(A,B,C,D,E) = 9+ lengthL(F,G,H,B,I,I):2+ case_33(J,I,K,B,L,M):2+ case_34(N,M,I,O,B,P,D,E):4
     [2*B>=E,2*I+1>=D,E>=1,D>=2,B>=1,I>=1,M>=1,G>=0,I+1=O,I+1=K,I+1=H,I+1=F,I+1=A,P=0,N=0,L=0,J=0,C=0] 
* CE 263: rotate(A,B,C,D,E) = 9+ lengthL(F,G,H,B,I,I):2+ case_33(J,I,K,B,C,L):2+ case_34(M,L,I,N,B,C,D,E):5
     [I+1>=D,C>=I,E>=0,D>=1,B>=1,I>=1,L>=1,G>=0,I+1=N,I+1=K,I+1=H,I+1=F,I+1=A,M=0,J=0] 
* CE 264: rotate(A,B,C,D,E) = 9+ lengthL(F,G,H,B,I,I):2+ case_33(J,I,K,B,C,L):2+ case_34(M,L,I,N,B,C,D,E):6
     [2*I+1>=D,C>=I,E>=1,D>=2,B>=1,I>=1,L>=1,G>=0,I+1=N,I+1=K,I+1=H,I+1=F,I+1=A,M=0,J=0] 
* CE 265: rotate(A,B,C,D,E) = 9+ lengthL(F,G,H,B,I,I):2+ case_33(J,I,K,B,C,L):2+ case_34(M,L,I,N,B,C,D,E):7
     [I+1>=C+D,I>=2*C,E>=0,D>=1,C>=1,B>=1,L>=1,G>=0,I+1=N,I+1=K,I+1=H,I+1=F,I+1=A,M=0,J=0] 
* CE 266: rotate(A,B,C,D,E) = 9+ lengthL(F,G,H,B,I,I):2+ case_33(J,I,K,B,C,L):2+ case_34(M,L,I,N,B,C,D,E):8
     [2*I+1>=2*C+D,I>=2*C,E>=1,D>=2,C>=1,B>=1,L>=1,G>=0,I+1=N,I+1=K,I+1=H,I+1=F,I+1=A,M=0,J=0] 
* CE 267: rotate(A,B,C,D,E) = 9+ lengthL(F,G,H,B,I,I):2+ case_33(J,I,K,B,C,L):2+ case_34(M,L,I,N,B,C,D,E):9
     [C+1>=D,I>=C+1,2*C>=I+1,E>=0,D>=1,B>=1,L>=1,G>=0,I+1=N,I+1=K,I+1=H,I+1=F,I+1=A,M=0,J=0] 
* CE 268: rotate(A,B,C,D,E) = 9+ lengthL(F,G,H,B,I,I):2+ case_33(J,I,K,B,C,L):2+ case_34(M,L,I,N,B,C,D,E):10
     [2*C+1>=D,I>=C+1,2*C>=I+1,E>=1,D>=2,B>=1,L>=1,G>=0,I+1=N,I+1=K,I+1=H,I+1=F,I+1=A,M=0,J=0] 

### Cost equations --> "Loop" of rotate/5 
* CEs [268] --> Loop 249 
* CEs [267] --> Loop 250 
* CEs [266] --> Loop 251 
* CEs [265] --> Loop 252 
* CEs [264] --> Loop 253 
* CEs [263] --> Loop 254 
* CEs [260] --> Loop 255 
* CEs [262] --> Loop 256 
* CEs [261] --> Loop 257 
* CEs [259] --> Loop 258 

#### Loops of rotate/5 
* Loop 249: rotate(A,B,C,D,E) [2*C+1>=D,A>=C+2,2*C>=A,E>=1,D>=2,B>=1] 
* Loop 250: rotate(A,B,C,D,E) [C+1>=D,A>=C+2,2*C>=A,E>=0,D>=1,B>=1] 
* Loop 251: rotate(A,B,C,D,E) [2*A>=2*C+D+1,A>=2*C+1,E>=1,D>=2,C>=1,B>=1] 
* Loop 252: rotate(A,B,C,D,E) [A>=C+D,A>=2*C+1,E>=0,D>=1,C>=1,B>=1] 
* Loop 253: rotate(A,B,C,D,E) [2*A>=D+1,C+1>=A,E>=1,D>=2,B>=1,A>=2] 
* Loop 254: rotate(A,B,C,D,E) [A>=D,C+1>=A,E>=0,D>=1,B>=1,A>=2] 
* Loop 255: rotate(A,B,C,A,B) [C>=0,B>=1,A>=2] 
* Loop 256: rotate(A,B,C,D,E) [2*B>=E,2*A>=D+1,E>=1,D>=2,B>=1,A>=2,C=0] 
* Loop 257: rotate(A,B,C,D,E) [B>=E,A>=D,E>=0,D>=1,B>=1,A>=2,C=0] 
* Loop 258: rotate(A,B,C,D,E) [C>=0,E=0,D=1,B=0,A=1] 

### Ranking functions of CR rotate(A,B,C,D,E) 

#### Partial ranking functions of CR rotate(A,B,C,D,E) 


### Resulting Chains:rotate(A,B,C,D,E) 
* [258]
* [257]
* [256]
* [255]
* [254]
* [253]
* [252]
* [251]
* [250]
* [249]


### Merging Chains  rotate/5 into  External patterns of execution 
* [[258]] --> 1 
* [[257]] --> 2 
* [[256]] --> 3 
* [[255]] --> 4 
* [[254]] --> 5 
* [[253]] --> 6 
* [[252]] --> 7 
* [[251]] --> 8 
* [[250]] --> 9 
* [[249]] --> 10 


### Specialization of cost equations drop_slice/5 
* CE 74 is refined into CE [269] 
* CE 72 is refined into CE [270] 
* CE 73 is refined into CE [271] 


#### Refined cost equations drop_slice/5 
* CE 269: drop_slice(A,B,C,D,E) = 9+ drop_slice(F,G,H,D,E)
     [C>=H,H>=0,G>=1,F>=0,E>=0,D>=0,C>=1,G+1=B,F+1=A] 
* CE 270: drop_slice(A,B,C,D,E) = 3
     [A>=0,E=0,D=1,C=0,B=1] 
* CE 271: drop_slice(A,B,C,B,C) = 6
     [C>=1,B>=2,A=0] 

### Cost equations --> "Loop" of drop_slice/5 
* CEs [270] --> Loop 259 
* CEs [271] --> Loop 260 
* CEs [269] --> Loop 261 

#### Loops of drop_slice/5 
* Loop 259: drop_slice(A,B,C,D,E) [A>=0,E=0,D=1,C=0,B=1] 
* Loop 260: drop_slice(A,B,C,B,C) [C>=1,B>=2,A=0] 
* Loop 261: drop_slice(A,B,C,D,E)->  drop_slice(A',B',C',D,E)
                  [C>=C',C'>=0,B'>=1,A'>=0,E>=0,D>=0,C>=1,B'+1=B,A'+1=A] 

### Ranking functions of CR drop_slice(A,B,C,D,E) 
* RF of phase [261]: [A,B-1]

#### Partial ranking functions of CR drop_slice(A,B,C,D,E) 
* Partial RF of phase [261]:
  - RF of loop [261:1]:
    A
    B-1

Discarded unfeasible chain [[261]]...(Non-terminating chain proved terminating)

### Resulting Chains:drop_slice(A,B,C,D,E) 
* [[261],260]
* [[261],259]
* [260]
* [259]


### Merging Chains  drop_slice/5 into  External patterns of execution 
* [[260]] --> 1 
* [[259]] --> 2 
* [[259,[261]]] --> 3 
* [[260,[261]]] --> 4 


### Specialization of cost equations take_slice/5 
* CE 77 is refined into CE [272,273] 
* CE 75 is refined into CE [274] 
* CE 76 is refined into CE [275] 


#### Refined cost equations take_slice/5 
* CE 272: take_slice(A,B,C,D,E) = 10+ take_slice(F,G,H,I,J)+ maxNorm(E,J,E):1
     [C>=H,C>=E,E>=J+1,I>=1,H>=0,G>=1,F>=0,J>=0,I+1=D,G+1=B,F+1=A] 
* CE 273: take_slice(A,B,C,D,E) = 10+ take_slice(F,G,H,I,E)+ maxNorm(J,E,E):2
     [C>=H,E>=J,C>=J,I>=1,H>=0,G>=1,F>=0,J>=1,I+1=D,G+1=B,F+1=A] 
* CE 274: take_slice(A,B,C,D,E) = 3
     [A>=0,E=0,D=1,C=0,B=1] 
* CE 275: take_slice(A,B,C,D,E) = 7
     [C>=1,B>=2,E=0,D=1,A=0] 

### Cost equations --> "Loop" of take_slice/5 
* CEs [274] --> Loop 262 
* CEs [275] --> Loop 263 
* CEs [272] --> Loop 264 
* CEs [273] --> Loop 265 

#### Loops of take_slice/5 
* Loop 262: take_slice(A,B,C,D,E) [A>=0,E=0,D=1,C=0,B=1] 
* Loop 263: take_slice(A,B,C,D,E) [C>=1,B>=2,E=0,D=1,A=0] 
* Loop 264: take_slice(A,B,C,D,E)->  take_slice(A',B',C',D',E')
                  [E>=E'+1,C>=C',C>=E,E'>=0,C'>=0,D>=2,B>=2,A>=1,D=D'+1,B=B'+1,A=A'+1] 
* Loop 265: take_slice(A,B,C,D,E)->  take_slice(A',B',C',D',E)
                  [C>=C',C'>=0,E>=1,D>=2,C>=1,B>=2,A>=1,D=D'+1,B=B'+1,A=A'+1] 

### Ranking functions of CR take_slice(A,B,C,D,E) 
* RF of phase [264,265]: [A,B-1]

#### Partial ranking functions of CR take_slice(A,B,C,D,E) 
* Partial RF of phase [264,265]:
  - RF of loop [264:1,265:1]:
    A
    B-1

Discarded unfeasible chain [[264,265]]...(Non-terminating chain proved terminating)

### Resulting Chains:take_slice(A,B,C,D,E) 
* [[264,265],263]
* [[264,265],262]
* [263]
* [262]


### Merging Chains  take_slice/5 into  External patterns of execution 
* [[263]] --> 1 
* [[262]] --> 2 
* [[263,[264,265]]] --> 3 
* [[262,[264,265]]] --> 4 


### Specialization of cost equations slice/6 
* CE 28 is refined into CE [276,277,278,279,280,281,282,283] 


#### Refined cost equations slice/6 
* CE 276: slice(A,B,C,D,E,F) = 7+ drop_slice(G,A,B,A,B):1+ take_slice(H,A,B,I,J):1
     [B>=1,A>=2,J=0,I=1,H=0,G=0,F=0,E=1,D=0,C=1] 
* CE 277: slice(A,B,C,D,E,F) = 7+ drop_slice(G,A,B,A,B):1+ take_slice(H,A,B,E,F):3
     [B>=F,A>=E+1,F>=1,E>=2,E=H+1,E=D+1,G=0,C=1] 
* CE 278: slice(A,B,C,D,A,E) = 7+ drop_slice(F,A,B,A,B):1+ take_slice(D,A,B,A,E):4
     [B>=E,D+1>=A,E>=1,A>=2,F=0,C=1] 
* CE 279: slice(A,B,C,D,E,F) = 7+ drop_slice(G,H,I,J,K):2+ take_slice(L,M,N,O,P):2
     [L>=0,G>=0,G+L=D,G+1=C,P=0,O=1,N=0,M=1,K=0,J=1,I=0,H=1,F=0,E=1,B=0,A=1] 
* CE 280: slice(A,B,C,D,E,F) = 7+ drop_slice(G,A,B,H,I):3+ take_slice(J,K,L,M,N):2
     [G+1>=A,J>=0,B>=1,A>=2,G+J=D,G+1=C,N=0,M=1,L=0,K=1,I=0,H=1,F=0,E=1] 
* CE 281: slice(A,B,C,D,E,F) = 7+ drop_slice(G,A,B,H,I):4+ take_slice(J,H,I,K,L):1
     [B>=I,A>=H+1,I>=1,H>=2,G+H=A,D+H=A,C+H=A+1,L=0,K=1,J=0,F=0,E=1] 
* CE 282: slice(A,B,C,D,E,F) = 7+ drop_slice(G,A,B,H,I):4+ take_slice(J,H,I,E,F):3
     [I>=F,H>=E+1,B>=I,A>=H+1,F>=1,E>=2,A+E=D+H+1,G+H=A,C+H=A+1,E=J+1] 
* CE 283: slice(A,B,C,D,E,F) = 7+ drop_slice(G,A,B,E,H):4+ take_slice(I,E,H,E,F):4
     [H>=F,I+1>=E,A>=E+1,B>=H,F>=1,E>=2,D+E=A+I,E+G=A,C+E=A+1] 

### Cost equations --> "Loop" of slice/6 
* CEs [282] --> Loop 266 
* CEs [283] --> Loop 267 
* CEs [280] --> Loop 268 
* CEs [281] --> Loop 269 
* CEs [278] --> Loop 270 
* CEs [277] --> Loop 271 
* CEs [276] --> Loop 272 
* CEs [279] --> Loop 273 

#### Loops of slice/6 
* Loop 266: slice(A,B,C,D,E,F) [B>=F,A>=D+2,D>=C,F>=1,C>=2,D+2=C+E] 
* Loop 267: slice(A,B,C,D,E,F) [B>=F,A>=C+1,D+1>=A,F>=1,C>=2,C+E=A+1] 
* Loop 268: slice(A,B,C,D,E,F) [D+1>=C,C>=A,B>=1,A>=2,F=0,E=1] 
* Loop 269: slice(A,B,C,D,E,F) [A>=C+1,C>=2,B>=1,C=D+1,F=0,E=1] 
* Loop 270: slice(A,B,C,D,A,E) [B>=E,D+1>=A,E>=1,A>=2,C=1] 
* Loop 271: slice(A,B,C,D,E,F) [B>=F,A>=D+2,F>=1,D>=1,D+1=E,C=1] 
* Loop 272: slice(A,B,C,D,E,F) [B>=1,A>=2,F=0,E=1,D=0,C=1] 
* Loop 273: slice(A,B,C,D,E,F) [D+1>=C,C>=1,F=0,E=1,B=0,A=1] 

### Ranking functions of CR slice(A,B,C,D,E,F) 

#### Partial ranking functions of CR slice(A,B,C,D,E,F) 


### Resulting Chains:slice(A,B,C,D,E,F) 
* [273]
* [272]
* [271]
* [270]
* [269]
* [268]
* [267]
* [266]


### Merging Chains  slice/6 into  External patterns of execution 
* [[273]] --> 1 
* [[272]] --> 2 
* [[270]] --> 3 
* [[271]] --> 4 
* [[269]] --> 5 
* [[268]] --> 6 
* [[267]] --> 7 
* [[266]] --> 8 


Computing Bounds
=====================================

#### Simplifying cost structure of CE 98 

#### Computing cost of phase [98] 

#### Simplifying cost structure of CE 96 

#### Cost of loops [98] 

 * loop 98:at(A,B,C,D,E) -> [at(A',B',C',D',E')] 
9
##### Pending set at(A,B,C,D,E)
* Psum in Loop 98: [it(98)=<1]

###### Computing sum for it(98)=<1  in Loop 98 
   - Applying inductive sum strategy 
     - head Candidate: B-1 
     - head Candidate: A 
     - head Candidate: A 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B-1 
     - tail Candidate: A 
     - tail Candidate: A 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(98)=<B-1,it(98)=<A,it(98)=<A,it(98)=<B-1,it(98)=<B-B',it(98)=<A-A',it(98)=<A-A',it(98)=<B-B'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [98] 

#### Simplifying cost structure of phase [98] 

#### Cost of phase [98]:at(A,B,C,D,E) -> [at(A',B',C',D',E')] 
9*it(98)+0
  Such that:it(98) =< A
it(98) =< A-A'
it(98) =< B
it(98) =< B-B'

#### Simplifying cost structure of chain [[98],97] 

#### Simplifying cost structure of CE 97 

#### Found solution for phase  [98] in the cache 

#### Cost of phase [98]:at(A,B,C,D,E) -> [at(A',B',C',D',E')] 
9*it(98)+0
  Such that:it(98) =< A
it(98) =< A-A'
it(98) =< B
it(98) =< B-B'

#### Simplifying cost structure of chain [[98],96] 

#### Cost of chains of at(A,B,C,D,E):
* Chain [[98],97]: 9*it(98)+7
  Such that:it(98) =< A

  with precondition: [D=1,A>=1,E>=1,B>=A+2,C>=E] 

* Chain [[98],96]: 9*it(98)+3
  Such that:it(98) =< B

  with precondition: [D=1,E=0,B>=2,C>=1,A+1>=B] 

* Chain [97]: 7
  with precondition: [A=0,D=1,B>=2,E>=1,C>=E] 

* Chain [96]: 3
  with precondition: [B=1,C=0,D=1,E=0,A>=0] 


#### Simplifying cost structure of CE 99 

#### Computing cost of phase [99,100] 

#### Simplifying cost structure of CE 101 

#### Simplifying cost structure of CE 102 

#### Cost of loops [99,100] 

 * loop 99:compress(A,B,C,D) -> [compress(A',B',C',D')] 
10
 * loop 100:compress(A,B,C,D) -> [compress(A',B',C',D')] 
11
##### Pending set compress(A,B,C,D)
* Psum in Loop 99: [it(99)=<1]
* Psum in Loop 100: [it(100)=<1]

###### Computing sum for it(99)=<1  in Loop 99 
   - Applying inductive sum strategy 
     - head Candidate: A-2 
       - Loop 100 is collaborative and bounds [it(100)] 
     - head Candidate: A-2 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-2 
       - Loop 100 is collaborative and bounds [it(100)] 
     - tail Candidate: A-2 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(99)+it(100)=<A-2,it(99)+it(100)=<A-2,it(99)+it(100)=<A-A',it(99)+it(100)=<A-A'] 

##### Pending set A
* Psum in Loop 100: [it(100)=<1]

###### Computing sum for it(100)=<1  in Loop 100 
   - Applying inductive sum strategy 
     - head Candidate: A-2 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A-2 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-2 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-2 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(99)+it(100)=<A-2,it(99)+it(100)=<A-2,it(99)+it(100)=<A-A',it(99)+it(100)=<A-A'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [99,100] 

#### Simplifying cost structure of phase [99,100] 
 * Joined equivalent variables [it(99),it(100)] into it(99)

#### Cost of phase [99,100]:compress(A,B,C,D) -> [compress(A',B',C',D')] 
21*it(99)+0
  Such that:aux(1) =< A
aux(2) =< A-A'
it(99) =< aux(1)
it(99) =< aux(2)

#### Simplifying cost structure of chain [[99,100],101] 
 * Joined equivalent variables [aux(3),aux(1),aux(2)] into aux(3)

#### Simplifying cost structure of CE 100 

#### Cost of chains of compress(A,B,C,D):
* Chain [[99,100],101]: 21*it(99)+7
  Such that:aux(3) =< A
it(99) =< aux(3)

  with precondition: [A>=3,B>=0,C>=2,D>=0,A>=C,A+B>=C+1,A+D>=C+1] 

* Chain [102]: 3
  with precondition: [A=1,C=1,B>=0,D>=0] 

* Chain [101]: 7
  with precondition: [A=2,C=2,B>=0,D>=0] 


#### Simplifying cost structure of CE 104 

#### Simplifying cost structure of CE 103 

#### Cost of chains of maxNorm(A,B,C):
* Chain [104]: 0
  with precondition: [A=C,B>=0,A>=B+1] 

* Chain [103]: 0
  with precondition: [B=C,A>=0,B>=A] 


#### Simplifying cost structure of CE 105 

#### Computing cost of phase [105,106] 

#### Simplifying cost structure of CE 106 

#### Simplifying cost structure of CE 107 

#### Cost of loops [105,106] 

 * loop 105:concat(A,B,C,D,E,F,G,H,I,J,K,L) -> [concat(A',B',C',D',E',F',G',H',I',J',K',L')] 
5
 * loop 106:concat(A,B,C,D,E,F,G,H,I,J,K,L) -> [concat(A',B',C',D',E',F',G',H',I',J',K',L')] 
5
##### Pending set concat(A,B,C,D,E,F,G,H,I,J,K,L)
* Psum in Loop 105: [it(105)=<1]
* Psum in Loop 106: [it(106)=<1]

###### Computing sum for it(105)=<1  in Loop 105 
   - Applying inductive sum strategy 
     - head Candidate: C-1 
       - Loop 106 is collaborative and bounds [it(106)] 
     - head Candidate: A-1 
       - Loop 106 is collaborative and bounds [it(106)] 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - Loop 106 is collaborative and bounds [it(106)] 
     - tail Candidate: A-1 
       - Loop 106 is collaborative and bounds [it(106)] 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(105)+it(106)=<C-1,it(105)+it(106)=<A-1,it(105)+it(106)=<A-1,it(105)+it(106)=<C-1,it(105)+it(106)=<C-C',it(105)+it(106)=<A-A',it(105)+it(106)=<A-A',it(105)+it(106)=<C-C'] 

##### Pending set A
* Psum in Loop 106: [it(106)=<1]

###### Computing sum for it(106)=<1  in Loop 106 
   - Applying inductive sum strategy 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(105)+it(106)=<C-1,it(105)+it(106)=<A-1,it(105)+it(106)=<A-1,it(105)+it(106)=<C-1,it(105)+it(106)=<C-C',it(105)+it(106)=<A-A',it(105)+it(106)=<A-A',it(105)+it(106)=<C-C'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [105,106] 

#### Simplifying cost structure of phase [105,106] 
 * Joined equivalent variables [it(105),it(106)] into it(105)

#### Cost of phase [105,106]:concat(A,B,C,D,E,F,G,H,I,J,K,L) -> [concat(A',B',C',D',E',F',G',H',I',J',K',L')] 
10*it(105)+0
  Such that:aux(4) =< A
aux(5) =< A-A'
aux(6) =< C
aux(7) =< C-C'
it(105) =< aux(4)
it(105) =< aux(5)
it(105) =< aux(6)
it(105) =< aux(7)

#### Simplifying cost structure of chain [[105,106],107] 
 * Joined equivalent variables [aux(8),aux(4),aux(5),aux(6),aux(7)] into aux(8)

#### Cost of chains of concat(A,B,C,D,E,F,G,H,I,J,K,L):
* Chain [[105,106],107]: 10*it(105)+2
  Such that:aux(8) =< A
it(105) =< aux(8)

  with precondition: [A=C,A+E=I+1,A+G=K+1,A>=2,B>=0,D>=1,E>=1,F>=0,G>=1,H>=0,L>=1,J>=F,L>=H,D+H>=L] 

* Chain [107]: 2
  with precondition: [A=1,C=1,D=0,E=I,F=J,G=K,H=L,B>=0,E>=0,F>=0,G>=0,H>=0] 


#### Simplifying cost structure of CE 111 

#### Computing cost of phase [111] 

#### Simplifying cost structure of CE 110 

#### Cost of loops [111] 

 * loop 111:drop_aux(A,B,C,D,E,F) -> [drop_aux(A',B',C',D',E',F')] 
7
##### Pending set drop_aux(A,B,C,D,E,F)
* Psum in Loop 111: [it(111)=<1]

###### Computing sum for it(111)=<1  in Loop 111 
   - Applying inductive sum strategy 
     - head Candidate: C-1 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(111)=<C-1,it(111)=<C-1,it(111)=<C-C',it(111)=<C-C'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [111] 

#### Simplifying cost structure of phase [111] 

#### Cost of phase [111]:drop_aux(A,B,C,D,E,F) -> [drop_aux(A',B',C',D',E',F')] 
7*it(111)+0
  Such that:it(111) =< C
it(111) =< C-C'

#### Simplifying cost structure of chain [[111],108] 

#### Computing cost of phase [109,110] 

#### Simplifying cost structure of CE 108 

#### Simplifying cost structure of CE 109 

#### Cost of loops [109,110] 

 * loop 109:drop_aux(A,B,C,D,E,F) -> [drop_aux(A',B',C',D',E',F')] 
9
 * loop 110:drop_aux(A,B,C,D,E,F) -> [drop_aux(A',B',C',D',E',F')] 
9
##### Pending set drop_aux(A,B,C,D,E,F)
* Psum in Loop 109: [it(109)=<1]
* Psum in Loop 110: [it(110)=<1]

###### Computing sum for it(109)=<1  in Loop 109 
   - Applying inductive sum strategy 
     - head Candidate: C-1 
       - Loop 110 is collaborative and bounds [it(110)] 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - Loop 110 is collaborative and bounds [it(110)] 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(109)+it(110)=<C-1,it(109)+it(110)=<C-1,it(109)+it(110)=<C-C',it(109)+it(110)=<C-C'] 

##### Pending set A
* Psum in Loop 110: [it(110)=<1]

###### Computing sum for it(110)=<1  in Loop 110 
   - Applying inductive sum strategy 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(109)+it(110)=<C-1,it(109)+it(110)=<C-1,it(109)+it(110)=<C-C',it(109)+it(110)=<C-C'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [109,110] 

#### Simplifying cost structure of phase [109,110] 
 * Joined equivalent variables [it(109),it(110)] into it(109)

#### Cost of phase [109,110]:drop_aux(A,B,C,D,E,F) -> [drop_aux(A',B',C',D',E',F')] 
18*it(109)+0
  Such that:aux(9) =< C
aux(10) =< C-C'
it(109) =< aux(9)
it(109) =< aux(10)

#### Simplifying cost structure of chain [[109,110],108] 
 * Joined equivalent variables [aux(11),aux(9),aux(10)] into aux(11)

#### Cost of chains of drop_aux(A,B,C,D,E,F):
* Chain [[111],108]: 7*it(111)+3
  Such that:it(111) =< C

  with precondition: [A=1,B=1,E=1,F=0,C>=2,D>=1] 

* Chain [[109,110],108]: 18*it(109)+3
  Such that:aux(11) =< C
it(109) =< aux(11)

  with precondition: [C=E,A>=0,C>=2,F>=1,B>=A+1,D>=F] 

* Chain [108]: 3
  with precondition: [C=1,D=0,E=1,F=0,A>=0,B>=1] 


#### Simplifying cost structure of CE 113 
 * Renamed intermediate variables: 
[ (eq(114,1),aux(11))>>s(1), (eq(114,1),it(109))>>s(2)]

#### Simplifying cost structure of CE 114 
 * Renamed intermediate variables: 
[ (eq(112,1),it(111))>>s(3)]

#### Simplifying cost structure of CE 112 

#### Cost of chains of drop(A,B,C,D,E):
* Chain [114]: 5
  with precondition: [A=1,B=0,D=1,E=0,C>=0] 

* Chain [113]: 18*s(2)+5
  Such that:s(1) =< A
s(2) =< s(1)

  with precondition: [C=0,A=D,A>=2,E>=1,B>=E] 

* Chain [112]: 7*s(3)+5
  Such that:s(3) =< A

  with precondition: [C=1,D=1,E=0,A>=2,B>=1] 


#### Simplifying cost structure of CE 115 

#### Computing cost of phase [115,116] 

#### Simplifying cost structure of CE 116 

#### Simplifying cost structure of CE 117 

#### Cost of loops [115,116] 

 * loop 115:duplicate(A,B,C,D) -> [duplicate(A',B',C',D')] 
6
 * loop 116:duplicate(A,B,C,D) -> [duplicate(A',B',C',D')] 
6
##### Pending set duplicate(A,B,C,D)
* Psum in Loop 115: [it(115)=<1]
* Psum in Loop 116: [it(116)=<1]

###### Computing sum for it(115)=<1  in Loop 115 
   - Applying inductive sum strategy 
     - head Candidate: A-1 
       - Loop 116 is collaborative and bounds [it(116)] 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
       - Loop 116 is collaborative and bounds [it(116)] 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(115)+it(116)=<A-1,it(115)+it(116)=<A-1,it(115)+it(116)=<A-A',it(115)+it(116)=<A-A'] 

##### Pending set A
* Psum in Loop 116: [it(116)=<1]

###### Computing sum for it(116)=<1  in Loop 116 
   - Applying inductive sum strategy 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(115)+it(116)=<A-1,it(115)+it(116)=<A-1,it(115)+it(116)=<A-A',it(115)+it(116)=<A-A'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [115,116] 

#### Simplifying cost structure of phase [115,116] 
 * Joined equivalent variables [it(115),it(116)] into it(115)

#### Cost of phase [115,116]:duplicate(A,B,C,D) -> [duplicate(A',B',C',D')] 
12*it(115)+0
  Such that:aux(12) =< A
aux(13) =< A-A'
it(115) =< aux(12)
it(115) =< aux(13)

#### Simplifying cost structure of chain [[115,116],117] 
 * Joined equivalent variables [aux(14),aux(12),aux(13)] into aux(14)

#### Cost of chains of duplicate(A,B,C,D):
* Chain [[115,116],117]: 12*it(115)+3
  Such that:aux(14) =< A
it(115) =< aux(14)

  with precondition: [2*A=C+1,A>=2,D>=1,B>=D] 

* Chain [117]: 3
  with precondition: [A=1,B=0,C=1,D=0] 


#### Simplifying cost structure of CE 118 

#### Computing cost of phase [118,119,120] 

#### Simplifying cost structure of CE 121 

#### Simplifying cost structure of CE 123 

#### Simplifying cost structure of CE 122 

#### Cost of loops [118,119,120] 

 * loop 118:encode_aux(A,B,C,D,E,F,G,H,I) -> [encode_aux(A',B',C',D',E',F',G',H',I')] 
11
 * loop 119:encode_aux(A,B,C,D,E,F,G,H,I) -> [encode_aux(A',B',C',D',E',F',G',H',I')] 
14
 * loop 120:encode_aux(A,B,C,D,E,F,G,H,I) -> [encode_aux(A',B',C',D',E',F',G',H',I')] 
14
##### Pending set encode_aux(A,B,C,D,E,F,G,H,I)
* Psum in Loop 118: [it(118)=<1]
* Psum in Loop 119: [it(119)=<1]
* Psum in Loop 120: [it(120)=<1]

###### Computing sum for it(118)=<1  in Loop 118 
   - Applying inductive sum strategy 
     - head Candidate: E-2 
       - Loop 119 is collaborative and bounds [it(119)] 
       - Loop 120 is collaborative and bounds [it(120)] 
     - head Candidate: E-2 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: E-2 
       - Loop 119 is collaborative and bounds [it(119)] 
       - Loop 120 is collaborative and bounds [it(120)] 
     - tail Candidate: E-2 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(118)+it(119)+it(120)=<E-2,it(118)+it(119)+it(120)=<E-2,it(118)+it(119)+it(120)=<E-E',it(118)+it(119)+it(120)=<E-E'] 

##### Pending set A
* Psum in Loop 119: [it(119)=<1]
* Psum in Loop 120: [it(120)=<1]

###### Computing sum for it(119)=<1  in Loop 119 
   - Applying inductive sum strategy 
     - head Candidate: E-2 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: E-2 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: E-2 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: E-2 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(118)+it(119)+it(120)=<E-2,it(118)+it(119)+it(120)=<E-2,it(118)+it(119)+it(120)=<E-E',it(118)+it(119)+it(120)=<E-E'] 

##### Pending set A
* Psum in Loop 120: [it(120)=<1]

###### Computing sum for it(120)=<1  in Loop 120 
   - Applying inductive sum strategy 
     - head Candidate: E-2 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: -B+1 
       - Loop 118 is collaborative
       - Loop 119 is collaborative
     - head Candidate: E-2 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: E-2 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: -B+1 
       - Loop 118 is collaborative
       - Loop 119 is collaborative
     - tail Candidate: E-2 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(118)+it(119)+it(120)=<E-2,it(120)=< -B+1,it(118)+it(119)+it(120)=<E-2,it(118)+it(119)+it(120)=<E-E',it(120)=< -B+B',it(118)+it(119)+it(120)=<E-E'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [118,119,120] 

#### Simplifying cost structure of phase [118,119,120] 
 * Joined equivalent variables [it(118),it(119)] into it(118)

#### Cost of phase [118,119,120]:encode_aux(A,B,C,D,E,F,G,H,I) -> [encode_aux(A',B',C',D',E',F',G',H',I')] 
25*it(118)+14*it(120)+0
  Such that:it(120) =< -B+1
it(120) =< -B+B'
aux(15) =< E
aux(16) =< E-E'
it(118) =< aux(15)
it(120) =< aux(15)
it(118) =< aux(16)
it(120) =< aux(16)

#### Simplifying cost structure of chain [[118,119,120],122] 
 * Joined equivalent variables [aux(17),aux(15),aux(16)] into aux(17)

#### Simplifying cost structure of CE 119 

#### Found solution for phase  [118,119,120] in the cache 

#### Cost of phase [118,119,120]:encode_aux(A,B,C,D,E,F,G,H,I) -> [encode_aux(A',B',C',D',E',F',G',H',I')] 
25*it(118)+14*it(120)+0
  Such that:it(120) =< -B+1
it(120) =< -B+B'
aux(15) =< E
aux(16) =< E-E'
it(118) =< aux(15)
it(120) =< aux(15)
it(118) =< aux(16)
it(120) =< aux(16)

#### Simplifying cost structure of chain [[118,119,120],121] 
 * Joined equivalent variables [aux(18),aux(15),aux(16)] into aux(18)

#### Simplifying cost structure of CE 120 

#### Cost of chains of encode_aux(A,B,C,D,E,F,G,H,I):
* Chain [[118,119,120],122]: 25*it(118)+9
  Such that:aux(17) =< E
it(118) =< aux(17)

  with precondition: [B=0,G=1,C+1=H,A>=0,C>=1,D>=0,E>=3,F>=0,I>=D,I+1>=A+E] 

* Chain [[118,119,120],121]: 25*it(118)+14*it(120)+9
  Such that:it(120) =< -B+1
it(120) =< -B+G
aux(18) =< E
it(118) =< aux(18)
it(120) =< aux(18)

  with precondition: [A>=0,B>=0,D>=0,E>=3,F>=0,G>=1,I>=A+1,C>=B+1,G>=B,I>=D,B+F>=1,F+I>=A+2,C+E>=H+1,H+I>=A+C+3,B+H>=C+G+1,C+E+F>=H+2] 

* Chain [123]: 3
  with precondition: [A=0,B=0,C=1,E=1,G=0,H=1,D>=0,F>=0,I>=0] 

* Chain [122]: 9
  with precondition: [B=0,E=2,G=1,C+1=H,A>=0,C>=1,D>=0,F>=0,I>=A+1,I>=D] 


#### Simplifying cost structure of CE 124 

#### Simplifying cost structure of CE 125 
 * Renamed intermediate variables: 
[ (eq(126,1),aux(17))>>s(4), (eq(126,1),it(118))>>s(5)]

#### Simplifying cost structure of CE 126 
 * Renamed intermediate variables: 
[ (eq(127,1),it(120))>>s(6), (eq(127,1),aux(18))>>s(7), (eq(127,1),it(118))>>s(8)]

#### Simplifying cost structure of CE 127 

#### Cost of chains of encode(A,B,C,D,E):
* Chain [127]: 6
  with precondition: [A=1,C=0,D=1,B>=0,E>=0] 

* Chain [126]: 12
  with precondition: [A=2,C=1,D=2,B>=0,E>=1] 

* Chain [125]: 25*s(5)+12
  Such that:s(4) =< A
s(5) =< s(4)

  with precondition: [C=1,D=2,A>=3,B>=0,E+1>=A] 

* Chain [124]: 14*s(6)+25*s(8)+12
  Such that:s(6) =< 1
s(7) =< A
s(8) =< s(7)
s(6) =< s(7)

  with precondition: [B>=1,C>=1,E>=1,D>=C+2,A>=D] 


#### Simplifying cost structure of CE 129 

#### Simplifying cost structure of CE 128 

#### Cost of chains of case_10(A,B,C,D,E):
* Chain [129]: 2
  with precondition: [A=1,C=1,E=1,B>=0,D>=0] 

* Chain [128]: 3
  with precondition: [A=1,E=0,B>=0,C>=2,D>=0] 


#### Simplifying cost structure of CE 131 

#### Simplifying cost structure of CE 130 

#### Cost of chains of and_op(A,B,C):
* Chain [131]: 0
  with precondition: [A=0,C=0,B>=0] 

* Chain [130]: 0
  with precondition: [A=1,C=B,C>=0] 


#### Simplifying cost structure of CE 134 

#### Simplifying cost structure of CE 133 

#### Simplifying cost structure of CE 132 

#### Cost of chains of eq(A,B,C):
* Chain [134]: 0
  with precondition: [C=0,A>=0,B>=A+1] 

* Chain [133]: 0
  with precondition: [C=0,B>=0,A>=B+1] 

* Chain [132]: 0
  with precondition: [C=1,A=B,A>=0] 


#### Simplifying cost structure of CE 136 

#### Computing cost of phase [135,136,137] 

#### Simplifying cost structure of CE 140 

#### Simplifying cost structure of CE 138 

#### Simplifying cost structure of CE 139 

#### Cost of loops [135,136,137] 

 * loop 135:eq_lists(A,B,C,D,E) -> [eq_lists(A',B',C',D',E')] 
9
 * loop 136:eq_lists(A,B,C,D,E) -> [eq_lists(A',B',C',D',E')] 
9
 * loop 137:eq_lists(A,B,C,D,E) -> [eq_lists(A',B',C',D',E')] 
9
##### Pending set eq_lists(A,B,C,D,E)
* Psum in Loop 135: [it(135)=<1]
* Psum in Loop 136: [it(136)=<1]
* Psum in Loop 137: [it(137)=<1]

###### Computing sum for it(135)=<1  in Loop 135 
   - Applying inductive sum strategy 
     - head Candidate: C-1 
       - Loop 136 is collaborative and bounds [it(136)] 
       - Loop 137 is collaborative and bounds [it(137)] 
     - head Candidate: A-1 
       - Loop 136 is collaborative and bounds [it(136)] 
       - Loop 137 is collaborative and bounds [it(137)] 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - Loop 136 is collaborative and bounds [it(136)] 
       - Loop 137 is collaborative and bounds [it(137)] 
     - tail Candidate: A-1 
       - Loop 136 is collaborative and bounds [it(136)] 
       - Loop 137 is collaborative and bounds [it(137)] 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(135)+it(136)+it(137)=<C-1,it(135)+it(136)+it(137)=<A-1,it(135)+it(136)+it(137)=<A-1,it(135)+it(136)+it(137)=<C-1,it(135)+it(136)+it(137)=<C-C',it(135)+it(136)+it(137)=<A-A',it(135)+it(136)+it(137)=<A-A',it(135)+it(136)+it(137)=<C-C'] 

##### Pending set A
* Psum in Loop 136: [it(136)=<1]
* Psum in Loop 137: [it(137)=<1]

###### Computing sum for it(136)=<1  in Loop 136 
   - Applying inductive sum strategy 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(135)+it(136)+it(137)=<C-1,it(135)+it(136)+it(137)=<A-1,it(135)+it(136)+it(137)=<A-1,it(135)+it(136)+it(137)=<C-1,it(135)+it(136)+it(137)=<C-C',it(135)+it(136)+it(137)=<A-A',it(135)+it(136)+it(137)=<A-A',it(135)+it(136)+it(137)=<C-C'] 

##### Pending set A
* Psum in Loop 137: [it(137)=<1]

###### Computing sum for it(137)=<1  in Loop 137 
   - Applying inductive sum strategy 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(135)+it(136)+it(137)=<C-1,it(135)+it(136)+it(137)=<A-1,it(135)+it(136)+it(137)=<A-1,it(135)+it(136)+it(137)=<C-1,it(135)+it(136)+it(137)=<C-C',it(135)+it(136)+it(137)=<A-A',it(135)+it(136)+it(137)=<A-A',it(135)+it(136)+it(137)=<C-C'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [135,136,137] 

#### Simplifying cost structure of phase [135,136,137] 
 * Joined equivalent variables [it(135),it(136),it(137)] into it(135)

#### Cost of phase [135,136,137]:eq_lists(A,B,C,D,E) -> [eq_lists(A',B',C',D',E')] 
27*it(135)+0
  Such that:aux(19) =< A
aux(20) =< A-A'
aux(21) =< C
aux(22) =< C-C'
it(135) =< aux(19)
it(135) =< aux(20)
it(135) =< aux(21)
it(135) =< aux(22)

#### Simplifying cost structure of chain [[135,136,137],140] 
 * Joined equivalent variables [aux(23),aux(19),aux(20),aux(21),aux(22)] into aux(23)

#### Simplifying cost structure of CE 137 

#### Found solution for phase  [135,136,137] in the cache 

#### Cost of phase [135,136,137]:eq_lists(A,B,C,D,E) -> [eq_lists(A',B',C',D',E')] 
27*it(135)+0
  Such that:aux(19) =< A
aux(20) =< A-A'
aux(21) =< C
aux(22) =< C-C'
it(135) =< aux(19)
it(135) =< aux(20)
it(135) =< aux(21)
it(135) =< aux(22)

#### Simplifying cost structure of chain [[135,136,137],139] 
 * Joined equivalent variables [aux(24),aux(19),aux(20),aux(22)] into aux(24)

#### Simplifying cost structure of CE 135 

#### Found solution for phase  [135,136,137] in the cache 

#### Cost of phase [135,136,137]:eq_lists(A,B,C,D,E) -> [eq_lists(A',B',C',D',E')] 
27*it(135)+0
  Such that:aux(19) =< A
aux(20) =< A-A'
aux(21) =< C
aux(22) =< C-C'
it(135) =< aux(19)
it(135) =< aux(20)
it(135) =< aux(21)
it(135) =< aux(22)

#### Simplifying cost structure of chain [[135,136,137],138] 
 * Joined equivalent variables [aux(25),aux(20),aux(21),aux(22)] into aux(25)

#### Cost of chains of eq_lists(A,B,C,D,E):
* Chain [[135,136,137],140]: 27*it(135)+5
  Such that:aux(23) =< A
it(135) =< aux(23)

  with precondition: [A=C,1>=E,A>=2,B>=0,D>=0,E>=0,B+D+E>=1] 

* Chain [[135,136,137],139]: 27*it(135)+6
  Such that:aux(21) =< C
aux(24) =< A
it(135) =< aux(24)
it(135) =< aux(21)

  with precondition: [E=0,A>=2,B>=0,D>=0,C>=A+1] 

* Chain [[135,136,137],138]: 27*it(135)+6
  Such that:aux(19) =< A
aux(25) =< C
it(135) =< aux(19)
it(135) =< aux(25)

  with precondition: [E=0,B>=0,C>=2,D>=0,A>=C+1] 

* Chain [140]: 5
  with precondition: [A=1,C=1,E=1,B>=0,D>=0] 

* Chain [139]: 6
  with precondition: [A=1,E=0,B>=0,C>=2,D>=0] 

* Chain [138]: 6
  with precondition: [C=1,E=0,A>=2,B>=0,D>=0] 


#### Simplifying cost structure of CE 144 

#### Simplifying cost structure of CE 146 

#### Computing cost of phase [144,145] 

#### Simplifying cost structure of CE 141 

#### Simplifying cost structure of CE 142 

#### Cost of loops [144,145] 

 * loop 144:insertAt(A,B,C,D,E,F) -> [insertAt(A',B',C',D',E',F')] 
10
 * loop 145:insertAt(A,B,C,D,E,F) -> [insertAt(A',B',C',D',E',F')] 
10
##### Pending set insertAt(A,B,C,D,E,F)
* Psum in Loop 144: [it(144)=<1]
* Psum in Loop 145: [it(145)=<1]

###### Computing sum for it(144)=<1  in Loop 144 
   - Applying inductive sum strategy 
     - head Candidate: B-1 
       - Loop 145 is collaborative and bounds [it(145)] 
     - head Candidate: C-1 
       - Loop 145 is collaborative and bounds [it(145)] 
     - head Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B-1 
       - Loop 145 is collaborative and bounds [it(145)] 
     - tail Candidate: C-1 
       - Loop 145 is collaborative and bounds [it(145)] 
     - tail Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(144)+it(145)=<B-1,it(144)+it(145)=<C-1,it(144)+it(145)=<B-1,it(144)+it(145)=<C-1,it(144)+it(145)=<B-B',it(144)+it(145)=<C-C',it(144)+it(145)=<B-B',it(144)+it(145)=<C-C'] 

##### Pending set A
* Psum in Loop 145: [it(145)=<1]

###### Computing sum for it(145)=<1  in Loop 145 
   - Applying inductive sum strategy 
     - head Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(144)+it(145)=<B-1,it(144)+it(145)=<C-1,it(144)+it(145)=<B-1,it(144)+it(145)=<C-1,it(144)+it(145)=<B-B',it(144)+it(145)=<C-C',it(144)+it(145)=<B-B',it(144)+it(145)=<C-C'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [144,145] 

#### Simplifying cost structure of phase [144,145] 
 * Joined equivalent variables [it(144),it(145)] into it(144)

#### Cost of phase [144,145]:insertAt(A,B,C,D,E,F) -> [insertAt(A',B',C',D',E',F')] 
20*it(144)+0
  Such that:aux(26) =< B
aux(27) =< B-B'
aux(28) =< C
aux(29) =< C-C'
it(144) =< aux(26)
it(144) =< aux(27)
it(144) =< aux(28)
it(144) =< aux(29)

#### Simplifying cost structure of chain [[144,145],143] 
 * Joined equivalent variables [aux(30),aux(26),aux(27),aux(29)] into aux(30)

#### Simplifying cost structure of CE 145 

#### Simplifying cost structure of CE 147 

#### Found solution for phase  [144,145] in the cache 

#### Cost of phase [144,145]:insertAt(A,B,C,D,E,F) -> [insertAt(A',B',C',D',E',F')] 
20*it(144)+0
  Such that:aux(26) =< B
aux(27) =< B-B'
aux(28) =< C
aux(29) =< C-C'
it(144) =< aux(26)
it(144) =< aux(27)
it(144) =< aux(28)
it(144) =< aux(29)

#### Simplifying cost structure of chain [[144,145],142] 
 * Joined equivalent variables [aux(31),aux(26),aux(27),aux(29)] into aux(31)

#### Simplifying cost structure of CE 143 

#### Found solution for phase  [144,145] in the cache 

#### Cost of phase [144,145]:insertAt(A,B,C,D,E,F) -> [insertAt(A',B',C',D',E',F')] 
20*it(144)+0
  Such that:aux(26) =< B
aux(27) =< B-B'
aux(28) =< C
aux(29) =< C-C'
it(144) =< aux(26)
it(144) =< aux(27)
it(144) =< aux(28)
it(144) =< aux(29)

#### Simplifying cost structure of chain [[144,145],141] 
 * Joined equivalent variables [aux(32),aux(27),aux(28),aux(29)] into aux(32)

#### Cost of chains of insertAt(A,B,C,D,E,F):
* Chain [[144,145],143]: 20*it(144)+8
  Such that:aux(28) =< E
aux(30) =< B
it(144) =< aux(30)
it(144) =< aux(28)

  with precondition: [C+1=E,A>=2,B>=2,F>=A,C>=B+1,A+D>=F+1] 

* Chain [[144,145],142]: 20*it(144)+8
  Such that:aux(28) =< E
aux(31) =< B
it(144) =< aux(31)
it(144) =< aux(28)

  with precondition: [C+1=E,A>=1,B>=2,F>=A,C>=B+1,D>=F] 

* Chain [[144,145],141]: 20*it(144)+3
  Such that:aux(26) =< B
aux(32) =< C
it(144) =< aux(26)
it(144) =< aux(32)

  with precondition: [C=E,A>=0,C>=2,F>=1,B>=C,D>=F] 

* Chain [143]: 8
  with precondition: [B=1,C+1=E,A=F,A>=2,C>=2,D>=1] 

* Chain [142]: 8
  with precondition: [B=1,C+1=E,A>=1,C>=2,F>=A,D>=F] 

* Chain [141]: 3
  with precondition: [C=1,D=0,E=1,F=0,A>=0,B>=0] 


#### Simplifying cost structure of CE 148 

#### Computing cost of phase [146,147] 

#### Simplifying cost structure of CE 149 

#### Simplifying cost structure of CE 150 

#### Cost of loops [146,147] 

 * loop 146:aux_rev(A,B,C,D,E,F,G,H,I,J,K,L) -> [aux_rev(A',B',C',D',E',F',G',H',I',J',K',L')] 
5
 * loop 147:aux_rev(A,B,C,D,E,F,G,H,I,J,K,L) -> [aux_rev(A',B',C',D',E',F',G',H',I',J',K',L')] 
5
##### Pending set aux_rev(A,B,C,D,E,F,G,H,I,J,K,L)
* Psum in Loop 146: [it(146)=<1]
* Psum in Loop 147: [it(147)=<1]

###### Computing sum for it(146)=<1  in Loop 146 
   - Applying inductive sum strategy 
     - head Candidate: G-1 
       - Loop 147 is collaborative and bounds [it(147)] 
     - head Candidate: E-1 
       - Loop 147 is collaborative and bounds [it(147)] 
     - head Candidate: E-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: G-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: -D+H 
       - Loop 147 is collaborative
     - tail Candidate: G-1 
       - Loop 147 is collaborative and bounds [it(147)] 
     - tail Candidate: E-1 
       - Loop 147 is collaborative and bounds [it(147)] 
     - tail Candidate: E-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: G-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: -D+H 
       - Loop 147 is collaborative
 * Adding constraints: [it(146)+it(147)=<G-1,it(146)+it(147)=<E-1,it(146)+it(147)=<E-1,it(146)+it(147)=<G-1,it(146)=< -D+H,it(146)+it(147)=<G-G',it(146)+it(147)=<E-E',it(146)+it(147)=<E-E',it(146)+it(147)=<G-G',it(146)=< -D+H+D'-H'] 

##### Pending set A
* Psum in Loop 147: [it(147)=<1]

###### Computing sum for it(147)=<1  in Loop 147 
   - Applying inductive sum strategy 
     - head Candidate: G-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: E-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: E-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: G-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: G-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: E-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: E-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: G-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(146)+it(147)=<G-1,it(146)+it(147)=<E-1,it(146)+it(147)=<E-1,it(146)+it(147)=<G-1,it(146)+it(147)=<G-G',it(146)+it(147)=<E-E',it(146)+it(147)=<E-E',it(146)+it(147)=<G-G'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [146,147] 

#### Simplifying cost structure of phase [146,147] 

#### Cost of phase [146,147]:aux_rev(A,B,C,D,E,F,G,H,I,J,K,L) -> [aux_rev(A',B',C',D',E',F',G',H',I',J',K',L')] 
5*it(146)+5*it(147)+0
  Such that:it(146) =< -D+H
it(146) =< -D+H+D'-H'
aux(33) =< E
aux(34) =< E-E'
aux(35) =< G
aux(36) =< G-G'
it(146) =< aux(33)
it(147) =< aux(33)
it(146) =< aux(34)
it(147) =< aux(34)
it(146) =< aux(35)
it(147) =< aux(35)
it(146) =< aux(36)
it(147) =< aux(36)

#### Simplifying cost structure of chain [[146,147],148] 
 * Joined equivalent variables [aux(37),aux(33),aux(34),aux(35),aux(36)] into aux(37)

#### Cost of chains of aux_rev(A,B,C,D,E,F,G,H,I,J,K,L):
* Chain [[146,147],148]: 5*it(146)+5*it(147)+2
  Such that:it(146) =< -D+H
it(146) =< -D+H+L
aux(37) =< E
it(146) =< aux(37)
it(147) =< aux(37)

  with precondition: [A=C,E=G,A+E=I+1,A+E=K+1,A>=1,B>=0,D>=0,E>=2,F>=0,H>=1,L>=1,J>=B,L>=D] 

* Chain [148]: 2
  with precondition: [E=1,G=1,H=0,C=A,J=B,L=D,C=I,C=K,C>=1,F>=0,J>=0,L>=0] 


#### Simplifying cost structure of CE 151 
 * Renamed intermediate variables: 
[ (eq(152,1),it(146))>>s(9), (eq(152,1),aux(37))>>s(10), (eq(152,1),it(147))>>s(11)]

#### Simplifying cost structure of CE 152 

#### Cost of chains of rev(A,B,C,D,E,F,G,H):
* Chain [150]: 4
  with precondition: [A=1,C=1,D=0,E=1,G=1,H=0,B>=0,F>=0] 

* Chain [149]: 5*s(9)+5*s(11)+4
  Such that:s(10) =< C
s(9) =< D
s(9) =< s(10)
s(11) =< s(10)

  with precondition: [A=C,A=E,A=G,A>=2,B>=0,D>=1,F>=0,H>=1] 


#### Simplifying cost structure of CE 153 
 * Renamed intermediate variables: 
[ (eq(154,1),s(10))>>s(12), (eq(154,1),s(9))>>s(13), (eq(154,1),s(11))>>s(14)]
 * Renamed intermediate variables: 
[ (eq(154,2),aux(23))>>s(15), (eq(154,2),it(135))>>s(16)]

#### Simplifying cost structure of CE 154 
 * Joined equivalent variables [aux(38),s(12),s(15)] into aux(38)
 * Joined equivalent variables [s(13),s(14)] into s(13)
 * Joined equivalent variables [s(13),s(16)] into s(13)

#### Cost of chains of is_palindrome(A,B,C):
* Chain [152]: 11
  with precondition: [A=1,C=1,B>=0] 

* Chain [151]: 37*s(13)+11
  Such that:aux(38) =< A
s(13) =< aux(38)

  with precondition: [1>=C,A>=2,B>=0,C>=0] 


#### Simplifying cost structure of CE 156 

#### Computing cost of phase [155] 

#### Simplifying cost structure of CE 155 

#### Cost of loops [155] 

 * loop 155:last(A,B,C,D) -> [last(A',B',C',D')] 
7
##### Pending set last(A,B,C,D)
* Psum in Loop 155: [it(155)=<1]

###### Computing sum for it(155)=<1  in Loop 155 
   - Applying inductive sum strategy 
     - head Candidate: A-2 
     - head Candidate: A-2 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-2 
     - tail Candidate: A-2 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(155)=<A-2,it(155)=<A-2,it(155)=<A-A',it(155)=<A-A'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [155] 

#### Simplifying cost structure of phase [155] 

#### Cost of phase [155]:last(A,B,C,D) -> [last(A',B',C',D')] 
7*it(155)+0
  Such that:it(155) =< A
it(155) =< A-A'

#### Simplifying cost structure of chain [[155],153] 

#### Simplifying cost structure of CE 157 

#### Cost of chains of last(A,B,C,D):
* Chain [[155],153]: 7*it(155)+6
  Such that:it(155) =< A

  with precondition: [C=1,A>=3,D>=1,B>=D] 

* Chain [154]: 3
  with precondition: [A=1,B=0,C=1,D=0] 

* Chain [153]: 6
  with precondition: [A=2,C=1,D>=1,B>=D] 


#### Simplifying cost structure of CE 158 

#### Simplifying cost structure of CE 159 

#### Computing cost of phase [156] 

#### Simplifying cost structure of CE 162 

#### Cost of loops [156] 

 * loop 156:last_two(A,B,C,D,E) -> [last_two(A',B',C',D',E')] 
10
##### Pending set last_two(A,B,C,D,E)
* Psum in Loop 156: [it(156)=<1]

###### Computing sum for it(156)=<1  in Loop 156 
   - Applying inductive sum strategy 
     - head Candidate: A-3 
     - head Candidate: A-3 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-3 
     - tail Candidate: A-3 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(156)=<A-3,it(156)=<A-3,it(156)=<A-A',it(156)=<A-A'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [156] 

#### Simplifying cost structure of phase [156] 

#### Cost of phase [156]:last_two(A,B,C,D,E) -> [last_two(A',B',C',D',E')] 
10*it(156)+0
  Such that:it(156) =< A
it(156) =< A-A'

#### Simplifying cost structure of chain [[156],157] 

#### Simplifying cost structure of CE 161 

#### Simplifying cost structure of CE 160 

#### Cost of chains of last_two(A,B,C,D,E):
* Chain [[156],157]: 10*it(156)+10
  Such that:it(156) =< A

  with precondition: [C=1,D=1,A>=4,E>=1,B>=E] 

* Chain [159]: 3
  with precondition: [A=1,B=0,C=0,D=1,E=0] 

* Chain [158]: 6
  with precondition: [A=2,C=0,D=1,E=0,B>=1] 

* Chain [157]: 10
  with precondition: [A=3,C=1,D=1,E>=1,B>=E] 


#### Simplifying cost structure of CE 163 

#### Computing cost of phase [160] 

#### Simplifying cost structure of CE 164 

#### Cost of loops [160] 

 * loop 160:aux_length(A,B,C,D,E,F,G,H) -> [aux_length(A',B',C',D',E',F',G',H')] 
6
##### Pending set aux_length(A,B,C,D,E,F,G,H)
* Psum in Loop 160: [it(160)=<1]

###### Computing sum for it(160)=<1  in Loop 160 
   - Applying inductive sum strategy 
     - head Candidate: A-1 
     - head Candidate: C-1 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
     - tail Candidate: C-1 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(160)=<A-1,it(160)=<C-1,it(160)=<A-1,it(160)=<C-1,it(160)=<A-A',it(160)=<C-C',it(160)=<A-A',it(160)=<C-C'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [160] 

#### Simplifying cost structure of phase [160] 

#### Cost of phase [160]:aux_length(A,B,C,D,E,F,G,H) -> [aux_length(A',B',C',D',E',F',G',H')] 
6*it(160)+0
  Such that:it(160) =< A
it(160) =< A-A'
it(160) =< C
it(160) =< C-C'

#### Simplifying cost structure of chain [[160],161] 

#### Cost of chains of aux_length(A,B,C,D,E,F,G,H):
* Chain [[160],161]: 6*it(160)+2
  Such that:it(160) =< A

  with precondition: [A=C,E=F,A+E=G+1,A+E=H+1,A>=2,B>=0,D>=1,E>=0] 

* Chain [161]: 2
  with precondition: [A=1,C=1,D=0,F=E,F=G,F=H,B>=0,F>=0] 


#### Simplifying cost structure of CE 165 
 * Renamed intermediate variables: 
[ (eq(166,1),it(160))>>s(17)]

#### Simplifying cost structure of CE 166 

#### Cost of chains of lengthL(A,B,C,D,E,F):
* Chain [163]: 4
  with precondition: [A=1,C=1,D=0,E=0,F=0,B>=0] 

* Chain [162]: 6*s(17)+4
  Such that:s(17) =< C

  with precondition: [A=C,A=E+1,A=F+1,A>=2,B>=0,D>=1] 


#### Simplifying cost structure of CE 167 

#### Computing cost of phase [164] 

#### Simplifying cost structure of CE 168 

#### Cost of loops [164] 

 * loop 164:minusminus_aux(A,B,C,D) -> [minusminus_aux(A',B',C',D')] 
6
##### Pending set minusminus_aux(A,B,C,D)
* Psum in Loop 164: [it(164)=<1]

###### Computing sum for it(164)=<1  in Loop 164 
   - Applying inductive sum strategy 
     - head Candidate: -A+B+1 
     - head Candidate: -A+B+1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: -A+B+1 
     - tail Candidate: -A+B+1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(164)=< -A+B+1,it(164)=< -A+B+1,it(164)=< -A+B+A'-B',it(164)=< -A+B+A'-B'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [164] 

#### Simplifying cost structure of phase [164] 

#### Cost of phase [164]:minusminus_aux(A,B,C,D) -> [minusminus_aux(A',B',C',D')] 
6*it(164)+0
  Such that:it(164) =< -A+B+1
it(164) =< -A+B+A'-B'

#### Simplifying cost structure of chain [[164],165] 

#### Cost of chains of minusminus_aux(A,B,C,D):
* Chain [[164],165]: 6*it(164)+3
  Such that:it(164) =< -A+B+1

  with precondition: [A+C=B+2,A>=0,B>=A,D>=B] 

 * Renamed intermediate variables: 
[ (eq(170,1),it(164))>>s(18)]

#### Simplifying cost structure of CE 170 
 * Renamed intermediate variables: 
[ (eq(169,1),it(164))>>s(19)]
 * Renamed intermediate variables: 
[ (eq(169,2),s(10))>>s(20), (eq(169,2),s(9))>>s(21), (eq(169,2),s(11))>>s(22)]

#### Simplifying cost structure of CE 169 
 * Joined equivalent variables [s(21),s(22)] into s(21)

#### Cost of chains of case_41(A,B,C,D):
* Chain [167]: 6*s(18)+5
  Such that:s(18) =< -A+B+1

  with precondition: [A+C=B+2,A>=0,B>=A,D>=B] 

* Chain [166]: 6*s(19)+10*s(21)+10
  Such that:s(19) =< A-B+1
s(20) =< A-B+2
s(21) =< s(20)

  with precondition: [A+2=B+C,B>=0,D>=0,A>=B+1] 

 * Renamed intermediate variables: 
[ (eq(172,1),s(18))>>s(23)]

#### Simplifying cost structure of CE 172 
 * Renamed intermediate variables: 
[ (eq(171,1),s(19))>>s(24), (eq(171,1),s(20))>>s(25), (eq(171,1),s(21))>>s(26)]

#### Simplifying cost structure of CE 171 

#### Cost of chains of minusminus(A,B,C,D):
* Chain [169]: 6*s(23)+6
  Such that:s(23) =< -A+B+1

  with precondition: [B+2=A+C,A>=0,B>=A,D>=B] 

* Chain [168]: 6*s(24)+10*s(26)+11
  Such that:s(24) =< A-B+1
s(25) =< A-B+2
s(26) =< s(25)

  with precondition: [B+C=A+2,B>=0,D>=0,A>=B+1] 


#### Simplifying cost structure of CE 174 

#### Simplifying cost structure of CE 173 

#### Cost of chains of case_42(A,B,C):
* Chain [171]: 1
  with precondition: [A=C,A>=0,B>=A+1] 

* Chain [170]: 1
  with precondition: [B=C,B>=0,A>=B] 


#### Simplifying cost structure of CE 175 

#### Simplifying cost structure of CE 176 

#### Cost of chains of minL(A,B,C):
* Chain [173]: 2
  with precondition: [A=C,A>=0,B>=A+1] 

* Chain [172]: 2
  with precondition: [B=C,B>=0,A>=B] 

 * Renamed intermediate variables: 
[ (eq(180,1),aux(8))>>s(27), (eq(180,1),it(105))>>s(28)]

#### Simplifying cost structure of CE 180 

#### Computing cost of phase [177] 

#### Simplifying cost structure of CE 177 

#### Cost of loops [177] 

 * loop 177:rand_select_extract(A,B,C,D,E,F,G,H) -> [rand_select_extract(A',B',C',D',E',F',G',H')] 
10
##### Pending set rand_select_extract(A,B,C,D,E,F,G,H)
* Psum in Loop 177: [it(177)=<1]

###### Computing sum for it(177)=<1  in Loop 177 
   - Applying inductive sum strategy 
     - head Candidate: D-1 
     - head Candidate: C 
     - head Candidate: C 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: D-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: D-1 
     - tail Candidate: C 
     - tail Candidate: C 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: D-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(177)=<D-1,it(177)=<C,it(177)=<C,it(177)=<D-1,it(177)=<D-D',it(177)=<C-C',it(177)=<C-C',it(177)=<D-D'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [177] 

#### Simplifying cost structure of phase [177] 

#### Cost of phase [177]:rand_select_extract(A,B,C,D,E,F,G,H) -> [rand_select_extract(A',B',C',D',E',F',G',H')] 
10*it(177)+0
  Such that:it(177) =< C
it(177) =< C-C'
it(177) =< D
it(177) =< D-D'

#### Simplifying cost structure of chain [[177],175] 

#### Simplifying cost structure of CE 178 

#### Found solution for phase  [177] in the cache 

#### Cost of phase [177]:rand_select_extract(A,B,C,D,E,F,G,H) -> [rand_select_extract(A',B',C',D',E',F',G',H')] 
10*it(177)+0
  Such that:it(177) =< C
it(177) =< C-C'
it(177) =< D
it(177) =< D-D'

#### Simplifying cost structure of chain [[177],174] 

#### Simplifying cost structure of CE 179 

#### Cost of chains of rand_select_extract(A,B,C,D,E,F,G,H):
* Chain [[177],175]: 10*it(177)+10*s(28)+10
  Such that:it(177) =< C
s(27) =< C-D+G+2
s(28) =< s(27)

  with precondition: [F=1,A+D=G+2,A>=1,B>=0,C>=1,E>=0,H>=0,D>=C+2] 

* Chain [[177],174]: 10*it(177)+5
  Such that:it(177) =< D

  with precondition: [F=1,G=1,A>=1,B>=0,D>=2,E>=0,H>=0,C+1>=D] 

* Chain [176]: 10
  with precondition: [A=1,C=0,F=1,D=G+1,B>=0,D>=2,E>=0,H>=0] 

* Chain [174]: 5
  with precondition: [D=1,F=1,G=1,A>=1,B>=0,C>=0,E>=0,H>=0] 


#### Simplifying cost structure of CE 181 

#### Cost of chains of randomL(A,B):
* Chain [178]: 2
  with precondition: [A>=0,B>=0] 


#### Simplifying cost structure of CE 183 
 * Renamed intermediate variables: 
[ (eq(184,2),it(177))>>s(29)]

#### Simplifying cost structure of CE 184 

#### Simplifying cost structure of CE 182 
 * Renamed intermediate variables: 
[ (eq(185,2),it(177))>>s(30), (eq(185,2),s(27))>>s(31), (eq(185,2),s(28))>>s(32)]

#### Simplifying cost structure of CE 185 
 * Joined equivalent variables [aux(39),s(31)] into aux(39)
 * Joined equivalent variables [s(30),s(32)] into s(30)

#### Cost of chains of rand_select_extract_rand(A,B,C,D,E,F):
* Chain [181]: 10
  with precondition: [A=1,D=1,E=1,B>=0,C>=0,F>=0] 

* Chain [180]: 10*s(29)+10
  Such that:s(29) =< A

  with precondition: [D=1,E=1,A>=2,B>=0,C>=0,F>=0] 

* Chain [179]: 20*s(30)+15
  Such that:aux(39) =< A
s(30) =< aux(39)

  with precondition: [D=1,A=E+1,A>=2,B>=0,C>=0,F>=0] 


#### Simplifying cost structure of CE 189 

#### Computing cost of phase [185] 

#### Simplifying cost structure of CE 186 

#### Cost of loops [185] 

 * loop 185:rand_select_aux(A,B,C,D,E,F,G,H) -> [rand_select_aux(A',B',C',D',E',F',G',H')] 
24
##### Pending set rand_select_aux(A,B,C,D,E,F,G,H)
* Psum in Loop 185: [it(185)=<1]

###### Computing sum for it(185)=<1  in Loop 185 
   - Applying inductive sum strategy 
     - head Candidate: F+1 
     - head Candidate: A 
     - head Candidate: A 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: F+1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: F+1 
     - tail Candidate: A 
     - tail Candidate: A 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: F+1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(185)=<F+1,it(185)=<A,it(185)=<A,it(185)=<F+1,it(185)=<F-F',it(185)=<A-A',it(185)=<A-A',it(185)=<F-F'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [185] 

#### Simplifying cost structure of phase [185] 

#### Cost of phase [185]:rand_select_aux(A,B,C,D,E,F,G,H) -> [rand_select_aux(A',B',C',D',E',F',G',H')] 
24*it(185)+0
  Such that:it(185) =< A
it(185) =< A-A'
it(185) =< F+1
it(185) =< F-F'

#### Simplifying cost structure of chain [[185],182] 

#### Computing cost of phase [183] 
 * Renamed intermediate variables: 
[ (eq(188,1),aux(39))>>s(33), (eq(188,1),s(30))>>s(34)]

#### Simplifying cost structure of CE 188 
 * Renamed intermediate variables: 
[ (it(183),s(33))>>s(35), (it(183),s(34))>>s(36)]

#### Cost of loops [183] 

 * loop 183:rand_select_aux(A,B,C,D,E,F,G,H) -> [rand_select_aux(A',B',C',D',E',F',G',H')] 
20*s(36)+29
  Such that:s(35) =< D'+1
s(36) =< s(35)

##### Pending set rand_select_aux(A,B,C,D,E,F,G,H)
* Psum in Loop 183: [it(183)=<1,s(38)=<D'+1]

###### Computing sum for it(183)=<1  in Loop 183 
   - Applying inductive sum strategy 
     - head Candidate: F+1 
     - head Candidate: D-1 
     - head Candidate: A 
     - head Candidate: A 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: D-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: F+1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: F+1 
     - tail Candidate: D-1 
     - tail Candidate: A 
     - tail Candidate: A 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: D-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: F+1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(183)=<F+1,it(183)=<D-1,it(183)=<A,it(183)=<A,it(183)=<D-1,it(183)=<F+1,it(183)=<F-F',it(183)=<D-D',it(183)=<A-A',it(183)=<A-A',it(183)=<D-D',it(183)=<F-F'] 

##### Pending set A
* Psum in Loop 183: [s(38)=<D'+1]

###### Computing sum for s(38)=<D'+1  in Loop 183 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(40)=<D] 
 * Adding constraints: [s(38)=<it(183)*aux(40)] 

##### Pending set rand_select_aux(A,B,C,D,E,F,G,H)
* Pmax/min: [aux(40)=<D]

###### Computing max_min for aux(40)=<D  
   - Found a solution using transitive invariants 
 * Adding constraints:[aux(40)=<D] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [183] 

#### Simplifying cost structure of phase [183] 
 * Joined equivalent variables [aux(41),aux(40)] into aux(41)

#### Cost of phase [183]:rand_select_aux(A,B,C,D,E,F,G,H) -> [rand_select_aux(A',B',C',D',E',F',G',H')] 
29*it(183)+20*s(37)+0
  Such that:it(183) =< A
it(183) =< A-A'
it(183) =< D-D'
it(183) =< F+1
it(183) =< F-F'
aux(41) =< D
it(183) =< aux(41)
s(38) =< it(183)*aux(41)
s(37) =< s(38)

#### Simplifying cost structure of chain [[183],[185],182] 
 * Joined equivalent variables [aux(42),aux(41)] into aux(42)
 * Renamed intermediate variables: 
[ (eq(187,1),s(29))>>s(39)]

#### Simplifying cost structure of CE 187 

#### Simplifying cost structure of chain [184,[185],182] 

#### Found solution for phase  [183] in the cache 

#### Cost of phase [183]:rand_select_aux(A,B,C,D,E,F,G,H) -> [rand_select_aux(A',B',C',D',E',F',G',H')] 
29*it(183)+20*s(37)+0
  Such that:it(183) =< A
it(183) =< A-A'
it(183) =< D-D'
it(183) =< F+1
it(183) =< F-F'
aux(41) =< D
it(183) =< aux(41)
s(38) =< it(183)*aux(41)
s(37) =< s(38)

#### Simplifying cost structure of chain [[183],184,[185],182] 
 * Joined equivalent variables [aux(44),aux(41)] into aux(44)

#### Simplifying cost structure of chain [184,182] 

#### Found solution for phase  [183] in the cache 

#### Cost of phase [183]:rand_select_aux(A,B,C,D,E,F,G,H) -> [rand_select_aux(A',B',C',D',E',F',G',H')] 
29*it(183)+20*s(37)+0
  Such that:it(183) =< A
it(183) =< A-A'
it(183) =< D-D'
it(183) =< F+1
it(183) =< F-F'
aux(41) =< D
it(183) =< aux(41)
s(38) =< it(183)*aux(41)
s(37) =< s(38)

#### Simplifying cost structure of chain [[183],184,182] 

#### Found solution for phase  [183] in the cache 

#### Cost of phase [183]:rand_select_aux(A,B,C,D,E,F,G,H) -> [rand_select_aux(A',B',C',D',E',F',G',H')] 
29*it(183)+20*s(37)+0
  Such that:it(183) =< A
it(183) =< A-A'
it(183) =< D-D'
it(183) =< F+1
it(183) =< F-F'
aux(41) =< D
it(183) =< aux(41)
s(38) =< it(183)*aux(41)
s(37) =< s(38)

#### Simplifying cost structure of chain [[183],182] 
 * Renamed intermediate variables: 
[ (ch([184,182]),s(39))>>s(40)]
 * Renamed intermediate variables: 
[ (ch([[183],182]),it(183))>>s(41), (ch([[183],182]),aux(41))>>s(42), (ch([[183],182]),s(38))>>s(43), (ch([[183],182]),s(37))>>s(44)]
 * Renamed intermediate variables: 
[ (ch([[183],184,182]),s(39))>>s(45), (ch([[183],184,182]),it(183))>>s(46), (ch([[183],184,182]),aux(41))>>s(47), (ch([[183],184,182]),s(38))>>s(48), (ch([[183],184,182]),s(37))>>s(49)]
 * Joined equivalent variables [aux(46),s(42),s(47)] into aux(46)
 * Joined equivalent variables [s(41),s(46)] into s(41)
 * Joined equivalent variables [s(43),s(48)] into s(43)
 * Joined equivalent variables [s(44),s(49)] into s(44)
 * Renamed intermediate variables: 
[ (ch([184,[185],182]),it(185))>>s(50), (ch([184,[185],182]),s(39))>>s(51)]
 * Renamed intermediate variables: 
[ (ch([[183],184,[185],182]),aux(43))>>s(52), (ch([[183],184,[185],182]),aux(44))>>s(53), (ch([[183],184,[185],182]),it(183))>>s(54), (ch([[183],184,[185],182]),it(185))>>s(55), (ch([[183],184,[185],182]),s(39))>>s(56), (ch([[183],184,[185],182]),s(38))>>s(57), (ch([[183],184,[185],182]),s(37))>>s(58)]
 * Renamed intermediate variables: 
[ (ch([[183],[185],182]),it(185))>>s(59), (ch([[183],[185],182]),aux(42))>>s(60), (ch([[183],[185],182]),it(183))>>s(61), (ch([[183],[185],182]),s(38))>>s(62), (ch([[183],[185],182]),s(37))>>s(63)]
 * Joined equivalent variables [aux(47),s(53),s(60)] into aux(47)
 * Joined equivalent variables [s(51),s(56),s(61)] into s(51)

#### Cost of chains of rand_select_aux(A,B,C,D,E,F,G,H):
* Chain [[185],182]: 24*it(185)+3
  Such that:it(185) =< A

  with precondition: [D=1,A+B=G,A>=1,B>=1,C>=0,E>=0,F>=A,H>=C] 

* Chain [[183],[185],182]: 29*it(183)+24*it(185)+20*s(37)+3
  Such that:it(185) =< A-D+1
aux(42) =< D
it(183) =< aux(42)
s(38) =< it(183)*aux(42)
s(37) =< s(38)

  with precondition: [A+B=G,B>=1,C>=0,D>=2,E>=0,F>=A,H>=C,A>=D] 

* Chain [[183],184,[185],182]: 29*it(183)+24*it(185)+20*s(37)+10*s(39)+27
  Such that:aux(43) =< -B+G
aux(44) =< D
it(183) =< aux(43)
it(185) =< aux(43)
it(183) =< aux(44)
s(39) =< aux(44)
s(38) =< it(183)*aux(44)
s(37) =< s(38)

  with precondition: [A+B=G,A>=3,B>=1,C>=0,D>=3,E>=0,F>=A,H>=C] 

* Chain [[183],184,182]: 29*it(183)+20*s(37)+10*s(39)+27
  Such that:s(39) =< -A+D+1
it(183) =< A
aux(41) =< D
it(183) =< aux(41)
s(38) =< it(183)*aux(41)
s(37) =< s(38)

  with precondition: [A+B=G,A>=2,B>=1,C>=0,E>=0,D>=A+1,F>=A,H>=C] 

* Chain [[183],182]: 29*it(183)+20*s(37)+3
  Such that:it(183) =< A
aux(41) =< D
it(183) =< aux(41)
s(38) =< it(183)*aux(41)
s(37) =< s(38)

  with precondition: [A+B=G,A>=1,B>=1,C>=0,E>=0,D>=A+1,F>=A,H>=C] 

* Chain [184,[185],182]: 24*it(185)+10*s(39)+27
  Such that:it(185) =< A
s(39) =< D

  with precondition: [A+B=G,A>=2,B>=1,C>=0,D>=2,E>=0,F>=A,H>=C] 

* Chain [184,182]: 10*s(39)+27
  Such that:s(39) =< D

  with precondition: [A=1,G=B+1,C>=0,D>=2,E>=0,F>=1,G>=2,H>=C] 

* Chain [182]: 3
  with precondition: [A=0,G=B,H=C,D>=0,E>=0,F>=0,G>=1,H>=0] 


#### Simplifying cost structure of CE 190 
 * Renamed intermediate variables: 
[ (eq(191,1),s(17))>>s(64)]

#### Simplifying cost structure of CE 191 
 * Renamed intermediate variables: 
[ (eq(192,1),s(17))>>s(65)]
 * Renamed intermediate variables: 
[ (eq(192,3),s(45))>>s(66), (eq(192,3),aux(45))>>s(67), (eq(192,3),aux(46))>>s(68), (eq(192,3),s(41))>>s(69), (eq(192,3),s(40))>>s(70), (eq(192,3),s(43))>>s(71), (eq(192,3),s(44))>>s(72)]

#### Simplifying cost structure of CE 192 
 * Joined equivalent variables [aux(48),s(68)] into aux(48)
 * Joined equivalent variables [s(65),s(70)] into s(65)
 * Renamed intermediate variables: 
[ (eq(193,1),s(17))>>s(73)]
 * Renamed intermediate variables: 
[ (eq(193,3),s(50))>>s(74), (eq(193,3),s(59))>>s(75), (eq(193,3),s(52))>>s(76), (eq(193,3),aux(47))>>s(77), (eq(193,3),s(51))>>s(78), (eq(193,3),s(62))>>s(79), (eq(193,3),s(63))>>s(80), (eq(193,3),s(54))>>s(81), (eq(193,3),s(55))>>s(82), (eq(193,3),s(57))>>s(83), (eq(193,3),s(58))>>s(84)]

#### Simplifying cost structure of CE 193 
 * Joined equivalent variables [aux(49),s(77)] into aux(49)
 * Joined equivalent variables [aux(50),s(76)] into aux(50)
 * Joined equivalent variables [s(73),s(78)] into s(73)
 * Joined equivalent variables [s(74),s(82)] into s(74)
 * Joined equivalent variables [aux(51),aux(48),aux(49)] into aux(51)
 * Joined equivalent variables [aux(52),aux(50),s(67)] into aux(52)
 * Joined equivalent variables [s(65),s(73)] into s(65)
 * Joined equivalent variables [s(69),s(81)] into s(69)
 * Joined equivalent variables [s(71),s(83)] into s(71)
 * Joined equivalent variables [s(72),s(84)] into s(72)
 * Renamed intermediate variables: 
[ (eq(194,1),s(17))>>s(85)]
 * Renamed intermediate variables: 
[ (eq(194,3),s(45))>>s(86), (eq(194,3),aux(45))>>s(87), (eq(194,3),aux(46))>>s(88), (eq(194,3),s(41))>>s(89), (eq(194,3),s(40))>>s(90), (eq(194,3),s(43))>>s(91), (eq(194,3),s(44))>>s(92)]

#### Simplifying cost structure of CE 194 
 * Joined equivalent variables [aux(53),s(87),s(88)] into aux(53)
 * Joined equivalent variables [s(85),s(89),s(90)] into s(85)
 * Renamed intermediate variables: 
[ (eq(195,1),s(17))>>s(93)]
 * Renamed intermediate variables: 
[ (eq(195,3),s(50))>>s(94), (eq(195,3),s(59))>>s(95), (eq(195,3),s(52))>>s(96), (eq(195,3),aux(47))>>s(97), (eq(195,3),s(51))>>s(98), (eq(195,3),s(62))>>s(99), (eq(195,3),s(63))>>s(100), (eq(195,3),s(54))>>s(101), (eq(195,3),s(55))>>s(102), (eq(195,3),s(57))>>s(103), (eq(195,3),s(58))>>s(104)]

#### Simplifying cost structure of CE 195 
 * Joined equivalent variables [aux(54),s(96),s(97)] into aux(54)
 * Joined equivalent variables [s(93),s(94)] into s(93)
 * Joined equivalent variables [s(93),s(98),s(101),s(102)] into s(93)
 * Joined equivalent variables [s(99),s(103)] into s(99)
 * Joined equivalent variables [s(100),s(104)] into s(100)
 * Joined equivalent variables [aux(55),aux(53),aux(54)] into aux(55)
 * Joined equivalent variables [s(85),s(93)] into s(85)
 * Joined equivalent variables [s(91),s(99)] into s(91)
 * Joined equivalent variables [s(92),s(100)] into s(92)

#### Cost of chains of rand_select(A,B,C,D,E):
* Chain [189]: 15
  with precondition: [A=1,D=1,B>=0,C>=0,E>=0] 

* Chain [188]: 6*s(64)+15
  Such that:s(64) =< A

  with precondition: [C=0,D=1,A>=2,B>=0,E>=0] 

* Chain [187]: 71*s(65)+10*s(66)+87*s(69)+60*s(72)+48*s(74)+20*s(80)+39
  Such that:s(66) =< A-C+1
aux(51) =< A
aux(52) =< C
s(65) =< aux(51)
s(74) =< aux(52)
s(79) =< s(65)*aux(51)
s(80) =< s(79)
s(69) =< aux(52)
s(69) =< aux(51)
s(71) =< s(69)*aux(51)
s(72) =< s(71)

  with precondition: [C+1=D,B>=0,C>=1,E>=0,A>=C+2] 

* Chain [186]: 206*s(85)+10*s(86)+80*s(92)+39
  Such that:s(86) =< 2
aux(55) =< A
s(85) =< aux(55)
s(91) =< s(85)*aux(55)
s(92) =< s(91)

  with precondition: [A=D,A>=2,B>=0,E>=0,C+1>=A] 

 * Renamed intermediate variables: 
[ (eq(199,1),s(24))>>s(105), (eq(199,1),s(25))>>s(106), (eq(199,1),s(26))>>s(107)]
 * Renamed intermediate variables: 
[ (eq(199,2),s(64))>>s(108)]

#### Simplifying cost structure of CE 199 
 * Joined equivalent variables [aux(56),s(106)] into aux(56)
 * Joined equivalent variables [s(107),s(108)] into s(107)
 * Renamed intermediate variables: 
[ (eq(196,1),s(23))>>s(109)]
 * Renamed intermediate variables: 
[ (eq(196,2),s(64))>>s(110)]

#### Simplifying cost structure of CE 196 
 * Renamed intermediate variables: 
[ (eq(201,1),s(24))>>s(111), (eq(201,1),s(25))>>s(112), (eq(201,1),s(26))>>s(113)]
 * Renamed intermediate variables: 
[ (eq(201,2),s(66))>>s(114), (eq(201,2),aux(51))>>s(115), (eq(201,2),aux(52))>>s(116), (eq(201,2),s(65))>>s(117), (eq(201,2),s(74))>>s(118), (eq(201,2),s(79))>>s(119), (eq(201,2),s(80))>>s(120), (eq(201,2),s(69))>>s(121), (eq(201,2),s(71))>>s(122), (eq(201,2),s(72))>>s(123)]

#### Simplifying cost structure of CE 201 
 * Joined equivalent variables [aux(57),s(112),s(115)] into aux(57)
 * Joined equivalent variables [s(113),s(114),s(117)] into s(113)
 * Renamed intermediate variables: 
[ (eq(200,1),s(24))>>s(124), (eq(200,1),s(25))>>s(125), (eq(200,1),s(26))>>s(126)]
 * Renamed intermediate variables: 
[ (eq(200,2),s(86))>>s(127), (eq(200,2),aux(55))>>s(128), (eq(200,2),s(85))>>s(129), (eq(200,2),s(91))>>s(130), (eq(200,2),s(92))>>s(131)]

#### Simplifying cost structure of CE 200 
 * Joined equivalent variables [aux(59),s(125),s(128)] into aux(59)
 * Joined equivalent variables [s(124),s(127)] into s(124)
 * Joined equivalent variables [s(126),s(129)] into s(126)
 * Renamed intermediate variables: 
[ (eq(197,1),s(23))>>s(132)]
 * Renamed intermediate variables: 
[ (eq(197,2),s(86))>>s(133), (eq(197,2),aux(55))>>s(134), (eq(197,2),s(85))>>s(135), (eq(197,2),s(91))>>s(136), (eq(197,2),s(92))>>s(137)]

#### Simplifying cost structure of CE 197 
 * Renamed intermediate variables: 
[ (eq(198,1),s(23))>>s(138)]
 * Renamed intermediate variables: 
[ (eq(198,2),s(66))>>s(139), (eq(198,2),aux(51))>>s(140), (eq(198,2),aux(52))>>s(141), (eq(198,2),s(65))>>s(142), (eq(198,2),s(74))>>s(143), (eq(198,2),s(79))>>s(144), (eq(198,2),s(80))>>s(145), (eq(198,2),s(69))>>s(146), (eq(198,2),s(71))>>s(147), (eq(198,2),s(72))>>s(148)]

#### Simplifying cost structure of CE 198 

#### Cost of chains of lotto_select(A,B,C,D):
* Chain [195]: 6*s(105)+16*s(107)+29
  Such that:s(105) =< 2
aux(56) =< 3
s(107) =< aux(56)

  with precondition: [A=0,B=0,C=1,D>=0] 

* Chain [194]: 6*s(109)+6*s(110)+24
  Such that:s(109) =< B
s(110) =< B+1

  with precondition: [A=0,C=1,B>=1,D>=0] 

* Chain [193]: 6*s(111)+91*s(113)+48*s(118)+20*s(120)+87*s(121)+60*s(123)+53
  Such that:s(116) =< 1
s(111) =< 2
aux(57) =< 3
s(113) =< aux(57)
s(118) =< s(116)
s(119) =< s(113)*aux(57)
s(120) =< s(119)
s(121) =< s(116)
s(121) =< aux(57)
s(122) =< s(121)*aux(57)
s(123) =< s(122)

  with precondition: [A=1,B=0,C=2,D>=0] 

* Chain [192]: 16*s(124)+216*s(126)+80*s(131)+53
  Such that:aux(58) =< 2
aux(59) =< 3
s(124) =< aux(58)
s(126) =< aux(59)
s(130) =< s(126)*aux(59)
s(131) =< s(130)

  with precondition: [B=0,C=3,A>=2,D>=0] 

* Chain [191]: 6*s(132)+10*s(133)+206*s(135)+80*s(137)+48
  Such that:s(133) =< 2
s(132) =< B
s(134) =< B+1
s(135) =< s(134)
s(136) =< s(135)*s(134)
s(137) =< s(136)

  with precondition: [B+1=C,B>=1,D>=0,A>=B] 

* Chain [190]: 6*s(138)+10*s(139)+71*s(142)+48*s(143)+20*s(145)+87*s(146)+60*s(148)+48
  Such that:s(139) =< -A+B+2
s(141) =< A
s(138) =< B
s(140) =< B+1
s(142) =< s(140)
s(143) =< s(141)
s(144) =< s(142)*s(140)
s(145) =< s(144)
s(146) =< s(141)
s(146) =< s(140)
s(147) =< s(146)*s(140)
s(148) =< s(147)

  with precondition: [A+1=C,A>=1,D>=0,B>=A+1] 


#### Simplifying cost structure of CE 202 

#### Computing cost of phase [196,197,198] 

#### Simplifying cost structure of CE 205 

#### Simplifying cost structure of CE 207 

#### Simplifying cost structure of CE 206 

#### Cost of loops [196,197,198] 

 * loop 196:pack_aux(A,B,C,D,E,F,G,H,I,J) -> [pack_aux(A',B',C',D',E',F',G',H',I',J')] 
10
 * loop 197:pack_aux(A,B,C,D,E,F,G,H,I,J) -> [pack_aux(A',B',C',D',E',F',G',H',I',J')] 
12
 * loop 198:pack_aux(A,B,C,D,E,F,G,H,I,J) -> [pack_aux(A',B',C',D',E',F',G',H',I',J')] 
12
##### Pending set pack_aux(A,B,C,D,E,F,G,H,I,J)
* Psum in Loop 196: [it(196)=<1]
* Psum in Loop 197: [it(197)=<1]
* Psum in Loop 198: [it(198)=<1]

###### Computing sum for it(196)=<1  in Loop 196 
   - Applying inductive sum strategy 
     - head Candidate: F-2 
       - Loop 197 is collaborative and bounds [it(197)] 
       - Loop 198 is collaborative and bounds [it(198)] 
     - head Candidate: F-2 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: F-2 
       - Loop 197 is collaborative and bounds [it(197)] 
       - Loop 198 is collaborative and bounds [it(198)] 
     - tail Candidate: F-2 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(196)+it(197)+it(198)=<F-2,it(196)+it(197)+it(198)=<F-2,it(196)+it(197)+it(198)=<F-F',it(196)+it(197)+it(198)=<F-F'] 

##### Pending set A
* Psum in Loop 197: [it(197)=<1]
* Psum in Loop 198: [it(198)=<1]

###### Computing sum for it(197)=<1  in Loop 197 
   - Applying inductive sum strategy 
     - head Candidate: F-2 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: F-2 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: F-2 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: F-2 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(196)+it(197)+it(198)=<F-2,it(196)+it(197)+it(198)=<F-2,it(196)+it(197)+it(198)=<F-F',it(196)+it(197)+it(198)=<F-F'] 

##### Pending set A
* Psum in Loop 198: [it(198)=<1]

###### Computing sum for it(198)=<1  in Loop 198 
   - Applying inductive sum strategy 
     - head Candidate: F-2 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: F-2 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A-D+1 
       - Loop 196 adds a constant 1/1 
       - Loop 197 is collaborative
     - tail Candidate: F-2 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: F-2 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-D+1 
       - Loop 196 adds a constant 1/1 
       - Loop 197 is collaborative
 * Adding constraints: [it(198)=<it(196)+aux(60),it(198)=<it(196)+aux(61),it(196)+it(197)+it(198)=<F-2,it(196)+it(197)+it(198)=<F-2,aux(60)=<A-D+1,it(196)+it(197)+it(198)=<F-F',it(196)+it(197)+it(198)=<F-F',aux(61)=<A-D-A'+D'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [196,197,198] 

#### Simplifying cost structure of phase [196,197,198] 
 * Joined equivalent variables [it(196),it(197)] into it(196)

#### Cost of phase [196,197,198]:pack_aux(A,B,C,D,E,F,G,H,I,J) -> [pack_aux(A',B',C',D',E',F',G',H',I',J')] 
22*it(196)+12*it(198)+0
  Such that:aux(60) =< A-D+1
aux(61) =< A-D-A'+D'
aux(62) =< F
aux(63) =< F-F'
it(196) =< aux(62)
it(198) =< aux(62)
it(196) =< aux(63)
it(198) =< aux(63)
it(198) =< it(196)+aux(61)
it(198) =< it(196)+aux(60)

#### Simplifying cost structure of chain [[196,197,198],200] 
 * Joined equivalent variables [aux(64),aux(62),aux(63)] into aux(64)

#### Simplifying cost structure of CE 203 

#### Found solution for phase  [196,197,198] in the cache 

#### Cost of phase [196,197,198]:pack_aux(A,B,C,D,E,F,G,H,I,J) -> [pack_aux(A',B',C',D',E',F',G',H',I',J')] 
22*it(196)+12*it(198)+0
  Such that:aux(60) =< A-D+1
aux(61) =< A-D-A'+D'
aux(62) =< F
aux(63) =< F-F'
it(196) =< aux(62)
it(198) =< aux(62)
it(196) =< aux(63)
it(198) =< aux(63)
it(198) =< it(196)+aux(61)
it(198) =< it(196)+aux(60)

#### Simplifying cost structure of chain [[196,197,198],199] 
 * Joined equivalent variables [aux(65),aux(62),aux(63)] into aux(65)

#### Simplifying cost structure of CE 204 

#### Cost of chains of pack_aux(A,B,C,D,E,F,G,H,I,J):
* Chain [[196,197,198],200]: 22*it(196)+12*it(198)+7
  Such that:aux(61) =< A-D
aux(60) =< A-D+1
aux(61) =< 2*A-C+F+H-2*I
aux(64) =< F
it(196) =< aux(64)
it(198) =< aux(64)
it(198) =< it(196)+aux(61)
it(198) =< it(196)+aux(60)

  with precondition: [A>=1,B>=0,C>=1,D>=0,E>=0,G>=0,I>=A+2,J>=B,H>=C+1,I>=D+1,J>=E,A+C+F>=H+I] 

* Chain [[196,197,198],199]: 22*it(196)+12*it(198)+7
  Such that:aux(60) =< A-D+1
aux(61) =< A-D+G+I
aux(61) =< A-D+I
aux(65) =< F
it(196) =< aux(65)
it(198) =< aux(65)
it(198) =< it(196)+aux(61)
it(198) =< it(196)+aux(60)

  with precondition: [A>=1,B>=0,C>=1,D>=0,E>=0,F>=3,G>=0,I>=A+1,J>=B,H>=C+1,I>=D,J>=E,D+3*G>=3,D+3*J>=3,D+3*H>=3*C+6,G+I>=A+2,I+J>=A+2,C+F>=H+1,H+I>=A+C+3,C+F+G>=H+2,C+F+J>=H+2,A+D+F+2*H>=2*C+I+6,A+D+F+H>=C+I+4,A+D+F+G+H>=C+I+5,A+D+F+H+J>=C+I+5] 

* Chain [201]: 3
  with precondition: [A=1,C=1,D=0,F=1,H=1,I=0,B>=0,E>=0,G>=0,J>=0] 

* Chain [200]: 7
  with precondition: [F=2,I=A+1,H=C+1,B>=0,D>=0,E>=0,G>=0,H>=2,I>=2,J>=B,I>=D+1,J>=E] 


#### Simplifying cost structure of CE 208 

#### Simplifying cost structure of CE 209 
 * Renamed intermediate variables: 
[ (eq(211,1),aux(61))>>s(149), (eq(211,1),aux(60))>>s(150), (eq(211,1),aux(64))>>s(151), (eq(211,1),it(196))>>s(152), (eq(211,1),it(198))>>s(153)]

#### Simplifying cost structure of CE 211 
 * Renamed intermediate variables: 
[ (eq(210,1),aux(60))>>s(154), (eq(210,1),aux(61))>>s(155), (eq(210,1),aux(65))>>s(156), (eq(210,1),it(196))>>s(157), (eq(210,1),it(198))>>s(158)]

#### Simplifying cost structure of CE 210 

#### Cost of chains of pack(A,B,C,D,E):
* Chain [205]: 6
  with precondition: [A=1,C=1,D=0,B>=0,E>=0] 

* Chain [204]: 10
  with precondition: [A=2,C=2,D=2,B>=0,E>=0] 

* Chain [203]: 22*s(152)+12*s(153)+10
  Such that:s(149) =< 1
s(150) =< 2
s(151) =< A
s(149) =< 2*A
s(152) =< s(151)
s(153) =< s(151)
s(153) =< s(152)+s(149)
s(153) =< s(152)+s(150)

  with precondition: [B>=0,C>=2,D>=3,E>=0,A+2>=C+D] 

* Chain [202]: 22*s(157)+12*s(158)+10
  Such that:s(154) =< 2
s(156) =< A
s(155) =< 2*A
s(157) =< s(156)
s(158) =< s(156)
s(158) =< s(157)+s(155)
s(158) =< s(157)+s(154)

  with precondition: [B>=1,C>=3,D>=2,E>=1,A>=C,A+C>=D+4] 


#### Simplifying cost structure of CE 215 

#### Computing cost of phase [208,209] 

#### Simplifying cost structure of CE 212 

#### Simplifying cost structure of CE 213 

#### Cost of loops [208,209] 

 * loop 208:removeAt(A,B,C,D,E) -> [removeAt(A',B',C',D',E')] 
10
 * loop 209:removeAt(A,B,C,D,E) -> [removeAt(A',B',C',D',E')] 
10
##### Pending set removeAt(A,B,C,D,E)
* Psum in Loop 208: [it(208)=<1]
* Psum in Loop 209: [it(209)=<1]

###### Computing sum for it(208)=<1  in Loop 208 
   - Applying inductive sum strategy 
     - head Candidate: B-1 
       - Loop 209 is collaborative and bounds [it(209)] 
     - head Candidate: A-1 
       - Loop 209 is collaborative and bounds [it(209)] 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B-1 
       - Loop 209 is collaborative and bounds [it(209)] 
     - tail Candidate: A-1 
       - Loop 209 is collaborative and bounds [it(209)] 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(208)+it(209)=<B-1,it(208)+it(209)=<A-1,it(208)+it(209)=<A-1,it(208)+it(209)=<B-1,it(208)+it(209)=<B-B',it(208)+it(209)=<A-A',it(208)+it(209)=<A-A',it(208)+it(209)=<B-B'] 

##### Pending set A
* Psum in Loop 209: [it(209)=<1]

###### Computing sum for it(209)=<1  in Loop 209 
   - Applying inductive sum strategy 
     - head Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(208)+it(209)=<B-1,it(208)+it(209)=<A-1,it(208)+it(209)=<A-1,it(208)+it(209)=<B-1,it(208)+it(209)=<B-B',it(208)+it(209)=<A-A',it(208)+it(209)=<A-A',it(208)+it(209)=<B-B'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [208,209] 

#### Simplifying cost structure of phase [208,209] 
 * Joined equivalent variables [it(208),it(209)] into it(208)

#### Cost of phase [208,209]:removeAt(A,B,C,D,E) -> [removeAt(A',B',C',D',E')] 
20*it(208)+0
  Such that:aux(66) =< A
aux(67) =< A-A'
aux(68) =< B
aux(69) =< B-B'
it(208) =< aux(66)
it(208) =< aux(67)
it(208) =< aux(68)
it(208) =< aux(69)

#### Simplifying cost structure of chain [[208,209],207] 
 * Joined equivalent variables [aux(70),aux(66),aux(67),aux(69)] into aux(70)

#### Simplifying cost structure of CE 214 

#### Found solution for phase  [208,209] in the cache 

#### Cost of phase [208,209]:removeAt(A,B,C,D,E) -> [removeAt(A',B',C',D',E')] 
20*it(208)+0
  Such that:aux(66) =< A
aux(67) =< A-A'
aux(68) =< B
aux(69) =< B-B'
it(208) =< aux(66)
it(208) =< aux(67)
it(208) =< aux(68)
it(208) =< aux(69)

#### Simplifying cost structure of chain [[208,209],206] 
 * Joined equivalent variables [aux(71),aux(67),aux(68),aux(69)] into aux(71)

#### Cost of chains of removeAt(A,B,C,D,E):
* Chain [[208,209],207]: 20*it(208)+6
  Such that:aux(68) =< D+1
aux(70) =< A
it(208) =< aux(70)
it(208) =< aux(68)

  with precondition: [B=D+1,A>=2,E>=1,B>=A+1,C>=E] 

* Chain [[208,209],206]: 20*it(208)+3
  Such that:aux(66) =< A
aux(71) =< B
it(208) =< aux(66)
it(208) =< aux(71)

  with precondition: [B=D,B>=2,E>=1,A>=B,C>=E] 

* Chain [207]: 6
  with precondition: [A=1,B=D+1,B>=2,C>=1,E>=0,C>=E] 

* Chain [206]: 3
  with precondition: [B=1,C=0,D=1,E=0,A>=0] 


#### Simplifying cost structure of CE 216 

#### Computing cost of phase [211] 

#### Simplifying cost structure of CE 218 

#### Cost of loops [211] 

 * loop 211:prepend(A,B,C,D,E,F) -> [prepend(A',B',C',D',E',F')] 
7
##### Pending set prepend(A,B,C,D,E,F)
* Psum in Loop 211: [it(211)=<1]

###### Computing sum for it(211)=<1  in Loop 211 
   - Applying inductive sum strategy 
     - head Candidate: A 
     - head Candidate: A 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A 
     - tail Candidate: A 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(211)=<A,it(211)=<A,it(211)=<A-A',it(211)=<A-A'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [211] 

#### Simplifying cost structure of phase [211] 

#### Cost of phase [211]:prepend(A,B,C,D,E,F) -> [prepend(A',B',C',D',E',F')] 
7*it(211)+0
  Such that:it(211) =< A
it(211) =< A-A'

#### Simplifying cost structure of chain [[211],212] 

#### Simplifying cost structure of CE 217 

#### Simplifying cost structure of chain [210,[211],212] 

#### Simplifying cost structure of chain [210,212] 

#### Cost of chains of prepend(A,B,C,D,E,F):
* Chain [[211],212]: 7*it(211)+3
  Such that:it(211) =< A

  with precondition: [C=F,A+B=E,A>=1,B>=1,D>=1,C>=D] 

* Chain [212]: 3
  with precondition: [A=0,B=E,C=F,B>=0,C>=0,D>=1] 

* Chain [210,[211],212]: 7*it(211)+10
  Such that:it(211) =< A

  with precondition: [D=F,A+B=E,A>=2,B>=1,C>=0,D>=C+1] 

* Chain [210,212]: 10
  with precondition: [A=1,E=B+1,D=F,C>=0,E>=2,D>=C+1] 


#### Simplifying cost structure of CE 219 

#### Computing cost of phase [216] 

#### Simplifying cost structure of CE 220 

#### Cost of loops [216] 

 * loop 216:replicate_aux(A,B,C,D,E,F,G) -> [replicate_aux(A',B',C',D',E',F',G')] 
8
##### Pending set replicate_aux(A,B,C,D,E,F,G)
* Psum in Loop 216: [it(216)=<1]

###### Computing sum for it(216)=<1  in Loop 216 
   - Applying inductive sum strategy 
     - head Candidate: C-1 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(216)=<C-1,it(216)=<C-1,it(216)=<C-C',it(216)=<C-C'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [216] 

#### Simplifying cost structure of phase [216] 

#### Cost of phase [216]:replicate_aux(A,B,C,D,E,F,G) -> [replicate_aux(A',B',C',D',E',F',G')] 
8*it(216)+0
  Such that:it(216) =< C
it(216) =< C-C'

#### Simplifying cost structure of chain [[216],217] 

#### Computing cost of phase [213,214,215] 
 * Renamed intermediate variables: 
[ (eq(223,1),it(211))>>s(159)]

#### Simplifying cost structure of CE 223 
 * Renamed intermediate variables: 
[ (it(213),s(159))>>s(160)]
 * Renamed intermediate variables: 
[ (eq(222,1),it(211))>>s(161)]

#### Simplifying cost structure of CE 222 
 * Renamed intermediate variables: 
[ (it(214),s(161))>>s(162)]

#### Simplifying cost structure of CE 221 

#### Cost of loops [213,214,215] 

 * loop 213:replicate_aux(A,B,C,D,E,F,G) -> [replicate_aux(A',B',C',D',E',F',G')] 
7*s(160)+15
  Such that:s(160) =< E'

 * loop 214:replicate_aux(A,B,C,D,E,F,G) -> [replicate_aux(A',B',C',D',E',F',G')] 
7*s(162)+8
  Such that:s(162) =< E'

 * loop 215:replicate_aux(A,B,C,D,E,F,G) -> [replicate_aux(A',B',C',D',E',F',G')] 
15
##### Pending set replicate_aux(A,B,C,D,E,F,G)
* Psum in Loop 213: [it(213)=<1,s(163)=<E']
* Psum in Loop 214: [it(214)=<1,s(164)=<E']
* Psum in Loop 215: [it(215)=<1]

###### Computing sum for it(213)=<1  in Loop 213 
   - Applying inductive sum strategy 
     - head Candidate: C-1 
       - Loop 214 is collaborative and bounds [it(214)] 
       - Loop 215 is collaborative and bounds [it(215)] 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: -B+D 
       - Loop 214 is collaborative
       - Loop 215 is collaborative and bounds [it(215)] 
     - tail Candidate: C-1 
       - Loop 214 is collaborative and bounds [it(214)] 
       - Loop 215 is collaborative and bounds [it(215)] 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: -B+D 
       - Loop 214 is collaborative
       - Loop 215 is collaborative and bounds [it(215)] 
 * Adding constraints: [it(213)+it(214)+it(215)=<C-1,it(213)+it(214)+it(215)=<C-1,it(213)+it(215)=< -B+D,it(213)+it(214)+it(215)=<C-C',it(213)+it(214)+it(215)=<C-C',it(213)+it(215)=< -B+D+B'-D'] 

##### Pending set A
* Psum in Loop 213: [s(163)=<E']
* Psum in Loop 214: [it(214)=<1,s(164)=<E']
* Psum in Loop 215: [it(215)=<1]

###### Computing sum for s(163)=<E'  in Loop 213 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(72)=<E] 
 * Adding constraints: [s(163)=<it(213)*aux(72)] 

##### Pending set replicate_aux(A,B,C,D,E,F,G)
* Pmax/min: [aux(72)=<E]
* Psum in Loop 214: [it(214)=<1,s(164)=<E']
* Psum in Loop 215: [it(215)=<1]

###### Computing max_min for aux(72)=<E  
   - Found a solution using transitive invariants 
 * Adding constraints:[aux(72)=<E] 

##### Pending set replicate_aux(A,B,C,D,E,F,G)
* Psum in Loop 214: [it(214)=<1,s(164)=<E']
* Psum in Loop 215: [it(215)=<1]

###### Computing sum for it(214)=<1  in Loop 214 
   - Applying inductive sum strategy 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(213)+it(214)+it(215)=<C-1,it(213)+it(214)+it(215)=<C-1,it(213)+it(214)+it(215)=<C-C',it(213)+it(214)+it(215)=<C-C'] 

##### Pending set replicate_aux(A,B,C,D,E,F,G)
* Psum in Loop 214: [s(164)=<E']
* Psum in Loop 215: [it(215)=<1]

###### Computing sum for s(164)=<E'  in Loop 214 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(73)=<E] 
 * Adding constraints: [s(164)=<it(214)*aux(73)] 

##### Pending set replicate_aux(A,B,C,D,E,F,G)
* Pmax/min: [aux(73)=<E]
* Psum in Loop 215: [it(215)=<1]

###### Computing max_min for aux(73)=<E  
   - Found a solution using cacheing 
 * Adding constraints:[aux(73)=<aux(72)] 

##### Pending set replicate_aux(A,B,C,D,E,F,G)
* Psum in Loop 215: [it(215)=<1]

###### Computing sum for it(215)=<1  in Loop 215 
   - Applying inductive sum strategy 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: -B+D 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: -B+D 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(213)+it(214)+it(215)=<C-1,it(213)+it(214)+it(215)=<C-1,it(213)+it(215)=< -B+D,it(213)+it(214)+it(215)=<C-C',it(213)+it(214)+it(215)=<C-C',it(213)+it(215)=< -B+D+B'-D'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [213,214,215] 

#### Simplifying cost structure of phase [213,214,215] 
 * Joined equivalent variables [it(213),it(215)] into it(213)

#### Cost of phase [213,214,215]:replicate_aux(A,B,C,D,E,F,G) -> [replicate_aux(A',B',C',D',E',F',G')] 
30*it(213)+8*it(214)+7*s(163)+7*s(164)+0
  Such that:aux(72) =< E
aux(74) =< -B+D
aux(75) =< -B+D+B'-D'
aux(76) =< C
aux(77) =< C-C'
it(213) =< aux(74)
it(213) =< aux(75)
it(213) =< aux(76)
it(214) =< aux(76)
it(213) =< aux(77)
it(214) =< aux(77)
aux(73) =< aux(72)
s(163) =< it(213)*aux(72)
s(164) =< it(214)*aux(73)

#### Simplifying cost structure of chain [[213,214,215],217] 
 * Joined equivalent variables [aux(78),aux(76),aux(77)] into aux(78)

#### Cost of chains of replicate_aux(A,B,C,D,E,F,G):
* Chain [[216],217]: 8*it(216)+2
  Such that:it(216) =< C

  with precondition: [A=1,B=0,E=0,F=1,G=0,C>=2,D>=1] 

* Chain [[213,214,215],217]: 30*it(213)+8*it(214)+7*s(163)+7*s(164)+2
  Such that:aux(74) =< -B+D
aux(75) =< -B+D+G
aux(72) =< E
aux(78) =< C
it(213) =< aux(74)
it(213) =< aux(75)
it(213) =< aux(78)
it(214) =< aux(78)
aux(73) =< aux(72)
s(163) =< it(213)*aux(72)
s(164) =< it(214)*aux(73)

  with precondition: [A>=1,B>=0,C>=2,D>=1,E>=1,G>=1,G>=B,F+2>=A+C+E] 

* Chain [217]: 2
  with precondition: [C=1,D=0,A=F,B=G,A>=1,B>=0,E>=0] 


#### Simplifying cost structure of CE 224 
 * Renamed intermediate variables: 
[ (eq(225,1),s(10))>>s(165), (eq(225,1),s(9))>>s(166), (eq(225,1),s(11))>>s(167)]
 * Renamed intermediate variables: 
[ (eq(225,2),it(216))>>s(168)]

#### Simplifying cost structure of CE 225 
 * Joined equivalent variables [aux(79),s(165)] into aux(79)
 * Joined equivalent variables [s(167),s(168)] into s(167)
 * Renamed intermediate variables: 
[ (eq(226,1),s(10))>>s(169), (eq(226,1),s(9))>>s(170), (eq(226,1),s(11))>>s(171)]
 * Renamed intermediate variables: 
[ (eq(226,2),aux(74))>>s(172), (eq(226,2),aux(75))>>s(173), (eq(226,2),aux(72))>>s(174), (eq(226,2),aux(78))>>s(175), (eq(226,2),it(213))>>s(176), (eq(226,2),it(214))>>s(177), (eq(226,2),aux(73))>>s(178), (eq(226,2),s(163))>>s(179), (eq(226,2),s(164))>>s(180)]

#### Simplifying cost structure of CE 226 
 * Joined equivalent variables [aux(80),s(169),s(175)] into aux(80)
 * Joined equivalent variables [s(171),s(177)] into s(171)

#### Cost of chains of replicate(A,B,C,D,E):
* Chain [220]: 9
  with precondition: [A=1,B=0,D=1,E=0,C>=0] 

* Chain [219]: 5*s(166)+13*s(167)+9
  Such that:s(166) =< B
aux(79) =< A
s(167) =< aux(79)
s(166) =< aux(79)

  with precondition: [C=0,D=1,E=0,A>=2,B>=1] 

* Chain [218]: 5*s(170)+13*s(171)+30*s(176)+7*s(179)+7*s(180)+9
  Such that:s(170) =< B
s(174) =< C
aux(80) =< A
s(176) =< aux(80)
s(171) =< aux(80)
s(178) =< s(174)
s(179) =< s(176)*s(174)
s(180) =< s(171)*s(178)
s(170) =< aux(80)

  with precondition: [A>=2,B>=1,C>=1,E>=1,D+1>=A+C] 


#### Simplifying cost structure of CE 228 

#### Simplifying cost structure of CE 227 

#### Cost of chains of case_33(A,B,C,D,E,F):
* Chain [222]: 2
  with precondition: [A=0,B=0,F=0,C>=0,D>=0,E>=0] 

* Chain [221]: 4
  with precondition: [A=0,B>=1,C>=0,D>=0,E>=0,F>=0] 

 * Renamed intermediate variables: 
[ (eq(236,1),s(10))>>s(181), (eq(236,1),s(9))>>s(182), (eq(236,1),s(11))>>s(183)]

#### Simplifying cost structure of CE 236 

#### Computing cost of phase [230,231] 

#### Simplifying cost structure of CE 229 

#### Simplifying cost structure of CE 230 

#### Cost of loops [230,231] 

 * loop 230:split_aux(A,B,C,D,E,F,G,H) -> [split_aux(A',B',C',D',E',F',G',H')] 
10
 * loop 231:split_aux(A,B,C,D,E,F,G,H) -> [split_aux(A',B',C',D',E',F',G',H')] 
10
##### Pending set split_aux(A,B,C,D,E,F,G,H)
* Psum in Loop 230: [it(230)=<1]
* Psum in Loop 231: [it(231)=<1]

###### Computing sum for it(230)=<1  in Loop 230 
   - Applying inductive sum strategy 
     - head Candidate: D-1 
       - Loop 231 is collaborative and bounds [it(231)] 
     - head Candidate: A 
       - Loop 231 is collaborative and bounds [it(231)] 
     - head Candidate: A 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: D-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: -C+E 
       - Loop 231 is collaborative
     - tail Candidate: D-1 
       - Loop 231 is collaborative and bounds [it(231)] 
     - tail Candidate: A 
       - Loop 231 is collaborative and bounds [it(231)] 
     - tail Candidate: A 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: D-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: -C+E 
       - Loop 231 is collaborative
 * Adding constraints: [it(230)+it(231)=<D-1,it(230)+it(231)=<A,it(230)+it(231)=<A,it(230)+it(231)=<D-1,it(230)=< -C+E,it(230)+it(231)=<D-D',it(230)+it(231)=<A-A',it(230)+it(231)=<A-A',it(230)+it(231)=<D-D',it(230)=< -C+E+C'-E'] 

##### Pending set A
* Psum in Loop 231: [it(231)=<1]

###### Computing sum for it(231)=<1  in Loop 231 
   - Applying inductive sum strategy 
     - head Candidate: D-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: D-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: D-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: D-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(230)+it(231)=<D-1,it(230)+it(231)=<A,it(230)+it(231)=<A,it(230)+it(231)=<D-1,it(230)+it(231)=<D-D',it(230)+it(231)=<A-A',it(230)+it(231)=<A-A',it(230)+it(231)=<D-D'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [230,231] 

#### Simplifying cost structure of phase [230,231] 

#### Cost of phase [230,231]:split_aux(A,B,C,D,E,F,G,H) -> [split_aux(A',B',C',D',E',F',G',H')] 
10*it(230)+10*it(231)+0
  Such that:it(230) =< -C+E
it(230) =< -C+E+C'-E'
aux(81) =< A
aux(82) =< A-A'
aux(83) =< D
aux(84) =< D-D'
it(230) =< aux(81)
it(231) =< aux(81)
it(230) =< aux(82)
it(231) =< aux(82)
it(230) =< aux(83)
it(231) =< aux(83)
it(230) =< aux(84)
it(231) =< aux(84)

#### Simplifying cost structure of chain [[230,231],228] 
 * Joined equivalent variables [aux(85),aux(81),aux(82),aux(84)] into aux(85)
 * Renamed intermediate variables: 
[ (eq(234,1),s(10))>>s(184), (eq(234,1),s(9))>>s(185), (eq(234,1),s(11))>>s(186)]

#### Simplifying cost structure of CE 234 

#### Found solution for phase  [230,231] in the cache 

#### Cost of phase [230,231]:split_aux(A,B,C,D,E,F,G,H) -> [split_aux(A',B',C',D',E',F',G',H')] 
10*it(230)+10*it(231)+0
  Such that:it(230) =< -C+E
it(230) =< -C+E+C'-E'
aux(81) =< A
aux(82) =< A-A'
aux(83) =< D
aux(84) =< D-D'
it(230) =< aux(81)
it(231) =< aux(81)
it(230) =< aux(82)
it(231) =< aux(82)
it(230) =< aux(83)
it(231) =< aux(83)
it(230) =< aux(84)
it(231) =< aux(84)

#### Simplifying cost structure of chain [[230,231],227] 
 * Joined equivalent variables [aux(86),aux(81),aux(82),aux(84)] into aux(86)
 * Renamed intermediate variables: 
[ (eq(237,1),s(10))>>s(187), (eq(237,1),s(9))>>s(188), (eq(237,1),s(11))>>s(189)]

#### Simplifying cost structure of CE 237 

#### Found solution for phase  [230,231] in the cache 

#### Cost of phase [230,231]:split_aux(A,B,C,D,E,F,G,H) -> [split_aux(A',B',C',D',E',F',G',H')] 
10*it(230)+10*it(231)+0
  Such that:it(230) =< -C+E
it(230) =< -C+E+C'-E'
aux(81) =< A
aux(82) =< A-A'
aux(83) =< D
aux(84) =< D-D'
it(230) =< aux(81)
it(231) =< aux(81)
it(230) =< aux(82)
it(231) =< aux(82)
it(230) =< aux(83)
it(231) =< aux(83)
it(230) =< aux(84)
it(231) =< aux(84)

#### Simplifying cost structure of chain [[230,231],226] 
 * Joined equivalent variables [aux(87),aux(81),aux(82),aux(84)] into aux(87)
 * Renamed intermediate variables: 
[ (eq(235,1),s(10))>>s(190), (eq(235,1),s(9))>>s(191), (eq(235,1),s(11))>>s(192)]

#### Simplifying cost structure of CE 235 

#### Found solution for phase  [230,231] in the cache 

#### Cost of phase [230,231]:split_aux(A,B,C,D,E,F,G,H) -> [split_aux(A',B',C',D',E',F',G',H')] 
10*it(230)+10*it(231)+0
  Such that:it(230) =< -C+E
it(230) =< -C+E+C'-E'
aux(81) =< A
aux(82) =< A-A'
aux(83) =< D
aux(84) =< D-D'
it(230) =< aux(81)
it(231) =< aux(81)
it(230) =< aux(82)
it(231) =< aux(82)
it(230) =< aux(83)
it(231) =< aux(83)
it(230) =< aux(84)
it(231) =< aux(84)

#### Simplifying cost structure of chain [[230,231],225] 
 * Joined equivalent variables [aux(88),aux(81),aux(82),aux(84)] into aux(88)
 * Renamed intermediate variables: 
[ (eq(232,1),s(10))>>s(193), (eq(232,1),s(9))>>s(194), (eq(232,1),s(11))>>s(195)]

#### Simplifying cost structure of CE 232 

#### Found solution for phase  [230,231] in the cache 

#### Cost of phase [230,231]:split_aux(A,B,C,D,E,F,G,H) -> [split_aux(A',B',C',D',E',F',G',H')] 
10*it(230)+10*it(231)+0
  Such that:it(230) =< -C+E
it(230) =< -C+E+C'-E'
aux(81) =< A
aux(82) =< A-A'
aux(83) =< D
aux(84) =< D-D'
it(230) =< aux(81)
it(231) =< aux(81)
it(230) =< aux(82)
it(231) =< aux(82)
it(230) =< aux(83)
it(231) =< aux(83)
it(230) =< aux(84)
it(231) =< aux(84)

#### Simplifying cost structure of chain [[230,231],223] 
 * Joined equivalent variables [aux(89),aux(82),aux(83),aux(84)] into aux(89)

#### Simplifying cost structure of CE 233 

#### Simplifying cost structure of CE 231 

#### Cost of chains of split_aux(A,B,C,D,E,F,G,H):
* Chain [[230,231],228]: 10*it(230)+10*it(231)+5*s(182)+5*s(183)+12
  Such that:it(230) =< -C+E
s(182) =< C+E
aux(83) =< D
it(230) =< 2*E-H
s(181) =< G
aux(85) =< A
s(182) =< s(181)
s(183) =< s(181)
it(230) =< aux(85)
it(231) =< aux(85)
it(230) =< aux(83)
it(231) =< aux(83)

  with precondition: [F=1,A+B=G,A>=1,B>=1,C>=0,H>=1,D>=A+2,E>=H,B+2*A>=D+1] 

* Chain [[230,231],227]: 10*it(230)+10*it(231)+5*s(185)+5*s(186)+12
  Such that:it(230) =< -C+E
s(185) =< C+E
aux(83) =< D
it(230) =< 2*E
s(184) =< G
aux(86) =< A
s(185) =< s(184)
s(186) =< s(184)
it(230) =< aux(86)
it(231) =< aux(86)
it(230) =< aux(83)
it(231) =< aux(83)

  with precondition: [F=1,A+B=G,A>=1,B>=1,C>=0,E>=1,H>=2,D>=A+2,B+2*A>=D+1] 

* Chain [[230,231],226]: 10*it(230)+10*it(231)+5*s(188)+5*s(189)+12
  Such that:s(187) =< A+B
aux(83) =< A+G
it(230) =< -C+E
s(188) =< C+E
it(230) =< 2*E-H
aux(87) =< A
s(188) =< s(187)
s(189) =< s(187)
it(230) =< aux(87)
it(231) =< aux(87)
it(230) =< aux(83)
it(231) =< aux(83)

  with precondition: [F=1,A+G=D,A>=1,B>=1,C>=0,H>=1,E>=H,D>=2*A+B] 

* Chain [[230,231],225]: 10*it(230)+10*it(231)+5*s(191)+5*s(192)+12
  Such that:s(190) =< A+B
aux(83) =< A+G
it(230) =< -C+E
s(191) =< C+E
it(230) =< 2*E
aux(88) =< A
s(191) =< s(190)
s(192) =< s(190)
it(230) =< aux(88)
it(231) =< aux(88)
it(230) =< aux(83)
it(231) =< aux(83)

  with precondition: [F=1,A+G=D,A>=1,B>=1,C>=0,E>=1,H>=2,D>=2*A+B] 

* Chain [[230,231],223]: 10*it(230)+10*it(231)+5*s(194)+5*s(195)+9
  Such that:aux(81) =< A
it(230) =< -C+E
s(194) =< C+E
it(230) =< 2*E
s(193) =< G
aux(89) =< D
s(194) =< s(193)
s(195) =< s(193)
it(230) =< aux(81)
it(231) =< aux(81)
it(230) =< aux(89)
it(231) =< aux(89)

  with precondition: [F=1,B+D=G+1,B>=1,C>=0,D>=2,E>=1,H>=1,A+1>=D] 

* Chain [229]: 12
  with precondition: [A=0,B=1,C=0,F=1,D=G,E=H,D>=2,E>=1] 

* Chain [224]: 9
  with precondition: [B=1,C=0,D=1,E=0,F=1,G=1,H=0,A>=0] 


#### Simplifying cost structure of CE 239 

#### Simplifying cost structure of CE 238 
 * Renamed intermediate variables: 
[ (eq(242,1),it(230))>>s(196), (eq(242,1),s(185))>>s(197), (eq(242,1),aux(83))>>s(198), (eq(242,1),s(184))>>s(199), (eq(242,1),aux(86))>>s(200), (eq(242,1),s(186))>>s(201), (eq(242,1),it(231))>>s(202)]

#### Simplifying cost structure of CE 242 
 * Renamed intermediate variables: 
[ (eq(243,1),it(230))>>s(203), (eq(243,1),s(182))>>s(204), (eq(243,1),aux(83))>>s(205), (eq(243,1),s(181))>>s(206), (eq(243,1),aux(85))>>s(207), (eq(243,1),s(183))>>s(208), (eq(243,1),it(231))>>s(209)]

#### Simplifying cost structure of CE 243 
 * Renamed intermediate variables: 
[ (eq(244,1),aux(81))>>s(210), (eq(244,1),it(230))>>s(211), (eq(244,1),s(194))>>s(212), (eq(244,1),s(193))>>s(213), (eq(244,1),aux(89))>>s(214), (eq(244,1),s(195))>>s(215), (eq(244,1),it(231))>>s(216)]

#### Simplifying cost structure of CE 244 
 * Joined equivalent variables [aux(92),s(213),s(214)] into aux(92)
 * Renamed intermediate variables: 
[ (eq(240,1),s(190))>>s(217), (eq(240,1),aux(83))>>s(218), (eq(240,1),it(230))>>s(219), (eq(240,1),s(191))>>s(220), (eq(240,1),aux(88))>>s(221), (eq(240,1),s(192))>>s(222), (eq(240,1),it(231))>>s(223)]

#### Simplifying cost structure of CE 240 
 * Renamed intermediate variables: 
[ (eq(241,1),s(187))>>s(224), (eq(241,1),aux(83))>>s(225), (eq(241,1),it(230))>>s(226), (eq(241,1),s(188))>>s(227), (eq(241,1),aux(87))>>s(228), (eq(241,1),s(189))>>s(229), (eq(241,1),it(231))>>s(230)]

#### Simplifying cost structure of CE 241 

#### Cost of chains of split(A,B,C,D,E,F):
* Chain [238]: 11
  with precondition: [A=1,B=0,D=1,E=1,F=0,C>=0] 

* Chain [237]: 14
  with precondition: [C=0,D=1,A=E,B=F,A>=2,B>=1] 

* Chain [236]: 10*s(196)+5*s(197)+5*s(201)+10*s(202)+14
  Such that:s(198) =< A
s(200) =< C
s(199) =< C+1
aux(90) =< B
s(196) =< aux(90)
s(197) =< aux(90)
s(197) =< s(199)
s(201) =< s(199)
s(196) =< s(200)
s(202) =< s(200)
s(196) =< s(198)
s(202) =< s(198)

  with precondition: [D=1,C+1=E,B>=1,F>=2,2*C>=A,A>=C+2] 

* Chain [235]: 10*s(203)+5*s(204)+5*s(208)+10*s(209)+14
  Such that:s(205) =< A
s(207) =< C
s(206) =< C+1
aux(91) =< B
s(203) =< aux(91)
s(204) =< aux(91)
s(204) =< s(206)
s(208) =< s(206)
s(203) =< s(207)
s(209) =< s(207)
s(203) =< s(205)
s(209) =< s(205)

  with precondition: [D=1,C+1=E,F>=1,2*C>=A,A>=C+2,B>=F] 

* Chain [234]: 10*s(211)+5*s(212)+5*s(215)+10*s(216)+11
  Such that:s(210) =< C
aux(92) =< A
aux(93) =< B
s(211) =< aux(93)
s(212) =< aux(93)
s(212) =< aux(92)
s(215) =< aux(92)
s(211) =< s(210)
s(216) =< s(210)
s(211) =< aux(92)
s(216) =< aux(92)

  with precondition: [D=1,A=E,A>=2,B>=1,F>=1,C+1>=A] 

* Chain [233]: 10*s(219)+5*s(220)+5*s(222)+10*s(223)+14
  Such that:s(218) =< A
s(221) =< C
s(217) =< C+1
aux(94) =< B
s(219) =< aux(94)
s(220) =< aux(94)
s(220) =< s(217)
s(222) =< s(217)
s(219) =< s(221)
s(223) =< s(221)
s(219) =< s(218)
s(223) =< s(218)

  with precondition: [D=1,A=C+E,B>=1,C>=1,F>=2,A>=2*C+1] 

* Chain [232]: 10*s(226)+5*s(227)+5*s(229)+10*s(230)+14
  Such that:s(225) =< A
s(228) =< C
s(224) =< C+1
aux(95) =< B
s(226) =< aux(95)
s(227) =< aux(95)
s(227) =< s(224)
s(229) =< s(224)
s(226) =< s(228)
s(230) =< s(228)
s(226) =< s(225)
s(230) =< s(225)

  with precondition: [D=1,A=C+E,C>=1,F>=1,A>=2*C+1,B>=F] 


#### Simplifying cost structure of CE 258 

#### Simplifying cost structure of CE 245 

#### Simplifying cost structure of CE 246 
 * Renamed intermediate variables: 
[ (eq(247,2),aux(8))>>s(231), (eq(247,2),it(105))>>s(232)]

#### Simplifying cost structure of CE 247 
 * Renamed intermediate variables: 
[ (eq(248,1),s(210))>>s(233), (eq(248,1),aux(92))>>s(234), (eq(248,1),aux(93))>>s(235), (eq(248,1),s(211))>>s(236), (eq(248,1),s(212))>>s(237), (eq(248,1),s(215))>>s(238), (eq(248,1),s(216))>>s(239)]

#### Simplifying cost structure of CE 248 
 * Renamed intermediate variables: 
[ (eq(249,1),s(210))>>s(240), (eq(249,1),aux(92))>>s(241), (eq(249,1),aux(93))>>s(242), (eq(249,1),s(211))>>s(243), (eq(249,1),s(212))>>s(244), (eq(249,1),s(215))>>s(245), (eq(249,1),s(216))>>s(246)]
 * Renamed intermediate variables: 
[ (eq(249,2),aux(8))>>s(247), (eq(249,2),it(105))>>s(248)]

#### Simplifying cost structure of CE 249 
 * Joined equivalent variables [aux(96),s(241),s(247)] into aux(96)
 * Joined equivalent variables [s(245),s(248)] into s(245)
 * Renamed intermediate variables: 
[ (eq(254,1),s(218))>>s(249), (eq(254,1),s(221))>>s(250), (eq(254,1),s(217))>>s(251), (eq(254,1),aux(94))>>s(252), (eq(254,1),s(219))>>s(253), (eq(254,1),s(220))>>s(254), (eq(254,1),s(222))>>s(255), (eq(254,1),s(223))>>s(256)]

#### Simplifying cost structure of CE 254 
 * Renamed intermediate variables: 
[ (eq(256,1),s(225))>>s(257), (eq(256,1),s(228))>>s(258), (eq(256,1),s(224))>>s(259), (eq(256,1),aux(95))>>s(260), (eq(256,1),s(226))>>s(261), (eq(256,1),s(227))>>s(262), (eq(256,1),s(229))>>s(263), (eq(256,1),s(230))>>s(264)]

#### Simplifying cost structure of CE 256 
 * Joined equivalent variables [aux(97),s(249),s(257)] into aux(97)
 * Joined equivalent variables [aux(98),s(252),s(260)] into aux(98)
 * Joined equivalent variables [aux(99),s(250),s(258)] into aux(99)
 * Joined equivalent variables [aux(100),s(251),s(259)] into aux(100)
 * Joined equivalent variables [s(253),s(261)] into s(253)
 * Joined equivalent variables [s(256),s(264)] into s(256)
 * Joined equivalent variables [s(254),s(262)] into s(254)
 * Joined equivalent variables [s(255),s(263)] into s(255)
 * Renamed intermediate variables: 
[ (eq(255,1),s(218))>>s(265), (eq(255,1),s(221))>>s(266), (eq(255,1),s(217))>>s(267), (eq(255,1),aux(94))>>s(268), (eq(255,1),s(219))>>s(269), (eq(255,1),s(220))>>s(270), (eq(255,1),s(222))>>s(271), (eq(255,1),s(223))>>s(272)]
 * Renamed intermediate variables: 
[ (eq(255,2),aux(8))>>s(273), (eq(255,2),it(105))>>s(274)]

#### Simplifying cost structure of CE 255 
 * Renamed intermediate variables: 
[ (eq(257,1),s(225))>>s(275), (eq(257,1),s(228))>>s(276), (eq(257,1),s(224))>>s(277), (eq(257,1),aux(95))>>s(278), (eq(257,1),s(226))>>s(279), (eq(257,1),s(227))>>s(280), (eq(257,1),s(229))>>s(281), (eq(257,1),s(230))>>s(282)]
 * Renamed intermediate variables: 
[ (eq(257,2),aux(8))>>s(283), (eq(257,2),it(105))>>s(284)]

#### Simplifying cost structure of CE 257 
 * Joined equivalent variables [aux(101),s(265),s(275)] into aux(101)
 * Joined equivalent variables [aux(102),s(273),s(283)] into aux(102)
 * Joined equivalent variables [aux(103),s(268),s(278)] into aux(103)
 * Joined equivalent variables [aux(104),s(266),s(276)] into aux(104)
 * Joined equivalent variables [aux(105),s(267),s(277)] into aux(105)
 * Joined equivalent variables [s(269),s(279)] into s(269)
 * Joined equivalent variables [s(272),s(282)] into s(272)
 * Joined equivalent variables [s(274),s(284)] into s(274)
 * Joined equivalent variables [s(270),s(280)] into s(270)
 * Joined equivalent variables [s(271),s(281)] into s(271)
 * Renamed intermediate variables: 
[ (eq(250,1),s(198))>>s(285), (eq(250,1),s(200))>>s(286), (eq(250,1),s(199))>>s(287), (eq(250,1),aux(90))>>s(288), (eq(250,1),s(196))>>s(289), (eq(250,1),s(197))>>s(290), (eq(250,1),s(201))>>s(291), (eq(250,1),s(202))>>s(292)]

#### Simplifying cost structure of CE 250 
 * Renamed intermediate variables: 
[ (eq(252,1),s(205))>>s(293), (eq(252,1),s(207))>>s(294), (eq(252,1),s(206))>>s(295), (eq(252,1),aux(91))>>s(296), (eq(252,1),s(203))>>s(297), (eq(252,1),s(204))>>s(298), (eq(252,1),s(208))>>s(299), (eq(252,1),s(209))>>s(300)]

#### Simplifying cost structure of CE 252 
 * Joined equivalent variables [aux(106),s(285),s(293)] into aux(106)
 * Joined equivalent variables [aux(107),s(288),s(296)] into aux(107)
 * Joined equivalent variables [aux(108),s(286),s(294)] into aux(108)
 * Joined equivalent variables [aux(109),s(287),s(295)] into aux(109)
 * Joined equivalent variables [s(289),s(297)] into s(289)
 * Joined equivalent variables [s(292),s(300)] into s(292)
 * Joined equivalent variables [s(290),s(298)] into s(290)
 * Joined equivalent variables [s(291),s(299)] into s(291)
 * Renamed intermediate variables: 
[ (eq(251,1),s(198))>>s(301), (eq(251,1),s(200))>>s(302), (eq(251,1),s(199))>>s(303), (eq(251,1),aux(90))>>s(304), (eq(251,1),s(196))>>s(305), (eq(251,1),s(197))>>s(306), (eq(251,1),s(201))>>s(307), (eq(251,1),s(202))>>s(308)]
 * Renamed intermediate variables: 
[ (eq(251,2),aux(8))>>s(309), (eq(251,2),it(105))>>s(310)]

#### Simplifying cost structure of CE 251 
 * Joined equivalent variables [aux(110),s(303),s(309)] into aux(110)
 * Joined equivalent variables [s(307),s(310)] into s(307)
 * Renamed intermediate variables: 
[ (eq(253,1),s(205))>>s(311), (eq(253,1),s(207))>>s(312), (eq(253,1),s(206))>>s(313), (eq(253,1),aux(91))>>s(314), (eq(253,1),s(203))>>s(315), (eq(253,1),s(204))>>s(316), (eq(253,1),s(208))>>s(317), (eq(253,1),s(209))>>s(318)]
 * Renamed intermediate variables: 
[ (eq(253,2),aux(8))>>s(319), (eq(253,2),it(105))>>s(320)]

#### Simplifying cost structure of CE 253 
 * Joined equivalent variables [aux(111),s(313),s(319)] into aux(111)
 * Joined equivalent variables [s(317),s(320)] into s(317)
 * Joined equivalent variables [aux(112),s(301),s(311)] into aux(112)
 * Joined equivalent variables [aux(113),s(304),s(314)] into aux(113)
 * Joined equivalent variables [aux(114),s(302),s(312)] into aux(114)
 * Joined equivalent variables [aux(115),aux(110),aux(111)] into aux(115)
 * Joined equivalent variables [s(305),s(315)] into s(305)
 * Joined equivalent variables [s(308),s(318)] into s(308)
 * Joined equivalent variables [s(306),s(316)] into s(306)
 * Joined equivalent variables [s(307),s(317)] into s(307)

#### Cost of chains of case_34(A,B,C,D,E,F,G,H):
* Chain [248]: 1
  with precondition: [A=0,B=0,D=G,E=H,C>=0,D>=1,E>=0,F>=0] 

* Chain [247]: 20
  with precondition: [A=0,D=1,E=0,G=1,H=0,B>=1,C>=0,F>=0] 

* Chain [246]: 23
  with precondition: [A=0,F=0,B>=1,C>=0,D>=2,E>=1,G>=1,H>=0,D>=G,E>=H] 

* Chain [245]: 10*s(232)+23
  Such that:s(231) =< D
s(232) =< s(231)

  with precondition: [A=0,F=0,B>=1,C>=0,D>=2,E>=1,G>=2,H>=1,2*D>=G+1,2*E>=H] 

* Chain [244]: 10*s(236)+5*s(237)+5*s(238)+10*s(239)+20
  Such that:s(234) =< D
s(235) =< E
s(233) =< F
s(236) =< s(235)
s(237) =< s(235)
s(237) =< s(234)
s(238) =< s(234)
s(236) =< s(233)
s(239) =< s(233)
s(236) =< s(234)
s(239) =< s(234)

  with precondition: [A=0,B>=1,C>=0,D>=2,E>=1,G>=1,H>=0,F+1>=D,D>=G] 

* Chain [243]: 10*s(243)+5*s(244)+15*s(245)+10*s(246)+20
  Such that:s(242) =< E
s(240) =< F
aux(96) =< D
s(245) =< aux(96)
s(243) =< s(242)
s(244) =< s(242)
s(244) =< aux(96)
s(243) =< s(240)
s(246) =< s(240)
s(243) =< aux(96)
s(246) =< aux(96)

  with precondition: [A=0,B>=1,C>=0,D>=2,E>=1,G>=2,H>=1,F+1>=D,2*D>=G+1] 

* Chain [242]: 20*s(253)+10*s(254)+10*s(255)+20*s(256)+23
  Such that:aux(97) =< D
aux(98) =< E
aux(99) =< F
aux(100) =< F+1
s(253) =< aux(98)
s(254) =< aux(98)
s(254) =< aux(100)
s(255) =< aux(100)
s(253) =< aux(99)
s(256) =< aux(99)
s(253) =< aux(97)
s(256) =< aux(97)

  with precondition: [A=0,B>=1,C>=0,E>=1,F>=1,G>=1,H>=0,D>=2*F+1,D>=F+G] 

* Chain [241]: 20*s(269)+10*s(270)+10*s(271)+20*s(272)+20*s(274)+23
  Such that:aux(101) =< D
aux(102) =< D-F
aux(103) =< E
aux(104) =< F
aux(105) =< F+1
s(274) =< aux(102)
s(269) =< aux(103)
s(270) =< aux(103)
s(270) =< aux(105)
s(271) =< aux(105)
s(269) =< aux(104)
s(272) =< aux(104)
s(269) =< aux(101)
s(272) =< aux(101)

  with precondition: [A=0,B>=1,C>=0,E>=1,F>=1,G>=2,H>=1,D>=2*F+1,2*D>=2*F+G+1] 

* Chain [240]: 20*s(289)+10*s(290)+10*s(291)+20*s(292)+23
  Such that:aux(106) =< D
aux(107) =< E
aux(108) =< F
aux(109) =< F+1
s(289) =< aux(107)
s(290) =< aux(107)
s(290) =< aux(109)
s(291) =< aux(109)
s(289) =< aux(108)
s(292) =< aux(108)
s(289) =< aux(106)
s(292) =< aux(106)

  with precondition: [A=0,B>=1,C>=0,E>=1,G>=1,H>=0,2*F>=D,D>=F+2,F+1>=G] 

* Chain [239]: 20*s(305)+10*s(306)+30*s(307)+20*s(308)+23
  Such that:aux(112) =< D
aux(113) =< E
aux(114) =< F
aux(115) =< F+1
s(307) =< aux(115)
s(305) =< aux(113)
s(306) =< aux(113)
s(306) =< aux(115)
s(305) =< aux(114)
s(308) =< aux(114)
s(305) =< aux(112)
s(308) =< aux(112)

  with precondition: [A=0,B>=1,C>=0,E>=1,G>=2,H>=1,2*F>=D,D>=F+2,2*F+1>=G] 


#### Simplifying cost structure of CE 259 
 * Renamed intermediate variables: 
[ (eq(261,1),s(17))>>s(321)]

#### Simplifying cost structure of CE 261 
 * Renamed intermediate variables: 
[ (eq(262,1),s(17))>>s(322)]
 * Renamed intermediate variables: 
[ (eq(262,3),s(231))>>s(323), (eq(262,3),s(232))>>s(324)]

#### Simplifying cost structure of CE 262 
 * Joined equivalent variables [aux(116),s(323)] into aux(116)
 * Joined equivalent variables [s(322),s(324)] into s(322)
 * Renamed intermediate variables: 
[ (eq(260,1),s(17))>>s(325)]

#### Simplifying cost structure of CE 260 
 * Renamed intermediate variables: 
[ (eq(263,1),s(17))>>s(326)]
 * Renamed intermediate variables: 
[ (eq(263,3),s(234))>>s(327), (eq(263,3),s(235))>>s(328), (eq(263,3),s(233))>>s(329), (eq(263,3),s(236))>>s(330), (eq(263,3),s(237))>>s(331), (eq(263,3),s(238))>>s(332), (eq(263,3),s(239))>>s(333)]

#### Simplifying cost structure of CE 263 
 * Joined equivalent variables [aux(117),s(327)] into aux(117)
 * Joined equivalent variables [s(326),s(332)] into s(326)
 * Renamed intermediate variables: 
[ (eq(264,1),s(17))>>s(334)]
 * Renamed intermediate variables: 
[ (eq(264,3),s(242))>>s(335), (eq(264,3),s(240))>>s(336), (eq(264,3),aux(96))>>s(337), (eq(264,3),s(245))>>s(338), (eq(264,3),s(243))>>s(339), (eq(264,3),s(244))>>s(340), (eq(264,3),s(246))>>s(341)]

#### Simplifying cost structure of CE 264 
 * Joined equivalent variables [aux(118),s(337)] into aux(118)
 * Joined equivalent variables [s(334),s(338)] into s(334)
 * Renamed intermediate variables: 
[ (eq(265,1),s(17))>>s(342)]
 * Renamed intermediate variables: 
[ (eq(265,3),aux(97))>>s(343), (eq(265,3),aux(98))>>s(344), (eq(265,3),aux(99))>>s(345), (eq(265,3),aux(100))>>s(346), (eq(265,3),s(253))>>s(347), (eq(265,3),s(254))>>s(348), (eq(265,3),s(255))>>s(349), (eq(265,3),s(256))>>s(350)]

#### Simplifying cost structure of CE 265 
 * Joined equivalent variables [aux(119),s(343)] into aux(119)
 * Renamed intermediate variables: 
[ (eq(266,1),s(17))>>s(351)]
 * Renamed intermediate variables: 
[ (eq(266,3),aux(101))>>s(352), (eq(266,3),aux(102))>>s(353), (eq(266,3),aux(103))>>s(354), (eq(266,3),aux(104))>>s(355), (eq(266,3),aux(105))>>s(356), (eq(266,3),s(274))>>s(357), (eq(266,3),s(269))>>s(358), (eq(266,3),s(270))>>s(359), (eq(266,3),s(271))>>s(360), (eq(266,3),s(272))>>s(361)]

#### Simplifying cost structure of CE 266 
 * Joined equivalent variables [aux(120),s(352)] into aux(120)
 * Renamed intermediate variables: 
[ (eq(267,1),s(17))>>s(362)]
 * Renamed intermediate variables: 
[ (eq(267,3),aux(106))>>s(363), (eq(267,3),aux(107))>>s(364), (eq(267,3),aux(108))>>s(365), (eq(267,3),aux(109))>>s(366), (eq(267,3),s(289))>>s(367), (eq(267,3),s(290))>>s(368), (eq(267,3),s(291))>>s(369), (eq(267,3),s(292))>>s(370)]

#### Simplifying cost structure of CE 267 
 * Joined equivalent variables [aux(121),s(363)] into aux(121)
 * Renamed intermediate variables: 
[ (eq(268,1),s(17))>>s(371)]
 * Renamed intermediate variables: 
[ (eq(268,3),aux(112))>>s(372), (eq(268,3),aux(113))>>s(373), (eq(268,3),aux(114))>>s(374), (eq(268,3),aux(115))>>s(375), (eq(268,3),s(307))>>s(376), (eq(268,3),s(305))>>s(377), (eq(268,3),s(306))>>s(378), (eq(268,3),s(308))>>s(379)]

#### Simplifying cost structure of CE 268 
 * Joined equivalent variables [aux(122),s(372)] into aux(122)

#### Cost of chains of rotate(A,B,C,D,E):
* Chain [258]: 16
  with precondition: [A=1,B=0,D=1,E=0,C>=0] 

* Chain [257]: 6*s(321)+40
  Such that:s(321) =< A

  with precondition: [C=0,A>=2,B>=1,D>=1,E>=0,A>=D,B>=E] 

* Chain [256]: 16*s(322)+40
  Such that:aux(116) =< A
s(322) =< aux(116)

  with precondition: [C=0,A>=2,B>=1,D>=2,E>=1,2*A>=D+1,2*B>=E] 

* Chain [255]: 6*s(325)+18
  Such that:s(325) =< A

  with precondition: [A=D,B=E,A>=2,B>=1,C>=0] 

* Chain [254]: 11*s(326)+10*s(330)+5*s(331)+10*s(333)+37
  Such that:s(328) =< B
s(329) =< C
aux(117) =< A
s(326) =< aux(117)
s(330) =< s(328)
s(331) =< s(328)
s(331) =< aux(117)
s(330) =< s(329)
s(333) =< s(329)
s(330) =< aux(117)
s(333) =< aux(117)

  with precondition: [A>=2,B>=1,D>=1,E>=0,C+1>=A,A>=D] 

* Chain [253]: 21*s(334)+10*s(339)+5*s(340)+10*s(341)+37
  Such that:s(335) =< B
s(336) =< C
aux(118) =< A
s(334) =< aux(118)
s(339) =< s(335)
s(340) =< s(335)
s(340) =< aux(118)
s(339) =< s(336)
s(341) =< s(336)
s(339) =< aux(118)
s(341) =< aux(118)

  with precondition: [A>=2,B>=1,D>=2,E>=1,C+1>=A,2*A>=D+1] 

* Chain [252]: 6*s(342)+20*s(347)+10*s(348)+10*s(349)+20*s(350)+40
  Such that:s(344) =< B
s(345) =< C
s(346) =< C+1
aux(119) =< A
s(342) =< aux(119)
s(347) =< s(344)
s(348) =< s(344)
s(348) =< s(346)
s(349) =< s(346)
s(347) =< s(345)
s(350) =< s(345)
s(347) =< aux(119)
s(350) =< aux(119)

  with precondition: [B>=1,C>=1,D>=1,E>=0,A>=2*C+1,A>=C+D] 

* Chain [251]: 6*s(351)+20*s(357)+20*s(358)+10*s(359)+10*s(360)+20*s(361)+40
  Such that:s(353) =< A-C
s(354) =< B
s(355) =< C
s(356) =< C+1
aux(120) =< A
s(351) =< aux(120)
s(357) =< s(353)
s(358) =< s(354)
s(359) =< s(354)
s(359) =< s(356)
s(360) =< s(356)
s(358) =< s(355)
s(361) =< s(355)
s(358) =< aux(120)
s(361) =< aux(120)

  with precondition: [B>=1,C>=1,D>=2,E>=1,A>=2*C+1,2*A>=2*C+D+1] 

* Chain [250]: 6*s(362)+20*s(367)+10*s(368)+10*s(369)+20*s(370)+40
  Such that:s(364) =< B
s(365) =< C
s(366) =< C+1
aux(121) =< A
s(362) =< aux(121)
s(367) =< s(364)
s(368) =< s(364)
s(368) =< s(366)
s(369) =< s(366)
s(367) =< s(365)
s(370) =< s(365)
s(367) =< aux(121)
s(370) =< aux(121)

  with precondition: [B>=1,D>=1,E>=0,2*C>=A,A>=C+2,C+1>=D] 

* Chain [249]: 6*s(371)+30*s(376)+20*s(377)+10*s(378)+20*s(379)+40
  Such that:s(373) =< B
s(374) =< C
s(375) =< C+1
aux(122) =< A
s(371) =< aux(122)
s(376) =< s(375)
s(377) =< s(373)
s(378) =< s(373)
s(378) =< s(375)
s(377) =< s(374)
s(379) =< s(374)
s(377) =< aux(122)
s(379) =< aux(122)

  with precondition: [B>=1,D>=2,E>=1,2*C>=A,A>=C+2,2*C+1>=D] 


#### Simplifying cost structure of CE 271 

#### Computing cost of phase [261] 

#### Simplifying cost structure of CE 269 

#### Cost of loops [261] 

 * loop 261:drop_slice(A,B,C,D,E) -> [drop_slice(A',B',C',D',E')] 
9
##### Pending set drop_slice(A,B,C,D,E)
* Psum in Loop 261: [it(261)=<1]

###### Computing sum for it(261)=<1  in Loop 261 
   - Applying inductive sum strategy 
     - head Candidate: B-1 
     - head Candidate: A 
     - head Candidate: A 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B-1 
     - tail Candidate: A 
     - tail Candidate: A 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(261)=<B-1,it(261)=<A,it(261)=<A,it(261)=<B-1,it(261)=<B-B',it(261)=<A-A',it(261)=<A-A',it(261)=<B-B'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [261] 

#### Simplifying cost structure of phase [261] 

#### Cost of phase [261]:drop_slice(A,B,C,D,E) -> [drop_slice(A',B',C',D',E')] 
9*it(261)+0
  Such that:it(261) =< A
it(261) =< A-A'
it(261) =< B
it(261) =< B-B'

#### Simplifying cost structure of chain [[261],260] 

#### Simplifying cost structure of CE 270 

#### Found solution for phase  [261] in the cache 

#### Cost of phase [261]:drop_slice(A,B,C,D,E) -> [drop_slice(A',B',C',D',E')] 
9*it(261)+0
  Such that:it(261) =< A
it(261) =< A-A'
it(261) =< B
it(261) =< B-B'

#### Simplifying cost structure of chain [[261],259] 

#### Cost of chains of drop_slice(A,B,C,D,E):
* Chain [[261],260]: 9*it(261)+6
  Such that:it(261) =< B-D

  with precondition: [A+D=B,A>=1,E>=1,B>=A+2,C>=E] 

* Chain [[261],259]: 9*it(261)+3
  Such that:it(261) =< B

  with precondition: [D=1,E=0,B>=2,C>=1,A+1>=B] 

* Chain [260]: 6
  with precondition: [A=0,B=D,C=E,B>=2,C>=1] 

* Chain [259]: 3
  with precondition: [B=1,C=0,D=1,E=0,A>=0] 


#### Simplifying cost structure of CE 275 

#### Computing cost of phase [264,265] 

#### Simplifying cost structure of CE 272 

#### Simplifying cost structure of CE 273 

#### Cost of loops [264,265] 

 * loop 264:take_slice(A,B,C,D,E) -> [take_slice(A',B',C',D',E')] 
10
 * loop 265:take_slice(A,B,C,D,E) -> [take_slice(A',B',C',D',E')] 
10
##### Pending set take_slice(A,B,C,D,E)
* Psum in Loop 264: [it(264)=<1]
* Psum in Loop 265: [it(265)=<1]

###### Computing sum for it(264)=<1  in Loop 264 
   - Applying inductive sum strategy 
     - head Candidate: B-1 
       - Loop 265 is collaborative and bounds [it(265)] 
     - head Candidate: A 
       - Loop 265 is collaborative and bounds [it(265)] 
     - head Candidate: A 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B-1 
       - Loop 265 is collaborative and bounds [it(265)] 
     - tail Candidate: A 
       - Loop 265 is collaborative and bounds [it(265)] 
     - tail Candidate: A 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(264)+it(265)=<B-1,it(264)+it(265)=<A,it(264)+it(265)=<A,it(264)+it(265)=<B-1,it(264)+it(265)=<B-B',it(264)+it(265)=<A-A',it(264)+it(265)=<A-A',it(264)+it(265)=<B-B'] 

##### Pending set A
* Psum in Loop 265: [it(265)=<1]

###### Computing sum for it(265)=<1  in Loop 265 
   - Applying inductive sum strategy 
     - head Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(264)+it(265)=<B-1,it(264)+it(265)=<A,it(264)+it(265)=<A,it(264)+it(265)=<B-1,it(264)+it(265)=<B-B',it(264)+it(265)=<A-A',it(264)+it(265)=<A-A',it(264)+it(265)=<B-B'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [264,265] 

#### Simplifying cost structure of phase [264,265] 
 * Joined equivalent variables [it(264),it(265)] into it(264)

#### Cost of phase [264,265]:take_slice(A,B,C,D,E) -> [take_slice(A',B',C',D',E')] 
20*it(264)+0
  Such that:aux(123) =< A
aux(124) =< A-A'
aux(125) =< B
aux(126) =< B-B'
it(264) =< aux(123)
it(264) =< aux(124)
it(264) =< aux(125)
it(264) =< aux(126)

#### Simplifying cost structure of chain [[264,265],263] 
 * Joined equivalent variables [aux(127),aux(123),aux(124),aux(126)] into aux(127)

#### Simplifying cost structure of CE 274 

#### Found solution for phase  [264,265] in the cache 

#### Cost of phase [264,265]:take_slice(A,B,C,D,E) -> [take_slice(A',B',C',D',E')] 
20*it(264)+0
  Such that:aux(123) =< A
aux(124) =< A-A'
aux(125) =< B
aux(126) =< B-B'
it(264) =< aux(123)
it(264) =< aux(124)
it(264) =< aux(125)
it(264) =< aux(126)

#### Simplifying cost structure of chain [[264,265],262] 
 * Joined equivalent variables [aux(128),aux(124),aux(125),aux(126)] into aux(128)

#### Cost of chains of take_slice(A,B,C,D,E):
* Chain [[264,265],263]: 20*it(264)+7
  Such that:aux(125) =< B
aux(127) =< A
it(264) =< aux(127)
it(264) =< aux(125)

  with precondition: [A+1=D,A>=1,E>=1,B>=A+2,C>=E] 

* Chain [[264,265],262]: 20*it(264)+3
  Such that:aux(123) =< A
aux(128) =< B
it(264) =< aux(123)
it(264) =< aux(128)

  with precondition: [B=D,B>=2,E>=1,A+1>=B,C>=E] 

* Chain [263]: 7
  with precondition: [A=0,D=1,E=0,B>=2,C>=1] 

* Chain [262]: 3
  with precondition: [B=1,C=0,D=1,E=0,A>=0] 


#### Simplifying cost structure of CE 279 

#### Simplifying cost structure of CE 276 
 * Renamed intermediate variables: 
[ (eq(277,2),aux(125))>>s(380), (eq(277,2),aux(127))>>s(381), (eq(277,2),it(264))>>s(382)]

#### Simplifying cost structure of CE 277 
 * Renamed intermediate variables: 
[ (eq(278,2),aux(123))>>s(383), (eq(278,2),aux(128))>>s(384), (eq(278,2),it(264))>>s(385)]

#### Simplifying cost structure of CE 278 
 * Renamed intermediate variables: 
[ (eq(281,1),it(261))>>s(386)]

#### Simplifying cost structure of CE 281 
 * Renamed intermediate variables: 
[ (eq(280,1),it(261))>>s(387)]

#### Simplifying cost structure of CE 280 
 * Renamed intermediate variables: 
[ (eq(283,1),it(261))>>s(388)]
 * Renamed intermediate variables: 
[ (eq(283,2),aux(123))>>s(389), (eq(283,2),aux(128))>>s(390), (eq(283,2),it(264))>>s(391)]

#### Simplifying cost structure of CE 283 
 * Renamed intermediate variables: 
[ (eq(282,1),it(261))>>s(392)]
 * Renamed intermediate variables: 
[ (eq(282,2),aux(125))>>s(393), (eq(282,2),aux(127))>>s(394), (eq(282,2),it(264))>>s(395)]

#### Simplifying cost structure of CE 282 

#### Cost of chains of slice(A,B,C,D,E,F):
* Chain [273]: 13
  with precondition: [A=1,B=0,E=1,F=0,C>=1,D+1>=C] 

* Chain [272]: 20
  with precondition: [C=1,D=0,E=1,F=0,A>=2,B>=1] 

* Chain [271]: 20*s(382)+20
  Such that:s(380) =< A
s(381) =< D
s(382) =< s(381)
s(382) =< s(380)

  with precondition: [C=1,D+1=E,D>=1,F>=1,A>=D+2,B>=F] 

* Chain [270]: 20*s(385)+16
  Such that:s(384) =< A
s(383) =< D
s(385) =< s(383)
s(385) =< s(384)

  with precondition: [C=1,A=E,A>=2,F>=1,D+1>=A,B>=F] 

* Chain [269]: 9*s(386)+20
  Such that:s(386) =< D

  with precondition: [E=1,F=0,C=D+1,B>=1,C>=2,A>=C+1] 

* Chain [268]: 9*s(387)+13
  Such that:s(387) =< A

  with precondition: [E=1,F=0,A>=2,B>=1,C>=A,D+1>=C] 

* Chain [267]: 9*s(388)+20*s(391)+16
  Such that:s(390) =< A-C+1
s(389) =< -C+D+1
s(388) =< C
s(391) =< s(389)
s(391) =< s(390)

  with precondition: [A+1=C+E,C>=2,F>=1,D+1>=A,A>=C+1,B>=F] 

* Chain [266]: 9*s(392)+20*s(395)+20
  Such that:s(393) =< A-C+1
s(394) =< -C+D+1
s(392) =< C
s(395) =< s(394)
s(395) =< s(393)

  with precondition: [D+2=C+E,C>=2,F>=1,D>=C,A>=D+2,B>=F] 


Closed-form bounds of last(A,B,C,D): 
-------------------------------------
* Chain [[155],153] with precondition: [C=1,A>=3,D>=1,B>=D] 
    - Upper bound: 7*A+6 
    - Complexity: n 
* Chain [154] with precondition: [A=1,B=0,C=1,D=0] 
    - Upper bound: 3 
    - Complexity: constant 
* Chain [153] with precondition: [A=2,C=1,D>=1,B>=D] 
    - Upper bound: 6 
    - Complexity: constant 

### Maximum cost of last(A,B,C,D): 7*A+6 
Asymptotic class: n 

Closed-form bounds of last_two(A,B,C,D,E): 
-------------------------------------
* Chain [[156],157] with precondition: [C=1,D=1,A>=4,E>=1,B>=E] 
    - Upper bound: 10*A+10 
    - Complexity: n 
* Chain [159] with precondition: [A=1,B=0,C=0,D=1,E=0] 
    - Upper bound: 3 
    - Complexity: constant 
* Chain [158] with precondition: [A=2,C=0,D=1,E=0,B>=1] 
    - Upper bound: 6 
    - Complexity: constant 
* Chain [157] with precondition: [A=3,C=1,D=1,E>=1,B>=E] 
    - Upper bound: 10 
    - Complexity: constant 

### Maximum cost of last_two(A,B,C,D,E): 10*A+10 
Asymptotic class: n 

Closed-form bounds of at(A,B,C,D,E): 
-------------------------------------
* Chain [[98],97] with precondition: [D=1,A>=1,E>=1,B>=A+2,C>=E] 
    - Upper bound: 9*A+7 
    - Complexity: n 
* Chain [[98],96] with precondition: [D=1,E=0,B>=2,C>=1,A+1>=B] 
    - Upper bound: 9*B+3 
    - Complexity: n 
* Chain [97] with precondition: [A=0,D=1,B>=2,E>=1,C>=E] 
    - Upper bound: 7 
    - Complexity: constant 
* Chain [96] with precondition: [B=1,C=0,D=1,E=0,A>=0] 
    - Upper bound: 3 
    - Complexity: constant 

### Maximum cost of at(A,B,C,D,E): max([9*A+4,9*B])+3 
Asymptotic class: n 

Closed-form bounds of lengthL(A,B,C,D,E,F): 
-------------------------------------
* Chain [163] with precondition: [A=1,C=1,D=0,E=0,F=0,B>=0] 
    - Upper bound: 4 
    - Complexity: constant 
* Chain [162] with precondition: [A=C,A=E+1,A=F+1,A>=2,B>=0,D>=1] 
    - Upper bound: 6*C+4 
    - Complexity: n 

### Maximum cost of lengthL(A,B,C,D,E,F): 6*C+4 
Asymptotic class: n 

Closed-form bounds of rev(A,B,C,D,E,F,G,H): 
-------------------------------------
* Chain [150] with precondition: [A=1,C=1,D=0,E=1,G=1,H=0,B>=0,F>=0] 
    - Upper bound: 4 
    - Complexity: constant 
* Chain [149] with precondition: [A=C,A=E,A=G,A>=2,B>=0,D>=1,F>=0,H>=1] 
    - Upper bound: 5*C+5*D+4 
    - Complexity: n 

### Maximum cost of rev(A,B,C,D,E,F,G,H): 5*C+5*D+4 
Asymptotic class: n 

Closed-form bounds of eq_lists(A,B,C,D,E): 
-------------------------------------
* Chain [[135,136,137],140] with precondition: [A=C,1>=E,A>=2,B>=0,D>=0,E>=0,B+D+E>=1] 
    - Upper bound: 27*A+5 
    - Complexity: n 
* Chain [[135,136,137],139] with precondition: [E=0,A>=2,B>=0,D>=0,C>=A+1] 
    - Upper bound: 27*A+6 
    - Complexity: n 
* Chain [[135,136,137],138] with precondition: [E=0,B>=0,C>=2,D>=0,A>=C+1] 
    - Upper bound: 27*A+6 
    - Complexity: n 
* Chain [140] with precondition: [A=1,C=1,E=1,B>=0,D>=0] 
    - Upper bound: 5 
    - Complexity: constant 
* Chain [139] with precondition: [A=1,E=0,B>=0,C>=2,D>=0] 
    - Upper bound: 6 
    - Complexity: constant 
* Chain [138] with precondition: [C=1,E=0,A>=2,B>=0,D>=0] 
    - Upper bound: 6 
    - Complexity: constant 

### Maximum cost of eq_lists(A,B,C,D,E): 27*A+6 
Asymptotic class: n 

Closed-form bounds of is_palindrome(A,B,C): 
-------------------------------------
* Chain [152] with precondition: [A=1,C=1,B>=0] 
    - Upper bound: 11 
    - Complexity: constant 
* Chain [151] with precondition: [1>=C,A>=2,B>=0,C>=0] 
    - Upper bound: 37*A+11 
    - Complexity: n 

### Maximum cost of is_palindrome(A,B,C): 37*A+11 
Asymptotic class: n 

Closed-form bounds of compress(A,B,C,D): 
-------------------------------------
* Chain [[99,100],101] with precondition: [A>=3,B>=0,C>=2,D>=0,A>=C,A+B>=C+1,A+D>=C+1] 
    - Upper bound: 21*A+7 
    - Complexity: n 
* Chain [102] with precondition: [A=1,C=1,B>=0,D>=0] 
    - Upper bound: 3 
    - Complexity: constant 
* Chain [101] with precondition: [A=2,C=2,B>=0,D>=0] 
    - Upper bound: 7 
    - Complexity: constant 

### Maximum cost of compress(A,B,C,D): 21*A+7 
Asymptotic class: n 

Closed-form bounds of pack(A,B,C,D,E): 
-------------------------------------
* Chain [205] with precondition: [A=1,C=1,D=0,B>=0,E>=0] 
    - Upper bound: 6 
    - Complexity: constant 
* Chain [204] with precondition: [A=2,C=2,D=2,B>=0,E>=0] 
    - Upper bound: 10 
    - Complexity: constant 
* Chain [203] with precondition: [B>=0,C>=2,D>=3,E>=0,A+2>=C+D] 
    - Upper bound: 34*A+10 
    - Complexity: n 
* Chain [202] with precondition: [B>=1,C>=3,D>=2,E>=1,A>=C,A+C>=D+4] 
    - Upper bound: 34*A+10 
    - Complexity: n 

### Maximum cost of pack(A,B,C,D,E): 34*A+10 
Asymptotic class: n 

Closed-form bounds of encode(A,B,C,D,E): 
-------------------------------------
* Chain [127] with precondition: [A=1,C=0,D=1,B>=0,E>=0] 
    - Upper bound: 6 
    - Complexity: constant 
* Chain [126] with precondition: [A=2,C=1,D=2,B>=0,E>=1] 
    - Upper bound: 12 
    - Complexity: constant 
* Chain [125] with precondition: [C=1,D=2,A>=3,B>=0,E+1>=A] 
    - Upper bound: 25*A+12 
    - Complexity: n 
* Chain [124] with precondition: [B>=1,C>=1,E>=1,D>=C+2,A>=D] 
    - Upper bound: 25*A+26 
    - Complexity: n 

### Maximum cost of encode(A,B,C,D,E): 25*A+26 
Asymptotic class: n 

Closed-form bounds of duplicate(A,B,C,D): 
-------------------------------------
* Chain [[115,116],117] with precondition: [2*A=C+1,A>=2,D>=1,B>=D] 
    - Upper bound: 12*A+3 
    - Complexity: n 
* Chain [117] with precondition: [A=1,B=0,C=1,D=0] 
    - Upper bound: 3 
    - Complexity: constant 

### Maximum cost of duplicate(A,B,C,D): 12*A+3 
Asymptotic class: n 
 * Joined equivalent variables [s(171),s(176)] into s(171)

Closed-form bounds of replicate(A,B,C,D,E): 
-------------------------------------
* Chain [220] with precondition: [A=1,B=0,D=1,E=0,C>=0] 
    - Upper bound: 9 
    - Complexity: constant 
* Chain [219] with precondition: [C=0,D=1,E=0,A>=2,B>=1] 
    - Upper bound: 13*A+5*B+9 
    - Complexity: n 
* Chain [218] with precondition: [A>=2,B>=1,C>=1,E>=1,D+1>=A+C] 
    - Upper bound: 43*A+5*B+9+14*C*A 
    - Complexity: n^2 

### Maximum cost of replicate(A,B,C,D,E): 14*C*A+30*A+ (13*A+5*B)+9 
Asymptotic class: n^2 

Closed-form bounds of drop(A,B,C,D,E): 
-------------------------------------
* Chain [114] with precondition: [A=1,B=0,D=1,E=0,C>=0] 
    - Upper bound: 5 
    - Complexity: constant 
* Chain [113] with precondition: [C=0,A=D,A>=2,E>=1,B>=E] 
    - Upper bound: 18*A+5 
    - Complexity: n 
* Chain [112] with precondition: [C=1,D=1,E=0,A>=2,B>=1] 
    - Upper bound: 7*A+5 
    - Complexity: n 

### Maximum cost of drop(A,B,C,D,E): 18*A+5 
Asymptotic class: n 

Closed-form bounds of split(A,B,C,D,E,F): 
-------------------------------------
* Chain [238] with precondition: [A=1,B=0,D=1,E=1,F=0,C>=0] 
    - Upper bound: 11 
    - Complexity: constant 
* Chain [237] with precondition: [C=0,D=1,A=E,B=F,A>=2,B>=1] 
    - Upper bound: 14 
    - Complexity: constant 
* Chain [236] with precondition: [D=1,C+1=E,B>=1,F>=2,2*C>=A,A>=C+2] 
    - Upper bound: 15*B+15*C+19 
    - Complexity: n 
* Chain [235] with precondition: [D=1,C+1=E,F>=1,2*C>=A,A>=C+2,B>=F] 
    - Upper bound: 15*B+15*C+19 
    - Complexity: n 
* Chain [234] with precondition: [D=1,A=E,A>=2,B>=1,F>=1,C+1>=A] 
    - Upper bound: 5*A+15*B+10*C+11 
    - Complexity: n 
* Chain [233] with precondition: [D=1,A=C+E,B>=1,C>=1,F>=2,A>=2*C+1] 
    - Upper bound: 15*B+15*C+19 
    - Complexity: n 
* Chain [232] with precondition: [D=1,A=C+E,C>=1,F>=1,A>=2*C+1,B>=F] 
    - Upper bound: 15*B+15*C+19 
    - Complexity: n 

### Maximum cost of split(A,B,C,D,E,F): max([3,15*B+10*C+max([5*C+8,5*A])])+11 
Asymptotic class: n 

Closed-form bounds of slice(A,B,C,D,E,F): 
-------------------------------------
* Chain [273] with precondition: [A=1,B=0,E=1,F=0,C>=1,D+1>=C] 
    - Upper bound: 13 
    - Complexity: constant 
* Chain [272] with precondition: [C=1,D=0,E=1,F=0,A>=2,B>=1] 
    - Upper bound: 20 
    - Complexity: constant 
* Chain [271] with precondition: [C=1,D+1=E,D>=1,F>=1,A>=D+2,B>=F] 
    - Upper bound: 20*D+20 
    - Complexity: n 
* Chain [270] with precondition: [C=1,A=E,A>=2,F>=1,D+1>=A,B>=F] 
    - Upper bound: 20*D+16 
    - Complexity: n 
* Chain [269] with precondition: [E=1,F=0,C=D+1,B>=1,C>=2,A>=C+1] 
    - Upper bound: 9*D+20 
    - Complexity: n 
* Chain [268] with precondition: [E=1,F=0,A>=2,B>=1,C>=A,D+1>=C] 
    - Upper bound: 9*A+13 
    - Complexity: n 
* Chain [267] with precondition: [A+1=C+E,C>=2,F>=1,D+1>=A,A>=C+1,B>=F] 
    - Upper bound: -11*C+20*D+36 
    - Complexity: n 
* Chain [266] with precondition: [D+2=C+E,C>=2,F>=1,D>=C,A>=D+2,B>=F] 
    - Upper bound: -11*C+20*D+40 
    - Complexity: n 

### Maximum cost of slice(A,B,C,D,E,F): max([20*D+7,max([-11*C+20*D+27,9*A])])+13 
Asymptotic class: n 

Closed-form bounds of concat(A,B,C,D,E,F,G,H,I,J,K,L): 
-------------------------------------
* Chain [[105,106],107] with precondition: [A=C,A+E=I+1,A+G=K+1,A>=2,B>=0,D>=1,E>=1,F>=0,G>=1,H>=0,L>=1,J>=F,L>=H,D+H>=L] 
    - Upper bound: 10*A+2 
    - Complexity: n 
* Chain [107] with precondition: [A=1,C=1,D=0,E=I,F=J,G=K,H=L,B>=0,E>=0,F>=0,G>=0,H>=0] 
    - Upper bound: 2 
    - Complexity: constant 

### Maximum cost of concat(A,B,C,D,E,F,G,H,I,J,K,L): 10*A+2 
Asymptotic class: n 

Closed-form bounds of rotate(A,B,C,D,E): 
-------------------------------------
* Chain [258] with precondition: [A=1,B=0,D=1,E=0,C>=0] 
    - Upper bound: 16 
    - Complexity: constant 
* Chain [257] with precondition: [C=0,A>=2,B>=1,D>=1,E>=0,A>=D,B>=E] 
    - Upper bound: 6*A+40 
    - Complexity: n 
* Chain [256] with precondition: [C=0,A>=2,B>=1,D>=2,E>=1,2*A>=D+1,2*B>=E] 
    - Upper bound: 16*A+40 
    - Complexity: n 
* Chain [255] with precondition: [A=D,B=E,A>=2,B>=1,C>=0] 
    - Upper bound: 6*A+18 
    - Complexity: n 
* Chain [254] with precondition: [A>=2,B>=1,D>=1,E>=0,C+1>=A,A>=D] 
    - Upper bound: 11*A+15*B+10*C+37 
    - Complexity: n 
* Chain [253] with precondition: [A>=2,B>=1,D>=2,E>=1,C+1>=A,2*A>=D+1] 
    - Upper bound: 21*A+15*B+10*C+37 
    - Complexity: n 
* Chain [252] with precondition: [B>=1,C>=1,D>=1,E>=0,A>=2*C+1,A>=C+D] 
    - Upper bound: 6*A+30*B+30*C+50 
    - Complexity: n 
* Chain [251] with precondition: [B>=1,C>=1,D>=2,E>=1,A>=2*C+1,2*A>=2*C+D+1] 
    - Upper bound: 26*A+30*B+10*C+50 
    - Complexity: n 
* Chain [250] with precondition: [B>=1,D>=1,E>=0,2*C>=A,A>=C+2,C+1>=D] 
    - Upper bound: 6*A+30*B+30*C+50 
    - Complexity: n 
* Chain [249] with precondition: [B>=1,D>=2,E>=1,2*C>=A,A>=C+2,2*C+1>=D] 
    - Upper bound: 6*A+30*B+50*C+70 
    - Complexity: n 

### Maximum cost of rotate(A,B,C,D,E): 6*A+2+max([10*A+22,15*B+10*C+19+max([15*A,15*B+20*C+13+max([20*C+20,nat(A-C)*20])])])+16 
Asymptotic class: n 

Closed-form bounds of removeAt(A,B,C,D,E): 
-------------------------------------
* Chain [[208,209],207] with precondition: [B=D+1,A>=2,E>=1,B>=A+1,C>=E] 
    - Upper bound: 20*A+6 
    - Complexity: n 
* Chain [[208,209],206] with precondition: [B=D,B>=2,E>=1,A>=B,C>=E] 
    - Upper bound: 20*A+3 
    - Complexity: n 
* Chain [207] with precondition: [A=1,B=D+1,B>=2,C>=1,E>=0,C>=E] 
    - Upper bound: 6 
    - Complexity: constant 
* Chain [206] with precondition: [B=1,C=0,D=1,E=0,A>=0] 
    - Upper bound: 3 
    - Complexity: constant 

### Maximum cost of removeAt(A,B,C,D,E): 20*A+6 
Asymptotic class: n 

Closed-form bounds of insertAt(A,B,C,D,E,F): 
-------------------------------------
* Chain [[144,145],143] with precondition: [C+1=E,A>=2,B>=2,F>=A,C>=B+1,A+D>=F+1] 
    - Upper bound: 20*B+8 
    - Complexity: n 
* Chain [[144,145],142] with precondition: [C+1=E,A>=1,B>=2,F>=A,C>=B+1,D>=F] 
    - Upper bound: 20*B+8 
    - Complexity: n 
* Chain [[144,145],141] with precondition: [C=E,A>=0,C>=2,F>=1,B>=C,D>=F] 
    - Upper bound: 20*B+3 
    - Complexity: n 
* Chain [143] with precondition: [B=1,C+1=E,A=F,A>=2,C>=2,D>=1] 
    - Upper bound: 8 
    - Complexity: constant 
* Chain [142] with precondition: [B=1,C+1=E,A>=1,C>=2,F>=A,D>=F] 
    - Upper bound: 8 
    - Complexity: constant 
* Chain [141] with precondition: [C=1,D=0,E=1,F=0,A>=0,B>=0] 
    - Upper bound: 3 
    - Complexity: constant 

### Maximum cost of insertAt(A,B,C,D,E,F): 20*B+8 
Asymptotic class: n 

Closed-form bounds of minusminus(A,B,C,D): 
-------------------------------------
* Chain [169] with precondition: [B+2=A+C,A>=0,B>=A,D>=B] 
    - Upper bound: -6*A+6*B+12 
    - Complexity: n 
* Chain [168] with precondition: [B+C=A+2,B>=0,D>=0,A>=B+1] 
    - Upper bound: 16*A-16*B+37 
    - Complexity: n 

### Maximum cost of minusminus(A,B,C,D): max([nat(-A+B+1)*6,nat(A-B+1)*6+5+nat(A-B+2)*10])+6 
Asymptotic class: n 

Closed-form bounds of randomL(A,B): 
-------------------------------------
* Chain [178] with precondition: [A>=0,B>=0] 
    - Upper bound: 2 
    - Complexity: constant 

### Maximum cost of randomL(A,B): 2 
Asymptotic class: constant 

Closed-form bounds of minL(A,B,C): 
-------------------------------------
* Chain [173] with precondition: [A=C,A>=0,B>=A+1] 
    - Upper bound: 2 
    - Complexity: constant 
* Chain [172] with precondition: [B=C,B>=0,A>=B] 
    - Upper bound: 2 
    - Complexity: constant 

### Maximum cost of minL(A,B,C): 2 
Asymptotic class: constant 

Closed-form bounds of rand_select(A,B,C,D,E): 
-------------------------------------
* Chain [189] with precondition: [A=1,D=1,B>=0,C>=0,E>=0] 
    - Upper bound: 15 
    - Complexity: constant 
* Chain [188] with precondition: [C=0,D=1,A>=2,B>=0,E>=0] 
    - Upper bound: 6*A+15 
    - Complexity: n 
* Chain [187] with precondition: [C+1=D,B>=0,C>=1,E>=0,A>=C+2] 
    - Upper bound: 10*A-10*C+10+ (71*A+39+20*A*A+60*A*C+135*C) 
    - Complexity: n^2 
* Chain [186] with precondition: [A=D,A>=2,B>=0,E>=0,C+1>=A] 
    - Upper bound: 206*A+59+80*A*A 
    - Complexity: n^2 

### Maximum cost of rand_select(A,B,C,D,E): 65*A+24+20*A*A+max([135*A+20+60*A*A,60*A*C+135*C+nat(A-C+1)*10])+6*A+15 
Asymptotic class: n^2 

Closed-form bounds of lotto_select(A,B,C,D): 
-------------------------------------
* Chain [195] with precondition: [A=0,B=0,C=1,D>=0] 
    - Upper bound: 89 
    - Complexity: constant 
* Chain [194] with precondition: [A=0,C=1,B>=1,D>=0] 
    - Upper bound: 12*B+30 
    - Complexity: n 
* Chain [193] with precondition: [A=1,B=0,C=2,D>=0] 
    - Upper bound: 833 
    - Complexity: constant 
* Chain [192] with precondition: [B=0,C=3,A>=2,D>=0] 
    - Upper bound: 1453 
    - Complexity: constant 
* Chain [191] with precondition: [B+1=C,B>=1,D>=0,A>=B] 
    - Upper bound: 212*B+274+ (80*B+80)* (B+1) 
    - Complexity: n^2 
* Chain [190] with precondition: [A+1=C,A>=1,D>=0,B>=A+1] 
    - Upper bound: 135*A+77*B+119+ (60*B+60)*A+ (20*B+20)* (B+1)+ (-10*A+10*B+20) 
    - Complexity: n^2 

### Maximum cost of lotto_select(A,B,C,D): max([1429,65*B+89+ (20*B+20)* (B+1)+max([135*B+155+ (60*B+60)* (B+1), (60*B+60)*A+135*A+nat(-A+B+2)*10])+ (12*B+6)])+24 
Asymptotic class: n^2 
* Total analysis performed in 17156 ms.


Cost relation system solved by CoFloCo in 17179 ms.

Method last terminates?: YES

 - l_1: size of l wrt. List<A>
 - l_2: size of l wrt. A
UB for last(l_1,l_2) = 7*l_1+6

Method last_two terminates?: YES

 - l_1: size of l wrt. List<A>
 - l_2: size of l wrt. A
UB for last_two(l_1,l_2) = 10*l_1+10

Method at terminates?: YES

 - k_1: size of k wrt. Rat
 - l_1: size of l wrt. List<A>
 - l_2: size of l wrt. A
UB for at(k_1,l_1,l_2) = max([9*k_1+4,9*l_1])+3

Method lengthL terminates?: YES

 - list_1: size of list wrt. List<Rat>
 - list_2: size of list wrt. Rat
 - list_3: size of list wrt. List<A>
 - list_4: size of list wrt. A
UB for lengthL(list_1,list_2,list_3,list_4) = 6*list_3+4

Method rev terminates?: YES

 - l_1: size of l wrt. List<Rat>
 - l_2: size of l wrt. Rat
 - l_3: size of l wrt. List<A>
 - l_4: size of l wrt. A
UB for rev(l_1,l_2,l_3,l_4) = 5*l_3+5*l_4+4

Method eq_lists terminates?: YES

 - l1_1: size of l1 wrt. List<Rat>
 - l1_2: size of l1 wrt. Rat
 - l2_1: size of l2 wrt. List<Rat>
 - l2_2: size of l2 wrt. Rat
UB for eq_lists(l1_1,l1_2,l2_1,l2_2) = 27*l1_1+6

Method is_palindrome terminates?: YES

 - list_1: size of list wrt. List<Rat>
 - list_2: size of list wrt. Rat
UB for is_palindrome(list_1,list_2) = 37*list_1+11

Method compress terminates?: YES

 - l_1: size of l wrt. List<Rat>
 - l_2: size of l wrt. Rat
UB for compress(l_1,l_2) = 21*l_1+7

Method pack terminates?: YES

 - list_1: size of list wrt. List<Rat>
 - list_2: size of list wrt. Rat
UB for pack(list_1,list_2) = 34*list_1+10

Method encode terminates?: YES

 - list_1: size of list wrt. List<Rat>
 - list_2: size of list wrt. Rat
UB for encode(list_1,list_2) = 25*list_1+26

Method duplicate terminates?: YES

 - list_1: size of list wrt. List<A>
 - list_2: size of list wrt. A
UB for duplicate(list_1,list_2) = 12*list_1+3

Method replicate terminates?: YES

 - list_1: size of list wrt. List<A>
 - list_2: size of list wrt. A
 - n_1: size of n wrt. Rat
UB for replicate(list_1,list_2,n_1) = 14*n_1*list_1+30*list_1+ (13*list_1+5*list_2)+9

Method drop terminates?: YES

 - list_1: size of list wrt. List<A>
 - list_2: size of list wrt. A
 - n_1: size of n wrt. Rat
UB for drop(list_1,list_2,n_1) = 18*list_1+5

Method split terminates?: YES

 - list_1: size of list wrt. List<A>
 - list_2: size of list wrt. A
 - n_1: size of n wrt. Rat
UB for split(list_1,list_2,n_1) = max([3,15*list_2+10*n_1+max([5*n_1+8,5*list_1])])+11

Method slice terminates?: YES

 - list_1: size of list wrt. List<A>
 - list_2: size of list wrt. A
 - b_1: size of b wrt. Rat
 - e_1: size of e wrt. Rat
UB for slice(list_1,list_2,b_1,e_1) = max([20*e_1+7,max([-11*b_1+20*e_1+27,9*list_1])])+13

Method concat terminates?: YES

 - l1_1: size of l1 wrt. List<Rat>
 - l1_2: size of l1 wrt. Rat
 - l1_3: size of l1 wrt. List<A>
 - l1_4: size of l1 wrt. A
 - l2_1: size of l2 wrt. List<Rat>
 - l2_2: size of l2 wrt. Rat
 - l2_3: size of l2 wrt. List<A>
 - l2_4: size of l2 wrt. A
UB for concat(l1_1,l1_2,l1_3,l1_4,l2_1,l2_2,l2_3,l2_4) = 10*l1_1+2

Method rotate terminates?: YES

 - list_1: size of list wrt. List<A>
 - list_2: size of list wrt. A
 - n_1: size of n wrt. Rat
UB for rotate(list_1,list_2,n_1) = 6*list_1+2+max([10*list_1+22,15*list_2+10*n_1+19+max([15*list_1,15*list_2+20*n_1+13+max([20*n_1+20,nat(list_1-n_1)*20])])])+16

Method removeAt terminates?: YES

 - n_1: size of n wrt. Rat
 - l_1: size of l wrt. List<A>
 - l_2: size of l wrt. A
UB for removeAt(n_1,l_1,l_2) = 20*n_1+6

Method insertAt terminates?: YES

 - x_1: size of x wrt. A
 - n_1: size of n wrt. Rat
 - l_1: size of l wrt. List<A>
 - l_2: size of l wrt. A
UB for insertAt(x_1,n_1,l_1,l_2) = 20*n_1+8

Method minusminus terminates?: YES

 - a_1: size of a wrt. Rat
 - b_1: size of b wrt. Rat
UB for minusminus(a_1,b_1) = max([nat(-a_1+b_1+1)*6,nat(a_1-b_1+1)*6+5+nat(a_1-b_1+2)*10])+6

Method randomL terminates?: YES

 - n_1: size of n wrt. Rat
UB for randomL(n_1) = 2

Method minL terminates?: YES

 - m_1: size of m wrt. Rat
 - n_1: size of n wrt. Rat
UB for minL(m_1,n_1) = 2

Method rand_select terminates?: YES

 - list_1: size of list wrt. List<Rat>
 - list_2: size of list wrt. Rat
 - n_1: size of n wrt. Rat
UB for rand_select(list_1,list_2,n_1) = 65*list_1+24+20*list_1*list_1+max([135*list_1+20+60*list_1*list_1,60*list_1*n_1+135*n_1+nat(list_1-n_1+1)*10])+6*list_1+15

Method lotto_select terminates?: YES

 - n_1: size of n wrt. Rat
 - m_1: size of m wrt. Rat
UB for lotto_select(n_1,m_1) = max([1429,65*m_1+89+ (20*m_1+20)* (m_1+1)+max([135*m_1+155+ (60*m_1+60)* (m_1+1), (60*m_1+60)*n_1+135*n_1+nat(-n_1+m_1+2)*10])+ (12*m_1+6)])+24
