
Abs program loaded in 22 ms.

Rule based representation generated in 1 ms.

Rule based representation stored in /tmp/costabs/rbr.rbr

RBR properties stored in /tmp/costabs/rbr.properties

Class invariants generated and loaded in 1 ms.

Abstract compilation performed in 14 ms.

Cost relation system stored in /tmp/costabs/crs.crs

Generated 28 equations 
entry('append'(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O):[]).
entry('subtrees'(A,B,C,D,E):[]).
input_output_vars('and_op'(A,B,C),[A,B],[C]).
input_output_vars('append'(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O),[A,B,C,D,E,F,G,H,I,J],[K,L,M,N,O]).
input_output_vars('case_0'(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O),[A,B,C,D,E,F,G,H,I,J],[K,L,M,N,O]).
input_output_vars('case_1'(A,B,C,D,E),[A,B],[C,D,E]).
input_output_vars('eq'(A,B,C),[A,B],[C]).
input_output_vars('geq'(A,B,C),[A,B],[C]).
input_output_vars('gt'(A,B,C),[A,B],[C]).
input_output_vars('leq'(A,B,C),[A,B],[C]).
input_output_vars('lt'(A,B,C),[A,B],[C]).
input_output_vars('maxNorm'(A,B,C),[A,B],[C]).
input_output_vars('neg'(A,B),[A],[B]).
input_output_vars('neq'(A,B,C),[A,B],[C]).
input_output_vars('or'(A,B,C),[A,B],[C]).
input_output_vars('subtrees'(A,B,C,D,E),[A,B],[C,D,E]).
eq('eq',[A,B,C],0,[],[A=B,C=1,A>=0,B>=0,C>=0]).
eq('eq',[A,B,C],0,[],[A>=B+1,C=0,A>=0,B>=0,C>=0]).
eq('eq',[A,B,C],0,[],[B>=A+1,C=0,A>=0,B>=0,C>=0]).
eq('neq',[A,B,C],0,[],[A=B,C=0,A>=0,B>=0,C>=0]).
eq('neq',[A,B,C],0,[],[A>=B+1,C=1,A>=0,B>=0,C>=0]).
eq('neq',[A,B,C],0,[],[B>=A+1,C=1,A>=0,B>=0,C>=0]).
eq('lt',[A,B,C],0,[],[B-A>=1,C=1,A>=0,B>=0,C>=0]).
eq('lt',[A,B,C],0,[],[B=<A,C=0,A>=0,B>=0,C>=0]).
eq('leq',[A,B,C],0,[],[A=<B,C=1,A>=0,B>=0,C>=0]).
eq('leq',[A,B,C],0,[],[A-B>=1,C=0,A>=0,B>=0,C>=0]).
eq('gt',[A,B,C],0,[],[A-B>=1,C=1,A>=0,B>=0,C>=0]).
eq('gt',[A,B,C],0,[],[A=<B,C=0,A>=0,B>=0,C>=0]).
eq('geq',[A,B,C],0,[],[B=<A,C=1,A>=0,B>=0,C>=0]).
eq('geq',[A,B,C],0,[],[B-A>=1,C=0,A>=0,B>=0,C>=0]).
eq('neg',[A,B],0,[],[A=0,B=1,A>=0,B>=0]).
eq('neg',[A,B],0,[],[A=1,B=0,A>=0,B>=0]).
eq('and_op',[A,B,C],0,[],[A=0,C=0,A>=0,B>=0,C>=0]).
eq('and_op',[A,B,C],0,[],[A=1,C=B,A>=0,B>=0,C>=0]).
eq('or',[A,B,C],0,[],[A=1,C=1,A>=0,B>=0,C>=0]).
eq('or',[A,B,C],0,[],[A=0,C=B,A>=0,B>=0,C>=0]).
eq('maxNorm',[A,B,A],0,[],[A>=1+B,A>=0,B>=0,A>=0]).
eq('maxNorm',[A,B,B],0,[],[A=<B,A>=0,B>=0,B>=0]).
eq('case_0',[A,B,C,D,E,F,G,H,I,J,F,G,H,I,J],1,[],[E=0,D=1,C=0,A=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,F>=0,G>=0,H>=0,I>=0,J>=0]).
eq('case_0',[A,B,C,D,E,F,G,H,I,J,K,L,M,N,O],4,['append'(P,Q,R,S,T,F,G,H,I,J,U,V,W,X,Y),'maxNorm'(Z,Y,O),'maxNorm'(A1,W,M)],[E>=Z,E>=T,C>=A1,C>=R,B>=B1,B>=Q,D=S+1,A=P+1,S>=1,P>=1,Z>=1,A1>=1,L>=B1,L>=V,N=X+1,K=U+1,X>=1,U>=1,Z>=1,A1>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0,M>=0,N>=0,O>=0]).
eq('append',[A,B,C,D,E,F,G,H,I,J,K,L,M,N,O],1,['case_0'(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O)],[A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0,M>=0,N>=0,O>=0]).
eq('case_1',[A,B,C,D,E],2,[],[B=1,E=0,C=1,A>=0,B>=0,C>=0,D>=0,E>=0]).
eq('case_1',[A,B,C,D,E],7,['subtrees'(F,G,H,I,J),'subtrees'(K,L,M,N,O),'append'(H,I,J,P,Q,M,N,O,R,S,T,U,V,W,X),'maxNorm'(Y,V,E)],[A>=Z,A>=F,A>=K,B=L+G+1,L>=1,G>=1,A1>=Z,A1>=F,A1>=K,Y=L+G+1,L>=1,G>=1,D>=A1,D>=U,C=T+1,T>=1,Y>=1,A>=0,B>=0,C>=0,D>=0,E>=0]).
eq('subtrees',[A,B,C,D,E],1,['case_1'(A,B,C,D,E)],[A>=0,B>=0,C>=0,D>=0,E>=0]).

Preprocessing Cost Relations
=====================================

#### Computed strongly connected components 
0. non_recursive  : [maxNorm/3]
1. recursive [non_tail] : [append/15,case_0/15]
2. recursive [non_tail,multiple] : [case_1/5,subtrees/5]
Warning: the following predicates are never called:[and_op/3,eq/3,geq/3,gt/3,leq/3,lt/3,neg/2,neq/3,or/3]

#### Obtained direct recursion through partial evaluation 
0. SCC is partially evaluated into maxNorm/3
1. SCC is partially evaluated into append/15
2. SCC is partially evaluated into subtrees/5

Control-Flow Refinement of Cost Relations
=====================================

### Specialization of cost equations maxNorm/3 
* CE 6 is refined into CE [7] 
* CE 5 is refined into CE [8] 


#### Refined cost equations maxNorm/3 
* CE 7: maxNorm(A,B,B) = 0
     [B>=A,A>=1] 
* CE 8: maxNorm(A,B,A) = 0
     [A>=B+1,B>=0] 

### Cost equations --> "Loop" of maxNorm/3 
* CEs [7] --> Loop 7 
* CEs [8] --> Loop 8 

#### Loops of maxNorm/3 
* Loop 7: maxNorm(A,B,B) [B>=A,A>=1] 
* Loop 8: maxNorm(A,B,A) [A>=B+1,B>=0] 

### Ranking functions of CR maxNorm(A,B,C) 

#### Partial ranking functions of CR maxNorm(A,B,C) 


### Resulting Chains:maxNorm(A,B,C) 
* [8]
* [7]


### Merging Chains  maxNorm/3 into  External patterns of execution 
* [[7]] --> 1 
* [[8]] --> 2 


### Specialization of cost equations append/15 
* CE 2 is refined into CE [9] 
* CE 1 is refined into CE [10,11,12,13] 


#### Refined cost equations append/15 
* CE 9: append(A,B,C,D,E,F,G,H,I,J,F,G,H,I,J) = 2
     [J>=0,I>=0,H>=0,G>=0,F>=0,B>=0,E=0,D=1,C=0,A=1] 
* CE 10: append(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O) = 5+ append(P,Q,R,S,T,F,G,H,I,J,U,V,M,W,O)+ maxNorm(X,O,O):1+ maxNorm(Y,M,M):1
     [L>=V,E>=T,C>=R,B>=Q,M>=Y,C>=Y,O>=X,E>=X,W>=1,U>=1,S>=1,P>=1,Y>=1,X>=1,L>=0,J>=0,I>=0,H>=0,G>=0,F>=0,B>=0,W+1=N,U+1=K,S+1=D,P+1=A] 
* CE 11: append(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O) = 5+ append(P,Q,R,S,T,F,G,H,I,J,U,V,W,X,O)+ maxNorm(Y,O,O):1+ maxNorm(M,W,M):2
     [L>=V,E>=T,C>=R,B>=Q,C>=M,M>=W+1,O>=Y,E>=Y,X>=1,U>=1,S>=1,P>=1,W>=0,Y>=1,L>=0,J>=0,I>=0,H>=0,G>=0,F>=0,B>=0,X+1=N,U+1=K,S+1=D,P+1=A] 
* CE 12: append(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O) = 5+ append(P,Q,R,S,T,F,G,H,I,J,U,V,M,W,X)+ maxNorm(O,X,O):2+ maxNorm(Y,M,M):1
     [L>=V,E>=T,C>=R,B>=Q,M>=Y,C>=Y,E>=O,O>=X+1,W>=1,U>=1,S>=1,P>=1,Y>=1,X>=0,L>=0,J>=0,I>=0,H>=0,G>=0,F>=0,B>=0,W+1=N,U+1=K,S+1=D,P+1=A] 
* CE 13: append(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O) = 5+ append(P,Q,R,S,T,F,G,H,I,J,U,V,W,X,Y)+ maxNorm(O,Y,O):2+ maxNorm(M,W,M):2
     [L>=V,E>=T,C>=R,B>=Q,C>=M,M>=W+1,E>=O,O>=Y+1,X>=1,U>=1,S>=1,P>=1,W>=0,Y>=0,L>=0,J>=0,I>=0,H>=0,G>=0,F>=0,B>=0,X+1=N,U+1=K,S+1=D,P+1=A] 

### Cost equations --> "Loop" of append/15 
* CEs [13] --> Loop 9 
* CEs [11] --> Loop 10 
* CEs [12] --> Loop 11 
* CEs [10] --> Loop 12 
* CEs [9] --> Loop 13 

#### Loops of append/15 
* Loop 9: append(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O)->  append(A',B',C',D',E',F,G,H,I,J,F',G',H',I',J')
                  [O>=J'+1,M>=H'+1,L>=G',E>=E',C>=C',B>=B',E>=O,C>=M,J'>=0,H'>=0,N>=2,L>=0,K>=2,J>=0,I>=0,H>=0,G>=0,F>=0,D>=2,B>=0,A>=2,N=I'+1,K=F'+1,D=D'+1,A=A'+1] 
* Loop 10: append(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O)->  append(A',B',C',D',E',F,G,H,I,J,F',G',H',I',O)
                  [M>=H'+1,L>=G',E>=E',C>=C',B>=B',C>=M,H'>=0,O>=1,N>=2,L>=0,K>=2,J>=0,I>=0,H>=0,G>=0,F>=0,E>=1,D>=2,B>=0,A>=2,N=I'+1,K=F'+1,D=D'+1,A=A'+1] 
* Loop 11: append(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O)->  append(A',B',C',D',E',F,G,H,I,J,F',G',M,H',I')
                  [O>=I'+1,L>=G',E>=E',C>=C',B>=B',E>=O,I'>=0,N>=2,M>=1,L>=0,K>=2,J>=0,I>=0,H>=0,G>=0,F>=0,D>=2,C>=1,B>=0,A>=2,N=H'+1,K=F'+1,D=D'+1,A=A'+1] 
* Loop 12: append(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O)->  append(A',B',C',D',E',F,G,H,I,J,F',G',M,H',O)
                  [L>=G',E>=E',C>=C',B>=B',O>=1,N>=2,M>=1,L>=0,K>=2,J>=0,I>=0,H>=0,G>=0,F>=0,E>=1,D>=2,C>=1,B>=0,A>=2,N=H'+1,K=F'+1,D=D'+1,A=A'+1] 
* Loop 13: append(A,B,C,D,E,F,G,H,I,J,F,G,H,I,J) [J>=0,I>=0,H>=0,G>=0,F>=0,B>=0,E=0,D=1,C=0,A=1] 

### Ranking functions of CR append(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O) 
* RF of phase [9,10,11,12]: [A-1,D-1]

#### Partial ranking functions of CR append(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O) 
* Partial RF of phase [9,10,11,12]:
  - RF of loop [9:1,10:1,11:1,12:1]:
    A-1
    D-1

Discarded unfeasible chain [[9,10,11,12]]...(Non-terminating chain proved terminating)

### Resulting Chains:append(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O) 
* [[9,10,11,12],13]
* [13]


### Merging Chains  append/15 into  External patterns of execution 
* [[13]] --> 1 
* [[13,[9,10,11,12]]] --> 2 


### Specialization of cost equations subtrees/5 
* CE 4 is refined into CE [14] 
* CE 3 is refined into CE [15,16,17,18] 


#### Refined cost equations subtrees/5 
* CE 14: subtrees(A,B,C,D,E) = 3
     [D>=0,A>=0,E=0,C=1,B=1] 
* CE 15: subtrees(A,B,C,D,E) = 8+ subtrees(F,G,H,I,J)+ subtrees(K,L,M,N,E)+ append(O,I,P,Q,R,M,N,E,S,T,M,N,E,S,T):1+ maxNorm(B,E,E):1
     [B>=L+2,D>=K,A>=K,D>=F,A>=F,E>=B,D>=N,L>=1,T>=0,S>=0,N>=0,M>=1,I>=0,A>=0,B=G+L+1,M+1=C,J=0,H=1,R=0,Q=1,P=0,O=1] 
* CE 16: subtrees(A,B,C,D,B) = 8+ subtrees(E,F,G,H,I)+ subtrees(J,K,L,M,N)+ append(O,H,P,Q,R,L,M,N,S,T,L,M,N,S,T):1+ maxNorm(B,N,B):2
     [B>=K+2,D>=J,A>=J,D>=E,A>=E,B>=N+1,D>=M,K>=1,N>=0,T>=0,S>=0,M>=0,L>=1,H>=0,A>=0,B=F+K+1,L+1=C,I=0,G=1,R=0,Q=1,P=0,O=1] 
* CE 17: subtrees(A,B,C,D,E) = 8+ subtrees(F,G,H,I,J)+ subtrees(K,L,M,N,O)+ append(H,I,J,H,P,Q,N,O,R,S,T,U,E,V,W):2+ maxNorm(B,E,E):1
     [J+O>=E,P+S>=W,B>=L+2,D>=K,A>=K,D>=F,A>=F,E>=B,D>=U,W>=S,E>=O,U>=N,V>=H,T>=H,L>=1,W>=1,S>=0,O>=0,N>=0,P>=1,H>=2,J>=1,I>=0,A>=0,B=G+L+1,H+R=V+1,H+M=T+1,H+Q=T+1,T+1=C] 
* CE 18: subtrees(A,B,C,D,B) = 8+ subtrees(E,F,G,H,I)+ subtrees(J,K,L,M,N)+ append(G,H,I,G,O,P,M,N,Q,R,S,T,U,V,W):2+ maxNorm(B,U,B):2
     [I+N>=U,O+R>=W,B>=K+2,D>=J,A>=J,D>=E,A>=E,B>=U+1,D>=T,W>=R,U>=N,T>=M,V>=G,S>=G,K>=1,U>=1,W>=1,R>=0,N>=0,M>=0,O>=1,G>=2,I>=1,H>=0,A>=0,B=F+K+1,G+Q=V+1,G+L=S+1,G+P=S+1,S+1=C] 

### Cost equations --> "Loop" of subtrees/5 
* CEs [17] --> Loop 14 
* CEs [18] --> Loop 15 
* CEs [15] --> Loop 16 
* CEs [16] --> Loop 17 
* CEs [14] --> Loop 18 

#### Loops of subtrees/5 
* Loop 14: subtrees(A,B,C,D,E)->  subtrees(A',B',C',D',E')  subtrees(A'2,B'2,C'2,D'2,E'2)
                  [E'+E'2>=E,E>=E'2,D>=D'2,D>=A'2,A>=A'2,C>=C'+1,B>=B'+2,D>=A',A>=A',E>=B,E'2>=0,D'2>=0,E'>=1,D'>=0,C'>=2,B'>=1,A>=0,C'+C'2=C,B'+B'2+1=B] 
* Loop 15: subtrees(A,B,C,D,B)->  subtrees(A',B',C',D',E')  subtrees(A'2,B'2,C'2,D'2,E'2)
                  [B>=E'2+1,D>=D'2,D>=A'2,A>=A'2,C>=C'+1,B>=B'+2,D>=A',A>=A',E'2>=0,D'2>=0,E'>=1,D'>=0,C'>=2,B'>=1,A>=0,B=B'+B'2+1,C'+C'2=C] 
* Loop 16: subtrees(A,B,C,D,E)->  subtrees(A',B',C',D',E')  subtrees(A'2,B'2,C'2,D'2,E)
                  [D>=D'2,D>=A'2,A>=A'2,B>=B'+2,D>=A',A>=A',E>=B,D'2>=0,D'>=0,B'>=1,C>=2,A>=0,B'+B'2+1=B,C=C'2+1,E'=0,C'=1] 
* Loop 17: subtrees(A,B,C,D,B)->  subtrees(A',B',C',D',E')  subtrees(A'2,B'2,C'2,D'2,E'2)
                  [B>=E'2+1,D>=D'2,D>=A'2,A>=A'2,B>=B'+2,D>=A',A>=A',E'2>=0,D'2>=0,D'>=0,B'>=1,C>=2,A>=0,B=B'+B'2+1,C=C'2+1,E'=0,C'=1] 
* Loop 18: subtrees(A,B,C,D,E) [D>=0,A>=0,E=0,C=1,B=1] 

### Ranking functions of CR subtrees(A,B,C,D,E) 
* RF of phase [14,15,16,17]: [B/2-1]

#### Partial ranking functions of CR subtrees(A,B,C,D,E) 
* Partial RF of phase [14,15,16,17]:
  - RF of loop [14:1,14:2,15:1,15:2,16:1,16:2,17:1,17:2]:
    B/2-1

Discarded unfeasible chain [multiple([14,15,16,17],[[],[18]])]...(Non-terminating chain proved terminating)
Remaining chain: [multiple([14,15,16,17],[[18]])]

### Resulting Chains:subtrees(A,B,C,D,E) 
* [18]
* [multiple([14,15,16,17],[[18]])]


### Merging Chains  subtrees/5 into  External patterns of execution 
* [[18]] --> 1 
* [[multiple([14,15,16,17],[[18]])]] --> 2 


Computing Bounds
=====================================

#### Simplifying cost structure of CE 8 

#### Simplifying cost structure of CE 7 

#### Cost of chains of maxNorm(A,B,C):
* Chain [8]: 0
  with precondition: [A=C,B>=0,A>=B+1] 

* Chain [7]: 0
  with precondition: [C=B,A>=1,C>=A] 


#### Simplifying cost structure of CE 9 

#### Computing cost of phase [9,10,11,12] 

#### Simplifying cost structure of CE 13 

#### Simplifying cost structure of CE 11 

#### Simplifying cost structure of CE 12 

#### Simplifying cost structure of CE 10 

#### Cost of loops [9,10,11,12] 

 * loop 9:append(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O) -> [append(A',B',C',D',E',F',G',H',I',J',K',L',M',N',O')] 
5
 * loop 10:append(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O) -> [append(A',B',C',D',E',F',G',H',I',J',K',L',M',N',O')] 
5
 * loop 11:append(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O) -> [append(A',B',C',D',E',F',G',H',I',J',K',L',M',N',O')] 
5
 * loop 12:append(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O) -> [append(A',B',C',D',E',F',G',H',I',J',K',L',M',N',O')] 
5
##### Pending set append(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O)
* Psum in Loop 9: [it(9)=<1]
* Psum in Loop 10: [it(10)=<1]
* Psum in Loop 11: [it(11)=<1]
* Psum in Loop 12: [it(12)=<1]

###### Computing sum for it(9)=<1  in Loop 9 
   - Applying inductive sum strategy 
     - head Candidate: D-1 
       - Loop 10 is collaborative and bounds [it(10)] 
       - Loop 11 is collaborative and bounds [it(11)] 
       - Loop 12 is collaborative and bounds [it(12)] 
     - head Candidate: A-1 
       - Loop 10 is collaborative and bounds [it(10)] 
       - Loop 11 is collaborative and bounds [it(11)] 
       - Loop 12 is collaborative and bounds [it(12)] 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: D-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: D-1 
       - Loop 10 is collaborative and bounds [it(10)] 
       - Loop 11 is collaborative and bounds [it(11)] 
       - Loop 12 is collaborative and bounds [it(12)] 
     - tail Candidate: A-1 
       - Loop 10 is collaborative and bounds [it(10)] 
       - Loop 11 is collaborative and bounds [it(11)] 
       - Loop 12 is collaborative and bounds [it(12)] 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: D-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(9)+it(10)+it(11)+it(12)=<D-1,it(9)+it(10)+it(11)+it(12)=<A-1,it(9)+it(10)+it(11)+it(12)=<A-1,it(9)+it(10)+it(11)+it(12)=<D-1,it(9)+it(10)+it(11)+it(12)=<D-D',it(9)+it(10)+it(11)+it(12)=<A-A',it(9)+it(10)+it(11)+it(12)=<A-A',it(9)+it(10)+it(11)+it(12)=<D-D'] 

##### Pending set A
* Psum in Loop 10: [it(10)=<1]
* Psum in Loop 11: [it(11)=<1]
* Psum in Loop 12: [it(12)=<1]

###### Computing sum for it(10)=<1  in Loop 10 
   - Applying inductive sum strategy 
     - head Candidate: D-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: D-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: D-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: D-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(9)+it(10)+it(11)+it(12)=<D-1,it(9)+it(10)+it(11)+it(12)=<A-1,it(9)+it(10)+it(11)+it(12)=<A-1,it(9)+it(10)+it(11)+it(12)=<D-1,it(9)+it(10)+it(11)+it(12)=<D-D',it(9)+it(10)+it(11)+it(12)=<A-A',it(9)+it(10)+it(11)+it(12)=<A-A',it(9)+it(10)+it(11)+it(12)=<D-D'] 

##### Pending set A
* Psum in Loop 11: [it(11)=<1]
* Psum in Loop 12: [it(12)=<1]

###### Computing sum for it(11)=<1  in Loop 11 
   - Applying inductive sum strategy 
     - head Candidate: D-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: D-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: D-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: D-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(9)+it(10)+it(11)+it(12)=<D-1,it(9)+it(10)+it(11)+it(12)=<A-1,it(9)+it(10)+it(11)+it(12)=<A-1,it(9)+it(10)+it(11)+it(12)=<D-1,it(9)+it(10)+it(11)+it(12)=<D-D',it(9)+it(10)+it(11)+it(12)=<A-A',it(9)+it(10)+it(11)+it(12)=<A-A',it(9)+it(10)+it(11)+it(12)=<D-D'] 

##### Pending set A
* Psum in Loop 12: [it(12)=<1]

###### Computing sum for it(12)=<1  in Loop 12 
   - Applying inductive sum strategy 
     - head Candidate: D-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: D-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: D-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: D-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(9)+it(10)+it(11)+it(12)=<D-1,it(9)+it(10)+it(11)+it(12)=<A-1,it(9)+it(10)+it(11)+it(12)=<A-1,it(9)+it(10)+it(11)+it(12)=<D-1,it(9)+it(10)+it(11)+it(12)=<D-D',it(9)+it(10)+it(11)+it(12)=<A-A',it(9)+it(10)+it(11)+it(12)=<A-A',it(9)+it(10)+it(11)+it(12)=<D-D'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [9,10,11,12] 

#### Simplifying cost structure of phase [9,10,11,12] 
 * Joined equivalent variables [it(9),it(10),it(11),it(12)] into it(9)

#### Cost of phase [9,10,11,12]:append(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O) -> [append(A',B',C',D',E',F',G',H',I',J',K',L',M',N',O')] 
20*it(9)+0
  Such that:aux(1) =< A
aux(2) =< A-A'
aux(3) =< D
aux(4) =< D-D'
it(9) =< aux(1)
it(9) =< aux(2)
it(9) =< aux(3)
it(9) =< aux(4)

#### Simplifying cost structure of chain [[9,10,11,12],13] 
 * Joined equivalent variables [aux(5),aux(1),aux(2),aux(3),aux(4)] into aux(5)

#### Cost of chains of append(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O):
* Chain [[9,10,11,12],13]: 20*it(9)+2
  Such that:aux(5) =< D
it(9) =< aux(5)

  with precondition: [A=D,A+F=K+1,A+I=N+1,A>=2,B>=0,C>=1,E>=1,F>=1,G>=0,H>=0,I>=1,J>=0,M>=1,O>=1,L>=G,M>=H,O>=J,C+H>=M,E+J>=O] 

* Chain [13]: 2
  with precondition: [A=1,C=0,D=1,E=0,F=K,G=L,H=M,I=N,J=O,B>=0,F>=0,G>=0,H>=0,I>=0,J>=0] 


#### Simplifying cost structure of CE 14 

#### Computing cost of chain [multiple([14,15,16,17],[[18]])] with multiple recursion
 * The following loops are unfeasible in this instance of the phase [14,15,16,17] : [14,16] 
 * Renamed intermediate variables: 
[ (eq(18,1),aux(5))>>s(1), (eq(18,1),it(9))>>s(2)]

#### Simplifying cost structure of CE 18 
 * Renamed intermediate variables: 
[ (it(15),s(1))>>s(3), (it(15),s(2))>>s(4)]

#### Simplifying cost structure of CE 16 

#### Cost of loops [15,17] 

 * loop 15:subtrees(A,B,C,D,E) -> [subtrees(A',B',C',D',E'),subtrees(A'2,B'2,C'2,D'2,E'2)] 
20*s(4)+10
  Such that:s(3) =< B/2-B'2/2
s(4) =< s(3)

 * loop 17:subtrees(A,B,C,D,E) -> [subtrees(A',B',C',D',E'),subtrees(A'2,B'2,C'2,D'2,E'2)] 
10
##### Pending set subtrees(A,B,C,D,E)
* Psum in Loop 15: [it(15)=<1,s(6)=<B/2-B'2/2]
* Psum in Loop 17: [it(17)=<1]
* Psum in Chain-Tail [18]: [it([18])=<1]

###### Computing sum for it(15)=<1  in Loop 15 
   - Applying inductive sum strategy 
     - head Candidate: 2/3*B-1/3 
       - Loop 17 is collaborative and bounds [it(17)] 
       - Chain-Tail [18] is collaborative
     - head Candidate: B/2-1/2 
       - Loop 17 is collaborative and bounds [it(17)] 
       - Chain-Tail [18] is collaborative
     - tail Candidate: 2/3*B-1/3 
       - Loop 17 is collaborative and bounds [it(17)] 
       - Chain-Tail [18] is collaborative
     - tail Candidate: B/2-1/2 
       - Loop 17 is collaborative and bounds [it(17)] 
       - Chain-Tail [18] is collaborative
 * Adding constraints: [it(15)+it(17)=<2/3*B-1/3,it(15)+it(17)=<B/2-1/2,it(15)+it(17)=<2/3*B-1/3,it(15)+it(17)=<B/2-1/2] 

##### Pending set A
* Psum in Loop 15: [s(6)=<B/2-B'2/2]
* Psum in Loop 17: [it(17)=<1]
* Psum in Chain-Tail [18]: [it([18])=<1]

###### Computing sum for s(6)=<B/2-B'2/2  in Loop 15 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(6)=<B/2-1/2] 
 * Adding constraints: [s(6)=<it(15)*aux(6)] 

##### Pending set subtrees(A,B,C,D,E)
* Pmax/min: [aux(6)=<B/2-1/2]
* Psum in Loop 17: [it(17)=<1]
* Psum in Chain-Tail [18]: [it([18])=<1]

###### Computing max_min for aux(6)=<B/2-1/2  
   - Found a solution using transitive invariants 
 * Adding constraints:[aux(6)=<B/2-1/2] 

##### Pending set subtrees(A,B,C,D,E)
* Psum in Loop 17: [it(17)=<1]
* Psum in Chain-Tail [18]: [it([18])=<1]

###### Computing sum for it(17)=<1  in Loop 17 
   - Applying inductive sum strategy 
     - head Candidate: 2/3*B-1/3 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: B/2-1/2 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: 2/3*B-1/3 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B/2-1/2 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(15)+it(17)=<2/3*B-1/3,it(15)+it(17)=<B/2-1/2,it(15)+it(17)=<2/3*B-1/3,it(15)+it(17)=<B/2-1/2] 

##### Pending set subtrees(A,B,C,D,E)
* Psum in Chain-Tail [18]: [it([18])=<1]

###### Computing sum for it([18])=<1  in Chain-Tail [18] 
   - Applying inductive sum strategy 
     - head Candidate: B/2+1/2 
       - Loop 15 is collaborative
       - Loop 17 is collaborative
     - tail Candidate: B/2+1/2 
       - Loop 15 is collaborative
       - Loop 17 is collaborative
 * Adding constraints: [it([18])=<B/2+1/2,it([18])=<B/2+1/2] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [15,17,[18]] 

#### Simplifying cost structure of phase [15,17,[18]] 
 * Joined equivalent variables [aux(7),aux(6)] into aux(7)
 * Joined equivalent variables [it(15),it(17)] into it(15)

#### Cost of phase [14,15,16,17]:subtrees(A,B,C,D,E) -> [] 
20*it(15)+3*it([18])+20*s(5)+0
  Such that:it([18]) =< B/2+1/2
aux(7) =< B/2
aux(8) =< 2/3*B
it(15) =< aux(7)
it(15) =< aux(8)
s(6) =< it(15)*aux(7)
s(5) =< s(6)

#### Cost of chains of subtrees(A,B,C,D,E):
* Chain [18]: 3
  with precondition: [B=1,C=1,E=0,A>=0,D>=0] 

* Chain [multiple([14,15,16,17],[[18]])]: 20*it(15)+3*it([18])+20*s(5)+0
  Such that:it([18]) =< B/2+1/2
aux(7) =< B/2
aux(8) =< 2/3*B
it(15) =< aux(7)
it(15) =< aux(8)
s(6) =< it(15)*aux(7)
s(5) =< s(6)

  with precondition: [B+1=2*C,B=E,A>=0,B>=3,D>=0] 


Closed-form bounds of append(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O): 
-------------------------------------
* Chain [[9,10,11,12],13] with precondition: [A=D,A+F=K+1,A+I=N+1,A>=2,B>=0,C>=1,E>=1,F>=1,G>=0,H>=0,I>=1,J>=0,M>=1,O>=1,L>=G,M>=H,O>=J,C+H>=M,E+J>=O] 
    - Upper bound: 20*D+2 
    - Complexity: n 
* Chain [13] with precondition: [A=1,C=0,D=1,E=0,F=K,G=L,H=M,I=N,J=O,B>=0,F>=0,G>=0,H>=0,I>=0,J>=0] 
    - Upper bound: 2 
    - Complexity: constant 

### Maximum cost of append(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O): 20*D+2 
Asymptotic class: n 

Closed-form bounds of subtrees(A,B,C,D,E): 
-------------------------------------
* Chain [18] with precondition: [B=1,C=1,E=0,A>=0,D>=0] 
    - Upper bound: 3 
    - Complexity: constant 
* Chain [multiple([14,15,16,17],[[18]])] with precondition: [B+1=2*C,B=E,A>=0,B>=3,D>=0] 
    - Upper bound: 23/2*B+3/2+B/2* (10*B) 
    - Complexity: n^2 

### Maximum cost of subtrees(A,B,C,D,E): max([3,23/2*B+3/2+B/2* (10*B)]) 
Asymptotic class: n^2 
* Total analysis performed in 979 ms.


Cost relation system solved by CoFloCo in 982 ms.

Method append terminates?: YES

 - l1_1: size of l1 wrt. List<Tree>
 - l1_2: size of l1 wrt. Rat
 - l1_3: size of l1 wrt. Tree
 - l1_4: size of l1 wrt. List<A>
 - l1_5: size of l1 wrt. A
 - l2_1: size of l2 wrt. List<Tree>
 - l2_2: size of l2 wrt. Rat
 - l2_3: size of l2 wrt. Tree
 - l2_4: size of l2 wrt. List<A>
 - l2_5: size of l2 wrt. A
UB for append(l1_1,l1_2,l1_3,l1_4,l1_5,l2_1,l2_2,l2_3,l2_4,l2_5) = 20*l1_4+2

Method subtrees terminates?: YES

 - t_1: size of t wrt. Rat
 - t_2: size of t wrt. Tree
UB for subtrees(t_1,t_2) = max([3,23/2*t_2+3/2+t_2/2* (10*t_2)])
