
Abs program loaded in 17 ms.

Rule based representation generated in 3 ms.

Rule based representation stored in /tmp/costabs/rbr.rbr

RBR properties stored in /tmp/costabs/rbr.properties

Class invariants generated and loaded in 0 ms.

Abstract compilation performed in 19 ms.

Cost relation system stored in /tmp/costabs/crs.crs

Generated 37 equations 
entry('appendL'(A,B,C,D,E,F):[]).
entry('flatten'(A,B,C,D,E):[]).
entry('insertL'(A,B,C,D,E):[]).
entry('insertionsort'(A,B,C,D):[]).
entry('flattensort'(A,B,C,D,E):[]).
input_output_vars('and_op'(A,B,C),[A,B],[C]).
input_output_vars('appendL'(A,B,C,D,E,F),[A,B,C,D],[E,F]).
input_output_vars('case_0'(A,B,C,D,E,F),[A,B,C,D],[E,F]).
input_output_vars('case_1'(A,B,C,D,E),[A,B,C],[D,E]).
input_output_vars('case_2'(A,B,C,D,E),[A,B,C],[D,E]).
input_output_vars('case_3'(A,B,C,D,E,F,G,H),[A,B,C,D,E,F],[G,H]).
input_output_vars('case_4'(A,B,C,D),[A,B],[C,D]).
input_output_vars('eq'(A,B,C),[A,B],[C]).
input_output_vars('flatten'(A,B,C,D,E),[A,B,C],[D,E]).
input_output_vars('flattensort'(A,B,C,D,E),[A,B,C],[D,E]).
input_output_vars('geq'(A,B,C),[A,B],[C]).
input_output_vars('gt'(A,B,C),[A,B],[C]).
input_output_vars('insertL'(A,B,C,D,E),[A,B,C],[D,E]).
input_output_vars('insertionsort'(A,B,C,D),[A,B],[C,D]).
input_output_vars('leq'(A,B,C),[A,B],[C]).
input_output_vars('lt'(A,B,C),[A,B],[C]).
input_output_vars('maxNorm'(A,B,C),[A,B],[C]).
input_output_vars('neg'(A,B),[A],[B]).
input_output_vars('neq'(A,B,C),[A,B],[C]).
input_output_vars('or'(A,B,C),[A,B],[C]).
eq('eq',[A,B,C],0,[],[A=B,C=1,A>=0,B>=0,C>=0]).
eq('eq',[A,B,C],0,[],[A>=B+1,C=0,A>=0,B>=0,C>=0]).
eq('eq',[A,B,C],0,[],[B>=A+1,C=0,A>=0,B>=0,C>=0]).
eq('neq',[A,B,C],0,[],[A=B,C=0,A>=0,B>=0,C>=0]).
eq('neq',[A,B,C],0,[],[A>=B+1,C=1,A>=0,B>=0,C>=0]).
eq('neq',[A,B,C],0,[],[B>=A+1,C=1,A>=0,B>=0,C>=0]).
eq('lt',[A,B,C],0,[],[B-A>=1,C=1,A>=0,B>=0,C>=0]).
eq('lt',[A,B,C],0,[],[B=<A,C=0,A>=0,B>=0,C>=0]).
eq('leq',[A,B,C],0,[],[A=<B,C=1,A>=0,B>=0,C>=0]).
eq('leq',[A,B,C],0,[],[A-B>=1,C=0,A>=0,B>=0,C>=0]).
eq('gt',[A,B,C],0,[],[A-B>=1,C=1,A>=0,B>=0,C>=0]).
eq('gt',[A,B,C],0,[],[A=<B,C=0,A>=0,B>=0,C>=0]).
eq('geq',[A,B,C],0,[],[B=<A,C=1,A>=0,B>=0,C>=0]).
eq('geq',[A,B,C],0,[],[B-A>=1,C=0,A>=0,B>=0,C>=0]).
eq('neg',[A,B],0,[],[A=0,B=1,A>=0,B>=0]).
eq('neg',[A,B],0,[],[A=1,B=0,A>=0,B>=0]).
eq('and_op',[A,B,C],0,[],[A=0,C=0,A>=0,B>=0,C>=0]).
eq('and_op',[A,B,C],0,[],[A=1,C=B,A>=0,B>=0,C>=0]).
eq('or',[A,B,C],0,[],[A=1,C=1,A>=0,B>=0,C>=0]).
eq('or',[A,B,C],0,[],[A=0,C=B,A>=0,B>=0,C>=0]).
eq('maxNorm',[A,B,A],0,[],[A>=1+B,A>=0,B>=0,A>=0]).
eq('maxNorm',[A,B,B],0,[],[A=<B,A>=0,B>=0,B>=0]).
eq('case_0',[A,B,C,D,C,D],1,[],[A=1,A>=0,B>=0,C>=0,D>=0,C>=0,D>=0]).
eq('case_0',[A,B,C,D,E,F],4,['appendL'(G,H,C,D,I,J)],[B>=K,B>=H,A=G+1,G>=1,F>=K,F>=J,E=I+1,I>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0]).
eq('appendL',[A,B,C,D,E,F],1,['case_0'(A,B,C,D,E,F)],[A>=0,B>=0,C>=0,D>=0,E>=0,F>=0]).
eq('case_1',[A,B,C,D,E],2,[],[C=1,A=0,D=1,A>=0,B>=0,C>=0,D>=0,E>=0]).
eq('case_1',[A,B,C,D,E],6,['flatten'(F,G,H,I,J),'flatten'(K,L,M,N,O),'appendL'(I,J,N,O,P,Q),'appendL'(R,S,P,Q,D,E)],[B>=S,B>=G,B>=L,A>=R,A>=F,A>=K,C=M+H+1,M>=1,H>=1,R>=1,A>=0,B>=0,C>=0,D>=0,E>=0]).
eq('flatten',[A,B,C,D,E],1,['case_1'(A,B,C,D,E)],[A>=0,B>=0,C>=0,D>=0,E>=0]).
eq('case_2',[A,B,C,D,E],3,[],[B=1,F=1,E>=A,E>=G,D=F+1,F>=1,A>=0,B>=0,C>=0,D>=0,E>=0]).
eq('case_3',[A,B,C,D,E,F,G,H],3,['insertL'(A,E,F,I,J)],[A>=D+1,H>=D,H>=J,G=I+1,I>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0]).
eq('case_3',[A,B,C,D,E,F,G,H],3,[],[D>=A,I>=D,I>=F,J=E+1,E>=1,H>=A,H>=I,G=J+1,J>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0]).
eq('case_2',[A,B,C,D,E],3,['case_3'(A,B,C,F,G,H,D,E)],[C>=F,C>=H,B=G+1,G>=1,A>=0,B>=0,C>=0,D>=0,E>=0]).
eq('insertL',[A,B,C,D,E],1,['case_2'(A,B,C,D,E)],[A>=0,B>=0,C>=0,D>=0,E>=0]).
eq('case_4',[A,B,C,D],2,[],[A=1,C=1,A>=0,B>=0,C>=0,D>=0]).
eq('case_4',[A,B,C,D],4,['insertionsort'(E,F,G,H),'insertL'(I,G,H,C,D)],[B>=I,B>=F,A=E+1,E>=1,A>=0,B>=0,C>=0,D>=0]).
eq('insertionsort',[A,B,C,D],1,['case_4'(A,B,C,D)],[A>=0,B>=0,C>=0,D>=0]).
eq('flattensort',[A,B,C,D,E],2,['flatten'(A,B,C,F,G),'insertionsort'(F,G,D,E)],[A>=0,B>=0,C>=0,D>=0,E>=0]).

Preprocessing Cost Relations
=====================================

#### Computed strongly connected components 
0. recursive  : [appendL/6,case_0/6]
1. recursive [non_tail,multiple] : [case_1/5,flatten/5]
2. recursive  : [case_2/5,case_3/8,insertL/5]
3. recursive [non_tail] : [case_4/4,insertionsort/4]
4. non_recursive  : [flattensort/5]
Warning: the following predicates are never called:[and_op/3,eq/3,geq/3,gt/3,leq/3,lt/3,maxNorm/3,neg/2,neq/3,or/3]

#### Obtained direct recursion through partial evaluation 
0. SCC is partially evaluated into appendL/6
1. SCC is partially evaluated into flatten/5
2. SCC is partially evaluated into insertL/5
3. SCC is partially evaluated into insertionsort/4
4. SCC is partially evaluated into flattensort/5

Control-Flow Refinement of Cost Relations
=====================================

### Specialization of cost equations appendL/6 
* CE 2 is refined into CE [11] 
* CE 1 is refined into CE [12] 


#### Refined cost equations appendL/6 
* CE 11: appendL(A,B,C,D,C,D) = 2
     [D>=0,C>=0,B>=0,A=1] 
* CE 12: appendL(A,B,C,D,E,F) = 5+ appendL(G,H,C,D,I,J)
     [F>=J,B>=H,I>=1,G>=1,F>=0,D>=0,C>=0,B>=0,I+1=E,G+1=A] 

### Cost equations --> "Loop" of appendL/6 
* CEs [12] --> Loop 11 
* CEs [11] --> Loop 12 

#### Loops of appendL/6 
* Loop 11: appendL(A,B,C,D,E,F)->  appendL(A',B',C,D,C',D')
                  [F>=D',B>=B',C'>=1,A'>=1,F>=0,D>=0,C>=0,B>=0,C'+1=E,A'+1=A] 
* Loop 12: appendL(A,B,C,D,C,D) [D>=0,C>=0,B>=0,A=1] 

### Ranking functions of CR appendL(A,B,C,D,E,F) 
* RF of phase [11]: [A-1]

#### Partial ranking functions of CR appendL(A,B,C,D,E,F) 
* Partial RF of phase [11]:
  - RF of loop [11:1]:
    A-1

Discarded unfeasible chain [[11]]...(Non-terminating chain proved terminating)

### Resulting Chains:appendL(A,B,C,D,E,F) 
* [[11],12]
* [12]


### Merging Chains  appendL/6 into  External patterns of execution 
* [[12]] --> 1 
* [[12,[11]]] --> 2 


### Specialization of cost equations flatten/5 
* CE 4 is refined into CE [13] 
* CE 3 is refined into CE [14,15,16,17] 


#### Refined cost equations flatten/5 
* CE 13: flatten(A,B,C,D,E) = 3
     [E>=0,B>=0,D=1,C=1,A=0] 
* CE 14: flatten(A,B,C,D,E) = 7+ flatten(F,G,H,I,J)+ flatten(K,L,M,D,E)+ appendL(N,J,D,E,D,E):1+ appendL(O,P,D,E,D,E):1
     [B>=L,A>=K,B>=G,A>=F,B>=P,M>=1,H>=1,E>=0,D>=0,P>=0,J>=0,A>=1,H+M+1=C,I=1,O=1,N=1] 
* CE 15: flatten(A,B,C,D,E) = 7+ flatten(F,G,H,I,J)+ flatten(K,L,M,N,O)+ appendL(P,J,Q,O,R,O):1+ appendL(S,T,U,O,D,E):2
     [B>=L,A>=K,B>=G,A>=F,E>=O,B>=T,D>=S,A>=S,M>=1,H>=1,O>=0,T>=0,S>=2,J>=0,D+1=S+N,D+1=S+U,D+1=R+S,D+1=Q+S,H+M+1=C,I=1,P=1] 
* CE 16: flatten(A,B,C,D,E) = 7+ flatten(F,G,H,I,J)+ flatten(K,L,M,N,O)+ appendL(I,J,P,O,D,E):2+ appendL(Q,R,D,E,D,E):1
     [B>=L,A>=K,B>=G,A>=F,B>=R,E>=O,D>=I,M>=1,H>=1,R>=0,O>=0,J>=0,I>=2,A>=1,D+1=I+N,D+1=I+P,H+M+1=C,Q=1] 
* CE 17: flatten(A,B,C,D,E) = 7+ flatten(F,G,H,I,J)+ flatten(K,L,M,N,O)+ appendL(I,J,P,O,Q,R):2+ appendL(S,T,U,R,D,E):2
     [D+1>=I+S,B>=L,A>=K,B>=G,A>=F,E>=R,B>=T,A>=S,R>=O,M>=1,H>=1,T>=0,S>=2,O>=0,J>=0,I>=2,D+2=I+S+N,D+2=I+P+S,D+1=S+U,D+1=Q+S,H+M+1=C] 

### Cost equations --> "Loop" of flatten/5 
* CEs [17] --> Loop 13 
* CEs [16] --> Loop 14 
* CEs [15] --> Loop 15 
* CEs [14] --> Loop 16 
* CEs [13] --> Loop 17 

#### Loops of flatten/5 
* Loop 13: flatten(A,B,C,D,E)->  flatten(A',B',C',D',E')  flatten(A'2,B'2,C'2,D'2,E'2)
                  [A+D'+D'2>=D+2,D>=D'+D'2,E>=E'2,B>=B'2,A>=A'2,C>=C'+2,B>=B',A>=A',E'2>=0,D'2>=1,E'>=0,D'>=2,C'>=1,B>=0,C'+C'2+1=C] 
* Loop 14: flatten(A,B,C,D,E)->  flatten(A',B',C',D',E')  flatten(A'2,B'2,C'2,D'2,E'2)
                  [E>=E'2,B>=B'2,A>=A'2,D>=D',C>=C'+2,B>=B',A>=A',E'2>=0,E'>=0,D'>=2,C'>=1,B>=0,A>=1,D'+D'2=D+1,C'+C'2+1=C] 
* Loop 15: flatten(A,B,C,D,E)->  flatten(A',B',C',D',E')  flatten(A'2,B'2,C'2,D'2,E'2)
                  [A+D'2>=D+1,E>=E'2,D>=D'2+1,B>=B'2,A>=A'2,C>=C'+2,B>=B',A>=A',E'2>=0,D'2>=1,E'>=0,C'>=1,B>=0,C'+C'2+1=C,D'=1] 
* Loop 16: flatten(A,B,C,D,E)->  flatten(A',B',C',D',E')  flatten(A'2,B'2,C'2,D,E)
                  [B>=B'2,A>=A'2,C>=C'+2,B>=B',A>=A',E'>=0,C'>=1,E>=0,D>=0,B>=0,A>=1,C'+C'2+1=C,D'=1] 
* Loop 17: flatten(A,B,C,D,E) [E>=0,B>=0,D=1,C=1,A=0] 

### Ranking functions of CR flatten(A,B,C,D,E) 
* RF of phase [13,14,15,16]: [C/2-1]

#### Partial ranking functions of CR flatten(A,B,C,D,E) 
* Partial RF of phase [13,14,15,16]:
  - RF of loop [13:1,13:2,14:1,14:2,15:1,15:2,16:1,16:2]:
    C/2-1

Discarded unfeasible chain [multiple([13,14,15,16],[[],[17]])]...(Non-terminating chain proved terminating)
Remaining chain: [multiple([13,14,15,16],[[17]])]

### Resulting Chains:flatten(A,B,C,D,E) 
* [17]
* [multiple([13,14,15,16],[[17]])]


### Merging Chains  flatten/5 into  External patterns of execution 
* [[17]] --> 1 
* [[multiple([13,14,15,16],[[17]])]] --> 2 


### Specialization of cost equations insertL/5 
* CE 7 is refined into CE [18] 
* CE 5 is refined into CE [19] 
* CE 6 is refined into CE [20] 


#### Refined cost equations insertL/5 
* CE 18: insertL(A,B,C,D,E) = 7
     [E>=A,C>=A,D>=3,A>=0,D=B+1] 
* CE 19: insertL(A,B,C,D,E) = 4
     [E>=A,C>=0,A>=0,D=2,B=1] 
* CE 20: insertL(A,B,C,D,E) = 7+ insertL(A,F,G,H,I)
     [E>=I,C>=G,H>=1,G>=0,F>=1,E>=0,A>=1,H+1=D,F+1=B] 

### Cost equations --> "Loop" of insertL/5 
* CEs [20] --> Loop 18 
* CEs [18] --> Loop 19 
* CEs [19] --> Loop 20 

#### Loops of insertL/5 
* Loop 18: insertL(A,B,C,D,E)->  insertL(A,A',B',C',D')
                  [E>=D',C>=B',C'>=1,B'>=0,A'>=1,E>=0,A>=1,C'+1=D,A'+1=B] 
* Loop 19: insertL(A,B,C,D,E) [E>=A,C>=A,B>=2,A>=0,B+1=D] 
* Loop 20: insertL(A,B,C,D,E) [E>=A,C>=0,A>=0,D=2,B=1] 

### Ranking functions of CR insertL(A,B,C,D,E) 
* RF of phase [18]: [B-1]

#### Partial ranking functions of CR insertL(A,B,C,D,E) 
* Partial RF of phase [18]:
  - RF of loop [18:1]:
    B-1

Discarded unfeasible chain [[18]]...(Non-terminating chain proved terminating)

### Resulting Chains:insertL(A,B,C,D,E) 
* [[18],20]
* [[18],19]
* [20]
* [19]


### Merging Chains  insertL/5 into  External patterns of execution 
* [[20]] --> 1 
* [[19],[19,[18]]] --> 2 
* [[20,[18]]] --> 3 


### Specialization of cost equations insertionsort/4 
* CE 9 is refined into CE [21] 
* CE 8 is refined into CE [22,23,24] 


#### Refined cost equations insertionsort/4 
* CE 21: insertionsort(A,B,C,D) = 3
     [D>=0,B>=0,C=1,A=1] 
* CE 22: insertionsort(A,B,C,D) = 5+ insertionsort(E,F,G,H)+ insertL(I,J,H,K,D):1
     [B>=F,D>=I,B>=I,E>=1,H>=0,I>=0,E+1=A,G=1,K=2,J=1,C=2] 
* CE 23: insertionsort(A,B,C,D) = 5+ insertionsort(E,F,G,H)+ insertL(I,J,H,C,D):2
     [B>=F,D>=I,H>=I,B>=I,E>=1,C>=3,I>=0,C=G+1,C=J+1,E+1=A] 
* CE 24: insertionsort(A,B,C,D) = 5+ insertionsort(E,F,G,H)+ insertL(I,J,H,C,D):3
     [B>=F,D>=I,B>=I,E>=1,C>=3,H>=0,I>=1,C=G+1,C=J+1,E+1=A] 

### Cost equations --> "Loop" of insertionsort/4 
* CEs [23,24] --> Loop 21 
* CEs [22] --> Loop 22 
* CEs [21] --> Loop 23 

#### Loops of insertionsort/4 
* Loop 21: insertionsort(A,B,C,D)->  insertionsort(A',B',C',D')
                  [B>=B',D'>=0,D>=0,C>=3,B>=0,A>=2,C=C'+1,A=A'+1] 
* Loop 22: insertionsort(A,B,C,D)->  insertionsort(A',B',C',D')
                  [B>=B',D'>=0,D>=0,B>=0,A>=2,A=A'+1,C'=1,C=2] 
* Loop 23: insertionsort(A,B,C,D) [D>=0,B>=0,C=1,A=1] 

### Ranking functions of CR insertionsort(A,B,C,D) 
* RF of phase [21]: [A-1]

#### Partial ranking functions of CR insertionsort(A,B,C,D) 
* Partial RF of phase [21]:
  - RF of loop [21:1]:
    A-1

Discarded unfeasible chain [[21]]...(Non-terminating chain proved terminating)

### Resulting Chains:insertionsort(A,B,C,D) 
* [[21],22,23]
* [23]
* [22,23]


### Merging Chains  insertionsort/4 into  External patterns of execution 
* [[23]] --> 1 
* [[23,22]] --> 2 
* [[23,22,[21]]] --> 3 


### Specialization of cost equations flattensort/5 
* CE 10 is refined into CE [25,26,27,28] 


#### Refined cost equations flattensort/5 
* CE 25: flattensort(A,B,C,D,E) = 2+ flatten(F,B,G,H,I):1+ insertionsort(J,I,K,E):1
     [E>=0,I>=0,B>=0,K=1,J=1,H=1,G=1,F=0,D=1,C=1,A=0] 
* CE 26: flattensort(A,B,C,D,E) = 2+ flatten(A,B,C,F,G):2+ insertionsort(H,G,I,E):1
     [E>=0,G>=0,C>=3,B>=0,A>=1,I=1,H=1,F=1,D=1] 
* CE 27: flattensort(A,B,C,D,E) = 2+ flatten(A,B,C,F,G):2+ insertionsort(H,G,I,E):2
     [E>=0,G>=0,C>=3,B>=0,A>=1,I=2,H=2,F=2,D=2] 
* CE 28: flattensort(A,B,C,D,E) = 2+ flatten(A,B,C,D,F):2+ insertionsort(D,F,D,E):3
     [E>=0,D>=3,F>=0,C>=3,B>=0,A>=1] 

### Cost equations --> "Loop" of flattensort/5 
* CEs [28] --> Loop 24 
* CEs [27] --> Loop 25 
* CEs [26] --> Loop 26 
* CEs [25] --> Loop 27 

#### Loops of flattensort/5 
* Loop 24: flattensort(A,B,C,D,E) [E>=0,D>=3,C>=3,B>=0,A>=1] 
* Loop 25: flattensort(A,B,C,D,E) [E>=0,C>=3,B>=0,A>=1,D=2] 
* Loop 26: flattensort(A,B,C,D,E) [E>=0,C>=3,B>=0,A>=1,D=1] 
* Loop 27: flattensort(A,B,C,D,E) [E>=0,B>=0,D=1,C=1,A=0] 

### Ranking functions of CR flattensort(A,B,C,D,E) 

#### Partial ranking functions of CR flattensort(A,B,C,D,E) 


### Resulting Chains:flattensort(A,B,C,D,E) 
* [27]
* [26]
* [25]
* [24]


### Merging Chains  flattensort/5 into  External patterns of execution 
* [[27]] --> 1 
* [[26]] --> 2 
* [[25]] --> 3 
* [[24]] --> 4 


Computing Bounds
=====================================

#### Simplifying cost structure of CE 11 

#### Computing cost of phase [11] 

#### Simplifying cost structure of CE 12 

#### Cost of loops [11] 

 * loop 11:appendL(A,B,C,D,E,F) -> [appendL(A',B',C',D',E',F')] 
5
##### Pending set appendL(A,B,C,D,E,F)
* Psum in Loop 11: [it(11)=<1]

###### Computing sum for it(11)=<1  in Loop 11 
   - Applying inductive sum strategy 
     - head Candidate: A-1 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(11)=<A-1,it(11)=<A-1,it(11)=<A-A',it(11)=<A-A'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [11] 

#### Simplifying cost structure of phase [11] 

#### Cost of phase [11]:appendL(A,B,C,D,E,F) -> [appendL(A',B',C',D',E',F')] 
5*it(11)+0
  Such that:it(11) =< A
it(11) =< A-A'

#### Simplifying cost structure of chain [[11],12] 

#### Cost of chains of appendL(A,B,C,D,E,F):
* Chain [[11],12]: 5*it(11)+2
  Such that:it(11) =< -C+E

  with precondition: [A+C=E+1,A>=2,B>=0,C>=1,D>=0,F>=D] 

* Chain [12]: 2
  with precondition: [A=1,C=E,D=F,B>=0,C>=0,D>=0] 


#### Simplifying cost structure of CE 13 

#### Computing cost of chain [multiple([13,14,15,16],[[17]])] with multiple recursion
 * Renamed intermediate variables: 
[ (eq(17,1),it(11))>>s(1)]
 * Renamed intermediate variables: 
[ (eq(17,2),it(11))>>s(2)]

#### Simplifying cost structure of CE 17 
 * Renamed intermediate variables: 
[ (it(13),s(2))>>s(3), (it(13),s(1))>>s(4)]
 * Renamed intermediate variables: 
[ (eq(16,1),it(11))>>s(5)]

#### Simplifying cost structure of CE 16 
 * Renamed intermediate variables: 
[ (it(14),s(5))>>s(6)]
 * Renamed intermediate variables: 
[ (eq(15,2),it(11))>>s(7)]

#### Simplifying cost structure of CE 15 
 * Renamed intermediate variables: 
[ (it(15),s(7))>>s(8)]

#### Simplifying cost structure of CE 14 

#### Cost of loops [13,14,15,16] 

 * loop 13:flatten(A,B,C,D,E) -> [flatten(A',B',C',D',E'),flatten(A'2,B'2,C'2,D'2,E'2)] 
5*s(4)+5*s(3)+11
  Such that:s(3) =< A

Unbounded itvars
s(4) :  it(13),s(1)

 * loop 14:flatten(A,B,C,D,E) -> [flatten(A',B',C',D',E'),flatten(A'2,B'2,C'2,D'2,E'2)] 
5*s(6)+11
Unbounded itvars
s(6) :  it(14),s(5)

 * loop 15:flatten(A,B,C,D,E) -> [flatten(A',B',C',D',E'),flatten(A'2,B'2,C'2,D'2,E'2)] 
5*s(8)+11
  Such that:s(8) =< A

 * loop 16:flatten(A,B,C,D,E) -> [flatten(A',B',C',D',E'),flatten(A'2,B'2,C'2,D'2,E'2)] 
11
##### Pending set flatten(A,B,C,D,E)
* Psum in Loop 13: [it(13)=<1,s(10)=<A]
* Psum in Loop 14: [it(14)=<1]
* Psum in Loop 15: [it(15)=<1,s(12)=<A]
* Psum in Loop 16: [it(16)=<1]
* Psum in Chain-Tail [17]: [it([17])=<1]

###### Computing sum for it(13)=<1  in Loop 13 
   - Applying inductive sum strategy 
     - head Candidate: C/2-1/2 
       - Loop 14 is collaborative and bounds [it(14)] 
       - Loop 15 is collaborative and bounds [it(15)] 
       - Loop 16 is collaborative and bounds [it(16)] 
       - Chain-Tail [17] is collaborative
     - tail Candidate: C/2-1/2 
       - Loop 14 is collaborative and bounds [it(14)] 
       - Loop 15 is collaborative and bounds [it(15)] 
       - Loop 16 is collaborative and bounds [it(16)] 
       - Chain-Tail [17] is collaborative
 * Adding constraints: [it(13)+it(14)+it(15)+it(16)=<C/2-1/2,it(13)+it(14)+it(15)+it(16)=<C/2-1/2] 

##### Pending set A
* Psum in Loop 13: [s(10)=<A]
* Psum in Loop 14: [it(14)=<1]
* Psum in Loop 15: [it(15)=<1,s(12)=<A]
* Psum in Loop 16: [it(16)=<1]
* Psum in Chain-Tail [17]: [it([17])=<1]

###### Computing sum for s(10)=<A  in Loop 13 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(1)=<A] 
 * Adding constraints: [s(10)=<it(13)*aux(1)] 

##### Pending set flatten(A,B,C,D,E)
* Pmax/min: [aux(1)=<A]
* Psum in Loop 14: [it(14)=<1]
* Psum in Loop 15: [it(15)=<1,s(12)=<A]
* Psum in Loop 16: [it(16)=<1]
* Psum in Chain-Tail [17]: [it([17])=<1]

###### Computing max_min for aux(1)=<A  
   - Found a solution using transitive invariants 
 * Adding constraints:[aux(1)=<A] 

##### Pending set flatten(A,B,C,D,E)
* Psum in Loop 14: [it(14)=<1]
* Psum in Loop 15: [it(15)=<1,s(12)=<A]
* Psum in Loop 16: [it(16)=<1]
* Psum in Chain-Tail [17]: [it([17])=<1]

###### Computing sum for it(14)=<1  in Loop 14 
   - Applying inductive sum strategy 
     - head Candidate: C/2-1/2 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C/2-1/2 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(13)+it(14)+it(15)+it(16)=<C/2-1/2,it(13)+it(14)+it(15)+it(16)=<C/2-1/2] 

##### Pending set flatten(A,B,C,D,E)
* Psum in Loop 15: [it(15)=<1,s(12)=<A]
* Psum in Loop 16: [it(16)=<1]
* Psum in Chain-Tail [17]: [it([17])=<1]

###### Computing sum for it(15)=<1  in Loop 15 
   - Applying inductive sum strategy 
     - head Candidate: C/2-1/2 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C/2-1/2 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(13)+it(14)+it(15)+it(16)=<C/2-1/2,it(13)+it(14)+it(15)+it(16)=<C/2-1/2] 

##### Pending set flatten(A,B,C,D,E)
* Psum in Loop 15: [s(12)=<A]
* Psum in Loop 16: [it(16)=<1]
* Psum in Chain-Tail [17]: [it([17])=<1]

###### Computing sum for s(12)=<A  in Loop 15 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(2)=<A] 
 * Adding constraints: [s(12)=<it(15)*aux(2)] 

##### Pending set flatten(A,B,C,D,E)
* Pmax/min: [aux(2)=<A]
* Psum in Loop 16: [it(16)=<1]
* Psum in Chain-Tail [17]: [it([17])=<1]

###### Computing max_min for aux(2)=<A  
   - Found a solution using cacheing 
 * Adding constraints:[aux(2)=<aux(1)] 

##### Pending set flatten(A,B,C,D,E)
* Psum in Loop 16: [it(16)=<1]
* Psum in Chain-Tail [17]: [it([17])=<1]

###### Computing sum for it(16)=<1  in Loop 16 
   - Applying inductive sum strategy 
     - head Candidate: C/2-1/2 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C/2-1/2 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(13)+it(14)+it(15)+it(16)=<C/2-1/2,it(13)+it(14)+it(15)+it(16)=<C/2-1/2] 

##### Pending set flatten(A,B,C,D,E)
* Psum in Chain-Tail [17]: [it([17])=<1]

###### Computing sum for it([17])=<1  in Chain-Tail [17] 
   - Applying inductive sum strategy 
     - head Candidate: C/2+1/2 
       - Loop 13 is collaborative
       - Loop 14 is collaborative
       - Loop 15 is collaborative
       - Loop 16 is collaborative
     - tail Candidate: C/2+1/2 
       - Loop 13 is collaborative
       - Loop 14 is collaborative
       - Loop 15 is collaborative
       - Loop 16 is collaborative
 * Adding constraints: [it([17])=<C/2+1/2,it([17])=<C/2+1/2] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [13,14,15,16,[17]] 

#### Simplifying cost structure of phase [13,14,15,16,[17]] 
 * Joined equivalent variables [s(9),s(11)] into s(9)
 * Joined equivalent variables [it(13),it(14),it(15),it(16)] into it(13)

#### Cost of phase [13,14,15,16]:flatten(A,B,C,D,E) -> [] 
44*it(13)+3*it([17])+10*s(9)+5*s(10)+5*s(12)+0
  Such that:aux(1) =< A
it([17]) =< C/2+1/2
aux(3) =< C/2
it(13) =< aux(3)
aux(2) =< aux(1)
s(10) =< it(13)*aux(1)
s(12) =< it(13)*aux(2)

Unbounded itvars
s(9) :  sum(13),s(4)

#### Cost of chains of flatten(A,B,C,D,E):
* Chain [17]: 3
  with precondition: [A=0,C=1,D=1,B>=0,E>=0] 

* Chain [multiple([13,14,15,16],[[17]])]: 44*it(13)+3*it([17])+10*s(9)+5*s(10)+5*s(12)+0
  Such that:aux(1) =< A
it([17]) =< C/2+1/2
aux(3) =< C/2
it(13) =< aux(3)
aux(2) =< aux(1)
s(10) =< it(13)*aux(1)
s(12) =< it(13)*aux(2)

Unbounded itvars
s(9) :  sum(13),s(4)

  with precondition: [A>=1,B>=0,C>=3,D>=1,E>=0] 


#### Simplifying cost structure of CE 19 

#### Computing cost of phase [18] 

#### Simplifying cost structure of CE 20 

#### Cost of loops [18] 

 * loop 18:insertL(A,B,C,D,E) -> [insertL(A',B',C',D',E')] 
7
##### Pending set insertL(A,B,C,D,E)
* Psum in Loop 18: [it(18)=<1]

###### Computing sum for it(18)=<1  in Loop 18 
   - Applying inductive sum strategy 
     - head Candidate: B-1 
     - head Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B-1 
     - tail Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(18)=<B-1,it(18)=<B-1,it(18)=<B-B',it(18)=<B-B'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [18] 

#### Simplifying cost structure of phase [18] 

#### Cost of phase [18]:insertL(A,B,C,D,E) -> [insertL(A',B',C',D',E')] 
7*it(18)+0
  Such that:it(18) =< B
it(18) =< B-B'

#### Simplifying cost structure of chain [[18],20] 

#### Simplifying cost structure of CE 18 

#### Found solution for phase  [18] in the cache 

#### Cost of phase [18]:insertL(A,B,C,D,E) -> [insertL(A',B',C',D',E')] 
7*it(18)+0
  Such that:it(18) =< B
it(18) =< B-B'

#### Simplifying cost structure of chain [[18],19] 
 * Renamed intermediate variables: 
[ (ch([[18],19]),it(18))>>s(13)]

#### Cost of chains of insertL(A,B,C,D,E):
* Chain [[18],20]: 7*it(18)+4
  Such that:it(18) =< D

  with precondition: [B+1=D,A>=1,B>=2,C>=0,E>=A] 

* Chain [[18],19]: 7*it(18)+7
  Such that:it(18) =< D

  with precondition: [B+1=D,A>=1,B>=3,C>=A,E>=A] 

* Chain [20]: 4
  with precondition: [B=1,D=2,A>=0,C>=0,E>=A] 

* Chain [19]: 7
  with precondition: [B+1=D,A>=0,B>=2,C>=A,E>=A] 


#### Simplifying cost structure of CE 21 

#### Simplifying cost structure of CE 22 

#### Simplifying cost structure of chain [22,23] 

#### Computing cost of phase [21] 
 * Renamed intermediate variables: 
[ (eq(23,1),s(13))>>s(14)]

#### Simplifying cost structure of CE 23 
 * Renamed intermediate variables: 
[ (eq(24,1),it(18))>>s(15)]

#### Simplifying cost structure of CE 24 
 * Joined equivalent variables [s(14),s(15)] into s(14)
 * Renamed intermediate variables: 
[ (it(21),aux(4))>>s(16), (it(21),s(14))>>s(17)]

#### Cost of loops [21] 

 * loop 21:insertionsort(A,B,C,D) -> [insertionsort(A',B',C',D')] 
14*s(17)+12
  Such that:s(16) =< A'+1
s(17) =< s(16)

##### Pending set insertionsort(A,B,C,D)
* Psum in Loop 21: [it(21)=<1,s(19)=<A'+1]

###### Computing sum for it(21)=<1  in Loop 21 
   - Applying inductive sum strategy 
     - head Candidate: A-1 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(21)=<A-1,it(21)=<A-1,it(21)=<A-A',it(21)=<A-A'] 

##### Pending set A
* Psum in Loop 21: [s(19)=<A'+1]

###### Computing sum for s(19)=<A'+1  in Loop 21 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(5)=<A] 
 * Adding constraints: [s(19)=<it(21)*aux(5)] 

##### Pending set insertionsort(A,B,C,D)
* Pmax/min: [aux(5)=<A]

###### Computing max_min for aux(5)=<A  
   - Found a solution using transitive invariants 
 * Adding constraints:[aux(5)=<A] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [21] 

#### Simplifying cost structure of phase [21] 
 * Joined equivalent variables [aux(6),aux(5)] into aux(6)

#### Cost of phase [21]:insertionsort(A,B,C,D) -> [insertionsort(A',B',C',D')] 
12*it(21)+14*s(18)+0
  Such that:it(21) =< A-A'
aux(6) =< A
it(21) =< aux(6)
s(19) =< it(21)*aux(6)
s(18) =< s(19)

#### Simplifying cost structure of chain [[21],22,23] 
 * Joined equivalent variables [aux(7),aux(6)] into aux(7)

#### Cost of chains of insertionsort(A,B,C,D):
* Chain [[21],22,23]: 12*it(21)+14*s(18)+12
  Such that:aux(7) =< A
it(21) =< aux(7)
s(19) =< it(21)*aux(7)
s(18) =< s(19)

  with precondition: [A=C,A>=3,B>=0,D>=0] 

* Chain [23]: 3
  with precondition: [A=1,C=1,B>=0,D>=0] 

* Chain [22,23]: 12
  with precondition: [A=2,C=2,B>=0,D>=0] 


#### Simplifying cost structure of CE 25 
 * Renamed intermediate variables: 
[ (eq(26,1),aux(1))>>s(20), (eq(26,1),it([17]))>>s(21), (eq(26,1),aux(3))>>s(22), (eq(26,1),it(13))>>s(23), (eq(26,1),aux(2))>>s(24), (eq(26,1),s(10))>>s(25), (eq(26,1),s(12))>>s(26), (eq(26,1),s(9))>>s(27)]

#### Simplifying cost structure of CE 26 
 * Renamed intermediate variables: 
[ (eq(27,1),aux(1))>>s(28), (eq(27,1),it([17]))>>s(29), (eq(27,1),aux(3))>>s(30), (eq(27,1),it(13))>>s(31), (eq(27,1),aux(2))>>s(32), (eq(27,1),s(10))>>s(33), (eq(27,1),s(12))>>s(34), (eq(27,1),s(9))>>s(35)]

#### Simplifying cost structure of CE 27 
 * Renamed intermediate variables: 
[ (eq(28,1),aux(1))>>s(36), (eq(28,1),it([17]))>>s(37), (eq(28,1),aux(3))>>s(38), (eq(28,1),it(13))>>s(39), (eq(28,1),aux(2))>>s(40), (eq(28,1),s(10))>>s(41), (eq(28,1),s(12))>>s(42), (eq(28,1),s(9))>>s(43)]
 * Renamed intermediate variables: 
[ (eq(28,2),aux(7))>>s(44), (eq(28,2),it(21))>>s(45), (eq(28,2),s(19))>>s(46), (eq(28,2),s(18))>>s(47)]

#### Simplifying cost structure of CE 28 

#### Cost of chains of flattensort(A,B,C,D,E):
* Chain [27]: 8
  with precondition: [A=0,C=1,D=1,B>=0,E>=0] 

* Chain [26]: 3*s(21)+44*s(23)+5*s(25)+5*s(26)+10*s(27)+5
  Such that:s(20) =< A
s(22) =< C/2
s(21) =< C/2+1/2
s(23) =< s(22)
s(24) =< s(20)
s(25) =< s(23)*s(20)
s(26) =< s(23)*s(24)

Unbounded itvars
s(27) :  eq(26,1),s(9)

  with precondition: [D=1,A>=1,B>=0,C>=3,E>=0] 

* Chain [25]: 3*s(29)+44*s(31)+5*s(33)+5*s(34)+10*s(35)+14
  Such that:s(28) =< A
s(30) =< C/2
s(29) =< C/2+1/2
s(31) =< s(30)
s(32) =< s(28)
s(33) =< s(31)*s(28)
s(34) =< s(31)*s(32)

Unbounded itvars
s(35) :  eq(27,1),s(9)

  with precondition: [D=2,A>=1,B>=0,C>=3,E>=0] 

* Chain [24]: 3*s(37)+44*s(39)+5*s(41)+5*s(42)+10*s(43)+12*s(45)+14*s(47)+14
  Such that:s(36) =< A
s(38) =< C/2
s(37) =< C/2+1/2
s(39) =< s(38)
s(40) =< s(36)
s(41) =< s(39)*s(36)
s(42) =< s(39)*s(40)

Unbounded itvars
s(43) :  eq(28,1),s(9)
s(45) :  eq(28,2),it(21)
s(47) :  eq(28,2),s(18)

  with precondition: [A>=1,B>=0,C>=3,D>=3,E>=0] 


Closed-form bounds of appendL(A,B,C,D,E,F): 
-------------------------------------
* Chain [[11],12] with precondition: [A+C=E+1,A>=2,B>=0,C>=1,D>=0,F>=D] 
    - Upper bound: 5*A+2 
    - Complexity: n 
* Chain [12] with precondition: [A=1,C=E,D=F,B>=0,C>=0,D>=0] 
    - Upper bound: 2 
    - Complexity: constant 

### Maximum cost of appendL(A,B,C,D,E,F): 5*A+2 
Asymptotic class: n 

Closed-form bounds of flatten(A,B,C,D,E): 
-------------------------------------
* Chain [17] with precondition: [A=0,C=1,D=1,B>=0,E>=0] 
    - Upper bound: 3 
    - Complexity: constant 
* Chain [multiple([13,14,15,16],[[17]])] with precondition: [A>=1,B>=0,C>=3,D>=1,E>=0] 
    - Upper bound: inf 
    - Complexity: infinity 

### Maximum cost of flatten(A,B,C,D,E): inf 
Asymptotic class: infinity 

Closed-form bounds of insertL(A,B,C,D,E): 
-------------------------------------
* Chain [[18],20] with precondition: [B+1=D,A>=1,B>=2,C>=0,E>=A] 
    - Upper bound: 7*B+11 
    - Complexity: n 
* Chain [[18],19] with precondition: [B+1=D,A>=1,B>=3,C>=A,E>=A] 
    - Upper bound: 7*B+14 
    - Complexity: n 
* Chain [20] with precondition: [B=1,D=2,A>=0,C>=0,E>=A] 
    - Upper bound: 4 
    - Complexity: constant 
* Chain [19] with precondition: [B+1=D,A>=0,B>=2,C>=A,E>=A] 
    - Upper bound: 7 
    - Complexity: constant 

### Maximum cost of insertL(A,B,C,D,E): 7*B+14 
Asymptotic class: n 

Closed-form bounds of insertionsort(A,B,C,D): 
-------------------------------------
* Chain [[21],22,23] with precondition: [A=C,A>=3,B>=0,D>=0] 
    - Upper bound: 12*A+12+14*A*A 
    - Complexity: n^2 
* Chain [23] with precondition: [A=1,C=1,B>=0,D>=0] 
    - Upper bound: 3 
    - Complexity: constant 
* Chain [22,23] with precondition: [A=2,C=2,B>=0,D>=0] 
    - Upper bound: 12 
    - Complexity: constant 

### Maximum cost of insertionsort(A,B,C,D): max([9,12*A+9+14*A*A])+3 
Asymptotic class: n^2 
 * Joined equivalent variables [s(43),s(45),s(47)] into s(43)

Closed-form bounds of flattensort(A,B,C,D,E): 
-------------------------------------
* Chain [27] with precondition: [A=0,C=1,D=1,B>=0,E>=0] 
    - Upper bound: 8 
    - Complexity: constant 
* Chain [26] with precondition: [D=1,A>=1,B>=0,C>=3,E>=0] 
    - Upper bound: inf 
    - Complexity: infinity 
* Chain [25] with precondition: [D=2,A>=1,B>=0,C>=3,E>=0] 
    - Upper bound: inf 
    - Complexity: infinity 
* Chain [24] with precondition: [A>=1,B>=0,C>=3,D>=3,E>=0] 
    - Upper bound: inf 
    - Complexity: infinity 

### Maximum cost of flattensort(A,B,C,D,E): inf 
Asymptotic class: infinity 
* Total analysis performed in 1698 ms.


Cost relation system solved by CoFloCo in 1703 ms.

Method appendL terminates?: YES

 - l1_1: size of l1 wrt. List<Rat>
 - l1_2: size of l1 wrt. Rat
 - l2_1: size of l2 wrt. List<Rat>
 - l2_2: size of l2 wrt. Rat
UB for appendL(l1_1,l1_2,l2_1,l2_2) = 5*l1_1+2

Method flatten terminates?: YES

 - t_1: size of t wrt. List<Rat>
 - t_2: size of t wrt. Rat
 - t_3: size of t wrt. Tree
UB for flatten(t_1,t_2,t_3) = inf

Method insertL terminates?: YES

 - x_1: size of x wrt. Rat
 - l_1: size of l wrt. List<Rat>
 - l_2: size of l wrt. Rat
UB for insertL(x_1,l_1,l_2) = 7*l_1+14

Method insertionsort terminates?: YES

 - l_1: size of l wrt. List<Rat>
 - l_2: size of l wrt. Rat
UB for insertionsort(l_1,l_2) = max([9,12*l_1+9+14*l_1*l_1])+3

Method flattensort terminates?: YES

 - t_1: size of t wrt. List<Rat>
 - t_2: size of t wrt. Rat
 - t_3: size of t wrt. Tree
UB for flattensort(t_1,t_2,t_3) = inf
