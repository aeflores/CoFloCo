
Abs program loaded in 11 ms.

Rule based representation generated in 1 ms.

Rule based representation stored in /tmp/costabs/rbr.rbr

RBR properties stored in /tmp/costabs/rbr.properties

Class invariants generated and loaded in 0 ms.

Abstract compilation performed in 7 ms.

Cost relation system stored in /tmp/costabs/crs.crs

Generated 37 equations 
entry('eqD'(A,B,C,D,E):[]).
entry('removeL'(A,B,C,D,E,F,G,H):[]).
entry('nub'(A,B,C,D,E,F):[]).
input_output_vars('and_op'(A,B,C),[A,B],[C]).
input_output_vars('case_0'(A,B,C,D,E),[A,B,C,D],[E]).
input_output_vars('case_1'(A,B,C,D,E),[A,B,C,D],[E]).
input_output_vars('case_2'(A,B,C,D,E,F,G,H),[A,B,C,D,E,F,G],[H]).
input_output_vars('case_3'(A,B,C,D,E,F,G,H),[A,B,C,D,E],[F,G,H]).
input_output_vars('case_4'(A,B,C,D,E,F,G,H,I,J,K,L,M,N),[A,B,C,D,E,F,G,H,I,J,K],[L,M,N]).
input_output_vars('case_5'(A,B,C,D,E,F),[A,B,C],[D,E,F]).
input_output_vars('eq'(A,B,C),[A,B],[C]).
input_output_vars('eqD'(A,B,C,D,E),[A,B,C,D],[E]).
input_output_vars('geq'(A,B,C),[A,B],[C]).
input_output_vars('gt'(A,B,C),[A,B],[C]).
input_output_vars('leq'(A,B,C),[A,B],[C]).
input_output_vars('lt'(A,B,C),[A,B],[C]).
input_output_vars('maxNorm'(A,B,C),[A,B],[C]).
input_output_vars('neg'(A,B),[A],[B]).
input_output_vars('neq'(A,B,C),[A,B],[C]).
input_output_vars('nub'(A,B,C,D,E,F),[A,B,C],[D,E,F]).
input_output_vars('or'(A,B,C),[A,B],[C]).
input_output_vars('removeL'(A,B,C,D,E,F,G,H),[A,B,C,D,E],[F,G,H]).
eq('eq',[A,B,C],0,[],[A=B,C=1,A>=0,B>=0,C>=0]).
eq('eq',[A,B,C],0,[],[A>=B+1,C=0,A>=0,B>=0,C>=0]).
eq('eq',[A,B,C],0,[],[B>=A+1,C=0,A>=0,B>=0,C>=0]).
eq('neq',[A,B,C],0,[],[A=B,C=0,A>=0,B>=0,C>=0]).
eq('neq',[A,B,C],0,[],[A>=B+1,C=1,A>=0,B>=0,C>=0]).
eq('neq',[A,B,C],0,[],[B>=A+1,C=1,A>=0,B>=0,C>=0]).
eq('lt',[A,B,C],0,[],[B-A>=1,C=1,A>=0,B>=0,C>=0]).
eq('lt',[A,B,C],0,[],[B=<A,C=0,A>=0,B>=0,C>=0]).
eq('leq',[A,B,C],0,[],[A=<B,C=1,A>=0,B>=0,C>=0]).
eq('leq',[A,B,C],0,[],[A-B>=1,C=0,A>=0,B>=0,C>=0]).
eq('gt',[A,B,C],0,[],[A-B>=1,C=1,A>=0,B>=0,C>=0]).
eq('gt',[A,B,C],0,[],[A=<B,C=0,A>=0,B>=0,C>=0]).
eq('geq',[A,B,C],0,[],[B=<A,C=1,A>=0,B>=0,C>=0]).
eq('geq',[A,B,C],0,[],[B-A>=1,C=0,A>=0,B>=0,C>=0]).
eq('neg',[A,B],0,[],[A=0,B=1,A>=0,B>=0]).
eq('neg',[A,B],0,[],[A=1,B=0,A>=0,B>=0]).
eq('and_op',[A,B,C],0,[],[A=0,C=0,A>=0,B>=0,C>=0]).
eq('and_op',[A,B,C],0,[],[A=1,C=B,A>=0,B>=0,C>=0]).
eq('or',[A,B,C],0,[],[A=1,C=1,A>=0,B>=0,C>=0]).
eq('or',[A,B,C],0,[],[A=0,C=B,A>=0,B>=0,C>=0]).
eq('maxNorm',[A,B,A],0,[],[A>=1+B,A>=0,B>=0,A>=0]).
eq('maxNorm',[A,B,B],0,[],[A=<B,A>=0,B>=0,B>=0]).
eq('case_1',[A,B,C,D,E],2,[],[C=1,E=1,A>=0,B>=0,C>=0,D>=0,E>=0]).
eq('case_1',[A,B,C,D,E],3,[],[D>=F,D>=G,C=H+1,H>=1,E=0,A>=0,B>=0,C>=0,D>=0,E>=0]).
eq('case_0',[A,B,C,D,E],2,['case_1'(A,B,C,D,E)],[A=1,A>=0,B>=0,C>=0,D>=0,E>=0]).
eq('case_2',[A,B,C,D,E,F,G,H],2,[],[C=1,H=0,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0]).
eq('case_2',[A,B,C,D,E,F,G,H],5,['eq'(E,I,J),'eqD'(F,G,K,L,M),'and_op'(J,M,H)],[D>=I,D>=L,C=K+1,K>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0]).
eq('case_0',[A,B,C,D,E],3,['case_2'(A,B,C,D,F,G,H,E)],[B>=F,B>=H,A=G+1,G>=1,A>=0,B>=0,C>=0,D>=0,E>=0]).
eq('eqD',[A,B,C,D,E],1,['case_0'(A,B,C,D,E)],[A>=0,B>=0,C>=0,D>=0,E>=0]).
eq('case_3',[A,B,C,D,E,F,G,H],2,[],[D=0,C=1,G=0,F=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0]).
eq('case_4',[A,B,C,D,E,F,G,H,I,J,K,L,M,N],2,['removeL'(B,C,I,J,K,L,M,N)],[A=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0,M>=0,N>=0]).
eq('case_4',[A,B,C,D,E,F,G,H,I,J,K,L,M,N],4,['removeL'(B,C,I,J,K,O,P,Q),'maxNorm'(G,P,M)],[A=0,N>=H,N>=Q,L=O+1,O>=1,G>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0,M>=0,N>=0]).
eq('case_3',[A,B,C,D,E,F,G,H],4,['eqD'(A,B,I,J,K),'case_4'(K,A,B,C,D,E,I,J,L,M,N,F,G,H)],[E>=J,E>=N,D>=I,D>=M,C=L+1,L>=1,I>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0]).
eq('removeL',[A,B,C,D,E,F,G,H],1,['case_3'(A,B,C,D,E,F,G,H)],[A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0]).
eq('case_5',[A,B,C,D,E,F],2,[],[B=0,A=1,E=0,D=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0]).
eq('case_5',[A,B,C,D,E,F],5,['removeL'(G,H,I,J,K,L,M,N),'nub'(L,M,N,O,P,Q),'maxNorm'(G,P,E)],[C>=H,C>=K,B>=G,B>=J,A=I+1,I>=1,G>=1,F>=H,F>=Q,D=O+1,O>=1,G>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0]).
eq('nub',[A,B,C,D,E,F],1,['case_5'(A,B,C,D,E,F)],[A>=0,B>=0,C>=0,D>=0,E>=0,F>=0]).

Preprocessing Cost Relations
=====================================

#### Computed strongly connected components 
0. non_recursive  : [case_1/5]
1. non_recursive  : [and_op/3]
2. non_recursive  : [eq/3]
3. recursive [non_tail] : [case_0/5,case_2/8,eqD/5]
4. non_recursive  : [maxNorm/3]
5. recursive [non_tail] : [case_3/8,case_4/14,removeL/8]
6. recursive [non_tail] : [case_5/6,nub/6]
Warning: the following predicates are never called:[geq/3,gt/3,leq/3,lt/3,neg/2,neq/3,or/3]

#### Obtained direct recursion through partial evaluation 
0. SCC is partially evaluated into case_1/5
1. SCC is partially evaluated into and_op/3
2. SCC is partially evaluated into eq/3
3. SCC is partially evaluated into eqD/5
4. SCC is partially evaluated into maxNorm/3
5. SCC is partially evaluated into removeL/8
6. SCC is partially evaluated into nub/6

Control-Flow Refinement of Cost Relations
=====================================

### Specialization of cost equations case_1/5 
* CE 10 is refined into CE [18] 
* CE 9 is refined into CE [19] 


#### Refined cost equations case_1/5 
* CE 18: case_1(A,B,C,D,E) = 3
     [D>=0,C>=2,B>=0,E=0,A=1] 
* CE 19: case_1(A,B,C,D,E) = 2
     [D>=0,B>=0,E=1,C=1,A=1] 

### Cost equations --> "Loop" of case_1/5 
* CEs [18] --> Loop 18 
* CEs [19] --> Loop 19 

#### Loops of case_1/5 
* Loop 18: case_1(A,B,C,D,E) [D>=0,C>=2,B>=0,E=0,A=1] 
* Loop 19: case_1(A,B,C,D,E) [D>=0,B>=0,E=1,C=1,A=1] 

### Ranking functions of CR case_1(A,B,C,D,E) 

#### Partial ranking functions of CR case_1(A,B,C,D,E) 


### Resulting Chains:case_1(A,B,C,D,E) 
* [19]
* [18]


### Merging Chains  case_1/5 into  External patterns of execution 
* [[19]] --> 1 
* [[18]] --> 2 


### Specialization of cost equations and_op/3 
* CE 15 is refined into CE [20] 
* CE 14 is refined into CE [21] 


#### Refined cost equations and_op/3 
* CE 20: and_op(A,B,B) = 0
     [B>=0,A=1] 
* CE 21: and_op(A,B,C) = 0
     [B>=0,C=0,A=0] 

### Cost equations --> "Loop" of and_op/3 
* CEs [20] --> Loop 20 
* CEs [21] --> Loop 21 

#### Loops of and_op/3 
* Loop 20: and_op(A,B,B) [B>=0,A=1] 
* Loop 21: and_op(A,B,C) [B>=0,C=0,A=0] 

### Ranking functions of CR and_op(A,B,C) 

#### Partial ranking functions of CR and_op(A,B,C) 


### Resulting Chains:and_op(A,B,C) 
* [21]
* [20]


### Merging Chains  and_op/3 into  External patterns of execution 
* [[21]] --> 1 
* [[20]] --> 2 


### Specialization of cost equations eq/3 
* CE 11 is refined into CE [22] 
* CE 12 is refined into CE [23] 
* CE 13 is refined into CE [24] 


#### Refined cost equations eq/3 
* CE 22: eq(A,A,B) = 0
     [A>=0,B=1] 
* CE 23: eq(A,B,C) = 0
     [A>=B+1,B>=0,C=0] 
* CE 24: eq(A,B,C) = 0
     [B>=A+1,A>=0,C=0] 

### Cost equations --> "Loop" of eq/3 
* CEs [22] --> Loop 22 
* CEs [23] --> Loop 23 
* CEs [24] --> Loop 24 

#### Loops of eq/3 
* Loop 22: eq(A,A,B) [A>=0,B=1] 
* Loop 23: eq(A,B,C) [A>=B+1,B>=0,C=0] 
* Loop 24: eq(A,B,C) [B>=A+1,A>=0,C=0] 

### Ranking functions of CR eq(A,B,C) 

#### Partial ranking functions of CR eq(A,B,C) 


### Resulting Chains:eq(A,B,C) 
* [24]
* [23]
* [22]


### Merging Chains  eq/3 into  External patterns of execution 
* [[24]] --> 1 
* [[23]] --> 2 
* [[22]] --> 3 


### Specialization of cost equations eqD/5 
* CE 3 is refined into CE [25,26,27] 
* CE 2 is refined into CE [28] 
* CE 1 is refined into CE [29,30] 


#### Refined cost equations eqD/5 
* CE 25: eqD(A,B,C,D,E) = 9+ eq(F,G,H):1+ eqD(I,J,K,L,M)+ and_op(N,M,O):1
     [D>=L,B>=J,D>=G,G>=F+1,B>=F,K>=1,J>=0,I>=1,M>=0,F>=0,K+1=C,I+1=A,O=0,N=0,H=0,E=0] 
* CE 26: eqD(A,B,C,D,E) = 9+ eq(F,G,H):2+ eqD(I,J,K,L,M)+ and_op(N,M,O):1
     [D>=L,B>=J,F>=G+1,D>=G,B>=F,K>=1,J>=0,I>=1,M>=0,G>=0,K+1=C,I+1=A,O=0,N=0,H=0,E=0] 
* CE 27: eqD(A,B,C,D,E) = 9+ eq(F,F,G):3+ eqD(H,I,J,K,E)+ and_op(L,E,E):2
     [D>=K,B>=I,D>=F,B>=F,J>=1,I>=0,H>=1,E>=0,F>=0,J+1=C,H+1=A,L=1,G=1] 
* CE 28: eqD(A,B,C,D,E) = 6
     [D>=0,B>=0,A>=2,E=0,C=1] 
* CE 29: eqD(A,B,C,D,E) = 3+ case_1(F,B,G,D,H):1
     [D>=0,B>=0,H=1,G=1,F=1,E=1,C=1,A=1] 
* CE 30: eqD(A,B,C,D,E) = 3+ case_1(F,B,C,D,G):2
     [D>=0,C>=2,B>=0,G=0,F=1,E=0,A=1] 

### Cost equations --> "Loop" of eqD/5 
* CEs [28] --> Loop 25 
* CEs [30] --> Loop 26 
* CEs [29] --> Loop 27 
* CEs [27] --> Loop 28 
* CEs [25] --> Loop 29 
* CEs [26] --> Loop 30 

#### Loops of eqD/5 
* Loop 25: eqD(A,B,C,D,E) [D>=0,B>=0,A>=2,E=0,C=1] 
* Loop 26: eqD(A,B,C,D,E) [D>=0,C>=2,B>=0,E=0,A=1] 
* Loop 27: eqD(A,B,C,D,E) [D>=0,B>=0,E=1,C=1,A=1] 
* Loop 28: eqD(A,B,C,D,E)->  eqD(A',B',C',D',E)
                  [D>=D',B>=B',B'>=0,E>=0,D>=0,C>=2,A>=2,C=C'+1,A=A'+1] 
* Loop 29: eqD(A,B,C,D,E)->  eqD(A',B',C',D',E')
                  [D>=D',B>=B',E'>=0,B'>=0,D>=1,C>=2,A>=2,C=C'+1,A=A'+1,E=0] 
* Loop 30: eqD(A,B,C,D,E)->  eqD(A',B',C',D',E')
                  [D>=D',B>=B',E'>=0,B'>=0,D>=0,C>=2,B>=1,A>=2,C=C'+1,A=A'+1,E=0] 

### Ranking functions of CR eqD(A,B,C,D,E) 
* RF of phase [28,29,30]: [A-1,C-1]

#### Partial ranking functions of CR eqD(A,B,C,D,E) 
* Partial RF of phase [28,29,30]:
  - RF of loop [28:1,29:1,30:1]:
    A-1
    C-1

Discarded unfeasible chain [[28,29,30]]...(Non-terminating chain proved terminating)

### Resulting Chains:eqD(A,B,C,D,E) 
* [[28,29,30],27]
* [[28,29,30],26]
* [[28,29,30],25]
* [27]
* [26]
* [25]


### Merging Chains  eqD/5 into  External patterns of execution 
* [[27]] --> 1 
* [[26]] --> 2 
* [[25]] --> 3 
* [[26,[28,29,30]]] --> 4 
* [[25,[28,29,30]]] --> 5 
* [[27,[28,29,30]]] --> 6 


### Specialization of cost equations maxNorm/3 
* CE 17 is refined into CE [31] 
* CE 16 is refined into CE [32] 


#### Refined cost equations maxNorm/3 
* CE 31: maxNorm(A,B,B) = 0
     [B>=A,A>=1] 
* CE 32: maxNorm(A,B,A) = 0
     [A>=B+1,B>=0] 

### Cost equations --> "Loop" of maxNorm/3 
* CEs [31] --> Loop 31 
* CEs [32] --> Loop 32 

#### Loops of maxNorm/3 
* Loop 31: maxNorm(A,B,B) [B>=A,A>=1] 
* Loop 32: maxNorm(A,B,A) [A>=B+1,B>=0] 

### Ranking functions of CR maxNorm(A,B,C) 

#### Partial ranking functions of CR maxNorm(A,B,C) 


### Resulting Chains:maxNorm(A,B,C) 
* [32]
* [31]


### Merging Chains  maxNorm/3 into  External patterns of execution 
* [[31]] --> 1 
* [[32]] --> 2 


### Specialization of cost equations removeL/8 
* CE 5 is refined into CE [33,34] 
* CE 6 is refined into CE [35,36,37,38,39,40,41,42,43,44] 
* CE 4 is refined into CE [45] 


#### Refined cost equations removeL/8 
* CE 33: removeL(A,B,C,D,E,F,G,H) = 7+ eqD(I,B,J,K,L):1+ removeL(M,B,N,O,P,F,G,H)
     [E>=P,D>=O,E>=K,P>=0,O>=0,N>=1,K>=0,B>=0,H>=0,G>=0,F>=0,D>=1,N+1=C,M=1,L=1,J=1,I=1,A=1] 
* CE 34: removeL(A,B,C,D,E,F,G,H) = 7+ eqD(A,B,A,I,J):6+ removeL(A,B,K,L,M,F,G,H)
     [E>=M,D>=L,E>=I,D>=A,M>=0,L>=0,K>=1,I>=0,A>=2,B>=0,H>=0,G>=0,F>=0,K+1=C,J=1] 
* CE 35: removeL(A,B,C,D,E,F,G,H) = 9+ eqD(I,B,J,K,L):2+ removeL(M,B,N,O,P,Q,G,R)+ maxNorm(J,G,G):1
     [H>=R,E>=P,D>=O,G>=J,D>=J,H>=K,E>=K,Q>=1,P>=0,O>=0,N>=1,J>=2,K>=0,B>=0,Q+1=F,N+1=C,M=1,L=0,I=1,A=1] 
* CE 36: removeL(A,B,C,D,E,F,G,H) = 9+ eqD(I,B,G,J,K):2+ removeL(L,B,M,N,O,P,Q,R)+ maxNorm(G,Q,G):2
     [H>=R,E>=O,D>=N,D>=G,G>=Q+1,H>=J,E>=J,P>=1,O>=0,N>=0,M>=1,G>=2,Q>=0,J>=0,B>=0,P+1=F,M+1=C,L=1,K=0,I=1,A=1] 
* CE 37: removeL(A,B,C,D,E,F,G,H) = 9+ eqD(A,B,I,J,K):3+ removeL(A,B,L,M,N,O,G,P)+ maxNorm(Q,G,G):1
     [H>=P,E>=N,D>=M,H>=J,E>=J,O>=1,N>=0,M>=0,L>=1,G>=1,J>=0,B>=0,A>=2,D>=1,O+1=F,L+1=C,Q=1,K=0,I=1] 
* CE 38: removeL(A,B,C,D,E,F,G,H) = 9+ eqD(A,B,I,J,K):3+ removeL(A,B,L,M,N,O,P,Q)+ maxNorm(R,S,T):2
     [H>=Q,E>=N,D>=M,H>=J,E>=J,O>=1,N>=0,M>=0,L>=1,J>=0,B>=0,A>=2,D>=1,O+1=F,L+1=C,P=0,T=1,S=0,R=1,K=0,I=1,G=1] 
* CE 39: removeL(A,B,C,D,E,F,G,H) = 9+ eqD(A,B,I,J,K):4+ removeL(A,B,L,M,N,O,G,P)+ maxNorm(I,G,G):1
     [H>=P,E>=N,D>=M,G>=I,D>=I,H>=J,E>=J,I>=A+1,O>=1,N>=0,M>=0,L>=1,J>=0,B>=0,A>=2,O+1=F,L+1=C,K=0] 
* CE 40: removeL(A,B,C,D,E,F,G,H) = 9+ eqD(A,B,G,I,J):4+ removeL(A,B,K,L,M,N,O,P)+ maxNorm(G,O,G):2
     [H>=P,E>=M,D>=L,D>=G,G>=O+1,H>=I,E>=I,G>=A+1,N>=1,M>=0,L>=0,K>=1,O>=0,I>=0,B>=0,A>=2,N+1=F,K+1=C,J=0] 
* CE 41: removeL(A,B,C,D,E,F,G,H) = 9+ eqD(A,B,I,J,K):5+ removeL(A,B,L,M,N,O,G,P)+ maxNorm(I,G,G):1
     [H>=P,E>=N,D>=M,G>=I,A>=I+1,D>=I,H>=J,E>=J,O>=1,N>=0,M>=0,L>=1,I>=2,J>=0,B>=0,O+1=F,L+1=C,K=0] 
* CE 42: removeL(A,B,C,D,E,F,G,H) = 9+ eqD(A,B,G,I,J):5+ removeL(A,B,K,L,M,N,O,P)+ maxNorm(G,O,G):2
     [H>=P,E>=M,D>=L,A>=G+1,D>=G,G>=O+1,H>=I,E>=I,N>=1,M>=0,L>=0,K>=1,G>=2,O>=0,I>=0,B>=0,N+1=F,K+1=C,J=0] 
* CE 43: removeL(A,B,C,D,E,F,G,H) = 9+ eqD(A,B,A,I,J):6+ removeL(A,B,K,L,M,N,G,O)+ maxNorm(A,G,G):1
     [B+I>=1,H>=O,E>=M,D>=L,G>=A,D>=A,H>=I,E>=I,N>=1,M>=0,L>=0,K>=1,A>=2,I>=0,B>=0,N+1=F,K+1=C,J=0] 
* CE 44: removeL(A,B,C,D,E,F,A,G) = 9+ eqD(A,B,A,H,I):6+ removeL(A,B,J,K,L,M,N,O)+ maxNorm(A,N,A):2
     [B+H>=1,G>=O,E>=L,D>=K,D>=A,A>=N+1,G>=H,E>=H,M>=1,L>=0,K>=0,J>=1,A>=2,N>=0,H>=0,B>=0,M+1=F,J+1=C,I=0] 
* CE 45: removeL(A,B,C,D,E,F,G,H) = 3
     [H>=0,E>=0,B>=0,A>=0,G=0,F=1,D=0,C=1] 

### Cost equations --> "Loop" of removeL/8 
* CEs [45] --> Loop 33 
* CEs [34] --> Loop 34 
* CEs [42] --> Loop 35 
* CEs [40] --> Loop 36 
* CEs [37,39,41,43] --> Loop 37 
* CEs [44] --> Loop 38 
* CEs [38] --> Loop 39 
* CEs [33] --> Loop 40 
* CEs [36] --> Loop 41 
* CEs [35] --> Loop 42 

#### Loops of removeL/8 
* Loop 33: removeL(A,B,C,D,E,F,G,H) [H>=0,E>=0,B>=0,A>=0,G=0,F=1,D=0,C=1] 
* Loop 34: removeL(A,B,C,D,E,F,G,H)->  removeL(A,B,A',B',C',F,G,H)
                  [E>=C',D>=B',D>=A,C'>=0,B'>=0,H>=0,G>=0,F>=0,C>=2,B>=0,A>=2,C=A'+1] 
* Loop 35: removeL(A,B,C,D,E,F,G,H)->  removeL(A,B,A',B',C',D',E',F')
                  [H>=F',G>=E'+1,E>=C',D>=B',D>=G,A>=G+1,E'>=0,C'>=0,B'>=0,H>=0,G>=2,F>=2,C>=2,B>=0,F=D'+1,C=A'+1] 
* Loop 36: removeL(A,B,C,D,E,F,G,H)->  removeL(A,B,A',B',C',D',E',F')
                  [H>=F',G>=E'+1,E>=C',D>=B',D>=G,G>=A+1,E'>=0,C'>=0,B'>=0,H>=0,F>=2,C>=2,B>=0,A>=2,F=D'+1,C=A'+1] 
* Loop 37: removeL(A,B,C,D,E,F,G,H)->  removeL(A,B,A',B',C',D',G,E')
                  [H>=E',E>=C',D>=B',C'>=0,B'>=0,H>=0,G>=1,F>=2,D>=1,C>=2,B>=0,A>=2,F=D'+1,C=A'+1] 
* Loop 38: removeL(A,B,C,D,E,F,A,G)->  removeL(A,B,A',B',C',D',E',F')
                  [B+G>=1,B+E>=1,G>=F',A>=E'+1,E>=C',D>=B',D>=A,E'>=0,C'>=0,B'>=0,G>=0,F>=2,C>=2,B>=0,A>=2,F=D'+1,C=A'+1] 
* Loop 39: removeL(A,B,C,D,E,F,G,H)->  removeL(A,B,A',B',C',D',E',F')
                  [H>=F',E>=C',D>=B',C'>=0,B'>=0,H>=0,F>=2,D>=1,C>=2,B>=0,A>=2,F=D'+1,C=A'+1,E'=0,G=1] 
* Loop 40: removeL(A,B,C,D,E,F,G,H)->  removeL(A',B,B',C',D',F,G,H)
                  [E>=D',D>=C',D'>=0,C'>=0,H>=0,G>=0,F>=0,D>=1,C>=2,B>=0,C=B'+1,A'=1,A=1] 
* Loop 41: removeL(A,B,C,D,E,F,G,H)->  removeL(A',B,B',C',D',E',F',G')
                  [H>=G',G>=F'+1,E>=D',D>=C',D>=G,F'>=0,D'>=0,C'>=0,H>=0,G>=2,F>=2,C>=2,B>=0,F=E'+1,C=B'+1,A'=1,A=1] 
* Loop 42: removeL(A,B,C,D,E,F,G,H)->  removeL(A',B,B',C',D',E',G,F')
                  [H>=F',E>=D',D>=C',D'>=0,C'>=0,H>=0,G>=2,F>=2,D>=2,C>=2,B>=0,F=E'+1,C=B'+1,A'=1,A=1] 

### Ranking functions of CR removeL(A,B,C,D,E,F,G,H) 
* RF of phase [34,35,36,37,38,39]: [C-1]
* RF of phase [40,41,42]: [C-1]

#### Partial ranking functions of CR removeL(A,B,C,D,E,F,G,H) 
* Partial RF of phase [34,35,36,37,38,39]:
  - RF of loop [34:1,35:1,36:1,37:1,38:1,39:1]:
    C-1
* Partial RF of phase [40,41,42]:
  - RF of loop [40:1,41:1,42:1]:
    C-1

Discarded unfeasible chain [[40,41,42]]...(Non-terminating chain proved terminating)
Discarded unfeasible chain [[34,35,36,37,38,39]](Non-terminating chain proved terminating)

### Resulting Chains:removeL(A,B,C,D,E,F,G,H) 
* [[40,41,42],33]
* [[34,35,36,37,38,39],33]
* [33]


### Merging Chains  removeL/8 into  External patterns of execution 
* [[33,[40,41,42]]] --> 1 
* [[33]] --> 2 
* [[33,[34,35,36,37,38,39]]] --> 3 


### Specialization of cost equations nub/6 
* CE 8 is refined into CE [46] 
* CE 7 is refined into CE [47,48,49,50,51,52] 


#### Refined cost equations nub/6 
* CE 46: nub(A,B,C,D,E,F) = 3
     [F>=0,C>=0,E=0,D=1,B=0,A=1] 
* CE 47: nub(A,B,C,D,E,F) = 6+ removeL(G,H,I,J,K,L,M,N):1+ nub(L,M,N,O,E,P)+ maxNorm(Q,E,E):1
     [J+L>=M+2,M+2*I>=2*L+2,F>=P,2*J>=M+2,J>=M,I>=L,C>=K,B>=J,F>=H,C>=H,O>=1,E>=1,N>=0,M>=0,L>=1,K>=0,I>=2,H>=0,O+1=D,I+1=A,Q=1,G=1] 
* CE 48: nub(A,B,C,D,E,F) = 6+ removeL(G,H,I,J,K,L,M,N):1+ nub(L,M,N,O,P,Q)+ maxNorm(R,S,T):2
     [J+L>=M+2,M+2*I>=2*L+2,F>=Q,2*J>=M+2,J>=M,I>=L,C>=K,B>=J,F>=H,C>=H,O>=1,N>=0,M>=0,L>=1,K>=0,I>=2,H>=0,O+1=D,I+1=A,P=0,T=1,S=0,R=1,G=1,E=1] 
* CE 49: nub(A,B,C,D,E,F) = 6+ removeL(G,H,I,J,K,L,M,N):2+ nub(O,P,N,Q,E,R)+ maxNorm(G,E,E):1
     [F>=R,E>=G,B>=G,C>=K,F>=H,C>=H,Q>=1,G>=1,N>=0,K>=0,H>=0,Q+1=D,P=0,O=1,M=0,L=1,J=0,I=1,A=2] 
* CE 50: nub(A,B,C,D,E,F) = 6+ removeL(E,G,H,I,J,K,L,M):2+ nub(N,O,M,P,Q,R)+ maxNorm(E,Q,E):2
     [F>=R,B>=E,E>=Q+1,C>=J,F>=G,C>=G,P>=1,Q>=0,M>=0,J>=0,G>=0,P+1=D,O=0,N=1,L=0,K=1,I=0,H=1,A=2] 
* CE 51: nub(A,B,C,D,E,F) = 6+ removeL(G,H,I,J,K,L,M,N):3+ nub(L,M,N,O,E,P)+ maxNorm(G,E,E):1
     [J+2*L>=M+4,I+M>=L+1,J+M>=2,F>=P,E>=G,B>=G,J>=M,I>=L,C>=K,B>=J,F>=H,C>=H,O>=1,G>=2,N>=0,M>=0,L>=1,K>=0,I>=2,H>=0,O+1=D,I+1=A] 
* CE 52: nub(A,B,C,D,E,F) = 6+ removeL(E,G,H,I,J,K,L,M):3+ nub(K,L,M,N,O,P)+ maxNorm(E,O,E):2
     [I+2*K>=L+4,H+L>=K+1,I+L>=2,F>=P,B>=E,E>=O+1,I>=L,H>=K,C>=J,B>=I,F>=G,C>=G,N>=1,E>=2,O>=0,M>=0,L>=0,K>=1,J>=0,H>=2,G>=0,N+1=D,H+1=A] 

### Cost equations --> "Loop" of nub/6 
* CEs [52] --> Loop 43 
* CEs [47] --> Loop 44 
* CEs [51] --> Loop 45 
* CEs [48] --> Loop 46 
* CEs [50] --> Loop 47 
* CEs [49] --> Loop 48 
* CEs [46] --> Loop 49 

#### Loops of nub/6 
* Loop 43: nub(A,B,C,D,E,F)->  nub(A',B',C',D',E',F')
                  [B+2*A'>=B'+4,A+B'>=A'+2,F>=F',E>=E'+1,B>=B',A>=A'+1,B>=E,E'>=0,C'>=0,B'>=0,A'>=1,F>=0,E>=2,D>=2,C>=0,A>=3,D=D'+1] 
* Loop 44: nub(A,B,C,D,E,F)->  nub(A',B',C',D',E,E')
                  [B+A'>=B'+2,B'+2*A>=2*A'+4,F>=E',2*B>=B'+2,B>=B',A>=A'+1,C'>=0,B'>=0,A'>=1,F>=0,E>=1,D>=2,C>=0,A>=3,D=D'+1] 
* Loop 45: nub(A,B,C,D,E,F)->  nub(A',B',C',D',E,E')
                  [B+2*A'>=B'+4,A+B'>=A'+2,F>=E',B>=B',A>=A'+1,C'>=0,B'>=0,A'>=1,F>=0,E>=2,D>=2,C>=0,B>=2,A>=3,D=D'+1] 
* Loop 46: nub(A,B,C,D,E,F)->  nub(A',B',C',D',E',F')
                  [B+A'>=B'+2,B'+2*A>=2*A'+4,F>=F',2*B>=B'+2,B>=B',A>=A'+1,C'>=0,B'>=0,A'>=1,F>=0,D>=2,C>=0,A>=3,D=D'+1,E'=0,E=1] 
* Loop 47: nub(A,B,C,D,E,F)->  nub(A',B',C',D',E',F')
                  [F>=F',E>=E'+1,B>=E,E'>=0,C'>=0,F>=0,D>=2,C>=0,D=D'+1,B'=0,A'=1,A=2] 
* Loop 48: nub(A,B,C,D,E,F)->  nub(A',B',C',D',E,E')
                  [F>=E',C'>=0,F>=0,E>=1,D>=2,C>=0,B>=1,D=D'+1,B'=0,A'=1,A=2] 
* Loop 49: nub(A,B,C,D,E,F) [F>=0,C>=0,E=0,D=1,B=0,A=1] 

### Ranking functions of CR nub(A,B,C,D,E,F) 
* RF of phase [43,44,45]: [A-2,A+B-3,A+2*B-4]

#### Partial ranking functions of CR nub(A,B,C,D,E,F) 
* Partial RF of phase [43,44,45]:
  - RF of loop [43:1,44:1,45:1]:
    A-2
  - RF of loop [43:1,45:1]:
    A+B-4
    A+B/2-7/2
  - RF of loop [44:1]:
    A+B-3
    A+B/2-3

Discarded unfeasible chain [[43,44,45]]...(Non-terminating chain proved terminating)

### Resulting Chains:nub(A,B,C,D,E,F) 
* [[43,44,45],49]
* [[43,44,45],47,49]
* [[43,44,45],46,49]
* [49]
* [47,49]
* [46,49]


### Merging Chains  nub/6 into  External patterns of execution 
* [[49]] --> 1 
* [[49,47]] --> 2 
* [[49,46]] --> 3 
* [[49,[43,44,45]]] --> 4 
* [[49,46,[43,44,45]],[49,47,[43,44,45]]] --> 5 


Computing Bounds
=====================================

#### Simplifying cost structure of CE 19 

#### Simplifying cost structure of CE 18 

#### Cost of chains of case_1(A,B,C,D,E):
* Chain [19]: 2
  with precondition: [A=1,C=1,E=1,B>=0,D>=0] 

* Chain [18]: 3
  with precondition: [A=1,E=0,B>=0,C>=2,D>=0] 


#### Simplifying cost structure of CE 21 

#### Simplifying cost structure of CE 20 

#### Cost of chains of and_op(A,B,C):
* Chain [21]: 0
  with precondition: [A=0,C=0,B>=0] 

* Chain [20]: 0
  with precondition: [A=1,C=B,C>=0] 


#### Simplifying cost structure of CE 24 

#### Simplifying cost structure of CE 23 

#### Simplifying cost structure of CE 22 

#### Cost of chains of eq(A,B,C):
* Chain [24]: 0
  with precondition: [C=0,A>=0,B>=A+1] 

* Chain [23]: 0
  with precondition: [C=0,B>=0,A>=B+1] 

* Chain [22]: 0
  with precondition: [C=1,A=B,A>=0] 


#### Simplifying cost structure of CE 29 

#### Computing cost of phase [28,29,30] 

#### Simplifying cost structure of CE 27 

#### Simplifying cost structure of CE 25 

#### Simplifying cost structure of CE 26 

#### Cost of loops [28,29,30] 

 * loop 28:eqD(A,B,C,D,E) -> [eqD(A',B',C',D',E')] 
9
 * loop 29:eqD(A,B,C,D,E) -> [eqD(A',B',C',D',E')] 
9
 * loop 30:eqD(A,B,C,D,E) -> [eqD(A',B',C',D',E')] 
9
##### Pending set eqD(A,B,C,D,E)
* Psum in Loop 28: [it(28)=<1]
* Psum in Loop 29: [it(29)=<1]
* Psum in Loop 30: [it(30)=<1]

###### Computing sum for it(28)=<1  in Loop 28 
   - Applying inductive sum strategy 
     - head Candidate: C-1 
       - Loop 29 is collaborative and bounds [it(29)] 
       - Loop 30 is collaborative and bounds [it(30)] 
     - head Candidate: A-1 
       - Loop 29 is collaborative and bounds [it(29)] 
       - Loop 30 is collaborative and bounds [it(30)] 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - Loop 29 is collaborative and bounds [it(29)] 
       - Loop 30 is collaborative and bounds [it(30)] 
     - tail Candidate: A-1 
       - Loop 29 is collaborative and bounds [it(29)] 
       - Loop 30 is collaborative and bounds [it(30)] 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(28)+it(29)+it(30)=<C-1,it(28)+it(29)+it(30)=<A-1,it(28)+it(29)+it(30)=<A-1,it(28)+it(29)+it(30)=<C-1,it(28)+it(29)+it(30)=<C-C',it(28)+it(29)+it(30)=<A-A',it(28)+it(29)+it(30)=<A-A',it(28)+it(29)+it(30)=<C-C'] 

##### Pending set A
* Psum in Loop 29: [it(29)=<1]
* Psum in Loop 30: [it(30)=<1]

###### Computing sum for it(29)=<1  in Loop 29 
   - Applying inductive sum strategy 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(28)+it(29)+it(30)=<C-1,it(28)+it(29)+it(30)=<A-1,it(28)+it(29)+it(30)=<A-1,it(28)+it(29)+it(30)=<C-1,it(28)+it(29)+it(30)=<C-C',it(28)+it(29)+it(30)=<A-A',it(28)+it(29)+it(30)=<A-A',it(28)+it(29)+it(30)=<C-C'] 

##### Pending set A
* Psum in Loop 30: [it(30)=<1]

###### Computing sum for it(30)=<1  in Loop 30 
   - Applying inductive sum strategy 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(28)+it(29)+it(30)=<C-1,it(28)+it(29)+it(30)=<A-1,it(28)+it(29)+it(30)=<A-1,it(28)+it(29)+it(30)=<C-1,it(28)+it(29)+it(30)=<C-C',it(28)+it(29)+it(30)=<A-A',it(28)+it(29)+it(30)=<A-A',it(28)+it(29)+it(30)=<C-C'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [28,29,30] 

#### Simplifying cost structure of phase [28,29,30] 
 * Joined equivalent variables [it(28),it(29),it(30)] into it(28)

#### Cost of phase [28,29,30]:eqD(A,B,C,D,E) -> [eqD(A',B',C',D',E')] 
27*it(28)+0
  Such that:aux(1) =< A
aux(2) =< A-A'
aux(3) =< C
aux(4) =< C-C'
it(28) =< aux(1)
it(28) =< aux(2)
it(28) =< aux(3)
it(28) =< aux(4)

#### Simplifying cost structure of chain [[28,29,30],27] 
 * Joined equivalent variables [aux(5),aux(1),aux(2),aux(3),aux(4)] into aux(5)

#### Simplifying cost structure of CE 30 

#### Found solution for phase  [28,29,30] in the cache 

#### Cost of phase [28,29,30]:eqD(A,B,C,D,E) -> [eqD(A',B',C',D',E')] 
27*it(28)+0
  Such that:aux(1) =< A
aux(2) =< A-A'
aux(3) =< C
aux(4) =< C-C'
it(28) =< aux(1)
it(28) =< aux(2)
it(28) =< aux(3)
it(28) =< aux(4)

#### Simplifying cost structure of chain [[28,29,30],26] 
 * Joined equivalent variables [aux(6),aux(1),aux(2),aux(4)] into aux(6)

#### Simplifying cost structure of CE 28 

#### Found solution for phase  [28,29,30] in the cache 

#### Cost of phase [28,29,30]:eqD(A,B,C,D,E) -> [eqD(A',B',C',D',E')] 
27*it(28)+0
  Such that:aux(1) =< A
aux(2) =< A-A'
aux(3) =< C
aux(4) =< C-C'
it(28) =< aux(1)
it(28) =< aux(2)
it(28) =< aux(3)
it(28) =< aux(4)

#### Simplifying cost structure of chain [[28,29,30],25] 
 * Joined equivalent variables [aux(7),aux(2),aux(3),aux(4)] into aux(7)

#### Cost of chains of eqD(A,B,C,D,E):
* Chain [[28,29,30],27]: 27*it(28)+5
  Such that:aux(5) =< A
it(28) =< aux(5)

  with precondition: [A=C,1>=E,A>=2,B>=0,D>=0,E>=0,B+D+E>=1] 

* Chain [[28,29,30],26]: 27*it(28)+6
  Such that:aux(3) =< C
aux(6) =< A
it(28) =< aux(6)
it(28) =< aux(3)

  with precondition: [E=0,A>=2,B>=0,D>=0,C>=A+1] 

* Chain [[28,29,30],25]: 27*it(28)+6
  Such that:aux(1) =< A
aux(7) =< C
it(28) =< aux(1)
it(28) =< aux(7)

  with precondition: [E=0,B>=0,C>=2,D>=0,A>=C+1] 

* Chain [27]: 5
  with precondition: [A=1,C=1,E=1,B>=0,D>=0] 

* Chain [26]: 6
  with precondition: [A=1,E=0,B>=0,C>=2,D>=0] 

* Chain [25]: 6
  with precondition: [C=1,E=0,A>=2,B>=0,D>=0] 


#### Simplifying cost structure of CE 32 

#### Simplifying cost structure of CE 31 

#### Cost of chains of maxNorm(A,B,C):
* Chain [32]: 0
  with precondition: [A=C,B>=0,A>=B+1] 

* Chain [31]: 0
  with precondition: [C=B,A>=1,C>=A] 


#### Simplifying cost structure of CE 45 

#### Computing cost of phase [40,41,42] 

#### Simplifying cost structure of CE 33 

#### Simplifying cost structure of CE 36 

#### Simplifying cost structure of CE 35 

#### Cost of loops [40,41,42] 

 * loop 40:removeL(A,B,C,D,E,F,G,H) -> [removeL(A',B',C',D',E',F',G',H')] 
12
 * loop 41:removeL(A,B,C,D,E,F,G,H) -> [removeL(A',B',C',D',E',F',G',H')] 
15
 * loop 42:removeL(A,B,C,D,E,F,G,H) -> [removeL(A',B',C',D',E',F',G',H')] 
15
##### Pending set removeL(A,B,C,D,E,F,G,H)
* Psum in Loop 40: [it(40)=<1]
* Psum in Loop 41: [it(41)=<1]
* Psum in Loop 42: [it(42)=<1]

###### Computing sum for it(40)=<1  in Loop 40 
   - Applying inductive sum strategy 
     - head Candidate: C-1 
       - Loop 41 is collaborative and bounds [it(41)] 
       - Loop 42 is collaborative and bounds [it(42)] 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - Loop 41 is collaborative and bounds [it(41)] 
       - Loop 42 is collaborative and bounds [it(42)] 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(40)+it(41)+it(42)=<C-1,it(40)+it(41)+it(42)=<C-1,it(40)+it(41)+it(42)=<C-C',it(40)+it(41)+it(42)=<C-C'] 

##### Pending set A
* Psum in Loop 41: [it(41)=<1]
* Psum in Loop 42: [it(42)=<1]

###### Computing sum for it(41)=<1  in Loop 41 
   - Applying inductive sum strategy 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(40)+it(41)+it(42)=<C-1,it(40)+it(41)+it(42)=<C-1,it(40)+it(41)+it(42)=<C-C',it(40)+it(41)+it(42)=<C-C'] 

##### Pending set A
* Psum in Loop 42: [it(42)=<1]

###### Computing sum for it(42)=<1  in Loop 42 
   - Applying inductive sum strategy 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(40)+it(41)+it(42)=<C-1,it(40)+it(41)+it(42)=<C-1,it(40)+it(41)+it(42)=<C-C',it(40)+it(41)+it(42)=<C-C'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [40,41,42] 

#### Simplifying cost structure of phase [40,41,42] 
 * Joined equivalent variables [it(40),it(41),it(42)] into it(40)

#### Cost of phase [40,41,42]:removeL(A,B,C,D,E,F,G,H) -> [removeL(A',B',C',D',E',F',G',H')] 
42*it(40)+0
  Such that:aux(8) =< C
aux(9) =< C-C'
it(40) =< aux(8)
it(40) =< aux(9)

#### Simplifying cost structure of chain [[40,41,42],33] 
 * Joined equivalent variables [aux(10),aux(8),aux(9)] into aux(10)

#### Computing cost of phase [34,35,36,37,38,39] 
 * Renamed intermediate variables: 
[ (eq(34,1),aux(5))>>s(1), (eq(34,1),it(28))>>s(2)]

#### Simplifying cost structure of CE 34 
 * Renamed intermediate variables: 
[ (it(34),s(1))>>s(3), (it(34),s(2))>>s(4)]
 * Renamed intermediate variables: 
[ (eq(42,1),aux(1))>>s(5), (eq(42,1),aux(7))>>s(6), (eq(42,1),it(28))>>s(7)]

#### Simplifying cost structure of CE 42 
 * Joined equivalent variables [aux(11),s(5)] into aux(11)
 * Renamed intermediate variables: 
[ (it(35),s(6))>>s(8), (it(35),aux(11))>>s(9), (it(35),s(7))>>s(10)]
 * Renamed intermediate variables: 
[ (eq(40,1),aux(3))>>s(11), (eq(40,1),aux(6))>>s(12), (eq(40,1),it(28))>>s(13)]

#### Simplifying cost structure of CE 40 
 * Renamed intermediate variables: 
[ (it(36),s(11))>>s(14), (it(36),s(12))>>s(15), (it(36),s(13))>>s(16)]

#### Simplifying cost structure of CE 37 
 * Renamed intermediate variables: 
[ (eq(39,1),aux(3))>>s(17), (eq(39,1),aux(6))>>s(18), (eq(39,1),it(28))>>s(19)]

#### Simplifying cost structure of CE 39 
 * Renamed intermediate variables: 
[ (eq(41,1),aux(1))>>s(20), (eq(41,1),aux(7))>>s(21), (eq(41,1),it(28))>>s(22)]

#### Simplifying cost structure of CE 41 
 * Joined equivalent variables [aux(12),s(20)] into aux(12)
 * Renamed intermediate variables: 
[ (eq(43,1),aux(5))>>s(23), (eq(43,1),it(28))>>s(24)]

#### Simplifying cost structure of CE 43 
 * Joined equivalent variables [aux(13),aux(12),s(18),s(23)] into aux(13)
 * Joined equivalent variables [aux(14),s(17)] into aux(14)
 * Renamed intermediate variables: 
[ (it(37),aux(13))>>s(25), (it(37),aux(14))>>s(26), (it(37),s(21))>>s(27), (it(37),s(19))>>s(28), (it(37),s(24))>>s(29), (it(37),s(22))>>s(30)]
 * Renamed intermediate variables: 
[ (eq(44,1),aux(5))>>s(31), (eq(44,1),it(28))>>s(32)]

#### Simplifying cost structure of CE 44 
 * Renamed intermediate variables: 
[ (it(38),s(31))>>s(33), (it(38),s(32))>>s(34)]

#### Simplifying cost structure of CE 38 

#### Cost of loops [34,35,36,37,38,39] 

 * loop 34:removeL(A,B,C,D,E,F,G,H) -> [removeL(A',B',C',D',E',F',G',H')] 
27*s(4)+12
  Such that:s(3) =< A'
s(4) =< s(3)

 * loop 35:removeL(A,B,C,D,E,F,G,H) -> [removeL(A',B',C',D',E',F',G',H')] 
27*s(10)+15
  Such that:s(8) =< D
s(9) =< A'
s(8) =< s(9)
s(10) =< s(9)
s(10) =< s(8)

 * loop 36:removeL(A,B,C,D,E,F,G,H) -> [removeL(A',B',C',D',E',F',G',H')] 
27*s(16)+15
  Such that:s(14) =< D
s(15) =< A'
s(16) =< s(15)
s(16) =< s(14)

 * loop 37:removeL(A,B,C,D,E,F,G,H) -> [removeL(A',B',C',D',E',F',G',H')] 
27*s(28)+27*s(30)+27*s(29)+15
  Such that:s(25) =< A'
s(26) =< D'
s(27) =< s(26)
s(28) =< s(25)
s(28) =< s(26)
s(29) =< s(25)
s(27) =< s(25)
s(30) =< s(25)
s(30) =< s(27)

 * loop 38:removeL(A,B,C,D,E,F,G,H) -> [removeL(A',B',C',D',E',F',G',H')] 
27*s(34)+14
  Such that:s(33) =< A'
s(34) =< s(33)

 * loop 39:removeL(A,B,C,D,E,F,G,H) -> [removeL(A',B',C',D',E',F',G',H')] 
15
##### Pending set removeL(A,B,C,D,E,F,G,H)
* Psum in Loop 34: [it(34)=<1,s(36)=<A']
* Psum in Loop 35: [it(35)=<1,s(38)=<D,s(39)=<A']
* Psum in Loop 36: [it(36)=<1,s(41)=<D,s(42)=<A']
* Psum in Loop 37: [it(37)=<1,s(47)=<A',s(48)=<D']
* Psum in Loop 38: [it(38)=<1,s(50)=<A']
* Psum in Loop 39: [it(39)=<1]

###### Computing sum for it(34)=<1  in Loop 34 
   - Applying inductive sum strategy 
     - head Candidate: C-1 
       - Loop 35 is collaborative and bounds [it(35)] 
       - Loop 36 is collaborative and bounds [it(36)] 
       - Loop 37 is collaborative and bounds [it(37)] 
       - Loop 38 is collaborative and bounds [it(38)] 
       - Loop 39 is collaborative and bounds [it(39)] 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - Loop 35 is collaborative and bounds [it(35)] 
       - Loop 36 is collaborative and bounds [it(36)] 
       - Loop 37 is collaborative and bounds [it(37)] 
       - Loop 38 is collaborative and bounds [it(38)] 
       - Loop 39 is collaborative and bounds [it(39)] 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(34)+it(35)+it(36)+it(37)+it(38)+it(39)=<C-1,it(34)+it(35)+it(36)+it(37)+it(38)+it(39)=<C-1,it(34)+it(35)+it(36)+it(37)+it(38)+it(39)=<C-C',it(34)+it(35)+it(36)+it(37)+it(38)+it(39)=<C-C'] 

##### Pending set A
* Psum in Loop 34: [s(36)=<A']
* Psum in Loop 35: [it(35)=<1,s(38)=<D,s(39)=<A']
* Psum in Loop 36: [it(36)=<1,s(41)=<D,s(42)=<A']
* Psum in Loop 37: [it(37)=<1,s(47)=<A',s(48)=<D']
* Psum in Loop 38: [it(38)=<1,s(50)=<A']
* Psum in Loop 39: [it(39)=<1]

###### Computing sum for s(36)=<A'  in Loop 34 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(15)=<A,aux(15)=<D] 
 * Adding constraints: [s(36)=<it(34)*aux(15)] 

##### Pending set removeL(A,B,C,D,E,F,G,H)
* Pmax/min: [aux(15)=<A,aux(15)=<D]
* Psum in Loop 35: [it(35)=<1,s(38)=<D,s(39)=<A']
* Psum in Loop 36: [it(36)=<1,s(41)=<D,s(42)=<A']
* Psum in Loop 37: [it(37)=<1,s(47)=<A',s(48)=<D']
* Psum in Loop 38: [it(38)=<1,s(50)=<A']
* Psum in Loop 39: [it(39)=<1]

###### Computing max_min for aux(15)=<A  
   - Found a solution using transitive invariants 
 * Adding constraints:[aux(15)=<A] 

##### Pending set removeL(A,B,C,D,E,F,G,H)
* Pmax/min: [aux(15)=<D]
* Psum in Loop 35: [it(35)=<1,s(38)=<D,s(39)=<A']
* Psum in Loop 36: [it(36)=<1,s(41)=<D,s(42)=<A']
* Psum in Loop 37: [it(37)=<1,s(47)=<A',s(48)=<D']
* Psum in Loop 38: [it(38)=<1,s(50)=<A']
* Psum in Loop 39: [it(39)=<1]

###### Computing max_min for aux(15)=<D  
   - Found a solution using transitive invariants 
 * Adding constraints:[aux(15)=<D] 

##### Pending set removeL(A,B,C,D,E,F,G,H)
* Psum in Loop 35: [it(35)=<1,s(38)=<D,s(39)=<A']
* Psum in Loop 36: [it(36)=<1,s(41)=<D,s(42)=<A']
* Psum in Loop 37: [it(37)=<1,s(47)=<A',s(48)=<D']
* Psum in Loop 38: [it(38)=<1,s(50)=<A']
* Psum in Loop 39: [it(39)=<1]

###### Computing sum for it(35)=<1  in Loop 35 
   - Applying inductive sum strategy 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(34)+it(35)+it(36)+it(37)+it(38)+it(39)=<C-1,it(34)+it(35)+it(36)+it(37)+it(38)+it(39)=<C-1,it(34)+it(35)+it(36)+it(37)+it(38)+it(39)=<C-C',it(34)+it(35)+it(36)+it(37)+it(38)+it(39)=<C-C'] 

##### Pending set removeL(A,B,C,D,E,F,G,H)
* Psum in Loop 35: [s(38)=<D,s(39)=<A']
* Psum in Loop 36: [it(36)=<1,s(41)=<D,s(42)=<A']
* Psum in Loop 37: [it(37)=<1,s(47)=<A',s(48)=<D']
* Psum in Loop 38: [it(38)=<1,s(50)=<A']
* Psum in Loop 39: [it(39)=<1]

###### Computing sum for s(38)=<D  in Loop 35 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(16)=<D] 
 * Adding constraints: [s(38)=<it(35)*aux(16)] 

##### Pending set removeL(A,B,C,D,E,F,G,H)
* Pmax/min: [aux(16)=<D]
* Psum in Loop 35: [s(39)=<A']
* Psum in Loop 36: [it(36)=<1,s(41)=<D,s(42)=<A']
* Psum in Loop 37: [it(37)=<1,s(47)=<A',s(48)=<D']
* Psum in Loop 38: [it(38)=<1,s(50)=<A']
* Psum in Loop 39: [it(39)=<1]

###### Computing max_min for aux(16)=<D  
   - Found a solution using cacheing 
 * Adding constraints:[aux(16)=<aux(15)] 

##### Pending set removeL(A,B,C,D,E,F,G,H)
* Psum in Loop 35: [s(39)=<A']
* Psum in Loop 36: [it(36)=<1,s(41)=<D,s(42)=<A']
* Psum in Loop 37: [it(37)=<1,s(47)=<A',s(48)=<D']
* Psum in Loop 38: [it(38)=<1,s(50)=<A']
* Psum in Loop 39: [it(39)=<1]

###### Computing sum for s(39)=<A'  in Loop 35 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(17)=<A] 
 * Adding constraints: [s(39)=<it(35)*aux(17)] 

##### Pending set removeL(A,B,C,D,E,F,G,H)
* Pmax/min: [aux(17)=<A]
* Psum in Loop 36: [it(36)=<1,s(41)=<D,s(42)=<A']
* Psum in Loop 37: [it(37)=<1,s(47)=<A',s(48)=<D']
* Psum in Loop 38: [it(38)=<1,s(50)=<A']
* Psum in Loop 39: [it(39)=<1]

###### Computing max_min for aux(17)=<A  
   - Found a solution using cacheing 
 * Adding constraints:[aux(17)=<aux(15)] 

##### Pending set removeL(A,B,C,D,E,F,G,H)
* Psum in Loop 36: [it(36)=<1,s(41)=<D,s(42)=<A']
* Psum in Loop 37: [it(37)=<1,s(47)=<A',s(48)=<D']
* Psum in Loop 38: [it(38)=<1,s(50)=<A']
* Psum in Loop 39: [it(39)=<1]

###### Computing sum for it(36)=<1  in Loop 36 
   - Applying inductive sum strategy 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(34)+it(35)+it(36)+it(37)+it(38)+it(39)=<C-1,it(34)+it(35)+it(36)+it(37)+it(38)+it(39)=<C-1,it(34)+it(35)+it(36)+it(37)+it(38)+it(39)=<C-C',it(34)+it(35)+it(36)+it(37)+it(38)+it(39)=<C-C'] 

##### Pending set removeL(A,B,C,D,E,F,G,H)
* Psum in Loop 36: [s(41)=<D,s(42)=<A']
* Psum in Loop 37: [it(37)=<1,s(47)=<A',s(48)=<D']
* Psum in Loop 38: [it(38)=<1,s(50)=<A']
* Psum in Loop 39: [it(39)=<1]

###### Computing sum for s(41)=<D  in Loop 36 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(18)=<D] 
 * Adding constraints: [s(41)=<it(36)*aux(18)] 

##### Pending set removeL(A,B,C,D,E,F,G,H)
* Pmax/min: [aux(18)=<D]
* Psum in Loop 36: [s(42)=<A']
* Psum in Loop 37: [it(37)=<1,s(47)=<A',s(48)=<D']
* Psum in Loop 38: [it(38)=<1,s(50)=<A']
* Psum in Loop 39: [it(39)=<1]

###### Computing max_min for aux(18)=<D  
   - Found a solution using cacheing 
 * Adding constraints:[aux(18)=<aux(15)] 

##### Pending set removeL(A,B,C,D,E,F,G,H)
* Psum in Loop 36: [s(42)=<A']
* Psum in Loop 37: [it(37)=<1,s(47)=<A',s(48)=<D']
* Psum in Loop 38: [it(38)=<1,s(50)=<A']
* Psum in Loop 39: [it(39)=<1]

###### Computing sum for s(42)=<A'  in Loop 36 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(19)=<A,aux(19)=<D-1] 
 * Adding constraints: [s(42)=<it(36)*aux(19)] 

##### Pending set removeL(A,B,C,D,E,F,G,H)
* Pmax/min: [aux(19)=<A,aux(19)=<D-1]
* Psum in Loop 37: [it(37)=<1,s(47)=<A',s(48)=<D']
* Psum in Loop 38: [it(38)=<1,s(50)=<A']
* Psum in Loop 39: [it(39)=<1]

###### Computing max_min for aux(19)=<A  
   - Found a solution using cacheing 
 * Adding constraints:[aux(19)=<aux(15)] 

##### Pending set removeL(A,B,C,D,E,F,G,H)
* Pmax/min: [aux(19)=<D-1]
* Psum in Loop 37: [it(37)=<1,s(47)=<A',s(48)=<D']
* Psum in Loop 38: [it(38)=<1,s(50)=<A']
* Psum in Loop 39: [it(39)=<1]

###### Computing max_min for aux(19)=<D-1  
   - Found a solution using cacheing 
 * Adding constraints:[aux(19)=<aux(15)-1] 

##### Pending set removeL(A,B,C,D,E,F,G,H)
* Psum in Loop 37: [it(37)=<1,s(47)=<A',s(48)=<D']
* Psum in Loop 38: [it(38)=<1,s(50)=<A']
* Psum in Loop 39: [it(39)=<1]

###### Computing sum for it(37)=<1  in Loop 37 
   - Applying inductive sum strategy 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(34)+it(35)+it(36)+it(37)+it(38)+it(39)=<C-1,it(34)+it(35)+it(36)+it(37)+it(38)+it(39)=<C-1,it(34)+it(35)+it(36)+it(37)+it(38)+it(39)=<C-C',it(34)+it(35)+it(36)+it(37)+it(38)+it(39)=<C-C'] 

##### Pending set removeL(A,B,C,D,E,F,G,H)
* Psum in Loop 37: [s(47)=<A',s(48)=<D']
* Psum in Loop 38: [it(38)=<1,s(50)=<A']
* Psum in Loop 39: [it(39)=<1]

###### Computing sum for s(47)=<A'  in Loop 37 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(20)=<A] 
 * Adding constraints: [s(47)=<it(37)*aux(20)] 

##### Pending set removeL(A,B,C,D,E,F,G,H)
* Pmax/min: [aux(20)=<A]
* Psum in Loop 37: [s(48)=<D']
* Psum in Loop 38: [it(38)=<1,s(50)=<A']
* Psum in Loop 39: [it(39)=<1]

###### Computing max_min for aux(20)=<A  
   - Found a solution using cacheing 
 * Adding constraints:[aux(20)=<aux(15)] 

##### Pending set removeL(A,B,C,D,E,F,G,H)
* Psum in Loop 37: [s(48)=<D']
* Psum in Loop 38: [it(38)=<1,s(50)=<A']
* Psum in Loop 39: [it(39)=<1]

###### Computing sum for s(48)=<D'  in Loop 37 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(21)=<D] 
 * Adding constraints: [s(48)=<it(37)*aux(21)] 

##### Pending set removeL(A,B,C,D,E,F,G,H)
* Pmax/min: [aux(21)=<D]
* Psum in Loop 38: [it(38)=<1,s(50)=<A']
* Psum in Loop 39: [it(39)=<1]

###### Computing max_min for aux(21)=<D  
   - Found a solution using cacheing 
 * Adding constraints:[aux(21)=<aux(15)] 

##### Pending set removeL(A,B,C,D,E,F,G,H)
* Psum in Loop 38: [it(38)=<1,s(50)=<A']
* Psum in Loop 39: [it(39)=<1]

###### Computing sum for it(38)=<1  in Loop 38 
   - Applying inductive sum strategy 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(34)+it(35)+it(36)+it(37)+it(38)+it(39)=<C-1,it(34)+it(35)+it(36)+it(37)+it(38)+it(39)=<C-1,it(34)+it(35)+it(36)+it(37)+it(38)+it(39)=<C-C',it(34)+it(35)+it(36)+it(37)+it(38)+it(39)=<C-C'] 

##### Pending set removeL(A,B,C,D,E,F,G,H)
* Psum in Loop 38: [s(50)=<A']
* Psum in Loop 39: [it(39)=<1]

###### Computing sum for s(50)=<A'  in Loop 38 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(22)=<A,aux(22)=<D] 
 * Adding constraints: [s(50)=<it(38)*aux(22)] 

##### Pending set removeL(A,B,C,D,E,F,G,H)
* Pmax/min: [aux(22)=<A,aux(22)=<D]
* Psum in Loop 39: [it(39)=<1]

###### Computing max_min for aux(22)=<A  
   - Found a solution using cacheing 
 * Adding constraints:[aux(22)=<aux(15)] 

##### Pending set removeL(A,B,C,D,E,F,G,H)
* Pmax/min: [aux(22)=<D]
* Psum in Loop 39: [it(39)=<1]

###### Computing max_min for aux(22)=<D  
   - Found a solution using cacheing 
 * Adding constraints:[aux(22)=<aux(15)] 

##### Pending set removeL(A,B,C,D,E,F,G,H)
* Psum in Loop 39: [it(39)=<1]

###### Computing sum for it(39)=<1  in Loop 39 
   - Applying inductive sum strategy 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(34)+it(35)+it(36)+it(37)+it(38)+it(39)=<C-1,it(34)+it(35)+it(36)+it(37)+it(38)+it(39)=<C-1,it(34)+it(35)+it(36)+it(37)+it(38)+it(39)=<C-C',it(34)+it(35)+it(36)+it(37)+it(38)+it(39)=<C-C'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [34,35,36,37,38,39] 

#### Simplifying cost structure of phase [34,35,36,37,38,39] 
 * Joined equivalent variables [aux(16),aux(17),aux(18),aux(20),aux(21),aux(22)] into aux(16)
 * Joined equivalent variables [it(34),it(35),it(36),it(37),it(38),it(39)] into it(34)
 * Joined equivalent variables [s(39),s(41),s(47),s(48),s(50)] into s(39)
 * Joined equivalent variables [s(39),s(46)] into s(39)
 * Joined equivalent variables [s(43),s(45),s(49)] into s(43)
 * Joined equivalent variables [s(43),s(44)] into s(43)

#### Cost of phase [34,35,36,37,38,39]:removeL(A,B,C,D,E,F,G,H) -> [removeL(A',B',C',D',E',F',G',H')] 
86*it(34)+27*s(35)+27*s(37)+27*s(40)+108*s(43)+0
  Such that:aux(15) =< A
aux(15) =< D
aux(23) =< C
aux(24) =< C-C'
it(34) =< aux(23)
it(34) =< aux(24)
aux(16) =< aux(15)
aux(19) =< aux(15)-1
aux(19) =< aux(15)
s(36) =< it(34)*aux(15)
s(39) =< it(34)*aux(16)
s(42) =< it(34)*aux(19)
s(38) =< it(34)*aux(16)
s(43) =< s(39)
s(40) =< s(42)
s(40) =< s(39)
s(38) =< s(39)
s(37) =< s(39)
s(37) =< s(38)
s(35) =< s(36)

#### Simplifying cost structure of chain [[34,35,36,37,38,39],33] 
 * Joined equivalent variables [aux(25),aux(23),aux(24)] into aux(25)

#### Cost of chains of removeL(A,B,C,D,E,F,G,H):
* Chain [[40,41,42],33]: 42*it(40)+3
  Such that:aux(10) =< C
it(40) =< aux(10)

  with precondition: [A=1,B>=0,C>=2,E>=0,F>=1,G>=0,H>=0,C>=F,D>=G,2*D>=G+2,G+2*C>=2*F+2,D+F>=G+2] 

* Chain [[34,35,36,37,38,39],33]: 86*it(34)+27*s(35)+27*s(37)+27*s(40)+108*s(43)+3
  Such that:aux(15) =< A
aux(15) =< D
aux(25) =< C
it(34) =< aux(25)
aux(16) =< aux(15)
aux(19) =< aux(15)-1
aux(19) =< aux(15)
s(36) =< it(34)*aux(15)
s(39) =< it(34)*aux(16)
s(42) =< it(34)*aux(19)
s(38) =< it(34)*aux(16)
s(43) =< s(39)
s(40) =< s(42)
s(40) =< s(39)
s(38) =< s(39)
s(37) =< s(39)
s(37) =< s(38)
s(35) =< s(36)

  with precondition: [A>=2,B>=0,C>=2,E>=0,F>=1,G>=0,H>=0,C>=F,D>=G,D+G>=2,C+G>=F+1,D+2*F>=G+4] 

* Chain [33]: 3
  with precondition: [C=1,D=0,F=1,G=0,A>=0,B>=0,E>=0,H>=0] 


#### Simplifying cost structure of CE 46 

#### Computing cost of phase [43,44,45] 
 * Renamed intermediate variables: 
[ (eq(52,1),aux(15))>>s(51), (eq(52,1),aux(25))>>s(52), (eq(52,1),it(34))>>s(53), (eq(52,1),aux(16))>>s(54), (eq(52,1),aux(19))>>s(55), (eq(52,1),s(36))>>s(56), (eq(52,1),s(39))>>s(57), (eq(52,1),s(42))>>s(58), (eq(52,1),s(38))>>s(59), (eq(52,1),s(43))>>s(60), (eq(52,1),s(40))>>s(61), (eq(52,1),s(37))>>s(62), (eq(52,1),s(35))>>s(63)]

#### Simplifying cost structure of CE 52 
 * Renamed intermediate variables: 
[ (it(43),s(52))>>s(64), (it(43),s(51))>>s(65), (it(43),s(53))>>s(66), (it(43),s(54))>>s(67), (it(43),s(55))>>s(68), (it(43),s(56))>>s(69), (it(43),s(57))>>s(70), (it(43),s(58))>>s(71), (it(43),s(59))>>s(72), (it(43),s(60))>>s(73), (it(43),s(61))>>s(74), (it(43),s(62))>>s(75), (it(43),s(63))>>s(76)]
 * Renamed intermediate variables: 
[ (eq(47,1),aux(10))>>s(77), (eq(47,1),it(40))>>s(78)]

#### Simplifying cost structure of CE 47 
 * Renamed intermediate variables: 
[ (it(44),s(77))>>s(79), (it(44),s(78))>>s(80)]
 * Renamed intermediate variables: 
[ (eq(51,1),aux(15))>>s(81), (eq(51,1),aux(25))>>s(82), (eq(51,1),it(34))>>s(83), (eq(51,1),aux(16))>>s(84), (eq(51,1),aux(19))>>s(85), (eq(51,1),s(36))>>s(86), (eq(51,1),s(39))>>s(87), (eq(51,1),s(42))>>s(88), (eq(51,1),s(38))>>s(89), (eq(51,1),s(43))>>s(90), (eq(51,1),s(40))>>s(91), (eq(51,1),s(37))>>s(92), (eq(51,1),s(35))>>s(93)]

#### Simplifying cost structure of CE 51 
 * Renamed intermediate variables: 
[ (it(45),s(82))>>s(94), (it(45),s(81))>>s(95), (it(45),s(83))>>s(96), (it(45),s(84))>>s(97), (it(45),s(85))>>s(98), (it(45),s(86))>>s(99), (it(45),s(87))>>s(100), (it(45),s(88))>>s(101), (it(45),s(89))>>s(102), (it(45),s(90))>>s(103), (it(45),s(91))>>s(104), (it(45),s(92))>>s(105), (it(45),s(93))>>s(106)]

#### Cost of loops [43,44,45] 

 * loop 43:nub(A,B,C,D,E,F) -> [nub(A',B',C',D',E',F')] 
86*s(66)+108*s(73)+27*s(74)+27*s(75)+27*s(76)+9
  Such that:s(64) =< A
s(65) =< B
s(66) =< s(64)
s(67) =< s(65)
s(68) =< s(65)-1
s(68) =< s(65)
s(69) =< s(66)*s(65)
s(70) =< s(66)*s(67)
s(71) =< s(66)*s(68)
s(72) =< s(66)*s(67)
s(73) =< s(70)
s(74) =< s(71)
s(74) =< s(70)
s(72) =< s(70)
s(75) =< s(70)
s(75) =< s(72)
s(76) =< s(69)

 * loop 44:nub(A,B,C,D,E,F) -> [nub(A',B',C',D',E',F')] 
42*s(80)+9
  Such that:s(79) =< A
s(80) =< s(79)

 * loop 45:nub(A,B,C,D,E,F) -> [nub(A',B',C',D',E',F')] 
86*s(96)+108*s(103)+27*s(104)+27*s(105)+27*s(106)+9
  Such that:s(94) =< A
s(95) =< B'
s(96) =< s(94)
s(97) =< s(95)
s(98) =< s(95)-1
s(98) =< s(95)
s(99) =< s(96)*s(95)
s(100) =< s(96)*s(97)
s(101) =< s(96)*s(98)
s(102) =< s(96)*s(97)
s(103) =< s(100)
s(104) =< s(101)
s(104) =< s(100)
s(102) =< s(100)
s(105) =< s(100)
s(105) =< s(102)
s(106) =< s(99)

##### Pending set nub(A,B,C,D,E,F)
* Pmax/min: [s(65)=<B,s(95)=<B]
* Psum in Loop 43: [it(43)=<1,s(116)=<A]
* Psum in Loop 44: [it(44)=<1,s(118)=<A]
* Psum in Loop 45: [it(45)=<1,s(128)=<A]

###### Computing max_min for s(65)=<B  
   - Found a solution using transitive invariants 
 * Adding constraints:[s(65)=<B] 

##### Pending set nub(A,B,C,D,E,F)
* Pmax/min: [s(95)=<B]
* Psum in Loop 43: [it(43)=<1,s(116)=<A]
* Psum in Loop 44: [it(44)=<1,s(118)=<A]
* Psum in Loop 45: [it(45)=<1,s(128)=<A]

###### Computing max_min for s(95)=<B  
   - Found a solution using cacheing 
 * Adding constraints:[s(95)=<s(65)] 

##### Pending set nub(A,B,C,D,E,F)
* Psum in Loop 43: [it(43)=<1,s(116)=<A]
* Psum in Loop 44: [it(44)=<1,s(118)=<A]
* Psum in Loop 45: [it(45)=<1,s(128)=<A]

###### Computing sum for it(43)=<1  in Loop 43 
   - Applying inductive sum strategy 
     - head Candidate: A+2*B-4 
       - Loop 44 is collaborative and bounds [it(44)] 
       - Loop 45 is collaborative and bounds [it(45)] 
     - head Candidate: A+B-3 
       - Loop 44 is collaborative and bounds [it(44)] 
       - Loop 45 is collaborative and bounds [it(45)] 
     - head Candidate: A-2 
       - Loop 44 is collaborative and bounds [it(44)] 
       - Loop 45 is collaborative and bounds [it(45)] 
     - head Candidate: A-2 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A+B-4 
       - Loop 44 is collaborative
       - Loop 45 is collaborative and bounds [it(45)] 
     - head Candidate: A+B/2-7/2 
       - Loop 44 is collaborative
       - Loop 45 is collaborative
     - tail Candidate: A+2*B-4 
       - Loop 44 is collaborative and bounds [it(44)] 
       - Loop 45 is collaborative and bounds [it(45)] 
     - tail Candidate: A+B-3 
       - Loop 44 is collaborative and bounds [it(44)] 
       - Loop 45 is collaborative and bounds [it(45)] 
     - tail Candidate: A-2 
       - Loop 44 is collaborative and bounds [it(44)] 
       - Loop 45 is collaborative and bounds [it(45)] 
     - tail Candidate: A-2 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A+B-4 
       - Loop 44 is collaborative and bounds [it(44)] 
       - Loop 45 is collaborative and bounds [it(45)] 
     - tail Candidate: A+B/2-7/2 
       - Loop 44 is collaborative and bounds [it(44)] 
       - Loop 45 is collaborative and bounds [it(45)] 
 * Adding constraints: [it(43)+it(44)+it(45)=<A+2*B-4,it(43)+it(44)+it(45)=<A+B-3,it(43)+it(44)+it(45)=<A-2,it(43)+it(44)+it(45)=<A-2,it(43)+it(45)=<A+B-4,it(43)=<A+B/2-7/2,it(43)+it(44)+it(45)=<A+2*B-A'-2*B',it(43)+it(44)+it(45)=<A+B-A'-B',it(43)+it(44)+it(45)=<A-A',it(43)+it(44)+it(45)=<A-A',it(43)+it(44)+it(45)=<A+B-A'-B',it(43)+it(44)+it(45)=<A+B/2-A'-B'/2] 

##### Pending set nub(A,B,C,D,E,F)
* Psum in Loop 43: [s(116)=<A]
* Psum in Loop 44: [it(44)=<1,s(118)=<A]
* Psum in Loop 45: [it(45)=<1,s(128)=<A]

###### Computing sum for s(116)=<A  in Loop 43 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(26)=<A] 
 * Adding constraints: [s(116)=<it(43)*aux(26)] 

##### Pending set nub(A,B,C,D,E,F)
* Pmax/min: [aux(26)=<A]
* Psum in Loop 44: [it(44)=<1,s(118)=<A]
* Psum in Loop 45: [it(45)=<1,s(128)=<A]

###### Computing max_min for aux(26)=<A  
   - Found a solution using transitive invariants 
 * Adding constraints:[aux(26)=<A] 

##### Pending set nub(A,B,C,D,E,F)
* Psum in Loop 44: [it(44)=<1,s(118)=<A]
* Psum in Loop 45: [it(45)=<1,s(128)=<A]

###### Computing sum for it(44)=<1  in Loop 44 
   - Applying inductive sum strategy 
     - head Candidate: A+2*B-4 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A+B-3 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A-2 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A-2 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A+B-3 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A+B/2-3 
       - Loop 43 is collaborative
       - Loop 45 is collaborative and bounds [it(45)] 
     - tail Candidate: A+2*B-4 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A+B-3 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-2 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-2 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A+B-3 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A+B/2-3 
       - Loop 43 is collaborative
       - Loop 45 is collaborative and bounds [it(45)] 
 * Adding constraints: [it(43)+it(44)+it(45)=<A+2*B-4,it(43)+it(44)+it(45)=<A+B-3,it(43)+it(44)+it(45)=<A-2,it(43)+it(44)+it(45)=<A-2,it(43)+it(44)+it(45)=<A+B-3,it(44)+it(45)=<A+B/2-3,it(43)+it(44)+it(45)=<A+2*B-A'-2*B',it(43)+it(44)+it(45)=<A+B-A'-B',it(43)+it(44)+it(45)=<A-A',it(43)+it(44)+it(45)=<A-A',it(43)+it(44)+it(45)=<A+B-A'-B',it(44)+it(45)=<A+B/2-A'-B'/2] 

##### Pending set nub(A,B,C,D,E,F)
* Psum in Loop 44: [s(118)=<A]
* Psum in Loop 45: [it(45)=<1,s(128)=<A]

###### Computing sum for s(118)=<A  in Loop 44 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(27)=<A] 
 * Adding constraints: [s(118)=<it(44)*aux(27)] 

##### Pending set nub(A,B,C,D,E,F)
* Pmax/min: [aux(27)=<A]
* Psum in Loop 45: [it(45)=<1,s(128)=<A]

###### Computing max_min for aux(27)=<A  
   - Found a solution using cacheing 
 * Adding constraints:[aux(27)=<aux(26)] 

##### Pending set nub(A,B,C,D,E,F)
* Psum in Loop 45: [it(45)=<1,s(128)=<A]

###### Computing sum for it(45)=<1  in Loop 45 
   - Applying inductive sum strategy 
     - head Candidate: A+2*B-4 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A+B-3 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A-2 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A-2 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A+B-4 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A+B/2-7/2 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A+2*B-4 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A+B-3 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-2 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-2 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A+B-4 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A+B/2-7/2 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(43)+it(44)+it(45)=<A+2*B-4,it(43)+it(44)+it(45)=<A+B-3,it(43)+it(44)+it(45)=<A-2,it(43)+it(44)+it(45)=<A-2,it(43)+it(45)=<A+B-4,it(43)+it(45)=<A+B/2-7/2,it(43)+it(44)+it(45)=<A+2*B-A'-2*B',it(43)+it(44)+it(45)=<A+B-A'-B',it(43)+it(44)+it(45)=<A-A',it(43)+it(44)+it(45)=<A-A',it(43)+it(44)+it(45)=<A+B-A'-B',it(43)+it(44)+it(45)=<A+B/2-A'-B'/2] 

##### Pending set nub(A,B,C,D,E,F)
* Psum in Loop 45: [s(128)=<A]

###### Computing sum for s(128)=<A  in Loop 45 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(28)=<A] 
 * Adding constraints: [s(128)=<it(45)*aux(28)] 

##### Pending set nub(A,B,C,D,E,F)
* Pmax/min: [aux(28)=<A]

###### Computing max_min for aux(28)=<A  
   - Found a solution using cacheing 
 * Adding constraints:[aux(28)=<aux(26)] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [43,44,45] 

#### Simplifying cost structure of phase [43,44,45] 
 * Joined equivalent variables [aux(29),aux(26)] into aux(29)
 * Joined equivalent variables [aux(27),aux(28)] into aux(27)
 * Joined equivalent variables [s(67),s(95)] into s(67)
 * Joined equivalent variables [it(43),it(44),it(45)] into it(43)
 * Joined equivalent variables [s(118),s(128)] into s(118)
 * Joined equivalent variables [s(117),s(119)] into s(117)

#### Cost of phase [43,44,45]:nub(A,B,C,D,E,F) -> [nub(A',B',C',D',E',F')] 
27*it(43)+86*s(107)+108*s(108)+27*s(109)+27*s(110)+27*s(111)+128*s(117)+108*s(120)+27*s(121)+27*s(122)+27*s(123)+0
  Such that:s(65) =< B
aux(29) =< A
aux(30) =< A+B
aux(31) =< A+B-A'-B'
aux(32) =< A+2*B
aux(33) =< A+2*B-A'-2*B'
aux(34) =< A+B/2
aux(35) =< A+B/2-A'-B'/2
aux(36) =< A-A'
it(43) =< aux(29)
it(43) =< aux(30)
it(43) =< aux(31)
it(43) =< aux(32)
it(43) =< aux(33)
it(43) =< aux(34)
it(43) =< aux(35)
it(43) =< aux(36)
aux(27) =< aux(29)
s(67) =< s(65)
s(116) =< it(43)*aux(29)
s(118) =< it(43)*aux(27)
s(117) =< s(118)
s(97) =< s(67)
s(98) =< s(67)-1
s(98) =< s(67)
s(124) =< s(117)*s(67)
s(126) =< s(117)*s(97)
s(127) =< s(117)*s(98)
s(125) =< s(117)*s(97)
s(120) =< s(126)
s(121) =< s(127)
s(121) =< s(126)
s(125) =< s(126)
s(122) =< s(126)
s(122) =< s(125)
s(123) =< s(124)
s(107) =< s(116)
s(68) =< s(65)-1
s(68) =< s(65)
s(112) =< s(107)*s(65)
s(114) =< s(107)*s(67)
s(115) =< s(107)*s(68)
s(113) =< s(107)*s(67)
s(108) =< s(114)
s(109) =< s(115)
s(109) =< s(114)
s(113) =< s(114)
s(110) =< s(114)
s(110) =< s(113)
s(111) =< s(112)

#### Simplifying cost structure of chain [[43,44,45],49] 
 * Joined equivalent variables [aux(37),aux(29),aux(36)] into aux(37)
 * Joined equivalent variables [aux(38),aux(30),aux(31)] into aux(38)
 * Joined equivalent variables [aux(39),aux(32),aux(33)] into aux(39)
 * Joined equivalent variables [aux(40),aux(34),aux(35)] into aux(40)

#### Simplifying cost structure of CE 50 

#### Simplifying cost structure of chain [47,49] 

#### Found solution for phase  [43,44,45] in the cache 

#### Cost of phase [43,44,45]:nub(A,B,C,D,E,F) -> [nub(A',B',C',D',E',F')] 
27*it(43)+86*s(107)+108*s(108)+27*s(109)+27*s(110)+27*s(111)+128*s(117)+108*s(120)+27*s(121)+27*s(122)+27*s(123)+0
  Such that:s(65) =< B
aux(29) =< A
aux(30) =< A+B
aux(31) =< A+B-A'-B'
aux(32) =< A+2*B
aux(33) =< A+2*B-A'-2*B'
aux(34) =< A+B/2
aux(35) =< A+B/2-A'-B'/2
aux(36) =< A-A'
it(43) =< aux(29)
it(43) =< aux(30)
it(43) =< aux(31)
it(43) =< aux(32)
it(43) =< aux(33)
it(43) =< aux(34)
it(43) =< aux(35)
it(43) =< aux(36)
aux(27) =< aux(29)
s(67) =< s(65)
s(116) =< it(43)*aux(29)
s(118) =< it(43)*aux(27)
s(117) =< s(118)
s(97) =< s(67)
s(98) =< s(67)-1
s(98) =< s(67)
s(124) =< s(117)*s(67)
s(126) =< s(117)*s(97)
s(127) =< s(117)*s(98)
s(125) =< s(117)*s(97)
s(120) =< s(126)
s(121) =< s(127)
s(121) =< s(126)
s(125) =< s(126)
s(122) =< s(126)
s(122) =< s(125)
s(123) =< s(124)
s(107) =< s(116)
s(68) =< s(65)-1
s(68) =< s(65)
s(112) =< s(107)*s(65)
s(114) =< s(107)*s(67)
s(115) =< s(107)*s(68)
s(113) =< s(107)*s(67)
s(108) =< s(114)
s(109) =< s(115)
s(109) =< s(114)
s(113) =< s(114)
s(110) =< s(114)
s(110) =< s(113)
s(111) =< s(112)

#### Simplifying cost structure of chain [[43,44,45],47,49] 
 * Joined equivalent variables [aux(41),aux(29),aux(36)] into aux(41)
 * Joined equivalent variables [aux(42),aux(30)] into aux(42)
 * Joined equivalent variables [aux(43),aux(32)] into aux(43)
 * Joined equivalent variables [aux(44),aux(34)] into aux(44)
 * Renamed intermediate variables: 
[ (eq(48,1),aux(10))>>s(129), (eq(48,1),it(40))>>s(130)]

#### Simplifying cost structure of CE 48 

#### Simplifying cost structure of chain [46,49] 

#### Found solution for phase  [43,44,45] in the cache 

#### Cost of phase [43,44,45]:nub(A,B,C,D,E,F) -> [nub(A',B',C',D',E',F')] 
27*it(43)+86*s(107)+108*s(108)+27*s(109)+27*s(110)+27*s(111)+128*s(117)+108*s(120)+27*s(121)+27*s(122)+27*s(123)+0
  Such that:s(65) =< B
aux(29) =< A
aux(30) =< A+B
aux(31) =< A+B-A'-B'
aux(32) =< A+2*B
aux(33) =< A+2*B-A'-2*B'
aux(34) =< A+B/2
aux(35) =< A+B/2-A'-B'/2
aux(36) =< A-A'
it(43) =< aux(29)
it(43) =< aux(30)
it(43) =< aux(31)
it(43) =< aux(32)
it(43) =< aux(33)
it(43) =< aux(34)
it(43) =< aux(35)
it(43) =< aux(36)
aux(27) =< aux(29)
s(67) =< s(65)
s(116) =< it(43)*aux(29)
s(118) =< it(43)*aux(27)
s(117) =< s(118)
s(97) =< s(67)
s(98) =< s(67)-1
s(98) =< s(67)
s(124) =< s(117)*s(67)
s(126) =< s(117)*s(97)
s(127) =< s(117)*s(98)
s(125) =< s(117)*s(97)
s(120) =< s(126)
s(121) =< s(127)
s(121) =< s(126)
s(125) =< s(126)
s(122) =< s(126)
s(122) =< s(125)
s(123) =< s(124)
s(107) =< s(116)
s(68) =< s(65)-1
s(68) =< s(65)
s(112) =< s(107)*s(65)
s(114) =< s(107)*s(67)
s(115) =< s(107)*s(68)
s(113) =< s(107)*s(67)
s(108) =< s(114)
s(109) =< s(115)
s(109) =< s(114)
s(113) =< s(114)
s(110) =< s(114)
s(110) =< s(113)
s(111) =< s(112)

#### Simplifying cost structure of chain [[43,44,45],46,49] 
 * Joined equivalent variables [aux(45),aux(29),aux(36)] into aux(45)
 * Joined equivalent variables [aux(46),aux(30)] into aux(46)
 * Joined equivalent variables [aux(47),aux(32)] into aux(47)
 * Joined equivalent variables [aux(48),aux(34)] into aux(48)

#### Cost of chains of nub(A,B,C,D,E,F):
* Chain [[43,44,45],49]: 27*it(43)+86*s(107)+108*s(108)+27*s(109)+27*s(110)+27*s(111)+128*s(117)+108*s(120)+27*s(121)+27*s(122)+27*s(123)+3
  Such that:s(65) =< B
aux(37) =< A
aux(38) =< A+B
aux(39) =< A+2*B
aux(40) =< A+B/2
it(43) =< aux(37)
it(43) =< aux(38)
it(43) =< aux(39)
it(43) =< aux(40)
aux(27) =< aux(37)
s(67) =< s(65)
s(116) =< it(43)*aux(37)
s(118) =< it(43)*aux(27)
s(117) =< s(118)
s(97) =< s(67)
s(98) =< s(67)-1
s(98) =< s(67)
s(124) =< s(117)*s(67)
s(126) =< s(117)*s(97)
s(127) =< s(117)*s(98)
s(125) =< s(117)*s(97)
s(120) =< s(126)
s(121) =< s(127)
s(121) =< s(126)
s(125) =< s(126)
s(122) =< s(126)
s(122) =< s(125)
s(123) =< s(124)
s(107) =< s(116)
s(68) =< s(65)-1
s(68) =< s(65)
s(112) =< s(107)*s(65)
s(114) =< s(107)*s(67)
s(115) =< s(107)*s(68)
s(113) =< s(107)*s(67)
s(108) =< s(114)
s(109) =< s(115)
s(109) =< s(114)
s(113) =< s(114)
s(110) =< s(114)
s(110) =< s(113)
s(111) =< s(112)

  with precondition: [C>=0,D>=2,E>=2,F>=0,A>=D+1,B>=E] 

* Chain [[43,44,45],47,49]: 27*it(43)+86*s(107)+108*s(108)+27*s(109)+27*s(110)+27*s(111)+128*s(117)+108*s(120)+27*s(121)+27*s(122)+27*s(123)+12
  Such that:aux(35) =< 2*A+B/2-D+E/2
aux(31) =< 3*A+B-2*D+E
aux(33) =< 5*A+2*B-4*D+2*E
s(65) =< B
aux(41) =< A
aux(42) =< A+B
aux(43) =< A+2*B
aux(44) =< A+B/2
aux(31) =< aux(42)
aux(33) =< aux(43)
aux(35) =< aux(44)
it(43) =< aux(41)
it(43) =< aux(42)
it(43) =< aux(31)
it(43) =< aux(43)
it(43) =< aux(33)
it(43) =< aux(44)
it(43) =< aux(35)
aux(27) =< aux(41)
s(67) =< s(65)
s(116) =< it(43)*aux(41)
s(118) =< it(43)*aux(27)
s(117) =< s(118)
s(97) =< s(67)
s(98) =< s(67)-1
s(98) =< s(67)
s(124) =< s(117)*s(67)
s(126) =< s(117)*s(97)
s(127) =< s(117)*s(98)
s(125) =< s(117)*s(97)
s(120) =< s(126)
s(121) =< s(127)
s(121) =< s(126)
s(125) =< s(126)
s(122) =< s(126)
s(122) =< s(125)
s(123) =< s(124)
s(107) =< s(116)
s(68) =< s(65)-1
s(68) =< s(65)
s(112) =< s(107)*s(65)
s(114) =< s(107)*s(67)
s(115) =< s(107)*s(68)
s(113) =< s(107)*s(67)
s(108) =< s(114)
s(109) =< s(115)
s(109) =< s(114)
s(113) =< s(114)
s(110) =< s(114)
s(110) =< s(113)
s(111) =< s(112)

  with precondition: [C>=0,D>=3,E>=1,F>=0,A>=D,B>=E,2*B>=E+2,A+B>=D+2] 

* Chain [[43,44,45],46,49]: 27*it(43)+86*s(107)+108*s(108)+27*s(109)+27*s(110)+27*s(111)+128*s(117)+108*s(120)+27*s(121)+27*s(122)+27*s(123)+42*s(130)+12
  Such that:aux(35) =< 2*A+B/2-D+E/2+1/2
aux(31) =< 3*A+B-2*D+E+1
aux(33) =< 5*A+2*B-4*D+2*E+2
s(65) =< B
aux(45) =< A
aux(46) =< A+B
aux(47) =< A+2*B
aux(48) =< A+B/2
s(129) =< aux(45)
aux(31) =< aux(46)
s(129) =< aux(46)
aux(33) =< aux(47)
aux(35) =< aux(48)
s(130) =< s(129)
it(43) =< aux(45)
it(43) =< aux(46)
it(43) =< aux(31)
it(43) =< aux(47)
it(43) =< aux(33)
it(43) =< aux(48)
it(43) =< aux(35)
aux(27) =< aux(45)
s(67) =< s(65)
s(116) =< it(43)*aux(45)
s(118) =< it(43)*aux(27)
s(117) =< s(118)
s(97) =< s(67)
s(98) =< s(67)-1
s(98) =< s(67)
s(124) =< s(117)*s(67)
s(126) =< s(117)*s(97)
s(127) =< s(117)*s(98)
s(125) =< s(117)*s(97)
s(120) =< s(126)
s(121) =< s(127)
s(121) =< s(126)
s(125) =< s(126)
s(122) =< s(126)
s(122) =< s(125)
s(123) =< s(124)
s(107) =< s(116)
s(68) =< s(65)-1
s(68) =< s(65)
s(112) =< s(107)*s(65)
s(114) =< s(107)*s(67)
s(115) =< s(107)*s(68)
s(113) =< s(107)*s(67)
s(108) =< s(114)
s(109) =< s(115)
s(109) =< s(114)
s(113) =< s(114)
s(110) =< s(114)
s(110) =< s(113)
s(111) =< s(112)

  with precondition: [C>=0,D>=3,E>=1,F>=0,A>=D+1,B>=E,2*B>=E+2,A+B>=D+3] 

* Chain [49]: 3
  with precondition: [A=1,B=0,D=1,E=0,C>=0,F>=0] 

* Chain [47,49]: 12
  with precondition: [A=2,D=2,C>=0,E>=1,F>=0,B>=E] 

* Chain [46,49]: 42*s(130)+12
  Such that:s(129) =< A
s(130) =< s(129)

  with precondition: [D=2,E=1,A>=3,B>=1,C>=0,F>=0] 


Closed-form bounds of eqD(A,B,C,D,E): 
-------------------------------------
* Chain [[28,29,30],27] with precondition: [A=C,1>=E,A>=2,B>=0,D>=0,E>=0,B+D+E>=1] 
    - Upper bound: 27*A+5 
    - Complexity: n 
* Chain [[28,29,30],26] with precondition: [E=0,A>=2,B>=0,D>=0,C>=A+1] 
    - Upper bound: 27*A+6 
    - Complexity: n 
* Chain [[28,29,30],25] with precondition: [E=0,B>=0,C>=2,D>=0,A>=C+1] 
    - Upper bound: 27*A+6 
    - Complexity: n 
* Chain [27] with precondition: [A=1,C=1,E=1,B>=0,D>=0] 
    - Upper bound: 5 
    - Complexity: constant 
* Chain [26] with precondition: [A=1,E=0,B>=0,C>=2,D>=0] 
    - Upper bound: 6 
    - Complexity: constant 
* Chain [25] with precondition: [C=1,E=0,A>=2,B>=0,D>=0] 
    - Upper bound: 6 
    - Complexity: constant 

### Maximum cost of eqD(A,B,C,D,E): 27*A+6 
Asymptotic class: n 

Closed-form bounds of removeL(A,B,C,D,E,F,G,H): 
-------------------------------------
* Chain [[40,41,42],33] with precondition: [A=1,B>=0,C>=2,E>=0,F>=1,G>=0,H>=0,C>=F,D>=G,2*D>=G+2,G+2*C>=2*F+2,D+F>=G+2] 
    - Upper bound: 42*C+3 
    - Complexity: n 
* Chain [[34,35,36,37,38,39],33] with precondition: [A>=2,B>=0,C>=2,E>=0,F>=1,G>=0,H>=0,C>=F,D>=G,D+G>=2,C+G>=F+1,D+2*F>=G+4] 
    - Upper bound: 162*A*C+3+86*C+ (27*A-27)*C 
    - Complexity: n^2 
* Chain [33] with precondition: [C=1,D=0,F=1,G=0,A>=0,B>=0,E>=0,H>=0] 
    - Upper bound: 3 
    - Complexity: constant 

### Maximum cost of removeL(A,B,C,D,E,F,G,H): 162*A*C+44*C+nat(A-1)*27*C+42*C+3 
Asymptotic class: n^2 

Closed-form bounds of nub(A,B,C,D,E,F): 
-------------------------------------
* Chain [[43,44,45],49] with precondition: [C>=0,D>=2,E>=2,F>=0,A>=D+1,B>=E] 
    - Upper bound: 27*A+3+214*A*A+135*A*A*B+189*B*A*A+ (54*B-54)*A*A 
    - Complexity: n^3 
* Chain [[43,44,45],47,49] with precondition: [C>=0,D>=3,E>=1,F>=0,A>=D,B>=E,2*B>=E+2,A+B>=D+2] 
    - Upper bound: 27*A+12+214*A*A+135*A*A*B+189*B*A*A+ (54*B-54)*A*A 
    - Complexity: n^3 
* Chain [[43,44,45],46,49] with precondition: [C>=0,D>=3,E>=1,F>=0,A>=D+1,B>=E,2*B>=E+2,A+B>=D+3] 
    - Upper bound: 69*A+12+214*A*A+135*A*A*B+189*B*A*A+ (54*B-54)*A*A 
    - Complexity: n^3 
* Chain [49] with precondition: [A=1,B=0,D=1,E=0,C>=0,F>=0] 
    - Upper bound: 3 
    - Complexity: constant 
* Chain [47,49] with precondition: [A=2,D=2,C>=0,E>=1,F>=0,B>=E] 
    - Upper bound: 12 
    - Complexity: constant 
* Chain [46,49] with precondition: [D=2,E=1,A>=3,B>=1,C>=0,F>=0] 
    - Upper bound: 42*A+12 
    - Complexity: n 

### Maximum cost of nub(A,B,C,D,E,F): max([9,27*A+max([15*A+9,135*A*A*B+214*A*A+189*B*A*A+nat(B-1)*54*A*A+ (42*A+9)])])+3 
Asymptotic class: n^3 
* Total analysis performed in 1248 ms.


Cost relation system solved by CoFloCo in 1249 ms.

Method eqD terminates?: YES

 - l1_1: size of l1 wrt. List<Rat>
 - l1_2: size of l1 wrt. Rat
 - l2_1: size of l2 wrt. List<Rat>
 - l2_2: size of l2 wrt. Rat
UB for eqD(l1_1,l1_2,l2_1,l2_2) = 27*l1_1+6

Method removeL terminates?: YES

 - x_1: size of x wrt. List<Rat>
 - x_2: size of x wrt. Rat
 - l_1: size of l wrt. List<List<Rat>>
 - l_2: size of l wrt. List<Rat>
 - l_3: size of l wrt. Rat
UB for removeL(x_1,x_2,l_1,l_2,l_3) = 162*x_1*l_1+44*l_1+nat(x_1-1)*27*l_1+42*l_1+3

Method nub terminates?: YES

 - l_1: size of l wrt. List<List<Rat>>
 - l_2: size of l wrt. List<Rat>
 - l_3: size of l wrt. Rat
UB for nub(l_1,l_2,l_3) = max([9,27*l_1+max([15*l_1+9,135*l_1*l_1*l_2+214*l_1*l_1+189*l_2*l_1*l_1+nat(l_2-1)*54*l_1*l_1+ (42*l_1+9)])])+3
