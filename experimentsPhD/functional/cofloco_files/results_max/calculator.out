
Abs program loaded in 6 ms.

Rule based representation generated in 2 ms.

Rule based representation stored in /tmp/costabs/rbr.rbr

RBR properties stored in /tmp/costabs/rbr.properties

Class invariants generated and loaded in 0 ms.

Abstract compilation performed in 9 ms.

Cost relation system stored in /tmp/costabs/crs.crs

Generated 50 equations 
entry('add'(A,B,C):[]).
entry('sub'(A,B,C):[]).
entry('mult'(A,B,C):[]).
entry('eval_simpl'(A,B,C):[]).
entry('eval'(A,B,C):[]).
entry('nat_to_int'(A,B):[]).
input_output_vars('add'(A,B,C),[A,B],[C]).
input_output_vars('and_op'(A,B,C),[A,B],[C]).
input_output_vars('case_0'(A,B,C),[A,B],[C]).
input_output_vars('case_1'(A,B,C),[A,B],[C]).
input_output_vars('case_2'(A,B,C,D),[A,B,C],[D]).
input_output_vars('case_3'(A,B,C),[A,B],[C]).
input_output_vars('case_4'(A,B,C),[A,B],[C]).
input_output_vars('case_5'(A,B,C),[A,B],[C]).
input_output_vars('case_6'(A,B,C,D,E,F,G,H),[A,B,C,D,E,F,G],[H]).
input_output_vars('case_7'(A,B,C,D,E,F,G,H),[A,B,C,D,E,F,G],[H]).
input_output_vars('case_8'(A,B,C,D,E,F,G,H,I,J),[A,B,C,D,E,F,G,H,I],[J]).
input_output_vars('case_9'(A,B),[A],[B]).
input_output_vars('eq'(A,B,C),[A,B],[C]).
input_output_vars('eval'(A,B,C),[A,B],[C]).
input_output_vars('eval_simpl'(A,B,C),[A,B],[C]).
input_output_vars('geq'(A,B,C),[A,B],[C]).
input_output_vars('gt'(A,B,C),[A,B],[C]).
input_output_vars('leq'(A,B,C),[A,B],[C]).
input_output_vars('lt'(A,B,C),[A,B],[C]).
input_output_vars('maxNorm'(A,B,C),[A,B],[C]).
input_output_vars('mult'(A,B,C),[A,B],[C]).
input_output_vars('nat_to_int'(A,B),[A],[B]).
input_output_vars('neg'(A,B),[A],[B]).
input_output_vars('neq'(A,B,C),[A,B],[C]).
input_output_vars('or'(A,B,C),[A,B],[C]).
input_output_vars('sub'(A,B,C),[A,B],[C]).
eq('eq',[A,B,C],0,[],[A=B,C=1,A>=0,B>=0,C>=0]).
eq('eq',[A,B,C],0,[],[A>=B+1,C=0,A>=0,B>=0,C>=0]).
eq('eq',[A,B,C],0,[],[B>=A+1,C=0,A>=0,B>=0,C>=0]).
eq('neq',[A,B,C],0,[],[A=B,C=0,A>=0,B>=0,C>=0]).
eq('neq',[A,B,C],0,[],[A>=B+1,C=1,A>=0,B>=0,C>=0]).
eq('neq',[A,B,C],0,[],[B>=A+1,C=1,A>=0,B>=0,C>=0]).
eq('lt',[A,B,C],0,[],[B-A>=1,C=1,A>=0,B>=0,C>=0]).
eq('lt',[A,B,C],0,[],[B=<A,C=0,A>=0,B>=0,C>=0]).
eq('leq',[A,B,C],0,[],[A=<B,C=1,A>=0,B>=0,C>=0]).
eq('leq',[A,B,C],0,[],[A-B>=1,C=0,A>=0,B>=0,C>=0]).
eq('gt',[A,B,C],0,[],[A-B>=1,C=1,A>=0,B>=0,C>=0]).
eq('gt',[A,B,C],0,[],[A=<B,C=0,A>=0,B>=0,C>=0]).
eq('geq',[A,B,C],0,[],[B=<A,C=1,A>=0,B>=0,C>=0]).
eq('geq',[A,B,C],0,[],[B-A>=1,C=0,A>=0,B>=0,C>=0]).
eq('neg',[A,B],0,[],[A=0,B=1,A>=0,B>=0]).
eq('neg',[A,B],0,[],[A=1,B=0,A>=0,B>=0]).
eq('and_op',[A,B,C],0,[],[A=0,C=0,A>=0,B>=0,C>=0]).
eq('and_op',[A,B,C],0,[],[A=1,C=B,A>=0,B>=0,C>=0]).
eq('or',[A,B,C],0,[],[A=1,C=1,A>=0,B>=0,C>=0]).
eq('or',[A,B,C],0,[],[A=0,C=B,A>=0,B>=0,C>=0]).
eq('maxNorm',[A,B,A],0,[],[A>=1+B,A>=0,B>=0,A>=0]).
eq('maxNorm',[A,B,B],0,[],[A=<B,A>=0,B>=0,B>=0]).
eq('case_0',[A,B,B],1,[],[A=1,A>=0,B>=0,B>=0]).
eq('case_0',[A,B,C],4,['add'(D,B,E)],[A=D+1,D>=1,C=E+1,E>=1,A>=0,B>=0,C>=0]).
eq('add',[A,B,C],1,['case_0'(A,B,C)],[A>=0,B>=0,C>=0]).
eq('case_1',[A,B,A],1,[],[B=1,A>=0,B>=0,A>=0]).
eq('case_2',[A,B,C,D],2,[],[A=1,D=1,A>=0,B>=0,C>=0,D>=0]).
eq('case_2',[A,B,C,D],3,['sub'(E,C,D)],[A=E+1,E>=1,A>=0,B>=0,C>=0,D>=0]).
eq('case_1',[A,B,C],3,['case_2'(A,B,D,C)],[B=D+1,D>=1,A>=0,B>=0,C>=0]).
eq('sub',[A,B,C],1,['case_1'(A,B,C)],[A>=0,B>=0,C>=0]).
eq('case_3',[A,B,C],2,[],[A=1,C=1,A>=0,B>=0,C>=0]).
eq('case_3',[A,B,C],4,['mult'(D,B,E),'add'(D,E,C)],[A=D+1,D>=1,A>=0,B>=0,C>=0]).
eq('mult',[A,B,C],1,['case_3'(A,B,C)],[A>=0,B>=0,C>=0]).
eq('case_4',[A,B,C],1,[],[B=1,A=C,C>=1,A>=0,B>=0,C>=0]).
eq('case_4',[A,B,C],5,['eval_simpl'(D,E,F),'eval_simpl'(G,H,I),'add'(F,I,C)],[A>=D,A>=G,B=H+E+1,H>=1,E>=1,A>=0,B>=0,C>=0]).
eq('case_4',[A,B,C],6,['eval_simpl'(D,E,F),'eval_simpl'(G,H,I),'sub'(F,I,C)],[A>=D,A>=G,B=H+E+1,H>=1,E>=1,A>=0,B>=0,C>=0]).
eq('eval_simpl',[A,B,C],1,['case_4'(A,B,C)],[A>=0,B>=0,C>=0]).
eq('case_5',[A,B,C],1,[],[B=1,A=C,C>=1,A>=0,B>=0,C>=0]).
eq('case_6',[A,B,C,D,E,F,G,H],2,['eval'(F,G,H)],[A=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0]).
eq('case_6',[A,B,C,D,E,F,G,H],6,['maxNorm'(I,F,J),'eval'(J,K,L)],[A=M+1,M>=1,N=1,I=M,M>=1,K=G+N+1,G>=1,N>=1,H=L+1,L>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0]).
eq('case_5',[A,B,C],6,['eval'(D,E,F),'case_6'(G,A,B,D,E,H,I,J)],[A>=D,A>=H,B=I+E+1,I>=1,E>=1,G=F,F>=1,C=J,J>=1,A>=0,B>=0,C>=0]).
eq('case_7',[A,B,C,D,E,F,G,H],2,['eval'(D,E,H)],[A=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0]).
eq('case_8',[A,B,C,D,E,F,G,H,I,J],2,[],[A=1,J=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0]).
eq('case_8',[A,B,C,D,E,F,G,H,I,J],6,['maxNorm'(K,L,M),'eval'(M,N,J)],[A=O+1,O>=1,P=1,K=O,O>=1,Q=1,L=I,I>=1,N=Q+P+1,Q>=1,P>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0]).
eq('case_7',[A,B,C,D,E,F,G,H],6,['eval'(D,E,I),'case_8'(J,A,B,C,D,E,F,G,K,L)],[A=K+1,K>=1,J=I,I>=1,H=L,L>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0]).
eq('case_5',[A,B,C],7,['eval'(D,E,F),'case_7'(G,A,B,H,I,D,E,J)],[A>=H,A>=D,B=E+I+1,E>=1,I>=1,G=F,F>=1,C=J,J>=1,A>=0,B>=0,C>=0]).
eq('eval',[A,B,C],1,['case_5'(A,B,C)],[A>=0,B>=0,C>=0]).
eq('case_9',[A,B],2,[],[A=1,B=0,A>=0,B>=0]).
eq('case_9',[A,B],5,['nat_to_int'(C,D)],[A=C+1,C>=1,E=1,B=D+E,A>=0,B>=0]).
eq('nat_to_int',[A,B],1,['case_9'(A,B)],[A>=0,B>=0]).

Preprocessing Cost Relations
=====================================

#### Computed strongly connected components 
0. recursive  : [add/3,case_0/3]
1. non_recursive  : [maxNorm/3]
2. recursive [multiple] : [case_5/3,case_6/8,case_7/8,case_8/10,eval/3]
3. recursive  : [case_1/3,case_2/4,sub/3]
4. recursive [non_tail,multiple] : [case_4/3,eval_simpl/3]
5. recursive [non_tail] : [case_3/3,mult/3]
6. recursive  : [case_9/2,nat_to_int/2]
Warning: the following predicates are never called:[and_op/3,eq/3,geq/3,gt/3,leq/3,lt/3,neg/2,neq/3,or/3]

#### Obtained direct recursion through partial evaluation 
0. SCC is partially evaluated into add/3
1. SCC is partially evaluated into maxNorm/3
2. SCC is partially evaluated into eval/3
3. SCC is partially evaluated into sub/3
4. SCC is partially evaluated into eval_simpl/3
5. SCC is partially evaluated into mult/3
6. SCC is partially evaluated into nat_to_int/2

Control-Flow Refinement of Cost Relations
=====================================

### Specialization of cost equations add/3 
* CE 2 is refined into CE [21] 
* CE 1 is refined into CE [22] 


#### Refined cost equations add/3 
* CE 21: add(A,B,B) = 2
     [B>=0,A=1] 
* CE 22: add(A,B,C) = 5+ add(D,B,E)
     [E>=1,D>=1,B>=0,E+1=C,D+1=A] 

### Cost equations --> "Loop" of add/3 
* CEs [22] --> Loop 19 
* CEs [21] --> Loop 20 

#### Loops of add/3 
* Loop 19: add(A,B,C)->  add(A',B,B')
                  [B'>=1,A'>=1,B>=0,B'+1=C,A'+1=A] 
* Loop 20: add(A,B,B) [B>=0,A=1] 

### Ranking functions of CR add(A,B,C) 
* RF of phase [19]: [A-1]

#### Partial ranking functions of CR add(A,B,C) 
* Partial RF of phase [19]:
  - RF of loop [19:1]:
    A-1

Discarded unfeasible chain [[19]]...(Non-terminating chain proved terminating)

### Resulting Chains:add(A,B,C) 
* [[19],20]
* [20]


### Merging Chains  add/3 into  External patterns of execution 
* [[20]] --> 1 
* [[20,[19]]] --> 2 


### Specialization of cost equations maxNorm/3 
* CE 20 is refined into CE [23] 
* CE 19 is refined into CE [24] 


#### Refined cost equations maxNorm/3 
* CE 23: maxNorm(A,B,B) = 0
     [B>=A,A>=1] 
* CE 24: maxNorm(A,B,A) = 0
     [A>=B+1,B>=0] 

### Cost equations --> "Loop" of maxNorm/3 
* CEs [23] --> Loop 21 
* CEs [24] --> Loop 22 

#### Loops of maxNorm/3 
* Loop 21: maxNorm(A,B,B) [B>=A,A>=1] 
* Loop 22: maxNorm(A,B,A) [A>=B+1,B>=0] 

### Ranking functions of CR maxNorm(A,B,C) 

#### Partial ranking functions of CR maxNorm(A,B,C) 


### Resulting Chains:maxNorm(A,B,C) 
* [22]
* [21]


### Merging Chains  maxNorm/3 into  External patterns of execution 
* [[22]] --> 1 
* [[21]] --> 2 


### Specialization of cost equations eval/3 
* CE 13 is refined into CE [25,26] 
* CE 12 is refined into CE [27] 
* CE 16 is refined into CE [28] 
* CE 15 is refined into CE [29] 
* CE 14 is refined into CE [30,31] 
* CE 11 is refined into CE [32] 


#### Refined cost equations eval/3 
* CE 25: eval(A,B,C) = 13+ eval(D,E,F)+ maxNorm(G,H,G):1+ eval(G,I,J)
     [B>=I,A>=D,G>=H+1,A>=H,J>=1,I>=3,D>=0,H>=0,E+I=B+1,G+1=F,J+1=C] 
* CE 26: eval(A,B,C) = 13+ eval(D,E,F)+ maxNorm(G,H,H):2+ eval(H,I,J)
     [B>=I,A>=D,A>=H,H>=G,J>=1,I>=3,D>=0,G>=1,E+I=B+1,G+1=F,J+1=C] 
* CE 27: eval(A,B,C) = 9+ eval(D,E,F)+ eval(G,H,C)
     [A>=G,B>=E+2,A>=D,G>=0,E>=1,D>=0,C>=1,E+H+1=B,F=1] 
* CE 28: eval(A,B,C) = 10+ eval(D,E,F)+ eval(G,H,C)
     [A>=G,B>=E+2,A>=D,G>=0,E>=1,D>=0,C>=1,E+H+1=B,F=1] 
* CE 29: eval(A,B,C) = 16+ eval(D,E,F)+ eval(G,H,I)
     [A>=G,B>=E+2,A>=D,G>=0,F>=2,E>=1,D>=0,E+H+1=B,I=1,C=1] 
* CE 30: eval(A,B,C) = 20+ eval(D,E,F)+ eval(G,H,I)+ maxNorm(J,K,J):1+ eval(J,L,C)
     [A>=G,B>=E+2,A>=D,J>=K+1,G>=0,E>=1,D>=0,K>=1,C>=1,E+H+1=B,J+1=I,K+1=F,L=3] 
* CE 31: eval(A,B,C) = 20+ eval(D,E,F)+ eval(G,H,I)+ maxNorm(J,K,K):2+ eval(K,L,C)
     [A>=G,B>=E+2,A>=D,K>=J,G>=0,E>=1,D>=0,J>=1,C>=1,E+H+1=B,J+1=I,K+1=F,L=3] 
* CE 32: eval(A,B,A) = 2
     [A>=1,B=1] 

### Cost equations --> "Loop" of eval/3 
* CEs [32] --> Loop 23 
* CEs [30] --> Loop 24 
* CEs [31] --> Loop 25 
* CEs [26] --> Loop 26 
* CEs [25] --> Loop 27 
* CEs [27,28] --> Loop 28 
* CEs [29] --> Loop 29 

#### Loops of eval/3 
* Loop 23: eval(A,B,A) [A>=1,B=1] 
* Loop 24: eval(A,B,C)->  eval(A',B',C')  eval(A'2,B'2,C'2)  eval(A'3,B'3,C)
                  [A>=A'2,C'2>=C'+1,B>=B'+2,A>=A',A'2>=0,C'>=2,B'>=1,A'>=0,C>=1,B=B'+B'2+1,C'2=A'3+1,B'3=3] 
* Loop 25: eval(A,B,C)->  eval(A',B',C')  eval(A'2,B'2,C'2)  eval(A'3,B'3,C)
                  [C'>=C'2,A>=A'2,B>=B'+2,A>=A',C'2>=2,A'2>=0,B'>=1,A'>=0,C>=1,B=B'+B'2+1,C'=A'3+1,B'3=3] 
* Loop 26: eval(A,B,C)->  eval(A',B',C')  eval(A'2,B'2,C'2)
                  [A>=A'2,A'2+1>=C',B>=B'+2,A>=A',C'>=2,B'>=1,A'>=0,C>=2,B'+B'2=B+1,C=C'2+1] 
* Loop 27: eval(A,B,C)->  eval(A',B',C')  eval(A'2,B'2,C'2)
                  [B>=B'+2,A>=A',C'>=2,B'>=1,A'>=0,C>=2,B'+B'2=B+1,C=C'2+1,C'=A'2+1] 
* Loop 28: eval(A,B,C)->  eval(A',B',C')  eval(A'2,B'2,C)
                  [A>=A'2,B>=B'+2,A>=A',A'2>=0,B'>=1,A'>=0,C>=1,B=B'+B'2+1,C'=1] 
* Loop 29: eval(A,B,C)->  eval(A',B',C')  eval(A'2,B'2,C'2)
                  [A>=A'2,B>=B'+2,A>=A',A'2>=0,C'>=2,B'>=1,A'>=0,B=B'+B'2+1,C'2=1,C=1] 

### Ranking functions of CR eval(A,B,C) 

#### Partial ranking functions of CR eval(A,B,C) 
* Partial RF of phase [24,25,26,27,28,29]:
  - RF of loop [24:1,24:2,25:1,25:2,26:1,27:1,28:1,28:2,29:1,29:2]:
    B/2-1


### Resulting Chains:eval(A,B,C) 
* [multiple([24,25,26,27,28,29],[[],[23]])]...
* [23]


### Merging Chains  eval/3 into  External patterns of execution 
* [[23]] --> 1 
* [[multiple([24,25,26,27,28,29],[[],[23]])]] --> 2 


### Specialization of cost equations sub/3 
* CE 5 is refined into CE [33] 
* CE 3 is refined into CE [34] 
* CE 4 is refined into CE [35] 


#### Refined cost equations sub/3 
* CE 33: sub(A,B,C) = 7+ sub(D,E,C)
     [E>=1,D>=1,C>=0,E+1=B,D+1=A] 
* CE 34: sub(A,B,A) = 2
     [A>=0,B=1] 
* CE 35: sub(A,B,C) = 6
     [B>=2,C=1,A=1] 

### Cost equations --> "Loop" of sub/3 
* CEs [34] --> Loop 30 
* CEs [35] --> Loop 31 
* CEs [33] --> Loop 32 

#### Loops of sub/3 
* Loop 30: sub(A,B,A) [A>=0,B=1] 
* Loop 31: sub(A,B,C) [B>=2,C=1,A=1] 
* Loop 32: sub(A,B,C)->  sub(A',B',C)
                  [B'>=1,A'>=1,C>=0,B'+1=B,A'+1=A] 

### Ranking functions of CR sub(A,B,C) 
* RF of phase [32]: [A-1,B-1]

#### Partial ranking functions of CR sub(A,B,C) 
* Partial RF of phase [32]:
  - RF of loop [32:1]:
    A-1
    B-1

Discarded unfeasible chain [[32]]...(Non-terminating chain proved terminating)

### Resulting Chains:sub(A,B,C) 
* [[32],31]
* [[32],30]
* [31]
* [30]


### Merging Chains  sub/3 into  External patterns of execution 
* [[31]] --> 1 
* [[30]] --> 2 
* [[31,[32]]] --> 3 
* [[30,[32]]] --> 4 


### Specialization of cost equations eval_simpl/3 
* CE 10 is refined into CE [36] 
* CE 8 is refined into CE [37,38,39,40] 
* CE 9 is refined into CE [41,42] 


#### Refined cost equations eval_simpl/3 
* CE 36: eval_simpl(A,B,A) = 2
     [A>=1,B=1] 
* CE 37: eval_simpl(A,B,C) = 7+ eval_simpl(D,E,F)+ eval_simpl(G,H,I)+ sub(J,I,K):1
     [A>=G,A>=D,H>=1,E>=1,I>=2,A>=0,E+H+1=B,F=1,K=1,J=1,C=1] 
* CE 38: eval_simpl(A,B,C) = 7+ eval_simpl(D,E,C)+ eval_simpl(F,G,H)+ sub(C,I,C):2
     [A>=F,A>=D,G>=1,E>=1,C>=0,A>=0,E+G+1=B,H=1,I=1] 
* CE 39: eval_simpl(A,B,C) = 7+ eval_simpl(D,E,F)+ eval_simpl(G,H,I)+ sub(F,I,J):3
     [A>=G,A>=D,I>=F+1,H>=1,E>=1,F>=2,A>=0,E+H+1=B,J=1,C=1] 
* CE 40: eval_simpl(A,B,C) = 7+ eval_simpl(D,E,F)+ eval_simpl(G,H,I)+ sub(J,I,C):4
     [A>=G,A>=D,H>=1,E>=1,C>=1,I>=2,A>=0,C+I=F+1,C+I=J+1,E+H+1=B] 
* CE 41: eval_simpl(A,B,C) = 6+ eval_simpl(D,E,F)+ eval_simpl(G,H,C)+ add(I,C,C):1
     [A>=G,A>=D,H>=1,E>=1,C>=0,A>=0,E+H+1=B,F=1,I=1] 
* CE 42: eval_simpl(A,B,C) = 6+ eval_simpl(D,E,F)+ eval_simpl(G,H,I)+ add(F,J,C):2
     [A>=G,A>=D,C>=F,H>=1,E>=1,F>=2,A>=0,C+1=F+I,C+1=F+J,E+H+1=B] 

### Cost equations --> "Loop" of eval_simpl/3 
* CEs [40] --> Loop 33 
* CEs [42] --> Loop 34 
* CEs [38] --> Loop 35 
* CEs [41] --> Loop 36 
* CEs [39] --> Loop 37 
* CEs [37] --> Loop 38 
* CEs [36] --> Loop 39 

#### Loops of eval_simpl/3 
* Loop 33: eval_simpl(A,B,C)->  eval_simpl(A',B',C')  eval_simpl(A'2,B'2,C'2)
                  [A>=A'2,B>=B'+2,A>=A',C'>=C+1,B'>=1,C>=1,A>=0,C+C'2=C'+1,B'+B'2+1=B] 
* Loop 34: eval_simpl(A,B,C)->  eval_simpl(A',B',C')  eval_simpl(A'2,B'2,C'2)
                  [A>=A'2,C>=C',B>=B'+2,A>=A',C'>=2,B'>=1,A>=0,C'+C'2=C+1,B'+B'2+1=B] 
* Loop 35: eval_simpl(A,B,C)->  eval_simpl(A',B',C)  eval_simpl(A'2,B'2,C'2)
                  [A>=A'2,B>=B'+2,A>=A',B'>=1,C>=0,A>=0,B'+B'2+1=B,C'2=1] 
* Loop 36: eval_simpl(A,B,C)->  eval_simpl(A',B',C')  eval_simpl(A'2,B'2,C)
                  [A>=A'2,B>=B'+2,A>=A',B'>=1,C>=0,A>=0,B'+B'2+1=B,C'=1] 
* Loop 37: eval_simpl(A,B,C)->  eval_simpl(A',B',C')  eval_simpl(A'2,B'2,C'2)
                  [A>=A'2,C'2>=C'+1,B>=B'+2,A>=A',C'>=2,B'>=1,A>=0,B'+B'2+1=B,C=1] 
* Loop 38: eval_simpl(A,B,C)->  eval_simpl(A',B',C')  eval_simpl(A'2,B'2,C'2)
                  [A>=A'2,B>=B'+2,A>=A',C'2>=2,B'>=1,A>=0,B'+B'2+1=B,C'=1,C=1] 
* Loop 39: eval_simpl(A,B,A) [A>=1,B=1] 

### Ranking functions of CR eval_simpl(A,B,C) 
* RF of phase [33,34,35,36,37,38]: [B/2-1]

#### Partial ranking functions of CR eval_simpl(A,B,C) 
* Partial RF of phase [33,34,35,36,37,38]:
  - RF of loop [33:1,33:2,34:1,34:2,35:1,35:2,36:1,36:2,37:1,37:2,38:1,38:2]:
    B/2-1

Discarded unfeasible chain [multiple([33,34,35,36,37,38],[[],[39]])]...(Non-terminating chain proved terminating)
Remaining chain: [multiple([33,34,35,36,37,38],[[39]])]

### Resulting Chains:eval_simpl(A,B,C) 
* [39]
* [multiple([33,34,35,36,37,38],[[39]])]


### Merging Chains  eval_simpl/3 into  External patterns of execution 
* [[39]] --> 1 
* [[multiple([33,34,35,36,37,38],[[39]])]] --> 2 


### Specialization of cost equations mult/3 
* CE 7 is refined into CE [43] 
* CE 6 is refined into CE [44,45] 


#### Refined cost equations mult/3 
* CE 43: mult(A,B,C) = 3
     [B>=0,C=1,A=1] 
* CE 44: mult(A,B,C) = 5+ mult(D,B,C)+ add(E,C,C):1
     [C>=0,B>=0,D=1,E=1,A=2] 
* CE 45: mult(A,B,C) = 5+ mult(D,B,E)+ add(D,F,C):2
     [C>=D,D>=2,B>=0,C+1=D+E,C+1=D+F,D+1=A] 

### Cost equations --> "Loop" of mult/3 
* CEs [45] --> Loop 40 
* CEs [44] --> Loop 41 
* CEs [43] --> Loop 42 

#### Loops of mult/3 
* Loop 40: mult(A,B,C)->  mult(A',B,B')
                  [C+1>=A,B>=0,A>=3,A+B'=C+2,A=A'+1] 
* Loop 41: mult(A,B,C)->  mult(A',B,C)
                  [C>=0,B>=0,A'=1,A=2] 
* Loop 42: mult(A,B,C) [B>=0,C=1,A=1] 

### Ranking functions of CR mult(A,B,C) 
* RF of phase [40]: [A-2]

#### Partial ranking functions of CR mult(A,B,C) 
* Partial RF of phase [40]:
  - RF of loop [40:1]:
    A-2

Discarded unfeasible chain [[40]]...(Non-terminating chain proved terminating)

### Resulting Chains:mult(A,B,C) 
* [[40],41,42]
* [42]
* [41,42]


### Merging Chains  mult/3 into  External patterns of execution 
* [[42]] --> 1 
* [[42,41]] --> 2 
* [[42,41,[40]]] --> 3 


### Specialization of cost equations nat_to_int/2 
* CE 18 is refined into CE [46] 
* CE 17 is refined into CE [47] 


#### Refined cost equations nat_to_int/2 
* CE 46: nat_to_int(A,B) = 3
     [B=0,A=1] 
* CE 47: nat_to_int(A,B) = 6+ nat_to_int(C,D)
     [D+1>=0,C>=1,D+1=B,C+1=A] 

### Cost equations --> "Loop" of nat_to_int/2 
* CEs [47] --> Loop 43 
* CEs [46] --> Loop 44 

#### Loops of nat_to_int/2 
* Loop 43: nat_to_int(A,B)->  nat_to_int(A',B')
                  [B'+1>=0,A'>=1,B'+1=B,A'+1=A] 
* Loop 44: nat_to_int(A,B) [B=0,A=1] 

### Ranking functions of CR nat_to_int(A,B) 
* RF of phase [43]: [A-1]

#### Partial ranking functions of CR nat_to_int(A,B) 
* Partial RF of phase [43]:
  - RF of loop [43:1]:
    A-1

Discarded unfeasible chain [[43]]...(Non-terminating chain proved terminating)

### Resulting Chains:nat_to_int(A,B) 
* [[43],44]
* [44]


### Merging Chains  nat_to_int/2 into  External patterns of execution 
* [[44]] --> 1 
* [[44,[43]]] --> 2 


Computing Bounds
=====================================

#### Simplifying cost structure of CE 21 

#### Computing cost of phase [19] 

#### Simplifying cost structure of CE 22 

#### Cost of loops [19] 

 * loop 19:add(A,B,C) -> [add(A',B',C')] 
5
##### Pending set add(A,B,C)
* Psum in Loop 19: [it(19)=<1]

###### Computing sum for it(19)=<1  in Loop 19 
   - Applying inductive sum strategy 
     - head Candidate: A-1 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(19)=<A-1,it(19)=<A-1,it(19)=<A-A',it(19)=<A-A'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [19] 

#### Simplifying cost structure of phase [19] 

#### Cost of phase [19]:add(A,B,C) -> [add(A',B',C')] 
5*it(19)+0
  Such that:it(19) =< A
it(19) =< A-A'

#### Simplifying cost structure of chain [[19],20] 

#### Cost of chains of add(A,B,C):
* Chain [[19],20]: 5*it(19)+2
  Such that:it(19) =< -B+C

  with precondition: [A+B=C+1,A>=2,B>=1] 

* Chain [20]: 2
  with precondition: [A=1,B=C,B>=0] 


#### Simplifying cost structure of CE 24 

#### Simplifying cost structure of CE 23 

#### Cost of chains of maxNorm(A,B,C):
* Chain [22]: 0
  with precondition: [A=C,B>=0,A>=B+1] 

* Chain [21]: 0
  with precondition: [B=C,A>=1,B>=A] 


#### Simplifying cost structure of CE 32 

#### Computing cost of chain [multiple([24,25,26,27,28,29],[[],[23]])] with multiple recursion

#### Simplifying cost structure of CE 30 

#### Simplifying cost structure of CE 31 

#### Simplifying cost structure of CE 26 

#### Simplifying cost structure of CE 25 

#### Simplifying cost structure of CE 27 

#### Simplifying cost structure of CE 28 

#### Simplifying cost structure of CE 29 

#### Cost of loops [24,25,26,27,28,29] 

 * loop 24:eval(A,B,C) -> [eval(A',B',C'),eval(A'2,B'2,C'2),eval(A'3,B'3,C'3)] 
20
 * loop 25:eval(A,B,C) -> [eval(A',B',C'),eval(A'2,B'2,C'2),eval(A'3,B'3,C'3)] 
20
 * loop 26:eval(A,B,C) -> [eval(A',B',C'),eval(A'2,B'2,C'2)] 
13
 * loop 27:eval(A,B,C) -> [eval(A',B',C'),eval(A'2,B'2,C'2)] 
13
 * loop 28:eval(A,B,C) -> [eval(A',B',C'),eval(A'2,B'2,C'2)] 
10
 * loop 29:eval(A,B,C) -> [eval(A',B',C'),eval(A'2,B'2,C'2)] 
16
##### Pending set eval(A,B,C)
* Psum in Loop 24: [it(24)=<1]
* Psum in Loop 25: [it(25)=<1]
* Psum in Loop 26: [it(26)=<1]
* Psum in Loop 27: [it(27)=<1]
* Psum in Loop 28: [it(28)=<1]
* Psum in Loop 29: [it(29)=<1]
* Psum in Chain-Tail [23]: [it([23])=<1]

###### Computing sum for it(24)=<1  in Loop 24 
   - Applying inductive sum strategy 
     - head Candidate: 3/4*B-5/4 
       - Loop 25 is collaborative and bounds [it(25)] 
       - Loop 26 is collaborative
       - Loop 27 is collaborative
       - Loop 28 is collaborative and bounds [it(28)] 
       - Loop 29 is collaborative and bounds [it(29)] 
       - Chain [23] is ignored
 * Adding constraints: [it(24)+it(25)+it(28)+it(29)=<3/4*B-5/4] 

##### Pending set A
* Psum in Loop 26: [it(26)=<1]
* Psum in Loop 27: [it(27)=<1]
* Psum in Chain-Tail [23]: [it([23])=<1]

###### Computing sum for it(26)=<1  in Loop 26 
   - Applying inductive sum strategy 
     - head Candidate: B-2 
       - Loop 24 is collaborative
       - Loop 25 is collaborative
       - Loop 27 is collaborative and bounds [it(27)] 
       - Loop 28 is collaborative
       - Loop 29 is collaborative
       - Chain [23] is ignored
 * Adding constraints: [it(26)+it(27)=<B-2] 

##### Pending set A
* Psum in Chain-Tail [23]: [it([23])=<1]

###### Computing sum for it([23])=<1  in Chain-Tail [23] 
   - Applying inductive sum strategy 
     - head Candidate: 1 
       - Loop 24 adds a constant 2/1 
       - Loop 25 adds a constant 2/1 
       - Loop 26 adds a constant 1/1 
       - Loop 27 adds a constant 1/1 
       - Loop 28 adds a constant 1/1 
       - Loop 29 adds a constant 1/1 
 * Adding constraints: [it([23])=<it(29)+it(28)+it(27)+it(26)+it(25)*2+it(24)*2+aux(1),aux(1)=<1] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [24,25,26,27,28,29,[23]] 

#### Simplifying cost structure of phase [24,25,26,27,28,29,[23]] 
 * Joined equivalent variables [it(26),it(27)] into it(26)
 * Joined equivalent variables [it(24),it(25),it(28),it(29)] into it(24)

#### Cost of phase [24,25,26,27,28,29]:eval(A,B,C) -> [] 
66*it(24)+26*it(26)+2*it([23])+0
  Such that:aux(1) =< 1
aux(2) =< B
aux(3) =< 3/4*B
it(26) =< aux(2)
it(24) =< aux(3)
it([23]) =< it(24)+it(24)+it(26)+it(26)+it(24)*2+it(24)*2+aux(1)

#### Cost of chains of eval(A,B,C):
* Chain [multiple([24,25,26,27,28,29],[[],[23]])]...: 66*it(24)+26*it(26)+2*it([23])+0
  Such that:aux(1) =< 1
aux(2) =< B
aux(3) =< 3/4*B
it(26) =< aux(2)
it(24) =< aux(3)
it([23]) =< it(24)+it(24)+it(26)+it(26)+it(24)*2+it(24)*2+aux(1)

  with precondition: [A>=0,B>=3,C>=1] 

* Chain [23]: 2
  with precondition: [B=1,A=C,A>=1] 


#### Simplifying cost structure of CE 35 

#### Computing cost of phase [32] 

#### Simplifying cost structure of CE 33 

#### Cost of loops [32] 

 * loop 32:sub(A,B,C) -> [sub(A',B',C')] 
7
##### Pending set sub(A,B,C)
* Psum in Loop 32: [it(32)=<1]

###### Computing sum for it(32)=<1  in Loop 32 
   - Applying inductive sum strategy 
     - head Candidate: B-1 
     - head Candidate: A-1 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B-1 
     - tail Candidate: A-1 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(32)=<B-1,it(32)=<A-1,it(32)=<A-1,it(32)=<B-1,it(32)=<B-B',it(32)=<A-A',it(32)=<A-A',it(32)=<B-B'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [32] 

#### Simplifying cost structure of phase [32] 

#### Cost of phase [32]:sub(A,B,C) -> [sub(A',B',C')] 
7*it(32)+0
  Such that:it(32) =< A
it(32) =< A-A'
it(32) =< B
it(32) =< B-B'

#### Simplifying cost structure of chain [[32],31] 

#### Simplifying cost structure of CE 34 

#### Found solution for phase  [32] in the cache 

#### Cost of phase [32]:sub(A,B,C) -> [sub(A',B',C')] 
7*it(32)+0
  Such that:it(32) =< A
it(32) =< A-A'
it(32) =< B
it(32) =< B-B'

#### Simplifying cost structure of chain [[32],30] 

#### Cost of chains of sub(A,B,C):
* Chain [[32],31]: 7*it(32)+6
  Such that:it(32) =< A

  with precondition: [C=1,A>=2,B>=A+1] 

* Chain [[32],30]: 7*it(32)+2
  Such that:it(32) =< B

  with precondition: [A+1=B+C,B>=2,A>=B] 

* Chain [31]: 6
  with precondition: [A=1,C=1,B>=2] 

* Chain [30]: 2
  with precondition: [B=1,A=C,A>=0] 


#### Simplifying cost structure of CE 36 

#### Computing cost of chain [multiple([33,34,35,36,37,38],[[39]])] with multiple recursion
 * Renamed intermediate variables: 
[ (eq(40,1),it(32))>>s(1)]

#### Simplifying cost structure of CE 40 
 * Renamed intermediate variables: 
[ (it(33),s(1))>>s(2)]
 * Renamed intermediate variables: 
[ (eq(42,1),it(19))>>s(3)]

#### Simplifying cost structure of CE 42 
 * Renamed intermediate variables: 
[ (it(34),s(3))>>s(4)]

#### Simplifying cost structure of CE 38 

#### Simplifying cost structure of CE 41 
 * Renamed intermediate variables: 
[ (eq(39,1),it(32))>>s(5)]

#### Simplifying cost structure of CE 39 
 * Renamed intermediate variables: 
[ (it(37),s(5))>>s(6)]

#### Simplifying cost structure of CE 37 

#### Cost of loops [33,34,35,36,37,38] 

 * loop 33:eval_simpl(A,B,C) -> [eval_simpl(A',B',C'),eval_simpl(A'2,B'2,C'2)] 
7*s(2)+9
Unbounded itvars
s(2) :  it(33),s(1)

 * loop 34:eval_simpl(A,B,C) -> [eval_simpl(A',B',C'),eval_simpl(A'2,B'2,C'2)] 
5*s(4)+8
Unbounded itvars
s(4) :  it(34),s(3)

 * loop 35:eval_simpl(A,B,C) -> [eval_simpl(A',B',C'),eval_simpl(A'2,B'2,C'2)] 
9
 * loop 36:eval_simpl(A,B,C) -> [eval_simpl(A',B',C'),eval_simpl(A'2,B'2,C'2)] 
8
 * loop 37:eval_simpl(A,B,C) -> [eval_simpl(A',B',C'),eval_simpl(A'2,B'2,C'2)] 
7*s(6)+13
Unbounded itvars
s(6) :  it(37),s(5)

 * loop 38:eval_simpl(A,B,C) -> [eval_simpl(A',B',C'),eval_simpl(A'2,B'2,C'2)] 
13
##### Pending set eval_simpl(A,B,C)
* Psum in Loop 33: [it(33)=<1]
* Psum in Loop 34: [it(34)=<1]
* Psum in Loop 35: [it(35)=<1]
* Psum in Loop 36: [it(36)=<1]
* Psum in Loop 37: [it(37)=<1]
* Psum in Loop 38: [it(38)=<1]
* Psum in Chain-Tail [39]: [it([39])=<1]

###### Computing sum for it(33)=<1  in Loop 33 
   - Applying inductive sum strategy 
     - head Candidate: B/2-1/2 
       - Loop 34 is collaborative and bounds [it(34)] 
       - Loop 35 is collaborative and bounds [it(35)] 
       - Loop 36 is collaborative and bounds [it(36)] 
       - Loop 37 is collaborative and bounds [it(37)] 
       - Loop 38 is collaborative and bounds [it(38)] 
       - Chain-Tail [39] is collaborative
     - tail Candidate: B/2-1/2 
       - Loop 34 is collaborative and bounds [it(34)] 
       - Loop 35 is collaborative and bounds [it(35)] 
       - Loop 36 is collaborative and bounds [it(36)] 
       - Loop 37 is collaborative and bounds [it(37)] 
       - Loop 38 is collaborative and bounds [it(38)] 
       - Chain-Tail [39] is collaborative
 * Adding constraints: [it(33)+it(34)+it(35)+it(36)+it(37)+it(38)=<B/2-1/2,it(33)+it(34)+it(35)+it(36)+it(37)+it(38)=<B/2-1/2] 

##### Pending set A
* Psum in Loop 34: [it(34)=<1]
* Psum in Loop 35: [it(35)=<1]
* Psum in Loop 36: [it(36)=<1]
* Psum in Loop 37: [it(37)=<1]
* Psum in Loop 38: [it(38)=<1]
* Psum in Chain-Tail [39]: [it([39])=<1]

###### Computing sum for it(34)=<1  in Loop 34 
   - Applying inductive sum strategy 
     - head Candidate: B/2-1/2 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B/2-1/2 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(33)+it(34)+it(35)+it(36)+it(37)+it(38)=<B/2-1/2,it(33)+it(34)+it(35)+it(36)+it(37)+it(38)=<B/2-1/2] 

##### Pending set A
* Psum in Loop 35: [it(35)=<1]
* Psum in Loop 36: [it(36)=<1]
* Psum in Loop 37: [it(37)=<1]
* Psum in Loop 38: [it(38)=<1]
* Psum in Chain-Tail [39]: [it([39])=<1]

###### Computing sum for it(35)=<1  in Loop 35 
   - Applying inductive sum strategy 
     - head Candidate: B/2-1/2 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B/2-1/2 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(33)+it(34)+it(35)+it(36)+it(37)+it(38)=<B/2-1/2,it(33)+it(34)+it(35)+it(36)+it(37)+it(38)=<B/2-1/2] 

##### Pending set A
* Psum in Loop 36: [it(36)=<1]
* Psum in Loop 37: [it(37)=<1]
* Psum in Loop 38: [it(38)=<1]
* Psum in Chain-Tail [39]: [it([39])=<1]

###### Computing sum for it(36)=<1  in Loop 36 
   - Applying inductive sum strategy 
     - head Candidate: B/2-1/2 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B/2-1/2 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(33)+it(34)+it(35)+it(36)+it(37)+it(38)=<B/2-1/2,it(33)+it(34)+it(35)+it(36)+it(37)+it(38)=<B/2-1/2] 

##### Pending set A
* Psum in Loop 37: [it(37)=<1]
* Psum in Loop 38: [it(38)=<1]
* Psum in Chain-Tail [39]: [it([39])=<1]

###### Computing sum for it(37)=<1  in Loop 37 
   - Applying inductive sum strategy 
     - head Candidate: B/2-1/2 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B/2-1/2 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(33)+it(34)+it(35)+it(36)+it(37)+it(38)=<B/2-1/2,it(33)+it(34)+it(35)+it(36)+it(37)+it(38)=<B/2-1/2] 

##### Pending set A
* Psum in Loop 38: [it(38)=<1]
* Psum in Chain-Tail [39]: [it([39])=<1]

###### Computing sum for it(38)=<1  in Loop 38 
   - Applying inductive sum strategy 
     - head Candidate: B/2-1/2 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B/2-1/2 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(33)+it(34)+it(35)+it(36)+it(37)+it(38)=<B/2-1/2,it(33)+it(34)+it(35)+it(36)+it(37)+it(38)=<B/2-1/2] 

##### Pending set A
* Psum in Chain-Tail [39]: [it([39])=<1]

###### Computing sum for it([39])=<1  in Chain-Tail [39] 
   - Applying inductive sum strategy 
     - head Candidate: B/2+1/2 
       - Loop 33 is collaborative
       - Loop 34 is collaborative
       - Loop 35 is collaborative
       - Loop 36 is collaborative
       - Loop 37 is collaborative
       - Loop 38 is collaborative
     - tail Candidate: B/2+1/2 
       - Loop 33 is collaborative
       - Loop 34 is collaborative
       - Loop 35 is collaborative
       - Loop 36 is collaborative
       - Loop 37 is collaborative
       - Loop 38 is collaborative
 * Adding constraints: [it([39])=<B/2+1/2,it([39])=<B/2+1/2] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [33,34,35,36,37,38,[39]] 

#### Simplifying cost structure of phase [33,34,35,36,37,38,[39]] 
 * Joined equivalent variables [s(7),s(8),s(9)] into s(7)
 * Joined equivalent variables [it(33),it(34),it(35),it(36),it(37),it(38)] into it(33)

#### Cost of phase [33,34,35,36,37,38]:eval_simpl(A,B,C) -> [] 
60*it(33)+2*it([39])+19*s(7)+0
  Such that:it([39]) =< B/2+1/2
aux(4) =< B/2
it(33) =< aux(4)

Unbounded itvars
s(7) :  sum(33),s(2)

#### Cost of chains of eval_simpl(A,B,C):
* Chain [39]: 2
  with precondition: [B=1,A=C,A>=1] 

* Chain [multiple([33,34,35,36,37,38],[[39]])]: 60*it(33)+2*it([39])+19*s(7)+0
  Such that:it([39]) =< B/2+1/2
aux(4) =< B/2
it(33) =< aux(4)

Unbounded itvars
s(7) :  sum(33),s(2)

  with precondition: [A>=0,B>=3,C>=1] 


#### Simplifying cost structure of CE 43 

#### Simplifying cost structure of CE 44 

#### Simplifying cost structure of chain [41,42] 

#### Computing cost of phase [40] 
 * Renamed intermediate variables: 
[ (eq(45,1),it(19))>>s(10)]

#### Simplifying cost structure of CE 45 
 * Renamed intermediate variables: 
[ (it(40),s(10))>>s(11)]

#### Cost of loops [40] 

 * loop 40:mult(A,B,C) -> [mult(A',B',C')] 
5*s(11)+7
  Such that:s(11) =< A'

##### Pending set mult(A,B,C)
* Psum in Loop 40: [it(40)=<1,s(12)=<A']

###### Computing sum for it(40)=<1  in Loop 40 
   - Applying inductive sum strategy 
     - head Candidate: A-2 
     - head Candidate: A-2 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-2 
     - tail Candidate: A-2 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(40)=<A-2,it(40)=<A-2,it(40)=<A-A',it(40)=<A-A'] 

##### Pending set A
* Psum in Loop 40: [s(12)=<A']

###### Computing sum for s(12)=<A'  in Loop 40 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(5)=<A-1] 
 * Adding constraints: [s(12)=<it(40)*aux(5)] 

##### Pending set mult(A,B,C)
* Pmax/min: [aux(5)=<A-1]

###### Computing max_min for aux(5)=<A-1  
   - Found a solution using transitive invariants 
 * Adding constraints:[aux(5)=<A-1] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [40] 

#### Simplifying cost structure of phase [40] 
 * Joined equivalent variables [aux(6),aux(5)] into aux(6)

#### Cost of phase [40]:mult(A,B,C) -> [mult(A',B',C')] 
7*it(40)+5*s(12)+0
  Such that:it(40) =< A-A'
aux(6) =< A
it(40) =< aux(6)
s(12) =< it(40)*aux(6)

#### Simplifying cost structure of chain [[40],41,42] 
 * Joined equivalent variables [aux(7),aux(6)] into aux(7)

#### Cost of chains of mult(A,B,C):
* Chain [[40],41,42]: 7*it(40)+5*s(12)+10
  Such that:aux(7) =< A
it(40) =< aux(7)
s(12) =< it(40)*aux(7)

  with precondition: [A>=3,B>=0,C+1>=A] 

* Chain [42]: 3
  with precondition: [A=1,C=1,B>=0] 

* Chain [41,42]: 10
  with precondition: [A=2,C=1,B>=0] 


#### Simplifying cost structure of CE 46 

#### Computing cost of phase [43] 

#### Simplifying cost structure of CE 47 

#### Cost of loops [43] 

 * loop 43:nat_to_int(A,B) -> [nat_to_int(A',B')] 
6
##### Pending set nat_to_int(A,B)
* Psum in Loop 43: [it(43)=<1]

###### Computing sum for it(43)=<1  in Loop 43 
   - Applying inductive sum strategy 
     - head Candidate: A-1 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(43)=<A-1,it(43)=<A-1,it(43)=<A-A',it(43)=<A-A'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [43] 

#### Simplifying cost structure of phase [43] 

#### Cost of phase [43]:nat_to_int(A,B) -> [nat_to_int(A',B')] 
6*it(43)+0
  Such that:it(43) =< A
it(43) =< A-A'

#### Simplifying cost structure of chain [[43],44] 

#### Cost of chains of nat_to_int(A,B):
* Chain [[43],44]: 6*it(43)+3
  Such that:it(43) =< B

  with precondition: [A=B+1,A>=2] 

* Chain [44]: 3
  with precondition: [A=1,B=0] 


Closed-form bounds of add(A,B,C): 
-------------------------------------
* Chain [[19],20] with precondition: [A+B=C+1,A>=2,B>=1] 
    - Upper bound: 5*A+2 
    - Complexity: n 
* Chain [20] with precondition: [A=1,B=C,B>=0] 
    - Upper bound: 2 
    - Complexity: constant 

### Maximum cost of add(A,B,C): 5*A+2 
Asymptotic class: n 

Closed-form bounds of sub(A,B,C): 
-------------------------------------
* Chain [[32],31] with precondition: [C=1,A>=2,B>=A+1] 
    - Upper bound: 7*A+6 
    - Complexity: n 
* Chain [[32],30] with precondition: [A+1=B+C,B>=2,A>=B] 
    - Upper bound: 7*B+2 
    - Complexity: n 
* Chain [31] with precondition: [A=1,C=1,B>=2] 
    - Upper bound: 6 
    - Complexity: constant 
* Chain [30] with precondition: [B=1,A=C,A>=0] 
    - Upper bound: 2 
    - Complexity: constant 

### Maximum cost of sub(A,B,C): max([7*A+4,7*B])+2 
Asymptotic class: n 

Closed-form bounds of mult(A,B,C): 
-------------------------------------
* Chain [[40],41,42] with precondition: [A>=3,B>=0,C+1>=A] 
    - Upper bound: 7*A+10+5*A*A 
    - Complexity: n^2 
* Chain [42] with precondition: [A=1,C=1,B>=0] 
    - Upper bound: 3 
    - Complexity: constant 
* Chain [41,42] with precondition: [A=2,C=1,B>=0] 
    - Upper bound: 10 
    - Complexity: constant 

### Maximum cost of mult(A,B,C): max([7,7*A+7+5*A*A])+3 
Asymptotic class: n^2 

Closed-form bounds of eval_simpl(A,B,C): 
-------------------------------------
* Chain [39] with precondition: [B=1,A=C,A>=1] 
    - Upper bound: 2 
    - Complexity: constant 
* Chain [multiple([33,34,35,36,37,38],[[39]])] with precondition: [A>=0,B>=3,C>=1] 
    - Upper bound: inf 
    - Complexity: infinity 

### Maximum cost of eval_simpl(A,B,C): inf 
Asymptotic class: infinity 

Closed-form bounds of eval(A,B,C): 
-------------------------------------
* Chain [multiple([24,25,26,27,28,29],[[],[23]])]... with precondition: [A>=0,B>=3,C>=1] 
    - Upper bound: 177/2*B+2 
    - Complexity: n 
* Chain [23] with precondition: [B=1,A=C,A>=1] 
    - Upper bound: 2 
    - Complexity: constant 

### Maximum cost of eval(A,B,C): 177/2*B+2 
Asymptotic class: n 

Closed-form bounds of nat_to_int(A,B): 
-------------------------------------
* Chain [[43],44] with precondition: [A=B+1,A>=2] 
    - Upper bound: 6*A+3 
    - Complexity: n 
* Chain [44] with precondition: [A=1,B=0] 
    - Upper bound: 3 
    - Complexity: constant 

### Maximum cost of nat_to_int(A,B): 6*A+3 
Asymptotic class: n 
* Total analysis performed in 608 ms.


Cost relation system solved by CoFloCo in 611 ms.

Method add terminates?: YES

 - n1_1: size of n1 wrt. Nat
 - n2_1: size of n2 wrt. Nat
UB for add(n1_1,n2_1) = 5*n1_1+2

Method sub terminates?: YES

 - n1_1: size of n1 wrt. Nat
 - n2_1: size of n2 wrt. Nat
UB for sub(n1_1,n2_1) = max([7*n1_1+4,7*n2_1])+2

Method mult terminates?: YES

 - n1_1: size of n1 wrt. Nat
 - n2_1: size of n2 wrt. Nat
UB for mult(n1_1,n2_1) = max([7,7*n1_1+7+5*n1_1*n1_1])+3

Method eval_simpl terminates?: YES

 - expr_1: size of expr wrt. Nat
 - expr_2: size of expr wrt. Expr
UB for eval_simpl(expr_1,expr_2) = inf

Method eval terminates?: YES

 - expr_1: size of expr wrt. Nat
 - expr_2: size of expr wrt. Expr
UB for eval(expr_1,expr_2) = 177/2*expr_2+2

Method nat_to_int terminates?: YES

 - n_1: size of n wrt. Nat
UB for nat_to_int(n_1) = 6*n_1+3
