
Abs program loaded in 15 ms.

Rule based representation generated in 1 ms.

Rule based representation stored in /tmp/costabs/rbr.rbr

RBR properties stored in /tmp/costabs/rbr.properties

Class invariants generated and loaded in 0 ms.

Abstract compilation performed in 3 ms.

Cost relation system stored in /tmp/costabs/crs.crs

Generated 28 equations 
entry('mult'(A,B,C,D,E):[]).
entry('dyade'(A,B,C,D,E,F,G):[]).
input_output_vars('and_op'(A,B,C),[A,B],[C]).
input_output_vars('case_0'(A,B,C,D,E),[A,B,C],[D,E]).
input_output_vars('case_1'(A,B,C,D,E,F,G),[A,B,C,D],[E,F,G]).
input_output_vars('dyade'(A,B,C,D,E,F,G),[A,B,C,D],[E,F,G]).
input_output_vars('eq'(A,B,C),[A,B],[C]).
input_output_vars('geq'(A,B,C),[A,B],[C]).
input_output_vars('gt'(A,B,C),[A,B],[C]).
input_output_vars('leq'(A,B,C),[A,B],[C]).
input_output_vars('lt'(A,B,C),[A,B],[C]).
input_output_vars('maxNorm'(A,B,C),[A,B],[C]).
input_output_vars('mult'(A,B,C,D,E),[A,B,C],[D,E]).
input_output_vars('neg'(A,B),[A],[B]).
input_output_vars('neq'(A,B,C),[A,B],[C]).
input_output_vars('or'(A,B,C),[A,B],[C]).
eq('eq',[A,B,C],0,[],[A=B,C=1,A>=0,B>=0,C>=0]).
eq('eq',[A,B,C],0,[],[A>=B+1,C=0,A>=0,B>=0,C>=0]).
eq('eq',[A,B,C],0,[],[B>=A+1,C=0,A>=0,B>=0,C>=0]).
eq('neq',[A,B,C],0,[],[A=B,C=0,A>=0,B>=0,C>=0]).
eq('neq',[A,B,C],0,[],[A>=B+1,C=1,A>=0,B>=0,C>=0]).
eq('neq',[A,B,C],0,[],[B>=A+1,C=1,A>=0,B>=0,C>=0]).
eq('lt',[A,B,C],0,[],[B-A>=1,C=1,A>=0,B>=0,C>=0]).
eq('lt',[A,B,C],0,[],[B=<A,C=0,A>=0,B>=0,C>=0]).
eq('leq',[A,B,C],0,[],[A=<B,C=1,A>=0,B>=0,C>=0]).
eq('leq',[A,B,C],0,[],[A-B>=1,C=0,A>=0,B>=0,C>=0]).
eq('gt',[A,B,C],0,[],[A-B>=1,C=1,A>=0,B>=0,C>=0]).
eq('gt',[A,B,C],0,[],[A=<B,C=0,A>=0,B>=0,C>=0]).
eq('geq',[A,B,C],0,[],[B=<A,C=1,A>=0,B>=0,C>=0]).
eq('geq',[A,B,C],0,[],[B-A>=1,C=0,A>=0,B>=0,C>=0]).
eq('neg',[A,B],0,[],[A=0,B=1,A>=0,B>=0]).
eq('neg',[A,B],0,[],[A=1,B=0,A>=0,B>=0]).
eq('and_op',[A,B,C],0,[],[A=0,C=0,A>=0,B>=0,C>=0]).
eq('and_op',[A,B,C],0,[],[A=1,C=B,A>=0,B>=0,C>=0]).
eq('or',[A,B,C],0,[],[A=1,C=1,A>=0,B>=0,C>=0]).
eq('or',[A,B,C],0,[],[A=0,C=B,A>=0,B>=0,C>=0]).
eq('maxNorm',[A,B,A],0,[],[A>=1+B,A>=0,B>=0,A>=0]).
eq('maxNorm',[A,B,B],0,[],[A=<B,A>=0,B>=0,B>=0]).
eq('case_0',[A,B,C,D,E],2,[],[B=1,D=1,A>=0,B>=0,C>=0,D>=0,E>=0]).
eq('case_0',[A,B,C,D,E],5,['mult'(A,F,G,H,I)],[C>=J,C>=G,B=F+1,F>=1,K=L,E>=K,E>=I,D=H+1,H>=1,A>=0,B>=0,C>=0,D>=0,E>=0]).
eq('mult',[A,B,C,D,E],1,['case_0'(A,B,C,D,E)],[A>=0,B>=0,C>=0,D>=0,E>=0]).
eq('case_1',[A,B,C,D,E,F,G],2,[],[A=1,F=0,E=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0]).
eq('case_1',[A,B,C,D,E,F,G],5,['mult'(H,C,D,I,J),'dyade'(K,L,C,D,M,N,O),'maxNorm'(I,N,F)],[B>=H,B>=L,A=K+1,K>=1,G>=J,G>=O,E=M+1,M>=1,I>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0]).
eq('dyade',[A,B,C,D,E,F,G],1,['case_1'(A,B,C,D,E,F,G)],[A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0]).

Preprocessing Cost Relations
=====================================

#### Computed strongly connected components 
0. non_recursive  : [maxNorm/3]
1. recursive  : [case_0/5,mult/5]
2. recursive [non_tail] : [case_1/7,dyade/7]
Warning: the following predicates are never called:[and_op/3,eq/3,geq/3,gt/3,leq/3,lt/3,neg/2,neq/3,or/3]

#### Obtained direct recursion through partial evaluation 
0. SCC is partially evaluated into maxNorm/3
1. SCC is partially evaluated into mult/5
2. SCC is partially evaluated into dyade/7

Control-Flow Refinement of Cost Relations
=====================================

### Specialization of cost equations maxNorm/3 
* CE 6 is refined into CE [7] 
* CE 5 is refined into CE [8] 


#### Refined cost equations maxNorm/3 
* CE 7: maxNorm(A,B,B) = 0
     [B>=A,A>=1] 
* CE 8: maxNorm(A,B,A) = 0
     [A>=B+1,B>=0] 

### Cost equations --> "Loop" of maxNorm/3 
* CEs [7] --> Loop 7 
* CEs [8] --> Loop 8 

#### Loops of maxNorm/3 
* Loop 7: maxNorm(A,B,B) [B>=A,A>=1] 
* Loop 8: maxNorm(A,B,A) [A>=B+1,B>=0] 

### Ranking functions of CR maxNorm(A,B,C) 

#### Partial ranking functions of CR maxNorm(A,B,C) 


### Resulting Chains:maxNorm(A,B,C) 
* [8]
* [7]


### Merging Chains  maxNorm/3 into  External patterns of execution 
* [[7]] --> 1 
* [[8]] --> 2 


### Specialization of cost equations mult/5 
* CE 2 is refined into CE [9] 
* CE 1 is refined into CE [10] 


#### Refined cost equations mult/5 
* CE 9: mult(A,B,C,D,E) = 3
     [E>=0,C>=0,A>=0,D=1,B=1] 
* CE 10: mult(A,B,C,D,E) = 6+ mult(A,F,G,H,I)
     [E>=I,C>=G,H>=1,F>=1,E>=0,C>=0,A>=0,H+1=D,F+1=B] 

### Cost equations --> "Loop" of mult/5 
* CEs [10] --> Loop 9 
* CEs [9] --> Loop 10 

#### Loops of mult/5 
* Loop 9: mult(A,B,C,D,E)->  mult(A,A',B',C',D')
                  [E>=D',C>=B',C'>=1,A'>=1,E>=0,C>=0,A>=0,C'+1=D,A'+1=B] 
* Loop 10: mult(A,B,C,D,E) [E>=0,C>=0,A>=0,D=1,B=1] 

### Ranking functions of CR mult(A,B,C,D,E) 
* RF of phase [9]: [B-1]

#### Partial ranking functions of CR mult(A,B,C,D,E) 
* Partial RF of phase [9]:
  - RF of loop [9:1]:
    B-1

Discarded unfeasible chain [[9]]...(Non-terminating chain proved terminating)

### Resulting Chains:mult(A,B,C,D,E) 
* [[9],10]
* [10]


### Merging Chains  mult/5 into  External patterns of execution 
* [[10]] --> 1 
* [[10,[9]]] --> 2 


### Specialization of cost equations dyade/7 
* CE 4 is refined into CE [11] 
* CE 3 is refined into CE [12,13,14,15] 


#### Refined cost equations dyade/7 
* CE 11: dyade(A,B,C,D,E,F,G) = 3
     [G>=0,D>=0,C>=0,B>=0,F=0,E=1,A=1] 
* CE 12: dyade(A,B,C,D,E,F,G) = 6+ mult(H,I,D,J,K):1+ dyade(L,M,N,D,O,F,P)+ maxNorm(Q,F,F):1
     [G>=P,B>=M,G>=K,B>=H,O>=1,L>=1,F>=1,K>=0,D>=0,H>=0,O+1=E,L+1=A,N=1,Q=1,J=1,I=1,C=1] 
* CE 13: dyade(A,B,C,D,E,F,G) = 6+ mult(H,I,D,J,K):1+ dyade(L,M,N,D,O,P,Q)+ maxNorm(R,S,T):2
     [G>=Q,B>=M,G>=K,B>=H,O>=1,L>=1,K>=0,D>=0,H>=0,O+1=E,L+1=A,P=0,N=1,T=1,S=0,R=1,J=1,I=1,F=1,C=1] 
* CE 14: dyade(A,B,C,D,E,F,G) = 6+ mult(H,C,D,C,I):2+ dyade(J,K,C,D,L,F,M)+ maxNorm(C,F,F):1
     [G>=M,B>=K,F>=C,G>=I,B>=H,L>=1,J>=1,C>=2,I>=0,D>=0,H>=0,L+1=E,J+1=A] 
* CE 15: dyade(A,B,C,D,E,C,F) = 6+ mult(G,C,D,C,H):2+ dyade(I,J,C,D,K,L,M)+ maxNorm(C,L,C):2
     [F>=M,B>=J,C>=L+1,F>=H,B>=G,K>=1,I>=1,C>=2,L>=0,H>=0,D>=0,G>=0,K+1=E,I+1=A] 

### Cost equations --> "Loop" of dyade/7 
* CEs [14] --> Loop 11 
* CEs [15] --> Loop 12 
* CEs [12] --> Loop 13 
* CEs [13] --> Loop 14 
* CEs [11] --> Loop 15 

#### Loops of dyade/7 
* Loop 11: dyade(A,B,C,D,E,F,G)->  dyade(A',B',C,D,C',F,D')
                  [G>=D',B>=B',F>=C,G>=0,E>=2,D>=0,C>=2,B>=0,A>=2,E=C'+1,A=A'+1] 
* Loop 12: dyade(A,B,C,D,E,C,F)->  dyade(A',B',C,D,C',D',E')
                  [F>=E',C>=D'+1,B>=B',D'>=0,F>=0,E>=2,D>=0,C>=2,B>=0,A>=2,E=C'+1,A=A'+1] 
* Loop 13: dyade(A,B,C,D,E,F,G)->  dyade(A',B',C',D,D',F,E')
                  [G>=E',B>=B',G>=0,F>=1,E>=2,D>=0,B>=0,A>=2,E=D'+1,A=A'+1,C'=1,C=1] 
* Loop 14: dyade(A,B,C,D,E,F,G)->  dyade(A',B',C',D,D',E',F')
                  [G>=F',B>=B',G>=0,E>=2,D>=0,B>=0,A>=2,E=D'+1,A=A'+1,E'=0,C'=1,F=1,C=1] 
* Loop 15: dyade(A,B,C,D,E,F,G) [G>=0,D>=0,C>=0,B>=0,F=0,E=1,A=1] 

### Ranking functions of CR dyade(A,B,C,D,E,F,G) 
* RF of phase [11]: [A-1]
* RF of phase [13]: [A-1]

#### Partial ranking functions of CR dyade(A,B,C,D,E,F,G) 
* Partial RF of phase [11]:
  - RF of loop [11:1]:
    A-1
* Partial RF of phase [13]:
  - RF of loop [13:1]:
    A-1

Discarded unfeasible chain [[13]]...(Non-terminating chain proved terminating)
Discarded unfeasible chain [[11]](Non-terminating chain proved terminating)

### Resulting Chains:dyade(A,B,C,D,E,F,G) 
* [[13],14,15]
* [[11],12,15]
* [15]
* [14,15]
* [12,15]


### Merging Chains  dyade/7 into  External patterns of execution 
* [[15]] --> 1 
* [[15,14]] --> 2 
* [[15,12]] --> 3 
* [[15,14,[13]]] --> 4 
* [[15,12,[11]]] --> 5 


Computing Bounds
=====================================

#### Simplifying cost structure of CE 8 

#### Simplifying cost structure of CE 7 

#### Cost of chains of maxNorm(A,B,C):
* Chain [8]: 0
  with precondition: [A=C,B>=0,A>=B+1] 

* Chain [7]: 0
  with precondition: [C=B,A>=1,C>=A] 


#### Simplifying cost structure of CE 9 

#### Computing cost of phase [9] 

#### Simplifying cost structure of CE 10 

#### Cost of loops [9] 

 * loop 9:mult(A,B,C,D,E) -> [mult(A',B',C',D',E')] 
6
##### Pending set mult(A,B,C,D,E)
* Psum in Loop 9: [it(9)=<1]

###### Computing sum for it(9)=<1  in Loop 9 
   - Applying inductive sum strategy 
     - head Candidate: B-1 
     - head Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B-1 
     - tail Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(9)=<B-1,it(9)=<B-1,it(9)=<B-B',it(9)=<B-B'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [9] 

#### Simplifying cost structure of phase [9] 

#### Cost of phase [9]:mult(A,B,C,D,E) -> [mult(A',B',C',D',E')] 
6*it(9)+0
  Such that:it(9) =< B
it(9) =< B-B'

#### Simplifying cost structure of chain [[9],10] 

#### Cost of chains of mult(A,B,C,D,E):
* Chain [[9],10]: 6*it(9)+3
  Such that:it(9) =< D

  with precondition: [B=D,A>=0,B>=2,C>=0,E>=0] 

* Chain [10]: 3
  with precondition: [B=1,D=1,A>=0,C>=0,E>=0] 


#### Simplifying cost structure of CE 11 

#### Simplifying cost structure of CE 13 

#### Simplifying cost structure of chain [14,15] 

#### Computing cost of phase [13] 

#### Simplifying cost structure of CE 12 

#### Cost of loops [13] 

 * loop 13:dyade(A,B,C,D,E,F,G) -> [dyade(A',B',C',D',E',F',G')] 
9
##### Pending set dyade(A,B,C,D,E,F,G)
* Psum in Loop 13: [it(13)=<1]

###### Computing sum for it(13)=<1  in Loop 13 
   - Applying inductive sum strategy 
     - head Candidate: A-1 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(13)=<A-1,it(13)=<A-1,it(13)=<A-A',it(13)=<A-A'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [13] 

#### Simplifying cost structure of phase [13] 

#### Cost of phase [13]:dyade(A,B,C,D,E,F,G) -> [dyade(A',B',C',D',E',F',G')] 
9*it(13)+0
  Such that:it(13) =< A
it(13) =< A-A'

#### Simplifying cost structure of chain [[13],14,15] 
 * Renamed intermediate variables: 
[ (eq(15,1),it(9))>>s(1)]

#### Simplifying cost structure of CE 15 

#### Simplifying cost structure of chain [12,15] 

#### Computing cost of phase [11] 
 * Renamed intermediate variables: 
[ (eq(14,1),it(9))>>s(2)]

#### Simplifying cost structure of CE 14 
 * Renamed intermediate variables: 
[ (it(11),s(2))>>s(3)]

#### Cost of loops [11] 

 * loop 11:dyade(A,B,C,D,E,F,G) -> [dyade(A',B',C',D',E',F',G')] 
6*s(3)+9
  Such that:s(3) =< C'

##### Pending set dyade(A,B,C,D,E,F,G)
* Psum in Loop 11: [it(11)=<1,s(4)=<C']

###### Computing sum for it(11)=<1  in Loop 11 
   - Applying inductive sum strategy 
     - head Candidate: A-1 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(11)=<A-1,it(11)=<A-1,it(11)=<A-A',it(11)=<A-A'] 

##### Pending set A
* Psum in Loop 11: [s(4)=<C']

###### Computing sum for s(4)=<C'  in Loop 11 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(1)=<C] 
 * Adding constraints: [s(4)=<it(11)*aux(1)] 

##### Pending set dyade(A,B,C,D,E,F,G)
* Pmax/min: [aux(1)=<C]

###### Computing max_min for aux(1)=<C  
   - Found a solution using transitive invariants 
 * Adding constraints:[aux(1)=<C] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [11] 

#### Simplifying cost structure of phase [11] 

#### Cost of phase [11]:dyade(A,B,C,D,E,F,G) -> [dyade(A',B',C',D',E',F',G')] 
9*it(11)+6*s(4)+0
  Such that:it(11) =< A
it(11) =< A-A'
aux(1) =< C
s(4) =< it(11)*aux(1)

#### Simplifying cost structure of chain [[11],12,15] 
 * Joined equivalent variables [aux(2),aux(1)] into aux(2)

#### Cost of chains of dyade(A,B,C,D,E,F,G):
* Chain [[13],14,15]: 9*it(13)+12
  Such that:it(13) =< A

  with precondition: [C=1,F=1,A=E,A>=3,B>=0,D>=0,G>=0] 

* Chain [[11],12,15]: 9*it(11)+6*s(1)+6*s(4)+12
  Such that:it(11) =< E
aux(2) =< C
s(1) =< aux(2)
s(4) =< it(11)*aux(2)

  with precondition: [A=E,C=F,A>=3,B>=0,C>=2,D>=0,G>=0] 

* Chain [15]: 3
  with precondition: [A=1,E=1,F=0,B>=0,C>=0,D>=0,G>=0] 

* Chain [14,15]: 12
  with precondition: [A=2,C=1,E=2,F=1,B>=0,D>=0,G>=0] 

* Chain [12,15]: 6*s(1)+12
  Such that:s(1) =< F

  with precondition: [A=2,E=2,C=F,B>=0,C>=2,D>=0,G>=0] 


Closed-form bounds of mult(A,B,C,D,E): 
-------------------------------------
* Chain [[9],10] with precondition: [B=D,A>=0,B>=2,C>=0,E>=0] 
    - Upper bound: 6*B+3 
    - Complexity: n 
* Chain [10] with precondition: [B=1,D=1,A>=0,C>=0,E>=0] 
    - Upper bound: 3 
    - Complexity: constant 

### Maximum cost of mult(A,B,C,D,E): 6*B+3 
Asymptotic class: n 

Closed-form bounds of dyade(A,B,C,D,E,F,G): 
-------------------------------------
* Chain [[13],14,15] with precondition: [C=1,F=1,A=E,A>=3,B>=0,D>=0,G>=0] 
    - Upper bound: 9*A+12 
    - Complexity: n 
* Chain [[11],12,15] with precondition: [A=E,C=F,A>=3,B>=0,C>=2,D>=0,G>=0] 
    - Upper bound: 9*A+12+6*A*C+6*C 
    - Complexity: n^2 
* Chain [15] with precondition: [A=1,E=1,F=0,B>=0,C>=0,D>=0,G>=0] 
    - Upper bound: 3 
    - Complexity: constant 
* Chain [14,15] with precondition: [A=2,C=1,E=2,F=1,B>=0,D>=0,G>=0] 
    - Upper bound: 12 
    - Complexity: constant 
* Chain [12,15] with precondition: [A=2,E=2,C=F,B>=0,C>=2,D>=0,G>=0] 
    - Upper bound: 6*C+12 
    - Complexity: n 

### Maximum cost of dyade(A,B,C,D,E,F,G): max([6*C+9,6*A*C+6*C+ (9*A+9)])+3 
Asymptotic class: n^2 
* Total analysis performed in 231 ms.


Cost relation system solved by CoFloCo in 233 ms.

Method mult terminates?: YES

 - n_1: size of n wrt. Rat
 - l_1: size of l wrt. List<Rat>
 - l_2: size of l wrt. Rat
UB for mult(n_1,l_1,l_2) = 6*l_1+3

Method dyade terminates?: YES

 - l1_1: size of l1 wrt. List<Rat>
 - l1_2: size of l1 wrt. Rat
 - l2_1: size of l2 wrt. List<Rat>
 - l2_2: size of l2 wrt. Rat
UB for dyade(l1_1,l1_2,l2_1,l2_2) = max([6*l2_1+9,6*l1_1*l2_1+6*l2_1+ (9*l1_1+9)])+3
