
Abs program loaded in 15 ms.

Rule based representation generated in 1 ms.

Rule based representation stored in /tmp/costabs/rbr.rbr

RBR properties stored in /tmp/costabs/rbr.properties

Class invariants generated and loaded in 0 ms.

Abstract compilation performed in 6 ms.

Cost relation system stored in /tmp/costabs/crs.crs

Generated 33 equations 
entry('append'(A,B,C,D,E,F,G,H,I,J,K,L):[]).
entry('part'(A,B,C,D,E,F,G,H,I):[]).
entry('qs'(A,B,C,D):[]).
input_output_vars('and_op'(A,B,C),[A,B],[C]).
input_output_vars('append'(A,B,C,D,E,F,G,H,I,J,K,L),[A,B,C,D,E,F,G,H],[I,J,K,L]).
input_output_vars('case_0'(A,B,C,D,E,F,G,H,I,J,K,L),[A,B,C,D,E,F,G,H],[I,J,K,L]).
input_output_vars('case_1'(A,B,C,D,E,F,G,H,I),[A,B,C,D,E,F,G],[H,I]).
input_output_vars('case_2'(A,B,C,D,E,F,G,H,I,J,K,L),[A,B,C,D,E,F,G,H,I,J],[K,L]).
input_output_vars('case_3'(A,B,C,D),[A,B],[C,D]).
input_output_vars('eq'(A,B,C),[A,B],[C]).
input_output_vars('geq'(A,B,C),[A,B],[C]).
input_output_vars('gt'(A,B,C),[A,B],[C]).
input_output_vars('leq'(A,B,C),[A,B],[C]).
input_output_vars('lt'(A,B,C),[A,B],[C]).
input_output_vars('maxNorm'(A,B,C),[A,B],[C]).
input_output_vars('neg'(A,B),[A],[B]).
input_output_vars('neq'(A,B,C),[A,B],[C]).
input_output_vars('or'(A,B,C),[A,B],[C]).
input_output_vars('part'(A,B,C,D,E,F,G,H,I),[A,B,C,D,E,F,G],[H,I]).
input_output_vars('qs'(A,B,C,D),[A,B],[C,D]).
eq('eq',[A,B,C],0,[],[A=B,C=1,A>=0,B>=0,C>=0]).
eq('eq',[A,B,C],0,[],[A>=B+1,C=0,A>=0,B>=0,C>=0]).
eq('eq',[A,B,C],0,[],[B>=A+1,C=0,A>=0,B>=0,C>=0]).
eq('neq',[A,B,C],0,[],[A=B,C=0,A>=0,B>=0,C>=0]).
eq('neq',[A,B,C],0,[],[A>=B+1,C=1,A>=0,B>=0,C>=0]).
eq('neq',[A,B,C],0,[],[B>=A+1,C=1,A>=0,B>=0,C>=0]).
eq('lt',[A,B,C],0,[],[B-A>=1,C=1,A>=0,B>=0,C>=0]).
eq('lt',[A,B,C],0,[],[B=<A,C=0,A>=0,B>=0,C>=0]).
eq('leq',[A,B,C],0,[],[A=<B,C=1,A>=0,B>=0,C>=0]).
eq('leq',[A,B,C],0,[],[A-B>=1,C=0,A>=0,B>=0,C>=0]).
eq('gt',[A,B,C],0,[],[A-B>=1,C=1,A>=0,B>=0,C>=0]).
eq('gt',[A,B,C],0,[],[A=<B,C=0,A>=0,B>=0,C>=0]).
eq('geq',[A,B,C],0,[],[B=<A,C=1,A>=0,B>=0,C>=0]).
eq('geq',[A,B,C],0,[],[B-A>=1,C=0,A>=0,B>=0,C>=0]).
eq('neg',[A,B],0,[],[A=0,B=1,A>=0,B>=0]).
eq('neg',[A,B],0,[],[A=1,B=0,A>=0,B>=0]).
eq('and_op',[A,B,C],0,[],[A=0,C=0,A>=0,B>=0,C>=0]).
eq('and_op',[A,B,C],0,[],[A=1,C=B,A>=0,B>=0,C>=0]).
eq('or',[A,B,C],0,[],[A=1,C=1,A>=0,B>=0,C>=0]).
eq('or',[A,B,C],0,[],[A=0,C=B,A>=0,B>=0,C>=0]).
eq('maxNorm',[A,B,A],0,[],[A>=1+B,A>=0,B>=0,A>=0]).
eq('maxNorm',[A,B,B],0,[],[A=<B,A>=0,B>=0,B>=0]).
eq('case_0',[A,B,C,D,E,F,G,H,E,F,G,H],1,[],[D=0,C=1,A=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,E>=0,F>=0,G>=0,H>=0]).
eq('case_0',[A,B,C,D,E,F,G,H,I,J,K,L],4,['append'(M,N,O,P,E,F,G,H,Q,R,S,T),'maxNorm'(U,T,L)],[D>=U,D>=P,B>=V,B>=N,C=O+1,A=M+1,O>=1,M>=1,U>=1,J>=V,J>=R,K=S+1,I=Q+1,S>=1,Q>=1,U>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0]).
eq('append',[A,B,C,D,E,F,G,H,I,J,K,L],1,['case_0'(A,B,C,D,E,F,G,H,I,J,K,L)],[A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0]).
eq('case_1',[A,B,C,D,E,F,G,H,I],5,['qs'(B,C,J,K),'qs'(D,E,L,M),'append'(J,K,N,O,P,Q,R,S,H,I,T,U)],[F=1,Q>=A,Q>=M,P=L+1,L>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0]).
eq('case_2',[A,B,C,D,E,F,G,H,I,J,K,L],3,['part'(A,M,N,D,E,I,J,K,L)],[A>=H+1,N>=H,N>=C,M=B+1,B>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0]).
eq('case_2',[A,B,C,D,E,F,G,H,I,J,K,L],3,['part'(A,B,C,M,N,I,J,K,L)],[H>=A,N>=H,N>=E,M=D+1,D>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0]).
eq('case_1',[A,B,C,D,E,F,G,H,I],3,['case_2'(A,B,C,D,E,F,G,J,K,L,H,I)],[G>=J,G>=L,F=K+1,K>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0]).
eq('part',[A,B,C,D,E,F,G,H,I],1,['case_1'(A,B,C,D,E,F,G,H,I)],[A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0]).
eq('case_3',[A,B,C,D],2,[],[A=1,C=1,A>=0,B>=0,C>=0,D>=0]).
eq('case_3',[A,B,C,D],5,['part'(E,F,G,H,I,J,K,C,D)],[B>=E,B>=K,A=J+1,J>=1,F=1,H=1,A>=0,B>=0,C>=0,D>=0]).
eq('qs',[A,B,C,D],1,['case_3'(A,B,C,D)],[A>=0,B>=0,C>=0,D>=0]).

Preprocessing Cost Relations
=====================================

#### Computed strongly connected components 
0. non_recursive  : [maxNorm/3]
1. recursive [non_tail] : [append/12,case_0/12]
2. recursive [non_tail,multiple] : [case_1/9,case_2/12,case_3/4,part/9,qs/4]
* The entry qs/4 is not a cutpoint so it becomes a new SCC 3
Warning: the following predicates are never called:[and_op/3,eq/3,geq/3,gt/3,leq/3,lt/3,neg/2,neq/3,or/3]

#### Obtained direct recursion through partial evaluation 
0. SCC is partially evaluated into maxNorm/3
1. SCC is partially evaluated into append/12
2. SCC is partially evaluated into part/9
3. SCC is partially evaluated into qs/4

Control-Flow Refinement of Cost Relations
=====================================

### Specialization of cost equations maxNorm/3 
* CE 12 is refined into CE [13] 
* CE 11 is refined into CE [14] 


#### Refined cost equations maxNorm/3 
* CE 13: maxNorm(A,B,B) = 0
     [B>=A,A>=1] 
* CE 14: maxNorm(A,B,A) = 0
     [A>=B+1,B>=0] 

### Cost equations --> "Loop" of maxNorm/3 
* CEs [13] --> Loop 13 
* CEs [14] --> Loop 14 

#### Loops of maxNorm/3 
* Loop 13: maxNorm(A,B,B) [B>=A,A>=1] 
* Loop 14: maxNorm(A,B,A) [A>=B+1,B>=0] 

### Ranking functions of CR maxNorm(A,B,C) 

#### Partial ranking functions of CR maxNorm(A,B,C) 


### Resulting Chains:maxNorm(A,B,C) 
* [14]
* [13]


### Merging Chains  maxNorm/3 into  External patterns of execution 
* [[13]] --> 1 
* [[14]] --> 2 


### Specialization of cost equations append/12 
* CE 2 is refined into CE [15] 
* CE 1 is refined into CE [16,17] 


#### Refined cost equations append/12 
* CE 15: append(A,B,C,D,E,F,G,H,E,F,G,H) = 2
     [H>=0,G>=0,F>=0,E>=0,B>=0,D=0,C=1,A=1] 
* CE 16: append(A,B,C,D,E,F,G,H,I,J,K,L) = 5+ append(M,N,O,P,E,F,G,H,Q,R,S,L)+ maxNorm(T,L,L):1
     [J>=R,D>=P,B>=N,L>=T,D>=T,S>=1,Q>=1,O>=1,M>=1,T>=1,J>=0,H>=0,G>=0,F>=0,E>=0,B>=0,S+1=K,Q+1=I,O+1=C,M+1=A] 
* CE 17: append(A,B,C,D,E,F,G,H,I,J,K,L) = 5+ append(M,N,O,P,E,F,G,H,Q,R,S,T)+ maxNorm(L,T,L):2
     [J>=R,D>=P,B>=N,D>=L,L>=T+1,S>=1,Q>=1,O>=1,M>=1,T>=0,J>=0,H>=0,G>=0,F>=0,E>=0,B>=0,S+1=K,Q+1=I,O+1=C,M+1=A] 

### Cost equations --> "Loop" of append/12 
* CEs [17] --> Loop 15 
* CEs [16] --> Loop 16 
* CEs [15] --> Loop 17 

#### Loops of append/12 
* Loop 15: append(A,B,C,D,E,F,G,H,I,J,K,L)->  append(A',B',C',D',E,F,G,H,E',F',G',H')
                  [L>=H'+1,J>=F',D>=D',B>=B',D>=L,H'>=0,K>=2,J>=0,I>=2,H>=0,G>=0,F>=0,E>=0,C>=2,B>=0,A>=2,K=G'+1,I=E'+1,C=C'+1,A=A'+1] 
* Loop 16: append(A,B,C,D,E,F,G,H,I,J,K,L)->  append(A',B',C',D',E,F,G,H,E',F',G',L)
                  [J>=F',D>=D',B>=B',L>=1,K>=2,J>=0,I>=2,H>=0,G>=0,F>=0,E>=0,D>=1,C>=2,B>=0,A>=2,K=G'+1,I=E'+1,C=C'+1,A=A'+1] 
* Loop 17: append(A,B,C,D,E,F,G,H,E,F,G,H) [H>=0,G>=0,F>=0,E>=0,B>=0,D=0,C=1,A=1] 

### Ranking functions of CR append(A,B,C,D,E,F,G,H,I,J,K,L) 
* RF of phase [15,16]: [A-1,C-1]

#### Partial ranking functions of CR append(A,B,C,D,E,F,G,H,I,J,K,L) 
* Partial RF of phase [15,16]:
  - RF of loop [15:1,16:1]:
    A-1
    C-1

Discarded unfeasible chain [[15,16]]...(Non-terminating chain proved terminating)

### Resulting Chains:append(A,B,C,D,E,F,G,H,I,J,K,L) 
* [[15,16],17]
* [17]


### Merging Chains  append/12 into  External patterns of execution 
* [[17]] --> 1 
* [[17,[15,16]]] --> 2 


### Specialization of cost equations part/9 
* CE 8 is refined into CE [18] 
* CE 7 is refined into CE [19] 
* CE 4 is refined into CE [20,21] 
* CE 5 is refined into CE [22] 
* CE 6 is refined into CE [23] 
* CE 3 is refined into CE [24,25] 


#### Refined cost equations part/9 
* CE 18: part(A,B,C,D,E,F,G,H,I) = 7+ part(A,B,C,J,K,L,M,H,I)
     [G>=M,K>=E,K>=A,G>=A,M>=0,L>=1,I>=0,H>=0,E>=0,D>=1,C>=0,B>=0,A>=0,D+1=J,L+1=F] 
* CE 19: part(A,B,C,D,E,F,G,H,I) = 7+ part(A,J,K,D,E,L,M,H,I)
     [G>=M,K>=C,M>=0,L>=1,I>=0,H>=0,E>=0,D>=0,C>=0,B>=1,A>=1,B+1=J,L+1=F] 
* CE 20: part(A,B,C,D,E,F,G,H,I) = 15+ part(J,K,L,M,N,O,P,Q,R)+ append(S,R,T,U,V,I,W,X,Y,I,W,X):1
     [C>=P,C>=J,I>=A,O>=1,X>=0,W>=0,R>=0,G>=0,E>=0,C>=0,A>=0,O+1=B,Q=1,M=1,K=1,Y=2,V=2,U=0,T=1,S=1,H=2,F=1,D=1] 
* CE 21: part(A,B,C,D,E,F,G,H,I) = 15+ part(J,K,L,M,N,O,P,Q,R)+ append(Q,R,Q,S,T,U,V,W,X,I,Y,Z):2
     [S+W>=Z,C>=P,C>=J,Z>=W,I>=U,Y>=Q,U>=A,O>=1,Z>=1,W>=0,S>=1,Q>=2,R>=0,G>=0,E>=0,C>=0,A>=0,Q+V=Y+1,Q+1=X,Q+1=H,O+1=B,M=1,K=1,T=2,F=1,D=1] 
* CE 22: part(A,B,C,D,E,F,G,H,I) = 15+ part(J,K,L,M,N,O,P,Q,R)+ append(S,T,U,V,H,I,W,X,H,I,W,X):1
     [I>=R,E>=P,E>=J,I>=A,R>=0,O>=1,X>=0,W>=0,H>=2,T>=0,G>=0,E>=0,C>=0,A>=0,H=Q+1,O+1=D,M=1,K=1,V=0,U=1,S=1,F=1,B=1] 
* CE 23: part(A,B,C,D,E,F,G,H,I) = 12+ append(J,K,L,M,N,I,O,P,Q,I,O,P):1
     [I>=A,P>=0,O>=0,K>=0,G>=0,E>=0,C>=0,A>=0,Q=2,N=2,M=0,L=1,J=1,H=2,F=1,D=1,B=1] 
* CE 24: part(A,B,C,D,E,F,G,H,I) = 18+ part(J,K,L,M,N,O,P,Q,R)+ part(S,T,U,V,W,X,Y,Z,A1)+ append(B1,R,C1,D1,H,I,E1,F1,H,I,E1,F1):1
     [I>=A1,E>=Y,E>=S,C>=P,C>=J,I>=A,A1>=0,X>=1,O>=1,F1>=0,E1>=0,H>=2,R>=0,G>=0,E>=0,C>=0,A>=0,H=Z+1,X+1=D,O+1=B,V=1,T=1,Q=1,M=1,K=1,D1=0,C1=1,B1=1,F=1] 
* CE 25: part(A,B,C,D,E,F,G,H,I) = 18+ part(J,K,L,M,N,O,P,Q,R)+ part(S,T,U,V,W,X,Y,Z,A1)+ append(Q,R,Q,B1,C1,D1,E1,F1,H,I,G1,H1):2
     [B1+F1>=H1,D1>=A1,E>=Y,E>=S,C>=P,C>=J,H1>=F1,I>=D1,G1>=Q,H>=Q+1,D1>=A,A1>=0,X>=1,O>=1,H1>=1,F1>=0,B1>=1,Q>=2,R>=0,G>=0,E>=0,C>=0,A>=0,Q+E1=G1+1,Q+Z=H,Q+C1=H+1,X+1=D,O+1=B,V=1,T=1,M=1,K=1,F=1] 

### Cost equations --> "Loop" of part/9 
* CEs [25] --> Loop 18 
* CEs [24] --> Loop 19 
* CEs [23] --> Loop 20 
* CEs [18] --> Loop 21 
* CEs [19] --> Loop 22 
* CEs [21] --> Loop 23 
* CEs [20] --> Loop 24 
* CEs [22] --> Loop 25 

#### Loops of part/9 
* Loop 18: part(A,B,C,D,E,F,G,H,I)->  part(A',B',C',D',E',F',G',H',I')  part(A'2,B'2,C'2,D'2,E'2,F'2,G'2,H'2,I'2)
                  [I>=I'2,E>=G'2,E>=A'2,H>=H'+1,C>=G',C>=A',I>=A,I'2>=0,I'>=0,H'>=2,G>=0,E>=0,D>=2,C>=0,B>=2,A>=0,H'+H'2=H,D=F'2+1,B=F'+1,D'2=1,B'2=1,D'=1,B'=1,F=1] 
* Loop 19: part(A,B,C,D,E,F,G,H,I)->  part(A',B',C',D',E',F',G',H',I')  part(A'2,B'2,C'2,D'2,E'2,F'2,G'2,H'2,I'2)
                  [I>=I'2,E>=G'2,E>=A'2,C>=G',C>=A',I>=A,I'2>=0,I'>=0,H>=2,G>=0,E>=0,D>=2,C>=0,B>=2,A>=0,H=H'2+1,D=F'2+1,B=F'+1,D'2=1,B'2=1,H'=1,D'=1,B'=1,F=1] 
* Loop 20: part(A,B,C,D,E,F,G,H,I) [I>=A,G>=0,E>=0,C>=0,A>=0,H=2,F=1,D=1,B=1] 
* Loop 21: part(A,B,C,D,E,F,G,H,I)->  part(A,B,C,A',B',C',D',H,I)
                  [G>=D',B'>=E,B'>=A,G>=A,D'>=0,I>=0,H>=0,F>=2,E>=0,D>=1,C>=0,B>=0,A>=0,F=C'+1,D+1=A'] 
* Loop 22: part(A,B,C,D,E,F,G,H,I)->  part(A,A',B',D,E,C',D',H,I)
                  [G>=D',B'>=C,D'>=0,I>=0,H>=0,F>=2,E>=0,D>=0,C>=0,B>=1,A>=1,F=C'+1,B+1=A'] 
* Loop 23: part(A,B,C,D,E,F,G,H,I)->  part(A',B',C',D',E',F',G',H',I')
                  [C>=G',C>=A',I>=A,I'>=0,H>=3,G>=0,E>=0,C>=0,B>=2,A>=0,H=H'+1,B=F'+1,D'=1,B'=1,F=1,D=1] 
* Loop 24: part(A,B,C,D,E,F,G,H,I)->  part(A',B',C',D',E',F',G',H',I')
                  [C>=G',C>=A',I>=A,I'>=0,G>=0,E>=0,C>=0,B>=2,A>=0,B=F'+1,H'=1,D'=1,B'=1,H=2,F=1,D=1] 
* Loop 25: part(A,B,C,D,E,F,G,H,I)->  part(A',B',C',D',E',F',G',H',I')
                  [I>=I',E>=G',E>=A',I>=A,I'>=0,H>=2,G>=0,E>=0,D>=2,C>=0,A>=0,H=H'+1,D=F'+1,D'=1,B'=1,F=1,B=1] 

### Ranking functions of CR part(A,B,C,D,E,F,G,H,I) 

#### Partial ranking functions of CR part(A,B,C,D,E,F,G,H,I) 
* Partial RF of phase [18,19,21,22,23,24,25]:
  - RF of loop [18:1,18:2,19:1,19:2,23:1,24:1]:
    B-1 depends on loops [22:1] 
  - RF of loop [18:1,18:2,19:1,19:2,25:1]:
    D-1 depends on loops [21:1] 
  - RF of loop [18:1,19:1,23:1,24:1]:
    B+F-2 depends on loops [18:2,19:2,25:1] 
  - RF of loop [18:2,19:2,25:1]:
    D+F-2 depends on loops [18:1,19:1,23:1,24:1] 
  - RF of loop [21:1,22:1]:
    F-1 depends on loops [18:1,18:2,19:1,19:2,23:1,24:1,25:1] 


### Resulting Chains:part(A,B,C,D,E,F,G,H,I) 
* [multiple([18,19,21,22,23,24,25],[[],[20]])]...
* [20]


### Merging Chains  part/9 into  External patterns of execution 
* [[20]] --> 1 
* [[multiple([18,19,21,22,23,24,25],[[],[20]])]] --> 2 


### Specialization of cost equations qs/4 
* CE 9 is refined into CE [26,27] 
* CE 10 is refined into CE [28] 


#### Refined cost equations qs/4 
* CE 26: qs(A,B,C,D) = 6+ part(E,F,G,H,I,J,K,L,D):1
     [B>=K,D>=E,B>=E,K>=0,I>=0,G>=0,E>=0,L=2,J=1,H=1,F=1,C=2,A=2] 
* CE 27: qs(A,B,C,D) = 6+ part(E,F,G,H,I,J,K,C,D):2
     [C+2*J>=4,B>=K,B>=E,2*J>=3,D>=0,C>=0,K>=0,I>=0,G>=0,E>=0,J+1=A,H=1,F=1] 
* CE 28: qs(A,B,C,D) = 3
     [D>=0,B>=0,C=1,A=1] 

### Cost equations --> "Loop" of qs/4 
* CEs [26] --> Loop 26 
* CEs [28] --> Loop 27 
* CEs [27] --> Loop 28 

#### Loops of qs/4 
* Loop 26: qs(A,B,C,D) [D>=0,B>=0,C=2,A=2] 
* Loop 27: qs(A,B,C,D) [D>=0,B>=0,C=1,A=1] 
* Loop 28: qs(A,B,C,D) [C+2*A>=6,2*A>=5,D>=0,C>=0,B>=0] 

### Ranking functions of CR qs(A,B,C,D) 

#### Partial ranking functions of CR qs(A,B,C,D) 


### Resulting Chains:qs(A,B,C,D) 
* [28]...
* [27]
* [26]


### Merging Chains  qs/4 into  External patterns of execution 
* [[27]] --> 1 
* [[26]] --> 2 
* [[28]] --> 3 


Computing Bounds
=====================================

#### Simplifying cost structure of CE 14 

#### Simplifying cost structure of CE 13 

#### Cost of chains of maxNorm(A,B,C):
* Chain [14]: 0
  with precondition: [A=C,B>=0,A>=B+1] 

* Chain [13]: 0
  with precondition: [C=B,A>=1,C>=A] 


#### Simplifying cost structure of CE 15 

#### Computing cost of phase [15,16] 

#### Simplifying cost structure of CE 17 

#### Simplifying cost structure of CE 16 

#### Cost of loops [15,16] 

 * loop 15:append(A,B,C,D,E,F,G,H,I,J,K,L) -> [append(A',B',C',D',E',F',G',H',I',J',K',L')] 
5
 * loop 16:append(A,B,C,D,E,F,G,H,I,J,K,L) -> [append(A',B',C',D',E',F',G',H',I',J',K',L')] 
5
##### Pending set append(A,B,C,D,E,F,G,H,I,J,K,L)
* Psum in Loop 15: [it(15)=<1]
* Psum in Loop 16: [it(16)=<1]

###### Computing sum for it(15)=<1  in Loop 15 
   - Applying inductive sum strategy 
     - head Candidate: C-1 
       - Loop 16 is collaborative and bounds [it(16)] 
     - head Candidate: A-1 
       - Loop 16 is collaborative and bounds [it(16)] 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - Loop 16 is collaborative and bounds [it(16)] 
     - tail Candidate: A-1 
       - Loop 16 is collaborative and bounds [it(16)] 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(15)+it(16)=<C-1,it(15)+it(16)=<A-1,it(15)+it(16)=<A-1,it(15)+it(16)=<C-1,it(15)+it(16)=<C-C',it(15)+it(16)=<A-A',it(15)+it(16)=<A-A',it(15)+it(16)=<C-C'] 

##### Pending set A
* Psum in Loop 16: [it(16)=<1]

###### Computing sum for it(16)=<1  in Loop 16 
   - Applying inductive sum strategy 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(15)+it(16)=<C-1,it(15)+it(16)=<A-1,it(15)+it(16)=<A-1,it(15)+it(16)=<C-1,it(15)+it(16)=<C-C',it(15)+it(16)=<A-A',it(15)+it(16)=<A-A',it(15)+it(16)=<C-C'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [15,16] 

#### Simplifying cost structure of phase [15,16] 
 * Joined equivalent variables [it(15),it(16)] into it(15)

#### Cost of phase [15,16]:append(A,B,C,D,E,F,G,H,I,J,K,L) -> [append(A',B',C',D',E',F',G',H',I',J',K',L')] 
10*it(15)+0
  Such that:aux(1) =< A
aux(2) =< A-A'
aux(3) =< C
aux(4) =< C-C'
it(15) =< aux(1)
it(15) =< aux(2)
it(15) =< aux(3)
it(15) =< aux(4)

#### Simplifying cost structure of chain [[15,16],17] 
 * Joined equivalent variables [aux(5),aux(1),aux(2),aux(3),aux(4)] into aux(5)

#### Cost of chains of append(A,B,C,D,E,F,G,H,I,J,K,L):
* Chain [[15,16],17]: 10*it(15)+2
  Such that:aux(5) =< A
it(15) =< aux(5)

  with precondition: [A=C,A+E=I+1,A+G=K+1,A>=2,B>=0,D>=1,E>=1,F>=0,G>=1,H>=0,L>=1,J>=F,L>=H,D+H>=L] 

* Chain [17]: 2
  with precondition: [A=1,C=1,D=0,E=I,F=J,G=K,H=L,B>=0,E>=0,F>=0,G>=0,H>=0] 


#### Simplifying cost structure of CE 23 

#### Computing cost of chain [multiple([18,19,21,22,23,24,25],[[],[20]])] with multiple recursion
 * Renamed intermediate variables: 
[ (eq(25,1),aux(5))>>s(1), (eq(25,1),it(15))>>s(2)]

#### Simplifying cost structure of CE 25 
 * Renamed intermediate variables: 
[ (it(18),s(2))>>s(3)]

#### Simplifying cost structure of CE 24 

#### Simplifying cost structure of CE 18 

#### Simplifying cost structure of CE 19 
 * Renamed intermediate variables: 
[ (eq(21,1),aux(5))>>s(4), (eq(21,1),it(15))>>s(5)]

#### Simplifying cost structure of CE 21 
 * Renamed intermediate variables: 
[ (it(23),s(5))>>s(6)]

#### Simplifying cost structure of CE 20 

#### Simplifying cost structure of CE 22 

#### Cost of loops [18,19,21,22,23,24,25] 

 * loop 18:part(A,B,C,D,E,F,G,H,I) -> [part(A',B',C',D',E',F',G',H',I'),part(A'2,B'2,C'2,D'2,E'2,F'2,G'2,H'2,I'2)] 
10*s(3)+20
Unbounded itvars
s(3) :  it(18),s(2)

 * loop 19:part(A,B,C,D,E,F,G,H,I) -> [part(A',B',C',D',E',F',G',H',I'),part(A'2,B'2,C'2,D'2,E'2,F'2,G'2,H'2,I'2)] 
20
 * loop 21:part(A,B,C,D,E,F,G,H,I) -> [part(A',B',C',D',E',F',G',H',I')] 
7
 * loop 22:part(A,B,C,D,E,F,G,H,I) -> [part(A',B',C',D',E',F',G',H',I')] 
7
 * loop 23:part(A,B,C,D,E,F,G,H,I) -> [part(A',B',C',D',E',F',G',H',I')] 
10*s(6)+17
Unbounded itvars
s(6) :  it(23),s(5)

 * loop 24:part(A,B,C,D,E,F,G,H,I) -> [part(A',B',C',D',E',F',G',H',I')] 
17
 * loop 25:part(A,B,C,D,E,F,G,H,I) -> [part(A',B',C',D',E',F',G',H',I')] 
17
##### Pending set part(A,B,C,D,E,F,G,H,I)
* Psum in Loop 18: [it(18)=<1]
* Psum in Loop 19: [it(19)=<1]
* Psum in Loop 21: [it(21)=<1]
* Psum in Loop 22: [it(22)=<1]
* Psum in Loop 23: [it(23)=<1]
* Psum in Loop 24: [it(24)=<1]
* Psum in Loop 25: [it(25)=<1]
* Psum in Chain-Tail [20]: [it([20])=<1]

###### Computing sum for it(18)=<1  in Loop 18 
   - Applying inductive sum strategy 
     - head Candidate: B-1 
       - Loop 19 is collaborative and bounds [it(19)] 
       - Loop 21 is collaborative
       - Loop 22 adds a constant 1/1 
       - Loop 23 is collaborative and bounds [it(23)] 
       - Loop 24 is collaborative and bounds [it(24)] 
       - Loop 25 is collaborative
       - Chain-Tail [20] is collaborative
     - head Candidate: B/2+D/2+F/2-3/2 
       - Loop 19 is collaborative and bounds [it(19)] 
       - Loop 21 is collaborative
       - Loop 22 is collaborative
       - Loop 23 is collaborative
       - Loop 24 is collaborative
       - Loop 25 is collaborative
       - Chain-Tail [20] is collaborative
 * Adding constraints: [it(18)+it(19)+it(23)+it(24)=<it(22)+aux(6),aux(6)=<B-1,it(18)+it(19)=<B/2+D/2+F/2-3/2] 

##### Pending set A
* Psum in Loop 21: [it(21)=<1]
* Psum in Loop 22: [it(22)=<1]
* Psum in Loop 23: [it(23)=<1]
* Psum in Loop 24: [it(24)=<1]
* Psum in Loop 25: [it(25)=<1]
* Psum in Chain-Tail [20]: [it([20])=<1]

###### Computing sum for it(21)=<1  in Loop 21 
   - Applying inductive sum strategy 
     - head Candidate: F-1 
       - Loop 18 adds an expression [B+D-4]
       - Loop 19 adds an expression [B+D-4]
       - Loop 22 is collaborative and bounds [it(22)] 
       - Loop 23 adds an expression [B-2]
       - Loop 24 adds an expression [B-2]
       - Loop 25 adds an expression [D-2]
       - Chain-Tail [20] is collaborative
     - tail Candidate: F-1 
       - Loop 18 adds an expression [B+D-4]
       - Loop 19 adds an expression [B+D-4]
       - Loop 22 is collaborative and bounds [it(22)] 
       - Loop 23 adds an expression [B-2]
       - Loop 24 adds an expression [B-2]
       - Loop 25 adds an expression [D-2]
       - Chain-Tail [20] is collaborative
 * Adding constraints: [it(21)+it(22)=<aux(11)+aux(10)+aux(9)+aux(8)+aux(7)+aux(12),it(21)+it(22)=<aux(17)+aux(16)+aux(15)+aux(14)+aux(13)+aux(18),aux(12)=<F-1,aux(18)=<F-1] 

##### Pending set A
* Psum in Loop 18: [aux(7)=<B+D-4,aux(13)=<B+D-4]
* Psum in Loop 19: [aux(8)=<B+D-4,aux(14)=<B+D-4]
* Psum in Loop 22: [it(22)=<1]
* Psum in Loop 23: [it(23)=<1,aux(9)=<B-2,aux(15)=<B-2]
* Psum in Loop 24: [it(24)=<1,aux(10)=<B-2,aux(16)=<B-2]
* Psum in Loop 25: [it(25)=<1,aux(11)=<D-2,aux(17)=<D-2]
* Psum in Chain-Tail [20]: [it([20])=<1]

###### Computing sum for aux(7)=<B+D-4  in Loop 18 
   - Applying inductive sum strategy 
     - head Candidate: B+D 
       - Loop 19 is collaborative and bounds [aux(8)] 
       - Loop 21 adds a constant 1/1 
       - Loop 22 adds a constant 1/1 
       - Loop 23 is collaborative and bounds [it(23)] 
       - Loop 24 is collaborative and bounds [it(24)] 
       - Loop 25 is collaborative and bounds [it(25)] 
       - Chain-Tail [20] is collaborative and bounds [it([20])] 
     - head Candidate: B+D-4 
       - Loop 19 is collaborative and bounds [aux(8)] 
       - Loop 21 adds a constant 1/1 
       - Loop 22 adds a constant 1/1 
       - Loop 23 is collaborative
       - Loop 24 is collaborative
       - Loop 25 is collaborative
       - Chain [20] is ignored
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(21)=<B+D-4] 
 * Adding constraints: [aux(7)=<it(18)*aux(21),aux(7)+aux(8)+it(23)+it(24)+it(25)+it([20])=<it(22)+it(21)+aux(19),aux(7)+aux(8)=<it(22)+it(21)+aux(20),aux(19)=<B+D,aux(20)=<B+D-4] 

##### Pending set part(A,B,C,D,E,F,G,H,I)
* Pmax/min: [aux(21)=<B+D-4]
* Psum in Loop 18: [aux(13)=<B+D-4]
* Psum in Loop 19: [aux(14)=<B+D-4]
* Psum in Loop 22: [it(22)=<1]
* Psum in Loop 23: [it(23)=<1,aux(9)=<B-2,aux(15)=<B-2]
* Psum in Loop 24: [it(24)=<1,aux(10)=<B-2,aux(16)=<B-2]
* Psum in Loop 25: [it(25)=<1,aux(11)=<D-2,aux(17)=<D-2]
* Psum in Chain-Tail [20]: [it([20])=<1]

###### Computing max_min for aux(21)=<B+D-4  
   - Found a solution using transitive invariants 
 * Adding constraints:[aux(21)=<B+D+F-5,aux(21)=<2*B+2*D+2*F-9] 

##### Pending set part(A,B,C,D,E,F,G,H,I)
* Psum in Loop 18: [aux(13)=<B+D-4]
* Psum in Loop 19: [aux(14)=<B+D-4]
* Psum in Loop 22: [it(22)=<1]
* Psum in Loop 23: [it(23)=<1,aux(9)=<B-2,aux(15)=<B-2]
* Psum in Loop 24: [it(24)=<1,aux(10)=<B-2,aux(16)=<B-2]
* Psum in Loop 25: [it(25)=<1,aux(11)=<D-2,aux(17)=<D-2]
* Psum in Chain-Tail [20]: [it([20])=<1]

###### Computing sum for aux(13)=<B+D-4  in Loop 18 
   - Found a solution using cacheing 
 * Adding constraints: [aux(13)=<aux(22),aux(22)=<it(18)*aux(21),aux(22)+aux(8)+it(23)+it(24)+it(25)+it([20])=<it(22)+it(21)+aux(19),aux(22)+aux(8)=<it(22)+it(21)+aux(20)] 

##### Pending set part(A,B,C,D,E,F,G,H,I)
* Psum in Loop 19: [aux(14)=<B+D-4]
* Psum in Loop 22: [it(22)=<1]
* Psum in Loop 23: [it(23)=<1,aux(9)=<B-2,aux(15)=<B-2]
* Psum in Loop 24: [it(24)=<1,aux(10)=<B-2,aux(16)=<B-2]
* Psum in Loop 25: [it(25)=<1,aux(11)=<D-2,aux(17)=<D-2]
* Psum in Chain-Tail [20]: [it([20])=<1]

###### Computing sum for aux(14)=<B+D-4  in Loop 19 
   - Applying inductive sum strategy 
     - head Candidate: B+D 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: B+D-4 
       - The candidate was classified before. We reuse its previous classification 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(25)=<B+D-4] 
 * Adding constraints: [aux(14)=<it(19)*aux(25),aux(7)+aux(14)+it(23)+it(24)+it(25)+it([20])=<it(22)+it(21)+aux(23),aux(7)+aux(14)=<it(22)+it(21)+aux(24),aux(23)=<B+D,aux(24)=<B+D-4] 

##### Pending set part(A,B,C,D,E,F,G,H,I)
* Pmax/min: [aux(25)=<B+D-4]
* Psum in Loop 22: [it(22)=<1]
* Psum in Loop 23: [it(23)=<1,aux(9)=<B-2,aux(15)=<B-2]
* Psum in Loop 24: [it(24)=<1,aux(10)=<B-2,aux(16)=<B-2]
* Psum in Loop 25: [it(25)=<1,aux(11)=<D-2,aux(17)=<D-2]
* Psum in Chain-Tail [20]: [it([20])=<1]

###### Computing max_min for aux(25)=<B+D-4  
   - Found a solution using cacheing 
 * Adding constraints:[aux(25)=<aux(21)] 

##### Pending set part(A,B,C,D,E,F,G,H,I)
* Psum in Loop 22: [it(22)=<1]
* Psum in Loop 23: [it(23)=<1,aux(9)=<B-2,aux(15)=<B-2]
* Psum in Loop 24: [it(24)=<1,aux(10)=<B-2,aux(16)=<B-2]
* Psum in Loop 25: [it(25)=<1,aux(11)=<D-2,aux(17)=<D-2]
* Psum in Chain-Tail [20]: [it([20])=<1]

###### Computing sum for it(22)=<1  in Loop 22 
   - Applying inductive sum strategy 
     - head Candidate: F-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: F-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(21)+it(22)=<aux(11)+aux(10)+aux(9)+aux(8)+aux(7)+aux(26),it(21)+it(22)=<aux(17)+aux(16)+aux(15)+aux(14)+aux(13)+aux(27),aux(26)=<F-1,aux(27)=<F-1] 

##### Pending set part(A,B,C,D,E,F,G,H,I)
* Psum in Loop 23: [it(23)=<1,aux(9)=<B-2,aux(15)=<B-2]
* Psum in Loop 24: [it(24)=<1,aux(10)=<B-2,aux(16)=<B-2]
* Psum in Loop 25: [it(25)=<1,aux(11)=<D-2,aux(17)=<D-2]
* Psum in Chain-Tail [20]: [it([20])=<1]

###### Computing sum for it(23)=<1  in Loop 23 
   - Applying inductive sum strategy 
     - head Candidate: B-1 
       - Loop 18 is collaborative
       - Loop 19 is collaborative
       - Loop 21 is collaborative
       - Loop 22 adds a constant 1/1 
       - Loop 24 is collaborative and bounds [it(24)] 
       - Loop 25 is collaborative
       - Chain-Tail [20] is collaborative
     - head Candidate: B+F-2 
       - Loop 18 adds an expression [D-3]
       - Loop 19 adds an expression [D-3]
       - Loop 21 is collaborative
       - Loop 22 is collaborative
       - Loop 24 is collaborative and bounds [it(24)] 
       - Loop 25 adds an expression [D-2]
       - Chain-Tail [20] is collaborative
     - tail Candidate: B-1 
       - Loop 18 is collaborative
       - Loop 19 is collaborative
       - Loop 21 is collaborative
       - Loop 22 adds a constant 1/1 
       - Loop 24 is collaborative and bounds [it(24)] 
       - Loop 25 is collaborative
       - Chain-Tail [20] is collaborative
     - tail Candidate: B+F-2 
       - Loop 18 adds an expression [D-3]
       - Loop 19 adds an expression [D-3]
       - Loop 21 is collaborative
       - Loop 22 is collaborative
       - Loop 24 is collaborative and bounds [it(24)] 
       - Loop 25 adds an expression [D-2]
       - Chain-Tail [20] is collaborative
 * Adding constraints: [it(23)+it(24)=<it(22)+aux(28),it(23)+it(24)=<aux(31)+aux(30)+aux(29)+aux(32),it(23)+it(24)=<it(22)+aux(33),it(23)+it(24)=<aux(36)+aux(35)+aux(34)+aux(37),aux(28)=<B-1,aux(32)=<B+F-2,aux(33)=<B-1,aux(37)=<B+F-2] 

##### Pending set part(A,B,C,D,E,F,G,H,I)
* Psum in Loop 18: [aux(29)=<D-3,aux(34)=<D-3]
* Psum in Loop 19: [aux(30)=<D-3,aux(35)=<D-3]
* Psum in Loop 23: [aux(9)=<B-2,aux(15)=<B-2]
* Psum in Loop 24: [it(24)=<1,aux(10)=<B-2,aux(16)=<B-2]
* Psum in Loop 25: [it(25)=<1,aux(11)=<D-2,aux(17)=<D-2,aux(31)=<D-2,aux(36)=<D-2]
* Psum in Chain-Tail [20]: [it([20])=<1]

###### Computing sum for aux(29)=<D-3  in Loop 18 
   - Applying inductive sum strategy 
     - head Candidate: D-3 
       - Loop 19 is collaborative and bounds [aux(30)] 
       - Loop 21 adds a constant 1/1 
       - Loop 22 is collaborative
       - Loop 23 is collaborative
       - Loop 24 is collaborative
       - Loop 25 is collaborative
       - Chain [20] is ignored
     - head Candidate: D 
       - Loop 19 is collaborative and bounds [aux(30)] 
       - Loop 21 adds a constant 1/1 
       - Loop 22 is collaborative
       - Loop 23 is collaborative
       - Loop 24 is collaborative
       - Loop 25 is collaborative and bounds [it(25)] 
       - Chain-Tail [20] is collaborative and bounds [it([20])] 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(40)=<D-3] 
 * Adding constraints: [aux(29)=<it(18)*aux(40),aux(29)+aux(30)=<it(21)+aux(38),aux(29)+aux(30)+it(25)+it([20])=<it(21)+aux(39),aux(38)=<D-3,aux(39)=<D] 

##### Pending set part(A,B,C,D,E,F,G,H,I)
* Pmax/min: [aux(40)=<D-3]
* Psum in Loop 18: [aux(34)=<D-3]
* Psum in Loop 19: [aux(35)=<D-3]
* Psum in Loop 23: [aux(9)=<B-2,aux(15)=<B-2]
* Psum in Loop 24: [it(24)=<1,aux(10)=<B-2,aux(16)=<B-2]
* Psum in Loop 25: [it(25)=<1,aux(11)=<D-2,aux(17)=<D-2,aux(31)=<D-2,aux(36)=<D-2]
* Psum in Chain-Tail [20]: [it([20])=<1]

###### Computing max_min for aux(40)=<D-3  
   - Found a solution using transitive invariants 
 * Adding constraints:[aux(40)=<B+D+F-5,aux(40)=<B+2*D+4*F-10] 

##### Pending set part(A,B,C,D,E,F,G,H,I)
* Psum in Loop 18: [aux(34)=<D-3]
* Psum in Loop 19: [aux(35)=<D-3]
* Psum in Loop 23: [aux(9)=<B-2,aux(15)=<B-2]
* Psum in Loop 24: [it(24)=<1,aux(10)=<B-2,aux(16)=<B-2]
* Psum in Loop 25: [it(25)=<1,aux(11)=<D-2,aux(17)=<D-2,aux(31)=<D-2,aux(36)=<D-2]
* Psum in Chain-Tail [20]: [it([20])=<1]

###### Computing sum for aux(34)=<D-3  in Loop 18 
   - Found a solution using cacheing 
 * Adding constraints: [aux(34)=<aux(41),aux(41)=<it(18)*aux(40),aux(41)+aux(30)=<it(21)+aux(38),aux(41)+aux(30)+it(25)+it([20])=<it(21)+aux(39)] 

##### Pending set part(A,B,C,D,E,F,G,H,I)
* Psum in Loop 19: [aux(35)=<D-3]
* Psum in Loop 23: [aux(9)=<B-2,aux(15)=<B-2]
* Psum in Loop 24: [it(24)=<1,aux(10)=<B-2,aux(16)=<B-2]
* Psum in Loop 25: [it(25)=<1,aux(11)=<D-2,aux(17)=<D-2,aux(31)=<D-2,aux(36)=<D-2]
* Psum in Chain-Tail [20]: [it([20])=<1]

###### Computing sum for aux(35)=<D-3  in Loop 19 
   - Applying inductive sum strategy 
     - head Candidate: D-3 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: D 
       - The candidate was classified before. We reuse its previous classification 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(44)=<D-3] 
 * Adding constraints: [aux(35)=<it(19)*aux(44),aux(29)+aux(35)=<it(21)+aux(42),aux(29)+aux(35)+it(25)+it([20])=<it(21)+aux(43),aux(42)=<D-3,aux(43)=<D] 

##### Pending set part(A,B,C,D,E,F,G,H,I)
* Pmax/min: [aux(44)=<D-3]
* Psum in Loop 23: [aux(9)=<B-2,aux(15)=<B-2]
* Psum in Loop 24: [it(24)=<1,aux(10)=<B-2,aux(16)=<B-2]
* Psum in Loop 25: [it(25)=<1,aux(11)=<D-2,aux(17)=<D-2,aux(31)=<D-2,aux(36)=<D-2]
* Psum in Chain-Tail [20]: [it([20])=<1]

###### Computing max_min for aux(44)=<D-3  
   - Found a solution using cacheing 
 * Adding constraints:[aux(44)=<aux(40)] 

##### Pending set part(A,B,C,D,E,F,G,H,I)
* Psum in Loop 23: [aux(9)=<B-2,aux(15)=<B-2]
* Psum in Loop 24: [it(24)=<1,aux(10)=<B-2,aux(16)=<B-2]
* Psum in Loop 25: [it(25)=<1,aux(11)=<D-2,aux(17)=<D-2,aux(31)=<D-2,aux(36)=<D-2]
* Psum in Chain-Tail [20]: [it([20])=<1]

###### Computing sum for aux(9)=<B-2  in Loop 23 
   - Applying inductive sum strategy 
     - head Candidate: B-2 
       - Loop 18 is collaborative
       - Loop 19 is collaborative
       - Loop 21 is collaborative
       - Loop 22 adds a constant 1/1 
       - Loop 24 is collaborative and bounds [aux(10)] 
       - Loop 25 is collaborative
       - Chain [20] is ignored
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(46)=<B-2] 
 * Adding constraints: [aux(9)=<it(23)*aux(46),aux(9)+aux(10)=<it(22)+aux(45),aux(45)=<B-2] 

##### Pending set part(A,B,C,D,E,F,G,H,I)
* Pmax/min: [aux(46)=<B-2]
* Psum in Loop 23: [aux(15)=<B-2]
* Psum in Loop 24: [it(24)=<1,aux(16)=<B-2]
* Psum in Loop 25: [it(25)=<1,aux(11)=<D-2,aux(17)=<D-2,aux(31)=<D-2,aux(36)=<D-2]
* Psum in Chain-Tail [20]: [it([20])=<1]

###### Computing max_min for aux(46)=<B-2  
   - Found a solution using transitive invariants 
 * Adding constraints:[aux(46)=<B+D+F-4,aux(46)=<2*B+D+4*F-9] 

##### Pending set part(A,B,C,D,E,F,G,H,I)
* Psum in Loop 23: [aux(15)=<B-2]
* Psum in Loop 24: [it(24)=<1,aux(16)=<B-2]
* Psum in Loop 25: [it(25)=<1,aux(11)=<D-2,aux(17)=<D-2,aux(31)=<D-2,aux(36)=<D-2]
* Psum in Chain-Tail [20]: [it([20])=<1]

###### Computing sum for aux(15)=<B-2  in Loop 23 
   - Found a solution using cacheing 
 * Adding constraints: [aux(15)=<aux(47),aux(47)=<it(23)*aux(46),aux(47)+aux(10)=<it(22)+aux(45)] 

##### Pending set part(A,B,C,D,E,F,G,H,I)
* Psum in Loop 24: [it(24)=<1,aux(16)=<B-2]
* Psum in Loop 25: [it(25)=<1,aux(11)=<D-2,aux(17)=<D-2,aux(31)=<D-2,aux(36)=<D-2]
* Psum in Chain-Tail [20]: [it([20])=<1]

###### Computing sum for it(24)=<1  in Loop 24 
   - Applying inductive sum strategy 
     - head Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: B+F-2 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B+F-2 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(23)+it(24)=<it(22)+aux(48),it(23)+it(24)=<aux(31)+aux(30)+aux(29)+aux(49),it(23)+it(24)=<it(22)+aux(50),it(23)+it(24)=<aux(36)+aux(35)+aux(34)+aux(51),aux(48)=<B-1,aux(49)=<B+F-2,aux(50)=<B-1,aux(51)=<B+F-2] 

##### Pending set part(A,B,C,D,E,F,G,H,I)
* Psum in Loop 24: [aux(16)=<B-2]
* Psum in Loop 25: [it(25)=<1,aux(11)=<D-2,aux(17)=<D-2,aux(31)=<D-2,aux(36)=<D-2]
* Psum in Chain-Tail [20]: [it([20])=<1]

###### Computing sum for aux(16)=<B-2  in Loop 24 
   - Applying inductive sum strategy 
     - head Candidate: B-2 
       - The candidate was classified before. We reuse its previous classification 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(53)=<B-2] 
 * Adding constraints: [aux(16)=<it(24)*aux(53),aux(9)+aux(16)=<it(22)+aux(52),aux(52)=<B-2] 

##### Pending set part(A,B,C,D,E,F,G,H,I)
* Pmax/min: [aux(53)=<B-2]
* Psum in Loop 25: [it(25)=<1,aux(11)=<D-2,aux(17)=<D-2,aux(31)=<D-2,aux(36)=<D-2]
* Psum in Chain-Tail [20]: [it([20])=<1]

###### Computing max_min for aux(53)=<B-2  
   - Found a solution using cacheing 
 * Adding constraints:[aux(53)=<aux(46)] 

##### Pending set part(A,B,C,D,E,F,G,H,I)
* Psum in Loop 25: [it(25)=<1,aux(11)=<D-2,aux(17)=<D-2,aux(31)=<D-2,aux(36)=<D-2]
* Psum in Chain-Tail [20]: [it([20])=<1]

###### Computing sum for it(25)=<1  in Loop 25 
   - Applying inductive sum strategy 
     - head Candidate: D-1 
       - Loop 18 is collaborative
       - Loop 19 is collaborative
       - Loop 21 adds a constant 1/1 
       - Loop 22 is collaborative
       - Loop 23 is collaborative
       - Loop 24 is collaborative
       - Chain-Tail [20] is collaborative
     - head Candidate: D+F-2 
       - Loop 18 adds an expression [B-3]
       - Loop 19 adds an expression [B-3]
       - Loop 21 is collaborative
       - Loop 22 is collaborative
       - Loop 23 adds an expression [B-2]
       - Loop 24 adds an expression [B-2]
       - Chain-Tail [20] is collaborative
     - tail Candidate: D-1 
       - Loop 18 is collaborative
       - Loop 19 is collaborative
       - Loop 21 adds a constant 1/1 
       - Loop 22 is collaborative
       - Loop 23 is collaborative
       - Loop 24 is collaborative
       - Chain-Tail [20] is collaborative
     - tail Candidate: D+F-2 
       - Loop 18 adds an expression [B-3]
       - Loop 19 adds an expression [B-3]
       - Loop 21 is collaborative
       - Loop 22 is collaborative
       - Loop 23 adds an expression [B-2]
       - Loop 24 adds an expression [B-2]
       - Chain-Tail [20] is collaborative
 * Adding constraints: [it(25)=<it(21)+aux(54),it(25)=<aux(58)+aux(57)+aux(56)+aux(55)+aux(59),it(25)=<it(21)+aux(60),it(25)=<aux(64)+aux(63)+aux(62)+aux(61)+aux(65),aux(54)=<D-1,aux(59)=<D+F-2,aux(60)=<D-1,aux(65)=<D+F-2] 

##### Pending set part(A,B,C,D,E,F,G,H,I)
* Psum in Loop 18: [aux(55)=<B-3,aux(61)=<B-3]
* Psum in Loop 19: [aux(56)=<B-3,aux(62)=<B-3]
* Psum in Loop 23: [aux(57)=<B-2,aux(63)=<B-2]
* Psum in Loop 24: [aux(58)=<B-2,aux(64)=<B-2]
* Psum in Loop 25: [aux(11)=<D-2,aux(17)=<D-2,aux(31)=<D-2,aux(36)=<D-2]
* Psum in Chain-Tail [20]: [it([20])=<1]

###### Computing sum for aux(55)=<B-3  in Loop 18 
   - Applying inductive sum strategy 
     - head Candidate: B-3 
       - Loop 19 is collaborative and bounds [aux(56)] 
       - Loop 21 is collaborative
       - Loop 22 adds a constant 1/1 
       - Loop 23 is collaborative
       - Loop 24 is collaborative
       - Loop 25 is collaborative
       - Chain [20] is ignored
     - head Candidate: B 
       - Loop 19 is collaborative and bounds [aux(56)] 
       - Loop 21 is collaborative
       - Loop 22 adds a constant 1/1 
       - Loop 23 is collaborative and bounds [aux(57)] 
       - Loop 24 is collaborative and bounds [aux(58)] 
       - Loop 25 is collaborative
       - Chain-Tail [20] is collaborative and bounds [it([20])] 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(68)=<B-3] 
 * Adding constraints: [aux(55)=<it(18)*aux(68),aux(55)+aux(56)=<it(22)+aux(66),aux(55)+aux(56)+aux(57)+aux(58)+it([20])=<it(22)+aux(67),aux(66)=<B-3,aux(67)=<B] 

##### Pending set part(A,B,C,D,E,F,G,H,I)
* Pmax/min: [aux(68)=<B-3]
* Psum in Loop 18: [aux(61)=<B-3]
* Psum in Loop 19: [aux(62)=<B-3]
* Psum in Loop 23: [aux(57)=<B-2,aux(63)=<B-2]
* Psum in Loop 24: [aux(58)=<B-2,aux(64)=<B-2]
* Psum in Loop 25: [aux(11)=<D-2,aux(17)=<D-2,aux(31)=<D-2,aux(36)=<D-2]
* Psum in Chain-Tail [20]: [it([20])=<1]

###### Computing max_min for aux(68)=<B-3  
   - Found a solution using cacheing 
 * Adding constraints:[aux(68)=<aux(46)-1] 

##### Pending set part(A,B,C,D,E,F,G,H,I)
* Psum in Loop 18: [aux(61)=<B-3]
* Psum in Loop 19: [aux(62)=<B-3]
* Psum in Loop 23: [aux(57)=<B-2,aux(63)=<B-2]
* Psum in Loop 24: [aux(58)=<B-2,aux(64)=<B-2]
* Psum in Loop 25: [aux(11)=<D-2,aux(17)=<D-2,aux(31)=<D-2,aux(36)=<D-2]
* Psum in Chain-Tail [20]: [it([20])=<1]

###### Computing sum for aux(61)=<B-3  in Loop 18 
   - Found a solution using cacheing 
 * Adding constraints: [aux(61)=<aux(69),aux(69)=<it(18)*aux(68),aux(69)+aux(56)=<it(22)+aux(66),aux(69)+aux(56)+aux(57)+aux(58)+it([20])=<it(22)+aux(67)] 

##### Pending set part(A,B,C,D,E,F,G,H,I)
* Psum in Loop 19: [aux(62)=<B-3]
* Psum in Loop 23: [aux(57)=<B-2,aux(63)=<B-2]
* Psum in Loop 24: [aux(58)=<B-2,aux(64)=<B-2]
* Psum in Loop 25: [aux(11)=<D-2,aux(17)=<D-2,aux(31)=<D-2,aux(36)=<D-2]
* Psum in Chain-Tail [20]: [it([20])=<1]

###### Computing sum for aux(62)=<B-3  in Loop 19 
   - Applying inductive sum strategy 
     - head Candidate: B-3 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: B 
       - The candidate was classified before. We reuse its previous classification 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(72)=<B-3] 
 * Adding constraints: [aux(62)=<it(19)*aux(72),aux(55)+aux(62)=<it(22)+aux(70),aux(55)+aux(57)+aux(58)+aux(62)+it([20])=<it(22)+aux(71),aux(70)=<B-3,aux(71)=<B] 

##### Pending set part(A,B,C,D,E,F,G,H,I)
* Pmax/min: [aux(72)=<B-3]
* Psum in Loop 23: [aux(57)=<B-2,aux(63)=<B-2]
* Psum in Loop 24: [aux(58)=<B-2,aux(64)=<B-2]
* Psum in Loop 25: [aux(11)=<D-2,aux(17)=<D-2,aux(31)=<D-2,aux(36)=<D-2]
* Psum in Chain-Tail [20]: [it([20])=<1]

###### Computing max_min for aux(72)=<B-3  
   - Found a solution using cacheing 
 * Adding constraints:[aux(72)=<aux(46)-1] 

##### Pending set part(A,B,C,D,E,F,G,H,I)
* Psum in Loop 23: [aux(57)=<B-2,aux(63)=<B-2]
* Psum in Loop 24: [aux(58)=<B-2,aux(64)=<B-2]
* Psum in Loop 25: [aux(11)=<D-2,aux(17)=<D-2,aux(31)=<D-2,aux(36)=<D-2]
* Psum in Chain-Tail [20]: [it([20])=<1]

###### Computing sum for aux(57)=<B-2  in Loop 23 
   - Found a solution using cacheing 
 * Adding constraints: [aux(57)=<aux(73),aux(73)=<it(23)*aux(46),aux(73)+aux(10)=<it(22)+aux(45)] 

##### Pending set part(A,B,C,D,E,F,G,H,I)
* Psum in Loop 23: [aux(63)=<B-2]
* Psum in Loop 24: [aux(58)=<B-2,aux(64)=<B-2]
* Psum in Loop 25: [aux(11)=<D-2,aux(17)=<D-2,aux(31)=<D-2,aux(36)=<D-2]
* Psum in Chain-Tail [20]: [it([20])=<1]

###### Computing sum for aux(63)=<B-2  in Loop 23 
   - Found a solution using cacheing 
 * Adding constraints: [aux(63)=<aux(74),aux(74)=<it(23)*aux(46),aux(74)+aux(10)=<it(22)+aux(45)] 

##### Pending set part(A,B,C,D,E,F,G,H,I)
* Psum in Loop 24: [aux(58)=<B-2,aux(64)=<B-2]
* Psum in Loop 25: [aux(11)=<D-2,aux(17)=<D-2,aux(31)=<D-2,aux(36)=<D-2]
* Psum in Chain-Tail [20]: [it([20])=<1]

###### Computing sum for aux(58)=<B-2  in Loop 24 
   - Found a solution using cacheing 
 * Adding constraints: [aux(58)=<aux(75),aux(75)=<it(24)*aux(53),aux(75)+aux(9)=<it(22)+aux(52)] 

##### Pending set part(A,B,C,D,E,F,G,H,I)
* Psum in Loop 24: [aux(64)=<B-2]
* Psum in Loop 25: [aux(11)=<D-2,aux(17)=<D-2,aux(31)=<D-2,aux(36)=<D-2]
* Psum in Chain-Tail [20]: [it([20])=<1]

###### Computing sum for aux(64)=<B-2  in Loop 24 
   - Found a solution using cacheing 
 * Adding constraints: [aux(64)=<aux(76),aux(76)=<it(24)*aux(53),aux(76)+aux(9)=<it(22)+aux(52)] 

##### Pending set part(A,B,C,D,E,F,G,H,I)
* Psum in Loop 25: [aux(11)=<D-2,aux(17)=<D-2,aux(31)=<D-2,aux(36)=<D-2]
* Psum in Chain-Tail [20]: [it([20])=<1]

###### Computing sum for aux(11)=<D-2  in Loop 25 
   - Applying inductive sum strategy 
     - head Candidate: D-2 
       - Loop 18 is collaborative
       - Loop 19 is collaborative
       - Loop 21 adds a constant 1/1 
       - Loop 22 is collaborative
       - Loop 23 is collaborative
       - Loop 24 is collaborative
       - Chain [20] is ignored
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(78)=<D-2] 
 * Adding constraints: [aux(11)=<it(25)*aux(78),aux(11)=<it(21)+aux(77),aux(77)=<D-2] 

##### Pending set part(A,B,C,D,E,F,G,H,I)
* Pmax/min: [aux(78)=<D-2]
* Psum in Loop 25: [aux(17)=<D-2,aux(31)=<D-2,aux(36)=<D-2]
* Psum in Chain-Tail [20]: [it([20])=<1]

###### Computing max_min for aux(78)=<D-2  
   - Found a solution using cacheing 
 * Adding constraints:[aux(78)=<aux(40)+1] 

##### Pending set part(A,B,C,D,E,F,G,H,I)
* Psum in Loop 25: [aux(17)=<D-2,aux(31)=<D-2,aux(36)=<D-2]
* Psum in Chain-Tail [20]: [it([20])=<1]

###### Computing sum for aux(17)=<D-2  in Loop 25 
   - Found a solution using cacheing 
 * Adding constraints: [aux(17)=<aux(79),aux(79)=<it(25)*aux(78),aux(79)=<it(21)+aux(77)] 

##### Pending set part(A,B,C,D,E,F,G,H,I)
* Psum in Loop 25: [aux(31)=<D-2,aux(36)=<D-2]
* Psum in Chain-Tail [20]: [it([20])=<1]

###### Computing sum for aux(31)=<D-2  in Loop 25 
   - Found a solution using cacheing 
 * Adding constraints: [aux(31)=<aux(80),aux(80)=<it(25)*aux(78),aux(80)=<it(21)+aux(77)] 

##### Pending set part(A,B,C,D,E,F,G,H,I)
* Psum in Loop 25: [aux(36)=<D-2]
* Psum in Chain-Tail [20]: [it([20])=<1]

###### Computing sum for aux(36)=<D-2  in Loop 25 
   - Found a solution using cacheing 
 * Adding constraints: [aux(36)=<aux(81),aux(81)=<it(25)*aux(78),aux(81)=<it(21)+aux(77)] 

##### Pending set part(A,B,C,D,E,F,G,H,I)
* Psum in Chain-Tail [20]: [it([20])=<1]

###### Computing sum for it([20])=<1  in Chain-Tail [20] 
   - Applying inductive sum strategy 
     - head Candidate: B/2+D/2+F/2-1/2 
       - Loop 18 is collaborative
       - Loop 19 is collaborative
       - Loop 21 is collaborative
       - Loop 22 is collaborative
       - Loop 23 is collaborative
       - Loop 24 is collaborative
       - Loop 25 is collaborative
     - head Candidate: B 
       - Loop 18 is collaborative
       - Loop 19 is collaborative
       - Loop 21 is collaborative
       - Loop 22 adds a constant 1/1 
       - Loop 23 is collaborative
       - Loop 24 is collaborative
       - Loop 25 is collaborative
 * Adding constraints: [it([20])=<it(22)+aux(82),it([20])=<B/2+D/2+F/2-1/2,aux(82)=<B] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [18,19,21,22,23,24,25,[20]] 
Found a cycle in the non-final constraints
 Removed possibly redundant constraints to solve a cycle in the cost structure 
it([20])=<it(22)+aux(82)
Found a cycle in the non-final constraints
Could not solve cycle in cost structure.
 Discarded constraints:  
aux(81)=<it(21)+aux(77)
aux(81)=<it(25)*aux(78)
aux(36)=<aux(81)
aux(80)=<it(21)+aux(77)
aux(80)=<it(25)*aux(78)
aux(31)=<aux(80)
aux(79)=<it(21)+aux(77)
aux(79)=<it(25)*aux(78)
aux(17)=<aux(79)
aux(11)=<it(21)+aux(77)
aux(11)=<it(25)*aux(78)
aux(9)+aux(76)=<it(22)+aux(52)
aux(76)=<it(24)*aux(53)
aux(64)=<aux(76)
aux(9)+aux(75)=<it(22)+aux(52)
aux(75)=<it(24)*aux(53)
aux(58)=<aux(75)
aux(10)+aux(74)=<it(22)+aux(45)
aux(74)=<it(23)*aux(46)
aux(63)=<aux(74)
aux(10)+aux(73)=<it(22)+aux(45)
aux(73)=<it(23)*aux(46)
aux(57)=<aux(73)
aux(55)+aux(57)+aux(58)+aux(62)+it([20])=<it(22)+aux(71)
aux(55)+aux(62)=<it(22)+aux(70)
aux(62)=<it(19)*aux(72)
aux(56)+aux(57)+aux(58)+aux(69)+it([20])=<it(22)+aux(67)
aux(56)+aux(69)=<it(22)+aux(66)
aux(69)=<it(18)*aux(68)
aux(61)=<aux(69)
aux(55)+aux(56)+aux(57)+aux(58)+it([20])=<it(22)+aux(67)
aux(55)+aux(56)=<it(22)+aux(66)
aux(55)=<it(18)*aux(68)
it(25)=<aux(64)+aux(63)+aux(62)+aux(61)+aux(65)
it(25)=<it(21)+aux(60)
it(25)=<aux(58)+aux(57)+aux(56)+aux(55)+aux(59)
it(25)=<it(21)+aux(54)
aux(9)+aux(16)=<it(22)+aux(52)
aux(16)=<it(24)*aux(53)
it(23)+it(24)=<aux(36)+aux(35)+aux(34)+aux(51)
it(23)+it(24)=<it(22)+aux(50)
it(23)+it(24)=<aux(31)+aux(30)+aux(29)+aux(49)
it(23)+it(24)=<it(22)+aux(48)
aux(10)+aux(47)=<it(22)+aux(45)
aux(47)=<it(23)*aux(46)
aux(15)=<aux(47)
aux(9)+aux(10)=<it(22)+aux(45)
aux(9)=<it(23)*aux(46)
aux(29)+aux(35)+it(25)+it([20])=<it(21)+aux(43)
aux(29)+aux(35)=<it(21)+aux(42)
aux(35)=<it(19)*aux(44)
aux(30)+aux(41)+it(25)+it([20])=<it(21)+aux(39)
aux(30)+aux(41)=<it(21)+aux(38)
aux(41)=<it(18)*aux(40)
aux(34)=<aux(41)
aux(29)+aux(30)+it(25)+it([20])=<it(21)+aux(39)
aux(29)+aux(30)=<it(21)+aux(38)
aux(29)=<it(18)*aux(40)
it(23)+it(24)=<aux(36)+aux(35)+aux(34)+aux(37)
it(23)+it(24)=<it(22)+aux(33)
it(23)+it(24)=<aux(31)+aux(30)+aux(29)+aux(32)
it(23)+it(24)=<it(22)+aux(28)
it(21)+it(22)=<aux(17)+aux(16)+aux(15)+aux(14)+aux(13)+aux(27)
it(21)+it(22)=<aux(11)+aux(10)+aux(9)+aux(8)+aux(7)+aux(26)
aux(7)+aux(14)=<it(22)+it(21)+aux(24)
aux(7)+aux(14)+it(23)+it(24)+it(25)+it([20])=<it(22)+it(21)+aux(23)
aux(14)=<it(19)*aux(25)
aux(8)+aux(22)=<it(22)+it(21)+aux(20)
aux(8)+aux(22)+it(23)+it(24)+it(25)+it([20])=<it(22)+it(21)+aux(19)
aux(22)=<it(18)*aux(21)
aux(13)=<aux(22)
aux(7)+aux(8)=<it(22)+it(21)+aux(20)
aux(7)+aux(8)+it(23)+it(24)+it(25)+it([20])=<it(22)+it(21)+aux(19)
aux(7)=<it(18)*aux(21)
it(21)+it(22)=<aux(17)+aux(16)+aux(15)+aux(14)+aux(13)+aux(18)
it(21)+it(22)=<aux(11)+aux(10)+aux(9)+aux(8)+aux(7)+aux(12)
it(18)+it(19)+it(23)+it(24)=<it(22)+aux(6)

#### Simplifying cost structure of phase [18,19,21,22,23,24,25,[20]] 
 * Joined equivalent variables [aux(83),aux(6),aux(28),aux(33),aux(45),aux(48),aux(50),aux(52),aux(66),aux(67),aux(70),aux(71),aux(82)] into aux(83)
 * Joined equivalent variables [aux(84),aux(19),aux(20),aux(23),aux(24)] into aux(84)
 * Joined equivalent variables [aux(86),aux(32),aux(37),aux(49),aux(51)] into aux(86)
 * Joined equivalent variables [aux(88),aux(38),aux(39),aux(42),aux(43),aux(54),aux(60),aux(77)] into aux(88)
 * Joined equivalent variables [aux(89),aux(59),aux(65)] into aux(89)
 * Joined equivalent variables [aux(90),aux(12),aux(18),aux(26),aux(27)] into aux(90)
 * Joined equivalent variables [aux(68),aux(72)] into aux(68)
 * Joined equivalent variables [it(21),it(22),it(23),it(24),it(25),s(7),s(8)] into it(21)
 * Joined equivalent variables [it(18),it(19),it([20])] into it(18)

#### Cost of phase [18,19,21,22,23,24,25]:part(A,B,C,D,E,F,G,H,I) -> [] 
54*it(18)+85*it(21)+0
  Such that:aux(87) =< B/2+D/2+F/2
it(18) =< aux(87)

Unbounded itvars
it(21) :  it(21)

#### Cost of chains of part(A,B,C,D,E,F,G,H,I):
* Chain [multiple([18,19,21,22,23,24,25],[[],[20]])]...: 54*it(18)+85*it(21)+0
  Such that:aux(87) =< B/2+D/2+F/2
it(18) =< aux(87)

Unbounded itvars
it(21) :  it(21)

  with precondition: [B+D>=1,D>=0,A+D>=1,D+F>=2,B+F>=2,F>=1,B>=0,A>=0,H>=0,H+2*F>=4,B+D+2*F>=5,G>=0,E>=0,C>=0,I>=0] 

* Chain [20]: 14
  with precondition: [B=1,D=1,F=1,H=2,A>=0,C>=0,E>=0,G>=0,I>=A] 

 * Renamed intermediate variables: 
[ (eq(27,1),aux(87))>>s(9), (eq(27,1),it(18))>>s(10), (eq(27,1),it(21))>>s(11)]

#### Simplifying cost structure of CE 27 

#### Simplifying cost structure of CE 28 

#### Simplifying cost structure of CE 26 

#### Cost of chains of qs(A,B,C,D):
* Chain [28]...: 54*s(10)+85*s(11)+6
  Such that:s(9) =< A/2+1/2
s(10) =< s(9)

Unbounded itvars
s(11) :  eq(27,1),it(21)

  with precondition: [B>=0,C>=0,D>=0,2*A>=5,C+2*A>=6] 

* Chain [27]: 3
  with precondition: [A=1,C=1,B>=0,D>=0] 

* Chain [26]: 20
  with precondition: [A=2,C=2,B>=0,D>=0] 


Closed-form bounds of append(A,B,C,D,E,F,G,H,I,J,K,L): 
-------------------------------------
* Chain [[15,16],17] with precondition: [A=C,A+E=I+1,A+G=K+1,A>=2,B>=0,D>=1,E>=1,F>=0,G>=1,H>=0,L>=1,J>=F,L>=H,D+H>=L] 
    - Upper bound: 10*A+2 
    - Complexity: n 
* Chain [17] with precondition: [A=1,C=1,D=0,E=I,F=J,G=K,H=L,B>=0,E>=0,F>=0,G>=0,H>=0] 
    - Upper bound: 2 
    - Complexity: constant 

### Maximum cost of append(A,B,C,D,E,F,G,H,I,J,K,L): 10*A+2 
Asymptotic class: n 

Closed-form bounds of part(A,B,C,D,E,F,G,H,I): 
-------------------------------------
* Chain [multiple([18,19,21,22,23,24,25],[[],[20]])]... with precondition: [B+D>=1,D>=0,A+D>=1,D+F>=2,B+F>=2,F>=1,B>=0,A>=0,H>=0,H+2*F>=4,B+D+2*F>=5,G>=0,E>=0,C>=0,I>=0] 
    - Upper bound: inf 
    - Complexity: infinity 
* Chain [20] with precondition: [B=1,D=1,F=1,H=2,A>=0,C>=0,E>=0,G>=0,I>=A] 
    - Upper bound: 14 
    - Complexity: constant 

### Maximum cost of part(A,B,C,D,E,F,G,H,I): inf 
Asymptotic class: infinity 

Closed-form bounds of qs(A,B,C,D): 
-------------------------------------
* Chain [28]... with precondition: [B>=0,C>=0,D>=0,2*A>=5,C+2*A>=6] 
    - Upper bound: inf 
    - Complexity: infinity 
* Chain [27] with precondition: [A=1,C=1,B>=0,D>=0] 
    - Upper bound: 3 
    - Complexity: constant 
* Chain [26] with precondition: [A=2,C=2,B>=0,D>=0] 
    - Upper bound: 20 
    - Complexity: constant 

### Maximum cost of qs(A,B,C,D): inf 
Asymptotic class: infinity 
* Total analysis performed in 2692 ms.


Cost relation system solved by CoFloCo in 2694 ms.

Method append terminates?: YES

 - l1_1: size of l1 wrt. List<Rat>
 - l1_2: size of l1 wrt. Rat
 - l1_3: size of l1 wrt. List<A>
 - l1_4: size of l1 wrt. A
 - l2_1: size of l2 wrt. List<Rat>
 - l2_2: size of l2 wrt. Rat
 - l2_3: size of l2 wrt. List<A>
 - l2_4: size of l2 wrt. A
UB for append(l1_1,l1_2,l1_3,l1_4,l2_1,l2_2,l2_3,l2_4) = 10*l1_1+2

Method part terminates?: YES

 - y_1: size of y wrt. Rat
 - l_1: size of l wrt. List<Rat>
 - l_2: size of l wrt. Rat
 - r_1: size of r wrt. List<Rat>
 - r_2: size of r wrt. Rat
 - xs_1: size of xs wrt. List<Rat>
 - xs_2: size of xs wrt. Rat
UB for part(y_1,l_1,l_2,r_1,r_2,xs_1,xs_2) = inf

Method qs terminates?: YES

 - l_1: size of l wrt. List<Rat>
 - l_2: size of l wrt. Rat
UB for qs(l_1,l_2) = inf
