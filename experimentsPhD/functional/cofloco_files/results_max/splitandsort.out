
Abs program loaded in 17 ms.

Rule based representation generated in 3 ms.

Rule based representation stored in /tmp/costabs/rbr.rbr

RBR properties stored in /tmp/costabs/rbr.properties

Class invariants generated and loaded in 0 ms.

Abstract compilation performed in 20 ms.

Cost relation system stored in /tmp/costabs/crs.crs

Generated 49 equations 
entry('insertL'(A,B,C,D,E,F,G,H,I,J):[]).
entry('split'(A,B,C,D,E,F,G):[]).
entry('splitqs'(A,B,C,D,E,F):[]).
entry('append'(A,B,C,D,E,F,G,H,I,J,K,L):[]).
entry('quicksort'(A,B,C,D):[]).
entry('sortAll'(A,B,C,D,E,F,G,H):[]).
entry('splitAndSort'(A,B,C,D,E,F,G):[]).
input_output_vars('and_op'(A,B,C),[A,B],[C]).
input_output_vars('append'(A,B,C,D,E,F,G,H,I,J,K,L),[A,B,C,D,E,F,G,H],[I,J,K,L]).
input_output_vars('case_0'(A,B,C,D,E,F,G,H,I,J),[A,B,C,D,E,F],[G,H,I,J]).
input_output_vars('case_1'(A,B,C,D,E,F,G,H,I,J,K,L),[A,B,C,D,E,F,G,H],[I,J,K,L]).
input_output_vars('case_10'(A,B,C,D,E,F,G,H,I,J),[A,B,C,D,E,F,G,H],[I,J]).
input_output_vars('case_11'(A,B,C,D,E,F,G,H),[A,B,C,D],[E,F,G,H]).
input_output_vars('case_2'(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S),[A,B,C,D,E,F,G,H,I,J,K,L,M,N,O],[P,Q,R,S]).
input_output_vars('case_3'(A,B,C,D,E,F,G),[A,B,C],[D,E,F,G]).
input_output_vars('case_4'(A,B,C,D,E,F),[A,B,C],[D,E,F]).
input_output_vars('case_5'(A,B,C,D,E,F,G,H,I),[A,B,C,D,E,F],[G,H,I]).
input_output_vars('case_6'(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O),[A,B,C,D,E,F,G,H,I,J,K,L],[M,N,O]).
input_output_vars('case_7'(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S),[A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P],[Q,R,S]).
input_output_vars('case_8'(A,B,C,D,E,F,G,H,I,J,K,L),[A,B,C,D,E,F,G,H],[I,J,K,L]).
input_output_vars('case_9'(A,B,C,D),[A,B],[C,D]).
input_output_vars('eq'(A,B,C),[A,B],[C]).
input_output_vars('geq'(A,B,C),[A,B],[C]).
input_output_vars('gt'(A,B,C),[A,B],[C]).
input_output_vars('insertL'(A,B,C,D,E,F,G,H,I,J),[A,B,C,D,E,F],[G,H,I,J]).
input_output_vars('leq'(A,B,C),[A,B],[C]).
input_output_vars('lt'(A,B,C),[A,B],[C]).
input_output_vars('maxNorm'(A,B,C),[A,B],[C]).
input_output_vars('neg'(A,B),[A],[B]).
input_output_vars('neq'(A,B,C),[A,B],[C]).
input_output_vars('or'(A,B,C),[A,B],[C]).
input_output_vars('quicksort'(A,B,C,D),[A,B],[C,D]).
input_output_vars('sortAll'(A,B,C,D,E,F,G,H),[A,B,C,D],[E,F,G,H]).
input_output_vars('split'(A,B,C,D,E,F,G),[A,B,C],[D,E,F,G]).
input_output_vars('splitAndSort'(A,B,C,D,E,F,G),[A,B,C],[D,E,F,G]).
input_output_vars('splitqs'(A,B,C,D,E,F),[A,B,C],[D,E,F]).
eq('eq',[A,B,C],0,[],[A=B,C=1,A>=0,B>=0,C>=0]).
eq('eq',[A,B,C],0,[],[A>=B+1,C=0,A>=0,B>=0,C>=0]).
eq('eq',[A,B,C],0,[],[B>=A+1,C=0,A>=0,B>=0,C>=0]).
eq('neq',[A,B,C],0,[],[A=B,C=0,A>=0,B>=0,C>=0]).
eq('neq',[A,B,C],0,[],[A>=B+1,C=1,A>=0,B>=0,C>=0]).
eq('neq',[A,B,C],0,[],[B>=A+1,C=1,A>=0,B>=0,C>=0]).
eq('lt',[A,B,C],0,[],[B-A>=1,C=1,A>=0,B>=0,C>=0]).
eq('lt',[A,B,C],0,[],[B=<A,C=0,A>=0,B>=0,C>=0]).
eq('leq',[A,B,C],0,[],[A=<B,C=1,A>=0,B>=0,C>=0]).
eq('leq',[A,B,C],0,[],[A-B>=1,C=0,A>=0,B>=0,C>=0]).
eq('gt',[A,B,C],0,[],[A-B>=1,C=1,A>=0,B>=0,C>=0]).
eq('gt',[A,B,C],0,[],[A=<B,C=0,A>=0,B>=0,C>=0]).
eq('geq',[A,B,C],0,[],[B=<A,C=1,A>=0,B>=0,C>=0]).
eq('geq',[A,B,C],0,[],[B-A>=1,C=0,A>=0,B>=0,C>=0]).
eq('neg',[A,B],0,[],[A=0,B=1,A>=0,B>=0]).
eq('neg',[A,B],0,[],[A=1,B=0,A>=0,B>=0]).
eq('and_op',[A,B,C],0,[],[A=0,C=0,A>=0,B>=0,C>=0]).
eq('and_op',[A,B,C],0,[],[A=1,C=B,A>=0,B>=0,C>=0]).
eq('or',[A,B,C],0,[],[A=1,C=1,A>=0,B>=0,C>=0]).
eq('or',[A,B,C],0,[],[A=0,C=B,A>=0,B>=0,C>=0]).
eq('maxNorm',[A,B,A],0,[],[A>=1+B,A>=0,B>=0,A>=0]).
eq('maxNorm',[A,B,B],0,[],[A=<B,A>=0,B>=0,B>=0]).
eq('case_1',[A,B,C,D,E,F,G,H,I,J,K,L],6,['maxNorm'(M,N,K),'maxNorm'(O,P,I)],[E=0,D=1,C=0,Q=1,R>=G,R>=S,T=Q+1,Q>=1,U>=R,U>=H,M=T,O=1,T>=1,N=0,V=1,P=0,L>=U,L>=W,J=V+1,V>=1,O>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0]).
eq('case_2',[A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S],4,['maxNorm'(T,N,R),'maxNorm'(U,L,P)],[K=H,V>=G,V>=J,W=I+1,I>=1,X>=V,X>=K,T=W,U=1,W>=1,S>=X,S>=O,Q=M+1,M>=1,U>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0,M>=0,N>=0,O>=0,P>=0,Q>=0,R>=0,S>=0]).
eq('case_2',[A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S],4,['insertL'(A,B,L,M,N,O,T,U,V,W),'maxNorm'(X,V,R),'maxNorm'(Y,T,P)],[K>=H+1,Z>=J,Z>=K,X=I,Y=1,I>=1,S>=Z,S>=W,Q=U+1,U>=1,Y>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0,M>=0,N>=0,O>=0,P>=0,Q>=0,R>=0,S>=0]).
eq('case_1',[A,B,C,D,E,F,G,H,I,J,K,L],3,['case_2'(A,B,C,D,E,F,G,H,M,N,O,P,Q,R,S,I,J,K,L)],[F>=S,F>=N,F>=O,E>=R,E>=M,C>=1,C>=P,D=Q+1,Q>=1,M>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0]).
eq('case_0',[A,B,C,D,E,F,G,H,I,J],2,['case_1'(A,B,C,D,E,F,K,L,G,H,I,J)],[B>=K,B>=L,A=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0]).
eq('insertL',[A,B,C,D,E,F,G,H,I,J],1,['case_0'(A,B,C,D,E,F,G,H,I,J)],[A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0]).
eq('case_3',[A,B,C,D,E,F,G],2,[],[B=1,A=0,F=0,E=1,D=0,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0]).
eq('case_3',[A,B,C,D,E,F,G],4,['split'(H,I,J,K,L,M,N),'insertL'(O,P,K,L,M,N,D,E,F,G)],[C>=P,C>=J,A>=O,A>=H,B=I+1,I>=1,O>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0]).
eq('split',[A,B,C,D,E,F,G],1,['case_3'(A,B,C,D,E,F,G)],[A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0]).
eq('case_5',[A,B,C,D,E,F,G,H,I],4,['maxNorm'(J,K,H)],[E=1,J=1,K=1,I>=L,I>=M,G=1,K>=1,J>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0]).
eq('case_7',[A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S],3,['maxNorm'(M,T,R)],[J>=G+1,U>=J,U>=P,T=O+1,O>=1,S>=N,S>=U,Q=1,T>=1,M>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0,M>=0,N>=0,O>=0,P>=0,Q>=0,R>=0,S>=0]).
eq('case_7',[A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S],3,['maxNorm'(T,O,R)],[G>=J,U>=J,U>=N,T=M+1,M>=1,S>=U,S>=P,Q=1,O>=1,T>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0,M>=0,N>=0,O>=0,P>=0,Q>=0,R>=0,S>=0]).
eq('case_6',[A,B,C,D,E,F,G,H,I,J,K,L,M,N,O],2,['case_7'(A,B,C,D,E,F,G,H,I,J,K,L,P,Q,R,S,M,N,O)],[C>=Q,C>=S,B>=P,B>=R,A=1,R>=1,P>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0,M>=0,N>=0,O>=0]).
eq('case_5',[A,B,C,D,E,F,G,H,I],7,['splitqs'(J,K,L,M,N,O),'case_6'(P,Q,R,A,B,C,D,E,F,S,T,U,V,W,X)],[F>=S,F>=U,E=T+1,T>=1,L>=D,L>=U,K=T,J=1,T>=1,R=O,Q=N,P=M,M>=1,I=X,H=W,G=V,V>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0]).
eq('case_4',[A,B,C,D,E,F],2,['case_5'(A,B,C,G,H,I,D,E,F)],[C>=G,C>=I,B=H,A=1,H>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0]).
eq('splitqs',[A,B,C,D,E,F],1,['case_4'(A,B,C,D,E,F)],[A>=0,B>=0,C>=0,D>=0,E>=0,F>=0]).
eq('case_8',[A,B,C,D,E,F,G,H,E,F,G,H],1,[],[D=0,C=1,A=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,E>=0,F>=0,G>=0,H>=0]).
eq('case_8',[A,B,C,D,E,F,G,H,I,J,K,L],4,['append'(M,N,O,P,E,F,G,H,Q,R,S,T),'maxNorm'(U,T,L)],[D>=U,D>=P,B>=V,B>=N,C=O+1,A=M+1,O>=1,M>=1,U>=1,J>=V,J>=R,K=S+1,I=Q+1,S>=1,Q>=1,U>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0]).
eq('append',[A,B,C,D,E,F,G,H,I,J,K,L],1,['case_8'(A,B,C,D,E,F,G,H,I,J,K,L)],[A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0]).
eq('case_9',[A,B,C,D],2,[],[A=1,C=1,A>=0,B>=0,C>=0,D>=0]).
eq('case_10',[A,B,C,D,E,F,G,H,I,J],5,['quicksort'(K,L,M,N),'quicksort'(O,P,Q,R),'append'(M,N,S,T,U,V,W,X,I,J,Y,Z)],[C>=L,C>=P,B>=K,B>=O,A=1,O>=1,K>=1,V>=F,V>=R,U=Q+1,Q>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0]).
eq('case_9',[A,B,C,D],7,['splitqs'(E,F,G,H,I,J),'case_10'(K,L,M,A,B,N,O,P,Q,R)],[B>=N,B>=P,A=O+1,O>=1,G>=N,G>=P,F=O,E=1,O>=1,M=J,L=I,K=H,H>=1,D=R,C=Q,Q>=1,A>=0,B>=0,C>=0,D>=0]).
eq('quicksort',[A,B,C,D],1,['case_9'(A,B,C,D)],[A>=0,B>=0,C>=0,D>=0]).
eq('case_11',[A,B,C,D,E,F,G,H],2,[],[C=0,B=1,A=0,G=0,F=1,E=0,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0]).
eq('case_11',[A,B,C,D,E,F,G,H],6,['quicksort'(I,J,K,L),'sortAll'(M,N,O,P,Q,R,S,T),'maxNorm'(U,S,G),'maxNorm'(V,Q,E)],[D>=P,D>=J,D>=W,C>=O,C>=I,A>=1,A>=M,B=N+1,N>=1,I>=1,X>=L,X>=W,U=K,V=1,K>=1,H>=X,H>=T,F=R+1,R>=1,V>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0]).
eq('sortAll',[A,B,C,D,E,F,G,H],1,['case_11'(A,B,C,D,E,F,G,H)],[A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0]).
eq('splitAndSort',[A,B,C,D,E,F,G],2,['split'(A,B,C,H,I,J,K),'sortAll'(H,I,J,K,D,E,F,G)],[A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0]).

Preprocessing Cost Relations
=====================================

#### Computed strongly connected components 
0. non_recursive  : [maxNorm/3]
1. recursive [non_tail] : [append/12,case_8/12]
2. recursive [non_tail] : [case_0/10,case_1/12,case_2/19,insertL/10]
3. non_recursive  : [case_7/19]
4. non_recursive  : [case_6/15]
5. recursive [non_tail] : [case_4/6,case_5/9,splitqs/6]
6. recursive [non_tail,multiple] : [case_10/10,case_9/4,quicksort/4]
7. recursive [non_tail] : [case_11/8,sortAll/8]
8. recursive [non_tail] : [case_3/7,split/7]
9. non_recursive  : [splitAndSort/7]
Warning: the following predicates are never called:[and_op/3,eq/3,geq/3,gt/3,leq/3,lt/3,neg/2,neq/3,or/3]

#### Obtained direct recursion through partial evaluation 
0. SCC is partially evaluated into maxNorm/3
1. SCC is partially evaluated into append/12
2. SCC is partially evaluated into insertL/10
3. SCC is partially evaluated into case_7/19
4. SCC is completely evaluated into other SCCs
5. SCC is partially evaluated into splitqs/6
6. SCC is partially evaluated into quicksort/4
7. SCC is partially evaluated into sortAll/8
8. SCC is partially evaluated into split/7
9. SCC is partially evaluated into splitAndSort/7

Control-Flow Refinement of Cost Relations
=====================================

### Specialization of cost equations maxNorm/3 
* CE 16 is refined into CE [19] 
* CE 15 is refined into CE [20] 


#### Refined cost equations maxNorm/3 
* CE 19: maxNorm(A,B,B) = 0
     [B>=A,A>=1] 
* CE 20: maxNorm(A,B,A) = 0
     [A>=B+1,B>=0] 

### Cost equations --> "Loop" of maxNorm/3 
* CEs [19] --> Loop 19 
* CEs [20] --> Loop 20 

#### Loops of maxNorm/3 
* Loop 19: maxNorm(A,B,B) [B>=A,A>=1] 
* Loop 20: maxNorm(A,B,A) [A>=B+1,B>=0] 

### Ranking functions of CR maxNorm(A,B,C) 

#### Partial ranking functions of CR maxNorm(A,B,C) 


### Resulting Chains:maxNorm(A,B,C) 
* [20]
* [19]


### Merging Chains  maxNorm/3 into  External patterns of execution 
* [[19]] --> 1 
* [[20]] --> 2 


### Specialization of cost equations append/12 
* CE 9 is refined into CE [21] 
* CE 8 is refined into CE [22,23] 


#### Refined cost equations append/12 
* CE 21: append(A,B,C,D,E,F,G,H,E,F,G,H) = 2
     [H>=0,G>=0,F>=0,E>=0,B>=0,D=0,C=1,A=1] 
* CE 22: append(A,B,C,D,E,F,G,H,I,J,K,L) = 5+ append(M,N,O,P,E,F,G,H,Q,R,S,L)+ maxNorm(T,L,L):1
     [J>=R,D>=P,B>=N,L>=T,D>=T,S>=1,Q>=1,O>=1,M>=1,T>=1,J>=0,H>=0,G>=0,F>=0,E>=0,B>=0,S+1=K,Q+1=I,O+1=C,M+1=A] 
* CE 23: append(A,B,C,D,E,F,G,H,I,J,K,L) = 5+ append(M,N,O,P,E,F,G,H,Q,R,S,T)+ maxNorm(L,T,L):2
     [J>=R,D>=P,B>=N,D>=L,L>=T+1,S>=1,Q>=1,O>=1,M>=1,T>=0,J>=0,H>=0,G>=0,F>=0,E>=0,B>=0,S+1=K,Q+1=I,O+1=C,M+1=A] 

### Cost equations --> "Loop" of append/12 
* CEs [23] --> Loop 21 
* CEs [22] --> Loop 22 
* CEs [21] --> Loop 23 

#### Loops of append/12 
* Loop 21: append(A,B,C,D,E,F,G,H,I,J,K,L)->  append(A',B',C',D',E,F,G,H,E',F',G',H')
                  [L>=H'+1,J>=F',D>=D',B>=B',D>=L,H'>=0,K>=2,J>=0,I>=2,H>=0,G>=0,F>=0,E>=0,C>=2,B>=0,A>=2,K=G'+1,I=E'+1,C=C'+1,A=A'+1] 
* Loop 22: append(A,B,C,D,E,F,G,H,I,J,K,L)->  append(A',B',C',D',E,F,G,H,E',F',G',L)
                  [J>=F',D>=D',B>=B',L>=1,K>=2,J>=0,I>=2,H>=0,G>=0,F>=0,E>=0,D>=1,C>=2,B>=0,A>=2,K=G'+1,I=E'+1,C=C'+1,A=A'+1] 
* Loop 23: append(A,B,C,D,E,F,G,H,E,F,G,H) [H>=0,G>=0,F>=0,E>=0,B>=0,D=0,C=1,A=1] 

### Ranking functions of CR append(A,B,C,D,E,F,G,H,I,J,K,L) 
* RF of phase [21,22]: [A-1,C-1]

#### Partial ranking functions of CR append(A,B,C,D,E,F,G,H,I,J,K,L) 
* Partial RF of phase [21,22]:
  - RF of loop [21:1,22:1]:
    A-1
    C-1

Discarded unfeasible chain [[21,22]]...(Non-terminating chain proved terminating)

### Resulting Chains:append(A,B,C,D,E,F,G,H,I,J,K,L) 
* [[21,22],23]
* [23]


### Merging Chains  append/12 into  External patterns of execution 
* [[23]] --> 1 
* [[23,[21,22]]] --> 2 


### Specialization of cost equations insertL/10 
* CE 3 is refined into CE [24,25,26,27] 
* CE 2 is refined into CE [28,29,30,31] 
* CE 1 is refined into CE [32] 


#### Refined cost equations insertL/10 
* CE 24: insertL(A,B,C,D,E,F,G,H,I,J) = 10+ insertL(K,B,L,M,N,O,G,P,I,Q)+ maxNorm(R,I,I):1+ maxNorm(S,G,G):1
     [J>=Q,F>=O,E>=N,C>=L,I>=R,E>=R,P>=1,O>=0,N>=0,M>=1,L>=0,G>=1,R>=1,J>=1,F>=1,C>=1,B>=0,P+1=H,M+1=D,K=1,S=1,A=1] 
* CE 25: insertL(A,B,C,D,E,F,G,H,I,J) = 10+ insertL(K,B,L,M,N,O,P,Q,I,R)+ maxNorm(S,I,I):1+ maxNorm(T,U,V):2
     [J>=R,F>=O,E>=N,C>=L,I>=S,E>=S,Q>=1,O>=0,N>=0,M>=1,L>=0,S>=1,J>=1,F>=1,C>=1,B>=0,Q+1=H,M+1=D,P=0,K=1,V=1,U=0,T=1,G=1,A=1] 
* CE 26: insertL(A,B,C,D,E,F,G,H,I,J) = 10+ insertL(K,B,L,M,N,O,G,P,Q,R)+ maxNorm(I,Q,I):2+ maxNorm(S,G,G):1
     [J>=R,F>=O,E>=N,C>=L,E>=I,I>=Q+1,P>=1,O>=0,N>=0,M>=1,L>=0,G>=1,Q>=0,J>=1,F>=1,C>=1,B>=0,P+1=H,M+1=D,K=1,S=1,A=1] 
* CE 27: insertL(A,B,C,D,E,F,G,H,I,J) = 10+ insertL(K,B,L,M,N,O,P,Q,R,S)+ maxNorm(I,R,I):2+ maxNorm(T,U,V):2
     [J>=S,F>=O,E>=N,C>=L,E>=I,I>=R+1,Q>=1,O>=0,N>=0,M>=1,L>=0,R>=0,J>=1,F>=1,C>=1,B>=0,Q+1=H,M+1=D,P=0,K=1,V=1,U=0,T=1,G=1,A=1] 
* CE 28: insertL(A,B,C,D,E,F,G,D,H,I) = 10+ maxNorm(J,H,H):1+ maxNorm(K,G,G):1
     [C>=G,E>=H,H>=J,G>=1,J>=2,I>=0,F>=0,D>=2,B>=0,K=1,A=1] 
* CE 29: insertL(A,B,C,D,E,F,G,D,H,I) = 10+ maxNorm(J,H,H):1+ maxNorm(K,L,M):2
     [E>=H,H>=J,J>=2,I>=0,F>=0,D>=2,C>=1,B>=0,M=1,L=0,K=1,G=1,A=1] 
* CE 30: insertL(A,B,C,D,E,F,G,D,H,I) = 10+ maxNorm(H,J,H):2+ maxNorm(K,G,G):1
     [C>=G,E+1>=H,H>=J+1,G>=1,H>=2,J>=0,I>=0,F>=0,D>=2,B>=0,K=1,A=1] 
* CE 31: insertL(A,B,C,D,E,F,G,D,H,I) = 10+ maxNorm(H,J,H):2+ maxNorm(K,L,M):2
     [E+1>=H,H>=J+1,H>=2,J>=0,I>=0,F>=0,D>=2,C>=1,B>=0,M=1,L=0,K=1,G=1,A=1] 
* CE 32: insertL(A,B,C,D,E,F,G,H,I,J) = 9+ maxNorm(K,L,M):2+ maxNorm(N,O,P):2
     [J>=0,F>=0,B>=0,P=1,O=0,N=1,M=2,L=0,K=2,I=2,H=2,G=1,E=0,D=1,C=0,A=1] 

### Cost equations --> "Loop" of insertL/10 
* CEs [28,29,30,31] --> Loop 24 
* CEs [32] --> Loop 25 
* CEs [26] --> Loop 26 
* CEs [24] --> Loop 27 
* CEs [27] --> Loop 28 
* CEs [25] --> Loop 29 

#### Loops of insertL/10 
* Loop 24: insertL(A,B,C,D,E,F,G,D,H,I) [E+1>=H,C>=G,I>=0,H>=2,G>=1,F>=0,D>=2,B>=0,A=1] 
* Loop 25: insertL(A,B,C,D,E,F,G,H,I,J) [J>=0,F>=0,B>=0,I=2,H=2,G=1,E=0,D=1,C=0,A=1] 
* Loop 26: insertL(A,B,C,D,E,F,G,H,I,J)->  insertL(A',B,B',C',D',E',G,F',G',H')
                  [J>=H',I>=G'+1,F>=E',E>=D',C>=B',E>=I,G'>=0,E'>=0,D'>=0,B'>=0,J>=1,H>=2,G>=1,F>=1,D>=2,C>=1,B>=0,H=F'+1,D=C'+1,A'=1,A=1] 
* Loop 27: insertL(A,B,C,D,E,F,G,H,I,J)->  insertL(A',B,B',C',D',E',G,F',I,G')
                  [J>=G',F>=E',E>=D',C>=B',E'>=0,D'>=0,B'>=0,J>=1,I>=1,H>=2,G>=1,F>=1,E>=1,D>=2,C>=1,B>=0,H=F'+1,D=C'+1,A'=1,A=1] 
* Loop 28: insertL(A,B,C,D,E,F,G,H,I,J)->  insertL(A',B,B',C',D',E',F',G',H',I')
                  [J>=I',I>=H'+1,F>=E',E>=D',C>=B',E>=I,H'>=0,E'>=0,D'>=0,B'>=0,J>=1,H>=2,F>=1,D>=2,C>=1,B>=0,H=G'+1,D=C'+1,F'=0,A'=1,G=1,A=1] 
* Loop 29: insertL(A,B,C,D,E,F,G,H,I,J)->  insertL(A',B,B',C',D',E',F',G',I,H')
                  [J>=H',F>=E',E>=D',C>=B',E'>=0,D'>=0,B'>=0,J>=1,I>=1,H>=2,F>=1,E>=1,D>=2,C>=1,B>=0,H=G'+1,D=C'+1,F'=0,A'=1,G=1,A=1] 

### Ranking functions of CR insertL(A,B,C,D,E,F,G,H,I,J) 
* RF of phase [26,27]: [D-1]

#### Partial ranking functions of CR insertL(A,B,C,D,E,F,G,H,I,J) 
* Partial RF of phase [26,27]:
  - RF of loop [26:1,27:1]:
    D-1

Discarded unfeasible chain [[26,27]]...(Non-terminating chain proved terminating)

### Resulting Chains:insertL(A,B,C,D,E,F,G,H,I,J) 
* [[26,27],25]
* [[26,27],24]
* [25]
* [24]


### Merging Chains  insertL/10 into  External patterns of execution 
* [[25]] --> 1 
* [[25,[26,27]]] --> 2 
* [[24],[24,[26,27]]] --> 3 


### Specialization of cost equations case_7/19 
* CE 18 is refined into CE [33,34] 
* CE 17 is refined into CE [35,36] 


#### Refined cost equations case_7/19 
* CE 33: case_7(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,O,R) = 3+ maxNorm(S,O,O):1
     [B>=O,O>=S,R>=P,C>=P,R>=N,C>=N,I>=L,R>=J,I>=J,G>=J,F>=I,F>=G,S>=2,P>=0,N>=0,L>=0,K>=1,J>=0,S=M+1,K+1=H,K+1=E,Q=1,D=1,A=1] 
* CE 34: case_7(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S) = 3+ maxNorm(R,O,R):2
     [B+1>=R,R>=O+1,S>=P,C>=P,S>=N,C>=N,I>=L,S>=J,I>=J,G>=J,F>=I,F>=G,O>=1,P>=0,N>=0,L>=0,K>=1,J>=0,R=M+1,K+1=H,K+1=E,Q=1,D=1,A=1] 
* CE 35: case_7(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S) = 3+ maxNorm(M,R,R):1
     [B+1>=R,R>=M,B>=M,S>=P,C>=P,S>=N,C>=N,I>=L,S>=J,I>=J,F>=I,J>=G+1,R>=2,M>=1,P>=0,N>=0,L>=0,K>=1,G>=0,R=O+1,K+1=H,K+1=E,Q=1,D=1,A=1] 
* CE 36: case_7(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,M,R) = 3+ maxNorm(M,S,M):2
     [B>=M,M>=S+1,R>=P,C>=P,R>=N,C>=N,I>=L,R>=J,I>=J,F>=I,J>=G+1,S>=2,P>=0,N>=0,L>=0,K>=1,G>=0,S=O+1,K+1=H,K+1=E,Q=1,D=1,A=1] 

### Cost equations --> "Loop" of case_7/19 
* CEs [33] --> Loop 30 
* CEs [36] --> Loop 31 
* CEs [35] --> Loop 32 
* CEs [34] --> Loop 33 

#### Loops of case_7/19 
* Loop 30: case_7(A,B,C,D,E,F,G,E,H,I,J,K,L,M,N,O,P,N,Q) [Q>=O,C>=O,B>=N,Q>=M,C>=M,N>=L+1,H>=K,Q>=I,H>=I,G>=I,F>=H,F>=G,O>=0,M>=0,L>=1,K>=0,I>=0,E>=2,E=J+1,P=1,D=1,A=1] 
* Loop 31: case_7(A,B,C,D,E,F,G,E,H,I,J,K,L,M,N,O,P,L,Q) [Q>=O,C>=O,L>=N+2,Q>=M,C>=M,B>=L,H>=K,Q>=I,H>=I,F>=H,I>=G+1,O>=0,N>=1,M>=0,K>=0,G>=0,E>=2,E=J+1,P=1,D=1,A=1] 
* Loop 32: case_7(A,B,C,D,E,F,G,E,H,I,J,K,L,M,N,O,P,Q,R) [R>=O,C>=O,B>=N,R>=M,C>=M,N+1>=L,B>=L,H>=K,R>=I,H>=I,F>=H,I>=G+1,O>=0,N>=1,M>=0,L>=1,K>=0,G>=0,E>=2,N+1=Q,E=J+1,P=1,D=1,A=1] 
* Loop 33: case_7(A,B,C,D,E,F,G,E,H,I,J,K,L,M,N,O,P,Q,R) [R>=O,C>=O,L>=N,R>=M,C>=M,B>=L,H>=K,R>=I,H>=I,G>=I,F>=H,F>=G,O>=0,N>=1,M>=0,K>=0,I>=0,E>=2,L+1=Q,E=J+1,P=1,D=1,A=1] 

### Ranking functions of CR case_7(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S) 

#### Partial ranking functions of CR case_7(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S) 


### Resulting Chains:case_7(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S) 
* [33]
* [32]
* [31]
* [30]


### Merging Chains  case_7/19 into  External patterns of execution 
* [[33]] --> 1 
* [[31]] --> 2 
* [[32]] --> 3 
* [[30]] --> 4 


### Specialization of cost equations splitqs/6 
* CE 7 is refined into CE [37] 
* CE 6 is refined into CE [38,39,40,41] 


#### Refined cost equations splitqs/6 
* CE 37: splitqs(A,B,C,D,E,F) = 7+ maxNorm(G,H,I):1
     [F>=0,C>=0,I=1,H=1,G=1,E=1,D=1,B=1,A=1] 
* CE 38: splitqs(A,B,C,D,E,F) = 12+ splitqs(G,H,I,J,K,L)+ case_7(M,K,L,N,B,C,O,B,P,Q,R,S,T,U,V,W,X,E,F):1
     [K+1>=E,F>=W,L>=W,E>=V+1,F>=U,L>=U,I>=S,P>=S,F>=Q,P>=Q,O>=Q,C>=P,I>=O,C>=O,W>=0,V>=1,U>=0,S>=0,Q>=0,B>=2,B=H+1,E=T+1,B=R+1,J=1,G=1,X=1,N=1,M=1,D=1,A=1] 
* CE 39: splitqs(A,B,C,D,E,F) = 12+ splitqs(G,H,I,J,K,L)+ case_7(M,K,L,N,B,C,O,B,P,Q,R,S,E,T,U,V,W,E,F):2
     [K>=E,F>=V,L>=V,E>=U+2,F>=T,L>=T,I>=S,P>=S,F>=Q,P>=Q,C>=P,I>=O,Q>=O+1,V>=0,U>=1,T>=0,S>=0,B>=2,O>=0,B=H+1,B=R+1,J=1,G=1,W=1,N=1,M=1,D=1,A=1] 
* CE 40: splitqs(A,B,C,D,E,F) = 12+ splitqs(G,H,I,J,K,L)+ case_7(M,K,L,N,B,C,O,B,P,Q,R,S,T,U,V,W,X,E,F):3
     [K+1>=E,F>=W,L>=W,F>=U,L>=U,E>=T,K>=T,I>=S,P>=S,F>=Q,P>=Q,C>=P,I>=O,Q>=O+1,E>=2,W>=0,U>=0,T>=1,S>=0,B>=2,O>=0,B=H+1,E=V+1,B=R+1,J=1,G=1,X=1,N=1,M=1,D=1,A=1] 
* CE 41: splitqs(A,B,C,D,E,F) = 12+ splitqs(G,H,I,J,K,L)+ case_7(M,K,L,N,B,C,O,B,P,Q,R,S,T,U,E,V,W,E,F):4
     [K>=E,F>=V,L>=V,F>=U,L>=U,E>=T+1,I>=S,P>=S,F>=Q,P>=Q,O>=Q,C>=P,I>=O,C>=O,V>=0,U>=0,T>=1,S>=0,Q>=0,B>=2,B=H+1,B=R+1,J=1,G=1,W=1,N=1,M=1,D=1,A=1] 

### Cost equations --> "Loop" of splitqs/6 
* CEs [38,39,40,41] --> Loop 34 
* CEs [37] --> Loop 35 

#### Loops of splitqs/6 
* Loop 34: splitqs(A,B,C,D,E,F)->  splitqs(A',B',C',D',E',F')
                  [E'+1>=E,F'>=0,C'>=0,F>=0,E>=2,C>=0,B>=2,B=B'+1,D'=1,A'=1,D=1,A=1] 
* Loop 35: splitqs(A,B,C,D,E,F) [F>=0,C>=0,E=1,D=1,B=1,A=1] 

### Ranking functions of CR splitqs(A,B,C,D,E,F) 
* RF of phase [34]: [B-1]

#### Partial ranking functions of CR splitqs(A,B,C,D,E,F) 
* Partial RF of phase [34]:
  - RF of loop [34:1]:
    B-1

Discarded unfeasible chain [[34]]...(Non-terminating chain proved terminating)

### Resulting Chains:splitqs(A,B,C,D,E,F) 
* [[34],35]
* [35]


### Merging Chains  splitqs/6 into  External patterns of execution 
* [[35]] --> 1 
* [[35,[34]]] --> 2 


### Specialization of cost equations quicksort/4 
* CE 11 is refined into CE [42,43,44,45] 
* CE 10 is refined into CE [46] 


#### Refined cost equations quicksort/4 
* CE 42: quicksort(A,B,C,D) = 13+ splitqs(E,F,G,H,I,J):1+ quicksort(K,L,M,N)+ quicksort(O,P,Q,R)+ append(S,N,T,U,C,D,V,W,C,D,V,W):1
     [D>=R,J>=P,J>=L,W>=0,V>=0,D>=0,C>=2,N>=0,J>=0,G>=0,B>=0,C=Q+1,O=1,M=1,K=1,U=0,T=1,S=1,I=1,H=1,F=1,E=1,A=2] 
* CE 43: quicksort(A,B,C,D) = 13+ splitqs(E,F,G,H,I,J):1+ quicksort(K,L,M,N)+ quicksort(O,P,Q,R)+ append(M,N,M,S,T,U,V,W,C,D,X,Y):2
     [S+W>=Y,U>=R,J>=P,J>=L,Y>=W,D>=U,X>=M,C>=M+1,Y>=1,W>=0,U>=0,S>=1,M>=2,N>=0,J>=0,G>=0,B>=0,M+V=X+1,M+Q=C,M+T=C+1,O=1,K=1,I=1,H=1,F=1,E=1,A=2] 
* CE 44: quicksort(A,B,C,D) = 13+ splitqs(E,F,G,H,I,J):2+ quicksort(K,L,M,N)+ quicksort(O,P,Q,R)+ append(S,N,T,U,C,D,V,W,C,D,V,W):1
     [D>=R,J>=P,I>=O,J>=L,I>=K,F>=I,O>=1,K>=1,W>=0,V>=0,D>=0,C>=2,N>=0,J>=0,I>=2,G>=0,B>=0,C=Q+1,F+1=A,M=1,U=0,T=1,S=1,H=1,E=1] 
* CE 45: quicksort(A,B,C,D) = 13+ splitqs(E,F,G,H,I,J):2+ quicksort(K,L,M,N)+ quicksort(O,P,Q,R)+ append(M,N,M,S,T,U,V,W,C,D,X,Y):2
     [S+W>=Y,U>=R,J>=P,I>=O,J>=L,I>=K,Y>=W,D>=U,X>=M,C>=M+1,F>=I,O>=1,K>=1,Y>=1,W>=0,U>=0,S>=1,M>=2,N>=0,J>=0,I>=2,G>=0,B>=0,M+V=X+1,M+Q=C,M+T=C+1,F+1=A,H=1,E=1] 
* CE 46: quicksort(A,B,C,D) = 3
     [D>=0,B>=0,C=1,A=1] 

### Cost equations --> "Loop" of quicksort/4 
* CEs [46] --> Loop 36 
* CEs [45] --> Loop 37 
* CEs [44] --> Loop 38 
* CEs [43] --> Loop 39 
* CEs [42] --> Loop 40 

#### Loops of quicksort/4 
* Loop 36: quicksort(A,B,C,D) [D>=0,B>=0,C=1,A=1] 
* Loop 37: quicksort(A,B,C,D)->  quicksort(A',B',C',D')  quicksort(A'2,B'2,C'2,D'2)
                  [D>=D'2,A>=A'2+1,C>=C'+1,A>=A'+1,A'2>=1,D'>=0,C'>=2,A'>=1,D>=0,B>=0,A>=3,C'+C'2=C] 
* Loop 38: quicksort(A,B,C,D)->  quicksort(A',B',C',D')  quicksort(A'2,B'2,C'2,D'2)
                  [D>=D'2,A>=A'2+1,A>=A'+1,A'2>=1,D'>=0,A'>=1,D>=0,C>=2,B>=0,A>=3,C=C'2+1,C'=1] 
* Loop 39: quicksort(A,B,C,D)->  quicksort(A',B',C',D')  quicksort(A'2,B'2,C'2,D'2)
                  [D>=D'2,C>=C'+1,D'>=0,C'>=2,D>=0,B>=0,C'+C'2=C,A'2=1,A'=1,A=2] 
* Loop 40: quicksort(A,B,C,D)->  quicksort(A',B',C',D')  quicksort(A'2,B'2,C'2,D'2)
                  [D>=D'2,D'>=0,D>=0,C>=2,B>=0,C=C'2+1,A'2=1,C'=1,A'=1,A=2] 

### Ranking functions of CR quicksort(A,B,C,D) 
* RF of phase [37,38]: [A-2]

#### Partial ranking functions of CR quicksort(A,B,C,D) 
* Partial RF of phase [37,38]:
  - RF of loop [37:1,37:2,38:1,38:2]:
    A-2

Discarded unfeasible chain [multiple([37,38],[[],[multiple(40,[[36]])],[multiple(39,[[36]])],[36]])]...(Non-terminating chain proved terminating)
Remaining chain: [multiple([37,38],[[multiple(40,[[36]])],[multiple(39,[[36]])],[36]])]

### Resulting Chains:quicksort(A,B,C,D) 
* [multiple(40,[[36]])]
* [36]
* [multiple([37,38],[[multiple(40,[[36]])],[multiple(39,[[36]])],[36]])]


### Merging Chains  quicksort/4 into  External patterns of execution 
* [[36]] --> 1 
* [[multiple(40,[[36]])]] --> 2 
* [[multiple([37,38],[[multiple(40,[[36]])],[multiple(39,[[36]])],[36]])]] --> 3 


### Specialization of cost equations sortAll/8 
* CE 13 is refined into CE [47] 
* CE 12 is refined into CE [48,49,50,51,52,53,54,55,56,57,58,59] 


#### Refined cost equations sortAll/8 
* CE 47: sortAll(A,B,C,D,E,F,G,H) = 3
     [H>=0,D>=0,G=0,F=1,E=0,C=0,B=1,A=0] 
* CE 48: sortAll(A,B,C,D,E,F,G,H) = 7+ quicksort(I,J,K,L):1+ sortAll(M,N,O,P,E,Q,G,R)+ maxNorm(S,G,G):1+ maxNorm(T,E,E):1
     [H>=R,D>=P,C>=O,A>=M,H>=L,D>=J,Q>=1,N>=1,E>=1,G>=1,L>=0,J>=0,C>=1,A>=1,Q+1=F,N+1=B,T=1,S=1,K=1,I=1] 
* CE 49: sortAll(A,B,C,D,E,F,G,H) = 7+ quicksort(I,J,K,L):1+ sortAll(M,N,O,P,Q,R,G,S)+ maxNorm(T,G,G):1+ maxNorm(U,V,W):2
     [H>=S,D>=P,C>=O,A>=M,H>=L,D>=J,R>=1,N>=1,G>=1,L>=0,J>=0,C>=1,A>=1,R+1=F,N+1=B,Q=0,W=1,V=0,U=1,T=1,K=1,I=1,E=1] 
* CE 50: sortAll(A,B,C,D,E,F,G,H) = 7+ quicksort(I,J,K,L):1+ sortAll(M,N,O,P,E,Q,R,S)+ maxNorm(T,U,V):2+ maxNorm(W,E,E):1
     [H>=S,D>=P,C>=O,A>=M,H>=L,D>=J,Q>=1,N>=1,E>=1,L>=0,J>=0,C>=1,A>=1,Q+1=F,N+1=B,R=0,W=1,V=1,U=0,T=1,K=1,I=1,G=1] 
* CE 51: sortAll(A,B,C,D,E,F,G,H) = 7+ quicksort(I,J,K,L):1+ sortAll(M,N,O,P,Q,R,S,T)+ maxNorm(U,V,W):2+ maxNorm(X,Y,Z):2
     [H>=T,D>=P,C>=O,A>=M,H>=L,D>=J,R>=1,N>=1,L>=0,J>=0,C>=1,A>=1,R+1=F,N+1=B,S=0,Q=0,Z=1,Y=0,X=1,W=1,V=0,U=1,K=1,I=1,G=1,E=1] 
* CE 52: sortAll(A,B,C,D,E,F,G,H) = 7+ quicksort(I,J,K,L):2+ sortAll(M,N,O,P,E,Q,G,R)+ maxNorm(S,G,G):1+ maxNorm(T,E,E):1
     [H>=R,D>=P,C>=O,A>=M,H>=L,D>=J,Q>=1,N>=1,E>=1,G>=2,L>=0,J>=0,C>=2,A>=1,Q+1=F,N+1=B,T=1,S=2,K=2,I=2] 
* CE 53: sortAll(A,B,C,D,E,F,G,H) = 7+ quicksort(I,J,K,L):2+ sortAll(M,N,O,P,Q,R,G,S)+ maxNorm(T,G,G):1+ maxNorm(U,V,W):2
     [H>=S,D>=P,C>=O,A>=M,H>=L,D>=J,R>=1,N>=1,G>=2,L>=0,J>=0,C>=2,A>=1,R+1=F,N+1=B,Q=0,W=1,V=0,U=1,T=2,K=2,I=2,E=1] 
* CE 54: sortAll(A,B,C,D,E,F,G,H) = 7+ quicksort(I,J,K,L):2+ sortAll(M,N,O,P,E,Q,R,S)+ maxNorm(T,R,U):2+ maxNorm(V,E,E):1
     [H>=S,D>=P,C>=O,A>=M,H>=L,D>=J,Q>=1,N>=1,E>=1,R>=0,L>=0,J>=0,C>=2,A>=1,1>=R,Q+1=F,N+1=B,V=1,U=2,T=2,K=2,I=2,G=2] 
* CE 55: sortAll(A,B,C,D,E,F,G,H) = 7+ quicksort(I,J,K,L):2+ sortAll(M,N,O,P,Q,R,S,T)+ maxNorm(U,S,V):2+ maxNorm(W,X,Y):2
     [H>=T,D>=P,C>=O,A>=M,H>=L,D>=J,R>=1,N>=1,S>=0,L>=0,J>=0,C>=2,A>=1,1>=S,R+1=F,N+1=B,Q=0,Y=1,X=0,W=1,V=2,U=2,K=2,I=2,G=2,E=1] 
* CE 56: sortAll(A,B,C,D,E,F,G,H) = 7+ quicksort(I,J,K,L):3+ sortAll(M,N,O,P,E,Q,G,R)+ maxNorm(K,G,G):1+ maxNorm(S,E,E):1
     [H>=R,D>=P,C>=O,A>=M,G>=K,H>=L,D>=J,C>=I,Q>=1,N>=1,E>=1,K>=2,L>=0,J>=0,I>=3,A>=1,Q+1=F,N+1=B,S=1] 
* CE 57: sortAll(A,B,C,D,E,F,G,H) = 7+ quicksort(I,J,K,L):3+ sortAll(M,N,O,P,Q,R,G,S)+ maxNorm(K,G,G):1+ maxNorm(T,U,V):2
     [H>=S,D>=P,C>=O,A>=M,G>=K,H>=L,D>=J,C>=I,R>=1,N>=1,K>=2,L>=0,J>=0,I>=3,A>=1,R+1=F,N+1=B,Q=0,V=1,U=0,T=1,E=1] 
* CE 58: sortAll(A,B,C,D,E,F,G,H) = 7+ quicksort(I,J,G,K):3+ sortAll(L,M,N,O,E,P,Q,R)+ maxNorm(G,Q,G):2+ maxNorm(S,E,E):1
     [H>=R,D>=O,C>=N,A>=L,G>=Q+1,H>=K,D>=J,C>=I,P>=1,M>=1,E>=1,G>=2,Q>=0,K>=0,J>=0,I>=3,A>=1,P+1=F,M+1=B,S=1] 
* CE 59: sortAll(A,B,C,D,E,F,G,H) = 7+ quicksort(I,J,G,K):3+ sortAll(L,M,N,O,P,Q,R,S)+ maxNorm(G,R,G):2+ maxNorm(T,U,V):2
     [H>=S,D>=O,C>=N,A>=L,G>=R+1,H>=K,D>=J,C>=I,Q>=1,M>=1,G>=2,R>=0,K>=0,J>=0,I>=3,A>=1,Q+1=F,M+1=B,P=0,V=1,U=0,T=1,E=1] 

### Cost equations --> "Loop" of sortAll/8 
* CEs [58] --> Loop 41 
* CEs [48,52,56] --> Loop 42 
* CEs [54] --> Loop 43 
* CEs [50] --> Loop 44 
* CEs [59] --> Loop 45 
* CEs [49,53,57] --> Loop 46 
* CEs [55] --> Loop 47 
* CEs [51] --> Loop 48 
* CEs [47] --> Loop 49 

#### Loops of sortAll/8 
* Loop 41: sortAll(A,B,C,D,E,F,G,H)->  sortAll(A',B',C',D',E,E',F',G')
                  [H>=G',G>=F'+1,D>=D',C>=C',A>=A',F'>=0,H>=0,G>=2,F>=2,E>=1,D>=0,C>=3,B>=2,A>=1,F=E'+1,B=B'+1] 
* Loop 42: sortAll(A,B,C,D,E,F,G,H)->  sortAll(A',B',C',D',E,E',G,F')
                  [H>=F',D>=D',C>=C',A>=A',H>=0,G>=1,F>=2,E>=1,D>=0,C>=1,B>=2,A>=1,F=E'+1,B=B'+1] 
* Loop 43: sortAll(A,B,C,D,E,F,G,H)->  sortAll(A',B',C',D',E,E',F',G')
                  [H>=G',D>=D',C>=C',A>=A',F'>=0,H>=0,F>=2,E>=1,D>=0,C>=2,B>=2,A>=1,1>=F',F=E'+1,B=B'+1,G=2] 
* Loop 44: sortAll(A,B,C,D,E,F,G,H)->  sortAll(A',B',C',D',E,E',F',G')
                  [H>=G',D>=D',C>=C',A>=A',H>=0,F>=2,E>=1,D>=0,C>=1,B>=2,A>=1,F=E'+1,B=B'+1,F'=0,G=1] 
* Loop 45: sortAll(A,B,C,D,E,F,G,H)->  sortAll(A',B',C',D',E',F',G',H')
                  [H>=H',G>=G'+1,D>=D',C>=C',A>=A',G'>=0,H>=0,G>=2,F>=2,D>=0,C>=3,B>=2,A>=1,F=F'+1,B=B'+1,E'=0,E=1] 
* Loop 46: sortAll(A,B,C,D,E,F,G,H)->  sortAll(A',B',C',D',E',F',G,G')
                  [H>=G',D>=D',C>=C',A>=A',H>=0,G>=1,F>=2,D>=0,C>=1,B>=2,A>=1,F=F'+1,B=B'+1,E'=0,E=1] 
* Loop 47: sortAll(A,B,C,D,E,F,G,H)->  sortAll(A',B',C',D',E',F',G',H')
                  [H>=H',D>=D',C>=C',A>=A',G'>=0,H>=0,F>=2,D>=0,C>=2,B>=2,A>=1,1>=G',F=F'+1,B=B'+1,E'=0,G=2,E=1] 
* Loop 48: sortAll(A,B,C,D,E,F,G,H)->  sortAll(A',B',C',D',E',F',G',H')
                  [H>=H',D>=D',C>=C',A>=A',H>=0,F>=2,D>=0,C>=1,B>=2,A>=1,F=F'+1,B=B'+1,G'=0,E'=0,G=1,E=1] 
* Loop 49: sortAll(A,B,C,D,E,F,G,H) [H>=0,D>=0,G=0,F=1,E=0,C=0,B=1,A=0] 

### Ranking functions of CR sortAll(A,B,C,D,E,F,G,H) 
* RF of phase [41,42,43]: [B-1]

#### Partial ranking functions of CR sortAll(A,B,C,D,E,F,G,H) 
* Partial RF of phase [41,42,43]:
  - RF of loop [41:1,42:1,43:1]:
    B-1

Discarded unfeasible chain [[41,42,43]]...(Non-terminating chain proved terminating)

### Resulting Chains:sortAll(A,B,C,D,E,F,G,H) 
* [[41,42,43],48,49]
* [[41,42,43],47,49]
* [[41,42,43],45,49]
* [49]
* [48,49]
* [47,49]
* [45,49]


### Merging Chains  sortAll/8 into  External patterns of execution 
* [[49]] --> 1 
* [[49,48]] --> 2 
* [[49,47]] --> 3 
* [[49,45]] --> 4 
* [[49,45,[41,42,43]],[49,47,[41,42,43]],[49,48,[41,42,43]]] --> 5 


### Specialization of cost equations split/7 
* CE 5 is refined into CE [60] 
* CE 4 is refined into CE [61,62,63] 


#### Refined cost equations split/7 
* CE 60: split(A,B,C,D,E,F,G) = 3
     [G>=0,C>=0,F=0,E=1,D=0,B=1,A=0] 
* CE 61: split(A,B,C,D,E,F,G) = 5+ split(H,I,J,K,L,M,N)+ insertL(O,P,Q,R,S,N,T,U,V,G):1
     [C>=J,A>=H,C>=P,I>=1,G>=0,N>=0,P>=0,A>=1,I+1=B,M=0,L=1,K=0,V=2,U=2,T=1,S=0,R=1,Q=0,O=1,F=2,E=2,D=1] 
* CE 62: split(A,B,C,D,E,F,G) = 5+ split(H,I,J,K,L,M,N)+ insertL(O,P,K,Q,M,N,R,E,F,G):2
     [C>=J,A>=H,M+1>=F,C>=P,I>=1,G>=1,F>=2,E>=3,N>=1,K>=1,P>=0,A>=1,E=L+1,E=Q+1,I+1=B,R=1,O=1,D=1] 
* CE 63: split(A,B,C,D,E,F,G) = 5+ split(H,I,J,K,E,L,M)+ insertL(N,O,K,E,L,M,D,E,F,G):3
     [C>=J,A>=H,L+1>=F,K>=D,C>=O,I>=1,G>=0,F>=2,E>=2,D>=1,M>=0,O>=0,A>=1,I+1=B,N=1] 

### Cost equations --> "Loop" of split/7 
* CEs [63] --> Loop 50 
* CEs [62] --> Loop 51 
* CEs [61] --> Loop 52 
* CEs [60] --> Loop 53 

#### Loops of split/7 
* Loop 50: split(A,B,C,D,E,F,G)->  split(A',B',C',D',E,E',F')
                  [C>=C',A>=A',E'+1>=F,D'>=D,F'>=0,G>=0,F>=2,E>=2,D>=1,C>=0,B>=2,A>=1,B=B'+1] 
* Loop 51: split(A,B,C,D,E,F,G)->  split(A',B',C',D',E',F',G')
                  [C>=C',A>=A',F'+1>=F,G'>=1,D'>=1,G>=1,F>=2,E>=3,C>=0,B>=2,A>=1,E=E'+1,B=B'+1,D=1] 
* Loop 52: split(A,B,C,D,E,F,G)->  split(A',B',C',D',E',F',G')
                  [C>=C',A>=A',G'>=0,G>=0,C>=0,B>=2,A>=1,B=B'+1,F'=0,E'=1,D'=0,F=2,E=2,D=1] 
* Loop 53: split(A,B,C,D,E,F,G) [G>=0,C>=0,F=0,E=1,D=0,B=1,A=0] 

### Ranking functions of CR split(A,B,C,D,E,F,G) 
* RF of phase [50,51]: [B-1]

#### Partial ranking functions of CR split(A,B,C,D,E,F,G) 
* Partial RF of phase [50,51]:
  - RF of loop [50:1,51:1]:
    B-1

Discarded unfeasible chain [[50,51]]...(Non-terminating chain proved terminating)

### Resulting Chains:split(A,B,C,D,E,F,G) 
* [[50,51],52,53]
* [53]
* [52,53]


### Merging Chains  split/7 into  External patterns of execution 
* [[53]] --> 1 
* [[53,52]] --> 2 
* [[53,52,[50,51]]] --> 3 


### Specialization of cost equations splitAndSort/7 
* CE 14 is refined into CE [64,65,66,67,68,69,70] 


#### Refined cost equations splitAndSort/7 
* CE 64: splitAndSort(A,B,C,D,E,F,G) = 2+ split(H,I,C,J,K,L,M):1+ sortAll(N,O,P,M,Q,R,S,G):1
     [G>=0,M>=0,C>=0,S=0,R=1,Q=0,P=0,O=1,N=0,L=0,K=1,J=0,I=1,H=0,F=0,E=1,D=0,B=1,A=0] 
* CE 65: splitAndSort(A,B,C,D,E,F,G) = 2+ split(A,H,C,I,J,K,L):2+ sortAll(M,N,O,L,P,Q,R,G):2
     [G>=0,L>=0,C>=0,A>=1,R=1,Q=2,P=1,O=2,N=2,M=1,K=2,J=2,I=1,H=2,F=1,E=2,D=1,B=2] 
* CE 66: splitAndSort(A,B,C,D,E,F,G) = 2+ split(A,H,C,I,J,K,L):2+ sortAll(M,N,O,L,P,Q,R,G):3
     [G>=0,L>=0,C>=0,A>=1,R=2,Q=2,P=1,O=2,N=2,M=1,K=2,J=2,I=1,H=2,F=2,E=2,D=1,B=2] 
* CE 67: splitAndSort(A,B,C,D,E,F,G) = 2+ split(A,B,C,H,I,J,K):3+ sortAll(L,M,J,K,N,O,P,G):2
     [B>=J,G>=0,K>=0,J>=2,C>=0,B>=3,A>=1,P=1,O=2,N=1,M=2,L=1,I=2,H=1,F=1,E=2,D=1] 
* CE 68: splitAndSort(A,B,C,D,E,F,G) = 2+ split(A,B,C,H,I,J,K):3+ sortAll(L,M,J,K,N,O,P,G):3
     [B>=J,G>=0,K>=0,J>=2,C>=0,B>=3,A>=1,P=2,O=2,N=1,M=2,L=1,I=2,H=1,F=2,E=2,D=1] 
* CE 69: splitAndSort(A,B,C,D,E,F,G) = 2+ split(A,B,C,H,I,J,K):3+ sortAll(L,M,J,K,N,O,F,G):4
     [B>=J,G>=0,F>=2,K>=0,J>=3,C>=0,A>=1,O=2,N=1,M=2,L=1,I=2,H=1,E=2,D=1] 
* CE 70: splitAndSort(A,B,C,D,E,F,G) = 2+ split(A,B,C,H,E,I,J):3+ sortAll(K,E,I,J,L,E,F,G):5
     [B+J>=E+1,B>=E,B>=I,G>=0,F>=1,E>=3,J>=0,I>=2,C>=0,A>=1,L=1,K=1,H=1,D=1] 

### Cost equations --> "Loop" of splitAndSort/7 
* CEs [70] --> Loop 54 
* CEs [68,69] --> Loop 55 
* CEs [67] --> Loop 56 
* CEs [66] --> Loop 57 
* CEs [65] --> Loop 58 
* CEs [64] --> Loop 59 

#### Loops of splitAndSort/7 
* Loop 54: splitAndSort(A,B,C,D,E,F,G) [B>=E,G>=0,F>=1,E>=3,C>=0,A>=1,D=1] 
* Loop 55: splitAndSort(A,B,C,D,E,F,G) [G>=0,F>=2,C>=0,B>=3,A>=1,E=2,D=1] 
* Loop 56: splitAndSort(A,B,C,D,E,F,G) [G>=0,C>=0,B>=3,A>=1,F=1,E=2,D=1] 
* Loop 57: splitAndSort(A,B,C,D,E,F,G) [G>=0,C>=0,A>=1,F=2,E=2,D=1,B=2] 
* Loop 58: splitAndSort(A,B,C,D,E,F,G) [G>=0,C>=0,A>=1,F=1,E=2,D=1,B=2] 
* Loop 59: splitAndSort(A,B,C,D,E,F,G) [G>=0,C>=0,F=0,E=1,D=0,B=1,A=0] 

### Ranking functions of CR splitAndSort(A,B,C,D,E,F,G) 

#### Partial ranking functions of CR splitAndSort(A,B,C,D,E,F,G) 


### Resulting Chains:splitAndSort(A,B,C,D,E,F,G) 
* [59]
* [58]
* [57]
* [56]
* [55]
* [54]


### Merging Chains  splitAndSort/7 into  External patterns of execution 
* [[59]] --> 1 
* [[58]] --> 2 
* [[57]] --> 3 
* [[56]] --> 4 
* [[55]] --> 5 
* [[54]] --> 6 


Computing Bounds
=====================================

#### Simplifying cost structure of CE 20 

#### Simplifying cost structure of CE 19 

#### Cost of chains of maxNorm(A,B,C):
* Chain [20]: 0
  with precondition: [A=C,B>=0,A>=B+1] 

* Chain [19]: 0
  with precondition: [C=B,A>=1,C>=A] 


#### Simplifying cost structure of CE 21 

#### Computing cost of phase [21,22] 

#### Simplifying cost structure of CE 23 

#### Simplifying cost structure of CE 22 

#### Cost of loops [21,22] 

 * loop 21:append(A,B,C,D,E,F,G,H,I,J,K,L) -> [append(A',B',C',D',E',F',G',H',I',J',K',L')] 
5
 * loop 22:append(A,B,C,D,E,F,G,H,I,J,K,L) -> [append(A',B',C',D',E',F',G',H',I',J',K',L')] 
5
##### Pending set append(A,B,C,D,E,F,G,H,I,J,K,L)
* Psum in Loop 21: [it(21)=<1]
* Psum in Loop 22: [it(22)=<1]

###### Computing sum for it(21)=<1  in Loop 21 
   - Applying inductive sum strategy 
     - head Candidate: C-1 
       - Loop 22 is collaborative and bounds [it(22)] 
     - head Candidate: A-1 
       - Loop 22 is collaborative and bounds [it(22)] 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - Loop 22 is collaborative and bounds [it(22)] 
     - tail Candidate: A-1 
       - Loop 22 is collaborative and bounds [it(22)] 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(21)+it(22)=<C-1,it(21)+it(22)=<A-1,it(21)+it(22)=<A-1,it(21)+it(22)=<C-1,it(21)+it(22)=<C-C',it(21)+it(22)=<A-A',it(21)+it(22)=<A-A',it(21)+it(22)=<C-C'] 

##### Pending set A
* Psum in Loop 22: [it(22)=<1]

###### Computing sum for it(22)=<1  in Loop 22 
   - Applying inductive sum strategy 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(21)+it(22)=<C-1,it(21)+it(22)=<A-1,it(21)+it(22)=<A-1,it(21)+it(22)=<C-1,it(21)+it(22)=<C-C',it(21)+it(22)=<A-A',it(21)+it(22)=<A-A',it(21)+it(22)=<C-C'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [21,22] 

#### Simplifying cost structure of phase [21,22] 
 * Joined equivalent variables [it(21),it(22)] into it(21)

#### Cost of phase [21,22]:append(A,B,C,D,E,F,G,H,I,J,K,L) -> [append(A',B',C',D',E',F',G',H',I',J',K',L')] 
10*it(21)+0
  Such that:aux(1) =< A
aux(2) =< A-A'
aux(3) =< C
aux(4) =< C-C'
it(21) =< aux(1)
it(21) =< aux(2)
it(21) =< aux(3)
it(21) =< aux(4)

#### Simplifying cost structure of chain [[21,22],23] 
 * Joined equivalent variables [aux(5),aux(1),aux(2),aux(3),aux(4)] into aux(5)

#### Cost of chains of append(A,B,C,D,E,F,G,H,I,J,K,L):
* Chain [[21,22],23]: 10*it(21)+2
  Such that:aux(5) =< A
it(21) =< aux(5)

  with precondition: [A=C,A+E=I+1,A+G=K+1,A>=2,B>=0,D>=1,E>=1,F>=0,G>=1,H>=0,L>=1,J>=F,L>=H,D+H>=L] 

* Chain [23]: 2
  with precondition: [A=1,C=1,D=0,E=I,F=J,G=K,H=L,B>=0,E>=0,F>=0,G>=0,H>=0] 


#### Simplifying cost structure of CE 32 

#### Computing cost of phase [26,27] 

#### Simplifying cost structure of CE 26 

#### Simplifying cost structure of CE 24 

#### Cost of loops [26,27] 

 * loop 26:insertL(A,B,C,D,E,F,G,H,I,J) -> [insertL(A',B',C',D',E',F',G',H',I',J')] 
10
 * loop 27:insertL(A,B,C,D,E,F,G,H,I,J) -> [insertL(A',B',C',D',E',F',G',H',I',J')] 
10
##### Pending set insertL(A,B,C,D,E,F,G,H,I,J)
* Psum in Loop 26: [it(26)=<1]
* Psum in Loop 27: [it(27)=<1]

###### Computing sum for it(26)=<1  in Loop 26 
   - Applying inductive sum strategy 
     - head Candidate: D-1 
       - Loop 27 is collaborative and bounds [it(27)] 
     - head Candidate: D-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: D-1 
       - Loop 27 is collaborative and bounds [it(27)] 
     - tail Candidate: D-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(26)+it(27)=<D-1,it(26)+it(27)=<D-1,it(26)+it(27)=<D-D',it(26)+it(27)=<D-D'] 

##### Pending set A
* Psum in Loop 27: [it(27)=<1]

###### Computing sum for it(27)=<1  in Loop 27 
   - Applying inductive sum strategy 
     - head Candidate: D-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: D-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: D-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: D-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(26)+it(27)=<D-1,it(26)+it(27)=<D-1,it(26)+it(27)=<D-D',it(26)+it(27)=<D-D'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [26,27] 

#### Simplifying cost structure of phase [26,27] 
 * Joined equivalent variables [it(26),it(27)] into it(26)

#### Cost of phase [26,27]:insertL(A,B,C,D,E,F,G,H,I,J) -> [insertL(A',B',C',D',E',F',G',H',I',J')] 
20*it(26)+0
  Such that:aux(6) =< D
aux(7) =< D-D'
it(26) =< aux(6)
it(26) =< aux(7)

#### Simplifying cost structure of chain [[26,27],25] 
 * Joined equivalent variables [aux(8),aux(6),aux(7)] into aux(8)

#### Simplifying cost structure of CE 28 

#### Simplifying cost structure of CE 29 

#### Simplifying cost structure of CE 30 

#### Simplifying cost structure of CE 31 

#### Found solution for phase  [26,27] in the cache 

#### Cost of phase [26,27]:insertL(A,B,C,D,E,F,G,H,I,J) -> [insertL(A',B',C',D',E',F',G',H',I',J')] 
20*it(26)+0
  Such that:aux(6) =< D
aux(7) =< D-D'
it(26) =< aux(6)
it(26) =< aux(7)

#### Simplifying cost structure of chain [[26,27],24] 
 * Joined equivalent variables [aux(9),aux(6),aux(7)] into aux(9)
 * Renamed intermediate variables: 
[ (ch([[26,27],24]),aux(9))>>s(1), (ch([[26,27],24]),it(26))>>s(2)]

#### Cost of chains of insertL(A,B,C,D,E,F,G,H,I,J):
* Chain [[26,27],25]: 20*it(26)+9
  Such that:aux(8) =< H
it(26) =< aux(8)

  with precondition: [A=1,G=1,D+1=H,B>=0,C>=1,D>=2,F>=1,I>=2,J>=1,E+1>=I] 

* Chain [[26,27],24]: 20*it(26)+10
  Such that:aux(9) =< H
it(26) =< aux(9)

  with precondition: [A=1,D=H,B>=0,D>=3,F>=1,G>=1,I>=2,J>=1,C>=G,E+1>=I] 

* Chain [25]: 9
  with precondition: [A=1,C=0,D=1,E=0,G=1,H=2,I=2,B>=0,F>=0,J>=0] 

* Chain [24]: 10
  with precondition: [A=1,D=H,B>=0,D>=2,F>=0,G>=1,I>=2,J>=0,C>=G,E+1>=I] 


#### Simplifying cost structure of CE 34 

#### Simplifying cost structure of CE 35 

#### Simplifying cost structure of CE 36 

#### Simplifying cost structure of CE 33 

#### Cost of chains of case_7(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S):
* Chain [33]: 3
  with precondition: [A=1,D=1,Q=1,H=E,H=K+1,M+1=R,H>=2,J>=0,L>=0,N>=0,O>=1,P>=0,F>=G,F>=I,G>=J,I>=J,S>=J,I>=L,B>=M,C>=N,S>=N,M>=O,C>=P,S>=P] 

* Chain [32]: 3
  with precondition: [A=1,D=1,Q=1,H=E,H=K+1,O+1=R,G>=0,H>=2,L>=0,M>=1,N>=0,O>=1,P>=0,J>=G+1,F>=I,I>=J,S>=J,I>=L,B>=M,O+1>=M,C>=N,S>=N,B>=O,C>=P,S>=P] 

* Chain [31]: 3
  with precondition: [A=1,D=1,Q=1,H=E,H=K+1,M=R,G>=0,H>=2,L>=0,N>=0,O>=1,P>=0,J>=G+1,F>=I,I>=J,S>=J,I>=L,B>=M,C>=N,S>=N,M>=O+2,C>=P,S>=P] 

* Chain [30]: 3
  with precondition: [A=1,D=1,Q=1,H=E,H=K+1,O=R,H>=2,J>=0,L>=0,M>=1,N>=0,P>=0,F>=G,F>=I,G>=J,I>=J,S>=J,I>=L,O>=M+1,C>=N,S>=N,B>=O,C>=P,S>=P] 


#### Simplifying cost structure of CE 37 

#### Computing cost of phase [34] 

#### Simplifying cost structure of CE 38 

#### Simplifying cost structure of CE 39 

#### Simplifying cost structure of CE 40 

#### Simplifying cost structure of CE 41 

#### Cost of loops [34] 

 * loop 34:splitqs(A,B,C,D,E,F) -> [splitqs(A',B',C',D',E',F')] 
15
##### Pending set splitqs(A,B,C,D,E,F)
* Psum in Loop 34: [it(34)=<1]

###### Computing sum for it(34)=<1  in Loop 34 
   - Applying inductive sum strategy 
     - head Candidate: B-1 
     - head Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B-1 
     - tail Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(34)=<B-1,it(34)=<B-1,it(34)=<B-B',it(34)=<B-B'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [34] 

#### Simplifying cost structure of phase [34] 

#### Cost of phase [34]:splitqs(A,B,C,D,E,F) -> [splitqs(A',B',C',D',E',F')] 
15*it(34)+0
  Such that:it(34) =< B
it(34) =< B-B'

#### Simplifying cost structure of chain [[34],35] 

#### Cost of chains of splitqs(A,B,C,D,E,F):
* Chain [[34],35]: 15*it(34)+7
  Such that:it(34) =< B

  with precondition: [A=1,D=1,C>=0,E>=2,F>=0,B>=E] 

* Chain [35]: 7
  with precondition: [A=1,B=1,D=1,E=1,C>=0,F>=0] 


#### Simplifying cost structure of CE 46 

#### Simplifying cost structure of CE 42 

#### Simplifying cost structure of chain [multiple(40,[[36]])] 
 * Renamed intermediate variables: 
[ (eq(43,2),aux(5))>>s(3), (eq(43,2),it(21))>>s(4)]

#### Simplifying cost structure of CE 43 

#### Simplifying cost structure of chain [multiple(39,[[36]])] 

#### Computing cost of chain [multiple([37,38],[[multiple(40,[[36]])],[multiple(39,[[36]])],[36]])] with multiple recursion
 * Renamed intermediate variables: 
[ (eq(45,1),it(34))>>s(5)]
 * Renamed intermediate variables: 
[ (eq(45,2),aux(5))>>s(6), (eq(45,2),it(21))>>s(7)]

#### Simplifying cost structure of CE 45 
 * Renamed intermediate variables: 
[ (it(37),s(5))>>s(8), (it(37),s(7))>>s(9)]
 * Renamed intermediate variables: 
[ (eq(44,1),it(34))>>s(10)]

#### Simplifying cost structure of CE 44 
 * Renamed intermediate variables: 
[ (it(38),s(10))>>s(11)]

#### Cost of loops [37,38] 

 * loop 37:quicksort(A,B,C,D) -> [quicksort(A',B',C',D'),quicksort(A'2,B'2,C'2,D'2)] 
15*s(8)+10*s(9)+22
  Such that:s(8) =< A

Unbounded itvars
s(9) :  it(37),s(7)

 * loop 38:quicksort(A,B,C,D) -> [quicksort(A',B',C',D'),quicksort(A'2,B'2,C'2,D'2)] 
15*s(11)+22
  Such that:s(11) =< A
 * The following chains are unfeasible as continuations of this chain: [[multiple(39,[[36]])]] 

##### Pending set quicksort(A,B,C,D)
* Psum in Loop 37: [it(37)=<1,s(12)=<A]
* Psum in Loop 38: [it(38)=<1,s(14)=<A]
* Psum in Chain-Tail [36]: [it([36])=<1]
* Psum in Chain-Tail [multiple(40,[[36]])]: [it([multiple(40,[[36]])])=<1]

###### Computing sum for it(37)=<1  in Loop 37 
   - Applying inductive sum strategy 
   - No strategy succeeded 
 * Adding constraints: [] 

##### Pending set A
* Psum in Loop 37: [s(12)=<A]
* Psum in Loop 38: [it(38)=<1,s(14)=<A]
* Psum in Chain-Tail [36]: [it([36])=<1]
* Psum in Chain-Tail [multiple(40,[[36]])]: [it([multiple(40,[[36]])])=<1]

###### Computing sum for s(12)=<A  in Loop 37 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(10)=<A] 
 * Adding constraints: [s(12)=<it(37)*aux(10)] 

##### Pending set quicksort(A,B,C,D)
* Pmax/min: [aux(10)=<A]
* Psum in Loop 38: [it(38)=<1,s(14)=<A]
* Psum in Chain-Tail [36]: [it([36])=<1]
* Psum in Chain-Tail [multiple(40,[[36]])]: [it([multiple(40,[[36]])])=<1]

###### Computing max_min for aux(10)=<A  
   - Found a solution using transitive invariants 
 * Adding constraints:[aux(10)=<A] 

##### Pending set quicksort(A,B,C,D)
* Psum in Loop 38: [it(38)=<1,s(14)=<A]
* Psum in Chain-Tail [36]: [it([36])=<1]
* Psum in Chain-Tail [multiple(40,[[36]])]: [it([multiple(40,[[36]])])=<1]

###### Computing sum for it(38)=<1  in Loop 38 
   - Applying inductive sum strategy 
   - No strategy succeeded 
 * Adding constraints: [] 

##### Pending set quicksort(A,B,C,D)
* Psum in Loop 38: [s(14)=<A]
* Psum in Chain-Tail [36]: [it([36])=<1]
* Psum in Chain-Tail [multiple(40,[[36]])]: [it([multiple(40,[[36]])])=<1]

###### Computing sum for s(14)=<A  in Loop 38 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(11)=<A] 
 * Adding constraints: [s(14)=<it(38)*aux(11)] 

##### Pending set quicksort(A,B,C,D)
* Pmax/min: [aux(11)=<A]
* Psum in Chain-Tail [36]: [it([36])=<1]
* Psum in Chain-Tail [multiple(40,[[36]])]: [it([multiple(40,[[36]])])=<1]

###### Computing max_min for aux(11)=<A  
   - Found a solution using cacheing 
 * Adding constraints:[aux(11)=<aux(10)] 

##### Pending set quicksort(A,B,C,D)
* Psum in Chain-Tail [36]: [it([36])=<1]
* Psum in Chain-Tail [multiple(40,[[36]])]: [it([multiple(40,[[36]])])=<1]

###### Computing sum for it([36])=<1  in Chain-Tail [36] 
   - Applying inductive sum strategy 
     - head Candidate: 1 
       - Loop 37 adds a constant 1/1 
       - Loop 38 adds a constant 1/1 
       - Chain-Tail [multiple(40,[[36]])] is collaborative and bounds [it([multiple(40,[[36]])])] 
     - tail Candidate: 1 
       - Loop 37 adds a constant 1/1 
       - Loop 38 adds a constant 1/1 
       - Chain-Tail [multiple(40,[[36]])] is collaborative and bounds [it([multiple(40,[[36]])])] 
 * Adding constraints: [it([36])+it([multiple(40,[[36]])])=<it(38)+it(37)+aux(12),it([36])+it([multiple(40,[[36]])])=<it(38)+it(37)+aux(13),aux(12)=<1,aux(13)=<1] 

##### Pending set quicksort(A,B,C,D)
* Psum in Chain-Tail [multiple(40,[[36]])]: [it([multiple(40,[[36]])])=<1]

###### Computing sum for it([multiple(40,[[36]])])=<1  in Chain-Tail [multiple(40,[[36]])] 
   - Applying inductive sum strategy 
     - head Candidate: 1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: 1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it([36])+it([multiple(40,[[36]])])=<it(38)+it(37)+aux(14),it([36])+it([multiple(40,[[36]])])=<it(38)+it(37)+aux(15),aux(14)=<1,aux(15)=<1] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [37,38,[multiple(40,[[36]])],[36]] 

#### Simplifying cost structure of phase [37,38,[multiple(40,[[36]])],[36]] 
 * Joined equivalent variables [aux(16),aux(12),aux(13),aux(14),aux(15)] into aux(16)
 * Joined equivalent variables [it([36]),it([multiple(40,[[36]])])] into it([36])
 * Joined equivalent variables [it(37),it(38),s(13)] into it(37)

#### Cost of phase [37,38]:quicksort(A,B,C,D) -> [] 
54*it(37)+31*it([36])+15*s(12)+15*s(14)+0
Unbounded itvars
it(37) :  it(37)
it([36]) :  it([36])
s(12) :  sum(37),s(8)
s(14) :  sum(38),s(11)

#### Cost of chains of quicksort(A,B,C,D):
* Chain [multiple(40,[[36]])]: 28
  with precondition: [A=2,C=2,B>=0,D>=0] 

* Chain [36]: 3
  with precondition: [A=1,C=1,B>=0,D>=0] 

* Chain [multiple([37,38],[[multiple(40,[[36]])],[multiple(39,[[36]])],[36]])]: 54*it(37)+31*it([36])+15*s(12)+15*s(14)+0
Unbounded itvars
it(37) :  it(37)
it([36]) :  it([36])
s(12) :  sum(37),s(8)
s(14) :  sum(38),s(11)

  with precondition: [A>=3,B>=0,C>=2,D>=0] 


#### Simplifying cost structure of CE 47 

#### Simplifying cost structure of CE 51 

#### Simplifying cost structure of chain [48,49] 

#### Computing cost of phase [41,42,43] 
 * Renamed intermediate variables: 
[ (eq(58,1),it(37))>>s(15), (eq(58,1),it([36]))>>s(16), (eq(58,1),s(12))>>s(17), (eq(58,1),s(14))>>s(18)]

#### Simplifying cost structure of CE 58 
 * Joined equivalent variables [s(15),s(16),s(17),s(18)] into s(15)
 * Renamed intermediate variables: 
[ (it(41),s(15))>>s(19)]

#### Simplifying cost structure of CE 48 

#### Simplifying cost structure of CE 52 
 * Renamed intermediate variables: 
[ (eq(56,1),it(37))>>s(20), (eq(56,1),it([36]))>>s(21), (eq(56,1),s(12))>>s(22), (eq(56,1),s(14))>>s(23)]

#### Simplifying cost structure of CE 56 
 * Joined equivalent variables [s(20),s(21),s(22),s(23)] into s(20)
 * Renamed intermediate variables: 
[ (it(42),aux(17))>>s(24)]

#### Simplifying cost structure of CE 54 

#### Cost of loops [41,42,43] 

 * loop 41:sortAll(A,B,C,D,E,F,G,H) -> [sortAll(A',B',C',D',E',F',G',H')] 
115*s(19)+7
Unbounded itvars
s(19) :  it(41),s(15)

 * loop 42:sortAll(A,B,C,D,E,F,G,H) -> [sortAll(A',B',C',D',E',F',G',H')] 
1*s(24)+0
Unbounded itvars
s(24) :  it(42),aux(17)

 * loop 43:sortAll(A,B,C,D,E,F,G,H) -> [sortAll(A',B',C',D',E',F',G',H')] 
35
##### Pending set sortAll(A,B,C,D,E,F,G,H)
* Psum in Loop 41: [it(41)=<1]
* Psum in Loop 42: [it(42)=<1]
* Psum in Loop 43: [it(43)=<1]

###### Computing sum for it(41)=<1  in Loop 41 
   - Applying inductive sum strategy 
     - head Candidate: B-1 
       - Loop 42 is collaborative and bounds [it(42)] 
       - Loop 43 is collaborative and bounds [it(43)] 
     - head Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B-1 
       - Loop 42 is collaborative and bounds [it(42)] 
       - Loop 43 is collaborative and bounds [it(43)] 
     - tail Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(41)+it(42)+it(43)=<B-1,it(41)+it(42)+it(43)=<B-1,it(41)+it(42)+it(43)=<B-B',it(41)+it(42)+it(43)=<B-B'] 

##### Pending set A
* Psum in Loop 42: [it(42)=<1]
* Psum in Loop 43: [it(43)=<1]

###### Computing sum for it(42)=<1  in Loop 42 
   - Applying inductive sum strategy 
     - head Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(41)+it(42)+it(43)=<B-1,it(41)+it(42)+it(43)=<B-1,it(41)+it(42)+it(43)=<B-B',it(41)+it(42)+it(43)=<B-B'] 

##### Pending set A
* Psum in Loop 43: [it(43)=<1]

###### Computing sum for it(43)=<1  in Loop 43 
   - Applying inductive sum strategy 
     - head Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(41)+it(42)+it(43)=<B-1,it(41)+it(42)+it(43)=<B-1,it(41)+it(42)+it(43)=<B-B',it(41)+it(42)+it(43)=<B-B'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [41,42,43] 

#### Simplifying cost structure of phase [41,42,43] 
 * Joined equivalent variables [s(25),s(26)] into s(25)
 * Joined equivalent variables [it(41),it(43)] into it(41)

#### Cost of phase [41,42,43]:sortAll(A,B,C,D,E,F,G,H) -> [sortAll(A',B',C',D',E',F',G',H')] 
42*it(41)+116*s(25)+0
  Such that:aux(18) =< B
aux(19) =< B-B'
it(41) =< aux(18)
it(41) =< aux(19)

Unbounded itvars
s(25) :  sum(41),s(19)

#### Simplifying cost structure of chain [[41,42,43],48,49] 
 * Joined equivalent variables [aux(20),aux(18),aux(19)] into aux(20)

#### Simplifying cost structure of CE 55 

#### Simplifying cost structure of chain [47,49] 

#### Found solution for phase  [41,42,43] in the cache 

#### Cost of phase [41,42,43]:sortAll(A,B,C,D,E,F,G,H) -> [sortAll(A',B',C',D',E',F',G',H')] 
42*it(41)+116*s(25)+0
  Such that:aux(18) =< B
aux(19) =< B-B'
it(41) =< aux(18)
it(41) =< aux(19)

Unbounded itvars
s(25) :  sum(41),s(19)

#### Simplifying cost structure of chain [[41,42,43],47,49] 
 * Joined equivalent variables [aux(21),aux(18),aux(19)] into aux(21)
 * Renamed intermediate variables: 
[ (eq(59,1),it(37))>>s(27), (eq(59,1),it([36]))>>s(28), (eq(59,1),s(12))>>s(29), (eq(59,1),s(14))>>s(30)]

#### Simplifying cost structure of CE 59 
 * Joined equivalent variables [s(27),s(28),s(29),s(30)] into s(27)

#### Simplifying cost structure of chain [45,49] 

#### Found solution for phase  [41,42,43] in the cache 

#### Cost of phase [41,42,43]:sortAll(A,B,C,D,E,F,G,H) -> [sortAll(A',B',C',D',E',F',G',H')] 
42*it(41)+116*s(25)+0
  Such that:aux(18) =< B
aux(19) =< B-B'
it(41) =< aux(18)
it(41) =< aux(19)

Unbounded itvars
s(25) :  sum(41),s(19)

#### Simplifying cost structure of chain [[41,42,43],45,49] 
 * Joined equivalent variables [aux(22),aux(18),aux(19)] into aux(22)
 * Joined equivalent variables [s(25),s(27)] into s(25)
 * Renamed intermediate variables: 
[ (ch([[41,42,43],45,49]),aux(22))>>s(31), (ch([[41,42,43],45,49]),it(41))>>s(32), (ch([[41,42,43],45,49]),s(25))>>s(33)]
 * Renamed intermediate variables: 
[ (ch([[41,42,43],47,49]),aux(21))>>s(34), (ch([[41,42,43],47,49]),it(41))>>s(35), (ch([[41,42,43],47,49]),s(25))>>s(36)]
 * Renamed intermediate variables: 
[ (ch([[41,42,43],48,49]),aux(20))>>s(37), (ch([[41,42,43],48,49]),it(41))>>s(38), (ch([[41,42,43],48,49]),s(25))>>s(39)]
 * Joined equivalent variables [aux(23),s(31),s(34),s(37)] into aux(23)
 * Joined equivalent variables [s(33),s(36),s(39)] into s(33)
 * Joined equivalent variables [s(32),s(35),s(38)] into s(32)

#### Cost of chains of sortAll(A,B,C,D,E,F,G,H):
* Chain [[41,42,43],48,49]: 42*it(41)+116*s(25)+13
  Such that:aux(20) =< F
it(41) =< aux(20)

Unbounded itvars
s(25) :  sum(41),s(19)

  with precondition: [E=1,B=F,A>=1,B>=3,C>=1,D>=0,G>=1,H>=0] 

* Chain [[41,42,43],47,49]: 42*it(41)+116*s(25)+38
  Such that:aux(21) =< F
it(41) =< aux(21)

Unbounded itvars
s(25) :  sum(41),s(19)

  with precondition: [E=1,B=F,A>=1,B>=3,C>=2,D>=0,G>=2,H>=0] 

* Chain [[41,42,43],45,49]: 42*it(41)+231*s(25)+10
  Such that:aux(22) =< F
it(41) =< aux(22)

Unbounded itvars
s(25) :  sum(41),s(19)

  with precondition: [E=1,B=F,A>=1,B>=3,C>=3,D>=0,G>=2,H>=0] 

* Chain [49]: 3
  with precondition: [A=0,B=1,C=0,E=0,F=1,G=0,D>=0,H>=0] 

* Chain [48,49]: 13
  with precondition: [B=2,E=1,F=2,G=1,A>=1,C>=1,D>=0,H>=0] 

* Chain [47,49]: 38
  with precondition: [B=2,E=1,F=2,G=2,A>=1,C>=2,D>=0,H>=0] 

* Chain [45,49]: 115*s(27)+10
Unbounded itvars
s(27) :  eq(59,1),it(37)

  with precondition: [B=2,E=1,F=2,A>=1,C>=3,D>=0,G>=2,H>=0] 


#### Simplifying cost structure of CE 60 

#### Simplifying cost structure of CE 61 

#### Simplifying cost structure of chain [52,53] 

#### Computing cost of phase [50,51] 
 * Renamed intermediate variables: 
[ (eq(63,1),s(1))>>s(40), (eq(63,1),s(2))>>s(41)]

#### Simplifying cost structure of CE 63 
 * Renamed intermediate variables: 
[ (it(50),s(40))>>s(42), (it(50),s(41))>>s(43)]
 * Renamed intermediate variables: 
[ (eq(62,1),aux(8))>>s(44), (eq(62,1),it(26))>>s(45)]

#### Simplifying cost structure of CE 62 
 * Renamed intermediate variables: 
[ (it(51),s(44))>>s(46), (it(51),s(45))>>s(47)]

#### Cost of loops [50,51] 

 * loop 50:split(A,B,C,D,E,F,G) -> [split(A',B',C',D',E',F',G')] 
20*s(43)+15
  Such that:s(42) =< B
s(43) =< s(42)

 * loop 51:split(A,B,C,D,E,F,G) -> [split(A',B',C',D',E',F',G')] 
20*s(47)+14
  Such that:s(46) =< B
s(47) =< s(46)

##### Pending set split(A,B,C,D,E,F,G)
* Psum in Loop 50: [it(50)=<1,s(49)=<B]
* Psum in Loop 51: [it(51)=<1,s(51)=<B]

###### Computing sum for it(50)=<1  in Loop 50 
   - Applying inductive sum strategy 
     - head Candidate: B-1 
       - Loop 51 is collaborative and bounds [it(51)] 
     - head Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B-1 
       - Loop 51 is collaborative and bounds [it(51)] 
     - tail Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(50)+it(51)=<B-1,it(50)+it(51)=<B-1,it(50)+it(51)=<B-B',it(50)+it(51)=<B-B'] 

##### Pending set A
* Psum in Loop 50: [s(49)=<B]
* Psum in Loop 51: [it(51)=<1,s(51)=<B]

###### Computing sum for s(49)=<B  in Loop 50 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(24)=<B] 
 * Adding constraints: [s(49)=<it(50)*aux(24)] 

##### Pending set split(A,B,C,D,E,F,G)
* Pmax/min: [aux(24)=<B]
* Psum in Loop 51: [it(51)=<1,s(51)=<B]

###### Computing max_min for aux(24)=<B  
   - Found a solution using transitive invariants 
 * Adding constraints:[aux(24)=<B] 

##### Pending set split(A,B,C,D,E,F,G)
* Psum in Loop 51: [it(51)=<1,s(51)=<B]

###### Computing sum for it(51)=<1  in Loop 51 
   - Applying inductive sum strategy 
     - head Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(50)+it(51)=<B-1,it(50)+it(51)=<B-1,it(50)+it(51)=<B-B',it(50)+it(51)=<B-B'] 

##### Pending set split(A,B,C,D,E,F,G)
* Psum in Loop 51: [s(51)=<B]

###### Computing sum for s(51)=<B  in Loop 51 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(25)=<B] 
 * Adding constraints: [s(51)=<it(51)*aux(25)] 

##### Pending set split(A,B,C,D,E,F,G)
* Pmax/min: [aux(25)=<B]

###### Computing max_min for aux(25)=<B  
   - Found a solution using cacheing 
 * Adding constraints:[aux(25)=<aux(24)] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [50,51] 

#### Simplifying cost structure of phase [50,51] 
 * Joined equivalent variables [aux(26),aux(24)] into aux(26)
 * Joined equivalent variables [it(50),it(51)] into it(50)

#### Cost of phase [50,51]:split(A,B,C,D,E,F,G) -> [split(A',B',C',D',E',F',G')] 
29*it(50)+20*s(48)+20*s(50)+0
  Such that:aux(26) =< B
aux(27) =< B-B'
it(50) =< aux(26)
it(50) =< aux(27)
aux(25) =< aux(26)
s(49) =< it(50)*aux(26)
s(51) =< it(50)*aux(25)
s(50) =< s(51)
s(48) =< s(49)

#### Simplifying cost structure of chain [[50,51],52,53] 
 * Joined equivalent variables [aux(28),aux(26),aux(27)] into aux(28)

#### Cost of chains of split(A,B,C,D,E,F,G):
* Chain [[50,51],52,53]: 29*it(50)+20*s(48)+20*s(50)+17
  Such that:aux(28) =< B
it(50) =< aux(28)
aux(25) =< aux(28)
s(49) =< it(50)*aux(28)
s(51) =< it(50)*aux(25)
s(50) =< s(51)
s(48) =< s(49)

  with precondition: [D=1,A>=1,B>=3,C>=0,E>=2,F>=2,G>=0,B>=E,B>=F,B+G>=E+1] 

* Chain [53]: 3
  with precondition: [A=0,B=1,D=0,E=1,F=0,C>=0,G>=0] 

* Chain [52,53]: 17
  with precondition: [B=2,D=1,E=2,F=2,A>=1,C>=0,G>=0] 


#### Simplifying cost structure of CE 64 

#### Simplifying cost structure of CE 65 

#### Simplifying cost structure of CE 66 
 * Renamed intermediate variables: 
[ (eq(67,1),aux(28))>>s(52), (eq(67,1),it(50))>>s(53), (eq(67,1),aux(25))>>s(54), (eq(67,1),s(49))>>s(55), (eq(67,1),s(51))>>s(56), (eq(67,1),s(50))>>s(57), (eq(67,1),s(48))>>s(58)]

#### Simplifying cost structure of CE 67 
 * Renamed intermediate variables: 
[ (eq(68,1),aux(28))>>s(59), (eq(68,1),it(50))>>s(60), (eq(68,1),aux(25))>>s(61), (eq(68,1),s(49))>>s(62), (eq(68,1),s(51))>>s(63), (eq(68,1),s(50))>>s(64), (eq(68,1),s(48))>>s(65)]

#### Simplifying cost structure of CE 68 
 * Renamed intermediate variables: 
[ (eq(69,1),aux(28))>>s(66), (eq(69,1),it(50))>>s(67), (eq(69,1),aux(25))>>s(68), (eq(69,1),s(49))>>s(69), (eq(69,1),s(51))>>s(70), (eq(69,1),s(50))>>s(71), (eq(69,1),s(48))>>s(72)]
 * Renamed intermediate variables: 
[ (eq(69,2),s(27))>>s(73)]

#### Simplifying cost structure of CE 69 
 * Joined equivalent variables [aux(29),s(59),s(66)] into aux(29)
 * Joined equivalent variables [s(61),s(68)] into s(61)
 * Joined equivalent variables [s(60),s(67)] into s(60)
 * Joined equivalent variables [s(63),s(70)] into s(63)
 * Joined equivalent variables [s(62),s(69)] into s(62)
 * Joined equivalent variables [s(65),s(72)] into s(65)
 * Joined equivalent variables [s(64),s(71)] into s(64)
 * Renamed intermediate variables: 
[ (eq(70,1),aux(28))>>s(74), (eq(70,1),it(50))>>s(75), (eq(70,1),aux(25))>>s(76), (eq(70,1),s(49))>>s(77), (eq(70,1),s(51))>>s(78), (eq(70,1),s(50))>>s(79), (eq(70,1),s(48))>>s(80)]
 * Renamed intermediate variables: 
[ (eq(70,2),aux(23))>>s(81), (eq(70,2),s(32))>>s(82), (eq(70,2),s(33))>>s(83)]

#### Simplifying cost structure of CE 70 
 * Joined equivalent variables [aux(30),s(74),s(81)] into aux(30)
 * Joined equivalent variables [s(75),s(82)] into s(75)

#### Cost of chains of splitAndSort(A,B,C,D,E,F,G):
* Chain [59]: 8
  with precondition: [A=0,B=1,D=0,E=1,F=0,C>=0,G>=0] 

* Chain [58]: 32
  with precondition: [B=2,D=1,E=2,F=1,A>=1,C>=0,G>=0] 

* Chain [57]: 57
  with precondition: [B=2,D=1,E=2,F=2,A>=1,C>=0,G>=0] 

* Chain [56]: 29*s(53)+20*s(57)+20*s(58)+32
  Such that:s(52) =< B
s(53) =< s(52)
s(54) =< s(52)
s(55) =< s(53)*s(52)
s(56) =< s(53)*s(54)
s(57) =< s(56)
s(58) =< s(55)

  with precondition: [D=1,E=2,F=1,A>=1,B>=3,C>=0,G>=0] 

* Chain [55]: 58*s(60)+40*s(64)+40*s(65)+115*s(73)+57
  Such that:aux(29) =< B
s(60) =< aux(29)
s(61) =< aux(29)
s(62) =< s(60)*aux(29)
s(63) =< s(60)*s(61)
s(64) =< s(63)
s(65) =< s(62)

Unbounded itvars
s(73) :  eq(69,2),s(27)

  with precondition: [D=1,E=2,A>=1,B>=3,C>=0,F>=2,G>=0] 

* Chain [54]: 155*s(75)+20*s(79)+20*s(80)+463*s(83)+57
  Such that:aux(30) =< B
s(75) =< aux(30)
s(76) =< aux(30)
s(77) =< s(75)*aux(30)
s(78) =< s(75)*s(76)
s(79) =< s(78)
s(80) =< s(77)

Unbounded itvars
s(83) :  eq(70,2),s(33)

  with precondition: [D=1,A>=1,C>=0,E>=3,F>=1,G>=0,B>=E] 


Closed-form bounds of insertL(A,B,C,D,E,F,G,H,I,J): 
-------------------------------------
* Chain [[26,27],25] with precondition: [A=1,G=1,D+1=H,B>=0,C>=1,D>=2,F>=1,I>=2,J>=1,E+1>=I] 
    - Upper bound: 20*D+29 
    - Complexity: n 
* Chain [[26,27],24] with precondition: [A=1,D=H,B>=0,D>=3,F>=1,G>=1,I>=2,J>=1,C>=G,E+1>=I] 
    - Upper bound: 20*D+10 
    - Complexity: n 
* Chain [25] with precondition: [A=1,C=0,D=1,E=0,G=1,H=2,I=2,B>=0,F>=0,J>=0] 
    - Upper bound: 9 
    - Complexity: constant 
* Chain [24] with precondition: [A=1,D=H,B>=0,D>=2,F>=0,G>=1,I>=2,J>=0,C>=G,E+1>=I] 
    - Upper bound: 10 
    - Complexity: constant 

### Maximum cost of insertL(A,B,C,D,E,F,G,H,I,J): 20*D+29 
Asymptotic class: n 

Closed-form bounds of split(A,B,C,D,E,F,G): 
-------------------------------------
* Chain [[50,51],52,53] with precondition: [D=1,A>=1,B>=3,C>=0,E>=2,F>=2,G>=0,B>=E,B>=F,B+G>=E+1] 
    - Upper bound: 29*B+17+40*B*B 
    - Complexity: n^2 
* Chain [53] with precondition: [A=0,B=1,D=0,E=1,F=0,C>=0,G>=0] 
    - Upper bound: 3 
    - Complexity: constant 
* Chain [52,53] with precondition: [B=2,D=1,E=2,F=2,A>=1,C>=0,G>=0] 
    - Upper bound: 17 
    - Complexity: constant 

### Maximum cost of split(A,B,C,D,E,F,G): max([14,29*B+14+40*B*B])+3 
Asymptotic class: n^2 

Closed-form bounds of splitqs(A,B,C,D,E,F): 
-------------------------------------
* Chain [[34],35] with precondition: [A=1,D=1,C>=0,E>=2,F>=0,B>=E] 
    - Upper bound: 15*B+7 
    - Complexity: n 
* Chain [35] with precondition: [A=1,B=1,D=1,E=1,C>=0,F>=0] 
    - Upper bound: 7 
    - Complexity: constant 

### Maximum cost of splitqs(A,B,C,D,E,F): 15*B+7 
Asymptotic class: n 

Closed-form bounds of append(A,B,C,D,E,F,G,H,I,J,K,L): 
-------------------------------------
* Chain [[21,22],23] with precondition: [A=C,A+E=I+1,A+G=K+1,A>=2,B>=0,D>=1,E>=1,F>=0,G>=1,H>=0,L>=1,J>=F,L>=H,D+H>=L] 
    - Upper bound: 10*A+2 
    - Complexity: n 
* Chain [23] with precondition: [A=1,C=1,D=0,E=I,F=J,G=K,H=L,B>=0,E>=0,F>=0,G>=0,H>=0] 
    - Upper bound: 2 
    - Complexity: constant 

### Maximum cost of append(A,B,C,D,E,F,G,H,I,J,K,L): 10*A+2 
Asymptotic class: n 
 * Joined equivalent variables [it(37),it([36]),s(12),s(14)] into it(37)

Closed-form bounds of quicksort(A,B,C,D): 
-------------------------------------
* Chain [multiple(40,[[36]])] with precondition: [A=2,C=2,B>=0,D>=0] 
    - Upper bound: 28 
    - Complexity: constant 
* Chain [36] with precondition: [A=1,C=1,B>=0,D>=0] 
    - Upper bound: 3 
    - Complexity: constant 
* Chain [multiple([37,38],[[multiple(40,[[36]])],[multiple(39,[[36]])],[36]])] with precondition: [A>=3,B>=0,C>=2,D>=0] 
    - Upper bound: inf 
    - Complexity: infinity 

### Maximum cost of quicksort(A,B,C,D): inf 
Asymptotic class: infinity 

Closed-form bounds of sortAll(A,B,C,D,E,F,G,H): 
-------------------------------------
* Chain [[41,42,43],48,49] with precondition: [E=1,B=F,A>=1,B>=3,C>=1,D>=0,G>=1,H>=0] 
    - Upper bound: inf 
    - Complexity: infinity 
* Chain [[41,42,43],47,49] with precondition: [E=1,B=F,A>=1,B>=3,C>=2,D>=0,G>=2,H>=0] 
    - Upper bound: inf 
    - Complexity: infinity 
* Chain [[41,42,43],45,49] with precondition: [E=1,B=F,A>=1,B>=3,C>=3,D>=0,G>=2,H>=0] 
    - Upper bound: inf 
    - Complexity: infinity 
* Chain [49] with precondition: [A=0,B=1,C=0,E=0,F=1,G=0,D>=0,H>=0] 
    - Upper bound: 3 
    - Complexity: constant 
* Chain [48,49] with precondition: [B=2,E=1,F=2,G=1,A>=1,C>=1,D>=0,H>=0] 
    - Upper bound: 13 
    - Complexity: constant 
* Chain [47,49] with precondition: [B=2,E=1,F=2,G=2,A>=1,C>=2,D>=0,H>=0] 
    - Upper bound: 38 
    - Complexity: constant 
* Chain [45,49] with precondition: [B=2,E=1,F=2,A>=1,C>=3,D>=0,G>=2,H>=0] 
    - Upper bound: inf 
    - Complexity: infinity 

### Maximum cost of sortAll(A,B,C,D,E,F,G,H): inf 
Asymptotic class: infinity 

Closed-form bounds of splitAndSort(A,B,C,D,E,F,G): 
-------------------------------------
* Chain [59] with precondition: [A=0,B=1,D=0,E=1,F=0,C>=0,G>=0] 
    - Upper bound: 8 
    - Complexity: constant 
* Chain [58] with precondition: [B=2,D=1,E=2,F=1,A>=1,C>=0,G>=0] 
    - Upper bound: 32 
    - Complexity: constant 
* Chain [57] with precondition: [B=2,D=1,E=2,F=2,A>=1,C>=0,G>=0] 
    - Upper bound: 57 
    - Complexity: constant 
* Chain [56] with precondition: [D=1,E=2,F=1,A>=1,B>=3,C>=0,G>=0] 
    - Upper bound: 29*B+32+40*B*B 
    - Complexity: n^2 
* Chain [55] with precondition: [D=1,E=2,A>=1,B>=3,C>=0,F>=2,G>=0] 
    - Upper bound: inf 
    - Complexity: infinity 
* Chain [54] with precondition: [D=1,A>=1,C>=0,E>=3,F>=1,G>=0,B>=E] 
    - Upper bound: inf 
    - Complexity: infinity 

### Maximum cost of splitAndSort(A,B,C,D,E,F,G): inf 
Asymptotic class: infinity 
* Total analysis performed in 4970 ms.


Cost relation system solved by CoFloCo in 4972 ms.

Method insertL terminates?: YES

 - x_1: size of x wrt. Pair<Rat, Rat>
 - x_2: size of x wrt. Rat
 - l_1: size of l wrt. Pair<List<Rat>, Rat>
 - l_2: size of l wrt. List<Pair<List<Rat>, Rat>>
 - l_3: size of l wrt. List<Rat>
 - l_4: size of l wrt. Rat
UB for insertL(x_1,x_2,l_1,l_2,l_3,l_4) = 20*l_2+29

Method split terminates?: YES

 - l_1: size of l wrt. Pair<Rat, Rat>
 - l_2: size of l wrt. List<Pair<Rat, Rat>>
 - l_3: size of l wrt. Rat
UB for split(l_1,l_2,l_3) = max([14,29*l_2+14+40*l_2*l_2])+3

Method splitqs terminates?: YES

 - q_1: size of q wrt. Pair<Rat, List<Rat>>
 - q_2: size of q wrt. List<Rat>
 - q_3: size of q wrt. Rat
UB for splitqs(q_1,q_2,q_3) = 15*q_2+7

Method append terminates?: YES

 - l_1: size of l wrt. List<Rat>
 - l_2: size of l wrt. Rat
 - l_3: size of l wrt. List<A>
 - l_4: size of l wrt. A
 - ys_1: size of ys wrt. List<Rat>
 - ys_2: size of ys wrt. Rat
 - ys_3: size of ys wrt. List<A>
 - ys_4: size of ys wrt. A
UB for append(l_1,l_2,l_3,l_4,ys_1,ys_2,ys_3,ys_4) = 10*l_1+2

Method quicksort terminates?: YES

 - l_1: size of l wrt. List<Rat>
 - l_2: size of l wrt. Rat
UB for quicksort(l_1,l_2) = inf

Method sortAll terminates?: YES

 - l_1: size of l wrt. Pair<List<Rat>, Rat>
 - l_2: size of l wrt. List<Pair<List<Rat>, Rat>>
 - l_3: size of l wrt. List<Rat>
 - l_4: size of l wrt. Rat
UB for sortAll(l_1,l_2,l_3,l_4) = inf

Method splitAndSort terminates?: YES

 - l_1: size of l wrt. Pair<Rat, Rat>
 - l_2: size of l wrt. List<Pair<Rat, Rat>>
 - l_3: size of l wrt. Rat
UB for splitAndSort(l_1,l_2,l_3) = inf
