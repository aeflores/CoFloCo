
Abs program loaded in 24 ms.

Rule based representation generated in 3 ms.

Rule based representation stored in /tmp/costabs/rbr.rbr

RBR properties stored in /tmp/costabs/rbr.properties

Class invariants generated and loaded in 0 ms.

Abstract compilation performed in 17 ms.

Cost relation system stored in /tmp/costabs/crs.crs

Generated 34 equations 
entry('append'(A,B,C,D,E,F):[]).
entry('append_all'(A,B,C,D,E):[]).
entry('append_all2'(A,B,C,D,E,F):[]).
entry('append_all3'(A,B,C,D,E,F,G):[]).
input_output_vars('and_op'(A,B,C),[A,B],[C]).
input_output_vars('append'(A,B,C,D,E,F),[A,B,C,D],[E,F]).
input_output_vars('append_all'(A,B,C,D,E),[A,B,C],[D,E]).
input_output_vars('append_all2'(A,B,C,D,E,F),[A,B,C,D],[E,F]).
input_output_vars('append_all3'(A,B,C,D,E,F,G),[A,B,C,D,E],[F,G]).
input_output_vars('case_0'(A,B,C,D,E,F),[A,B,C,D],[E,F]).
input_output_vars('case_1'(A,B,C,D,E),[A,B,C],[D,E]).
input_output_vars('case_2'(A,B,C,D,E,F),[A,B,C,D],[E,F]).
input_output_vars('case_3'(A,B,C,D,E,F,G),[A,B,C,D,E],[F,G]).
input_output_vars('eq'(A,B,C),[A,B],[C]).
input_output_vars('geq'(A,B,C),[A,B],[C]).
input_output_vars('gt'(A,B,C),[A,B],[C]).
input_output_vars('leq'(A,B,C),[A,B],[C]).
input_output_vars('lt'(A,B,C),[A,B],[C]).
input_output_vars('maxNorm'(A,B,C),[A,B],[C]).
input_output_vars('neg'(A,B),[A],[B]).
input_output_vars('neq'(A,B,C),[A,B],[C]).
input_output_vars('or'(A,B,C),[A,B],[C]).
eq('eq',[A,B,C],0,[],[A=B,C=1,A>=0,B>=0,C>=0]).
eq('eq',[A,B,C],0,[],[A>=B+1,C=0,A>=0,B>=0,C>=0]).
eq('eq',[A,B,C],0,[],[B>=A+1,C=0,A>=0,B>=0,C>=0]).
eq('neq',[A,B,C],0,[],[A=B,C=0,A>=0,B>=0,C>=0]).
eq('neq',[A,B,C],0,[],[A>=B+1,C=1,A>=0,B>=0,C>=0]).
eq('neq',[A,B,C],0,[],[B>=A+1,C=1,A>=0,B>=0,C>=0]).
eq('lt',[A,B,C],0,[],[B-A>=1,C=1,A>=0,B>=0,C>=0]).
eq('lt',[A,B,C],0,[],[B=<A,C=0,A>=0,B>=0,C>=0]).
eq('leq',[A,B,C],0,[],[A=<B,C=1,A>=0,B>=0,C>=0]).
eq('leq',[A,B,C],0,[],[A-B>=1,C=0,A>=0,B>=0,C>=0]).
eq('gt',[A,B,C],0,[],[A-B>=1,C=1,A>=0,B>=0,C>=0]).
eq('gt',[A,B,C],0,[],[A=<B,C=0,A>=0,B>=0,C>=0]).
eq('geq',[A,B,C],0,[],[B=<A,C=1,A>=0,B>=0,C>=0]).
eq('geq',[A,B,C],0,[],[B-A>=1,C=0,A>=0,B>=0,C>=0]).
eq('neg',[A,B],0,[],[A=0,B=1,A>=0,B>=0]).
eq('neg',[A,B],0,[],[A=1,B=0,A>=0,B>=0]).
eq('and_op',[A,B,C],0,[],[A=0,C=0,A>=0,B>=0,C>=0]).
eq('and_op',[A,B,C],0,[],[A=1,C=B,A>=0,B>=0,C>=0]).
eq('or',[A,B,C],0,[],[A=1,C=1,A>=0,B>=0,C>=0]).
eq('or',[A,B,C],0,[],[A=0,C=B,A>=0,B>=0,C>=0]).
eq('maxNorm',[A,B,A],0,[],[A>=1+B,A>=0,B>=0,A>=0]).
eq('maxNorm',[A,B,B],0,[],[A=<B,A>=0,B>=0,B>=0]).
eq('case_0',[A,B,C,D,C,D],1,[],[B=0,A=1,A>=0,B>=0,C>=0,D>=0,C>=0,D>=0]).
eq('case_0',[A,B,C,D,E,F],4,['append'(G,H,C,D,I,J),'maxNorm'(K,J,F)],[B>=K,B>=H,A=G+1,G>=1,K>=1,E=I+1,I>=1,K>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0]).
eq('append',[A,B,C,D,E,F],1,['case_0'(A,B,C,D,E,F)],[A>=0,B>=0,C>=0,D>=0,E>=0,F>=0]).
eq('case_1',[A,B,C,D,E],2,[],[C=0,B=0,A=1,E=0,D=1,A>=0,B>=0,C>=0,D>=0,E>=0]).
eq('case_1',[A,B,C,D,E],4,['append_all'(F,G,H,I,J),'append'(K,L,I,J,D,E)],[C>=L,C>=H,B>=K,B>=G,A=F+1,F>=1,K>=1,A>=0,B>=0,C>=0,D>=0,E>=0]).
eq('append_all',[A,B,C,D,E],1,['case_1'(A,B,C,D,E)],[A>=0,B>=0,C>=0,D>=0,E>=0]).
eq('case_2',[A,B,C,D,E,F],2,[],[D=0,C=0,B=0,A=1,F=0,E=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0]).
eq('case_2',[A,B,C,D,E,F],5,['append_all'(G,H,I,J,K),'append_all2'(L,M,N,O,P,Q),'append'(J,K,P,Q,E,F)],[D>=I,D>=O,C>=H,C>=N,B>=G,B>=M,A=L+1,L>=1,G>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0]).
eq('append_all2',[A,B,C,D,E,F],1,['case_2'(A,B,C,D,E,F)],[A>=0,B>=0,C>=0,D>=0,E>=0,F>=0]).
eq('case_3',[A,B,C,D,E,F,G],2,[],[E=0,D=0,C=0,B=0,A=1,G=0,F=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0]).
eq('case_3',[A,B,C,D,E,F,G],5,['append_all2'(H,I,J,K,L,M),'append_all3'(N,O,P,Q,R,S,T),'append'(L,M,S,T,F,G)],[E>=K,E>=R,D>=J,D>=Q,C>=I,C>=P,B>=H,B>=O,A=N+1,N>=1,H>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0]).
eq('append_all3',[A,B,C,D,E,F,G],1,['case_3'(A,B,C,D,E,F,G)],[A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0]).

Preprocessing Cost Relations
=====================================

#### Computed strongly connected components 
0. non_recursive  : [maxNorm/3]
1. recursive [non_tail] : [append/6,case_0/6]
2. recursive [non_tail] : [append_all/5,case_1/5]
3. recursive [non_tail] : [append_all2/6,case_2/6]
4. recursive [non_tail] : [append_all3/7,case_3/7]
Warning: the following predicates are never called:[and_op/3,eq/3,geq/3,gt/3,leq/3,lt/3,neg/2,neq/3,or/3]

#### Obtained direct recursion through partial evaluation 
0. SCC is partially evaluated into maxNorm/3
1. SCC is partially evaluated into append/6
2. SCC is partially evaluated into append_all/5
3. SCC is partially evaluated into append_all2/6
4. SCC is partially evaluated into append_all3/7

Control-Flow Refinement of Cost Relations
=====================================

### Specialization of cost equations maxNorm/3 
* CE 10 is refined into CE [11] 
* CE 9 is refined into CE [12] 


#### Refined cost equations maxNorm/3 
* CE 11: maxNorm(A,B,B) = 0
     [B>=A,A>=1] 
* CE 12: maxNorm(A,B,A) = 0
     [A>=B+1,B>=0] 

### Cost equations --> "Loop" of maxNorm/3 
* CEs [11] --> Loop 11 
* CEs [12] --> Loop 12 

#### Loops of maxNorm/3 
* Loop 11: maxNorm(A,B,B) [B>=A,A>=1] 
* Loop 12: maxNorm(A,B,A) [A>=B+1,B>=0] 

### Ranking functions of CR maxNorm(A,B,C) 

#### Partial ranking functions of CR maxNorm(A,B,C) 


### Resulting Chains:maxNorm(A,B,C) 
* [12]
* [11]


### Merging Chains  maxNorm/3 into  External patterns of execution 
* [[11]] --> 1 
* [[12]] --> 2 


### Specialization of cost equations append/6 
* CE 2 is refined into CE [13] 
* CE 1 is refined into CE [14,15] 


#### Refined cost equations append/6 
* CE 13: append(A,B,C,D,C,D) = 2
     [D>=0,C>=0,B=0,A=1] 
* CE 14: append(A,B,C,D,E,F) = 5+ append(G,H,C,D,I,F)+ maxNorm(J,F,F):1
     [B>=H,F>=J,B>=J,I>=1,G>=1,J>=1,D>=0,C>=0,I+1=E,G+1=A] 
* CE 15: append(A,B,C,D,E,F) = 5+ append(G,H,C,D,I,J)+ maxNorm(F,J,F):2
     [B>=H,B>=F,F>=J+1,I>=1,G>=1,J>=0,D>=0,C>=0,I+1=E,G+1=A] 

### Cost equations --> "Loop" of append/6 
* CEs [15] --> Loop 13 
* CEs [14] --> Loop 14 
* CEs [13] --> Loop 15 

#### Loops of append/6 
* Loop 13: append(A,B,C,D,E,F)->  append(A',B',C,D,C',D')
                  [F>=D'+1,B>=B',B>=F,D'>=0,E>=2,D>=0,C>=0,A>=2,E=C'+1,A=A'+1] 
* Loop 14: append(A,B,C,D,E,F)->  append(A',B',C,D,C',F)
                  [B>=B',F>=1,E>=2,D>=0,C>=0,B>=1,A>=2,E=C'+1,A=A'+1] 
* Loop 15: append(A,B,C,D,C,D) [D>=0,C>=0,B=0,A=1] 

### Ranking functions of CR append(A,B,C,D,E,F) 
* RF of phase [13,14]: [A-1]

#### Partial ranking functions of CR append(A,B,C,D,E,F) 
* Partial RF of phase [13,14]:
  - RF of loop [13:1,14:1]:
    A-1

Discarded unfeasible chain [[13,14]]...(Non-terminating chain proved terminating)

### Resulting Chains:append(A,B,C,D,E,F) 
* [[13,14],15]
* [15]


### Merging Chains  append/6 into  External patterns of execution 
* [[15]] --> 1 
* [[15,[13,14]]] --> 2 


### Specialization of cost equations append_all/5 
* CE 4 is refined into CE [16] 
* CE 3 is refined into CE [17,18] 


#### Refined cost equations append_all/5 
* CE 16: append_all(A,B,C,D,E) = 3
     [E=0,D=1,C=0,B=0,A=1] 
* CE 17: append_all(A,B,C,D,E) = 5+ append_all(F,G,H,D,E)+ append(I,J,D,E,D,E):1
     [C>=H,B>=G,F>=1,E>=0,D>=0,C>=0,B>=1,F+1=A,J=0,I=1] 
* CE 18: append_all(A,B,C,D,E) = 5+ append_all(F,G,H,I,J)+ append(K,L,M,J,D,E):2
     [L+J>=E,C>=H,B>=G,E>=J,C>=L,D>=K,B>=K,F>=1,E>=1,J>=0,L>=1,K>=2,D+1=K+I,D+1=K+M,F+1=A] 

### Cost equations --> "Loop" of append_all/5 
* CEs [18] --> Loop 16 
* CEs [17] --> Loop 17 
* CEs [16] --> Loop 18 

#### Loops of append_all/5 
* Loop 16: append_all(A,B,C,D,E)->  append_all(A',B',C',D',E')
                  [C+E'>=E,B+D'>=D+1,E>=E',D>=D'+1,C>=C',B>=B',E'>=0,D'>=1,E>=1,C>=1,A>=2,A=A'+1] 
* Loop 17: append_all(A,B,C,D,E)->  append_all(A',B',C',D,E)
                  [C>=C',B>=B',E>=0,D>=0,C>=0,B>=1,A>=2,A=A'+1] 
* Loop 18: append_all(A,B,C,D,E) [E=0,D=1,C=0,B=0,A=1] 

### Ranking functions of CR append_all(A,B,C,D,E) 
* RF of phase [16,17]: [A-1]

#### Partial ranking functions of CR append_all(A,B,C,D,E) 
* Partial RF of phase [16,17]:
  - RF of loop [16:1,17:1]:
    A-1

Discarded unfeasible chain [[16,17]]...(Non-terminating chain proved terminating)

### Resulting Chains:append_all(A,B,C,D,E) 
* [[16,17],18]
* [18]


### Merging Chains  append_all/5 into  External patterns of execution 
* [[18]] --> 1 
* [[18,[16,17]]] --> 2 


### Specialization of cost equations append_all2/6 
* CE 6 is refined into CE [19] 
* CE 5 is refined into CE [20,21,22] 


#### Refined cost equations append_all2/6 
* CE 19: append_all2(A,B,C,D,E,F) = 3
     [F=0,E=1,D=0,C=0,B=0,A=1] 
* CE 20: append_all2(A,B,C,D,E,F) = 6+ append_all(G,H,I,J,K):1+ append_all2(L,M,N,O,E,F)+ append(P,Q,E,F,E,F):1
     [D>=O,C>=N,B>=M,L>=1,F>=0,E>=0,D>=0,C>=0,B>=1,L+1=A,Q=0,P=1,K=0,J=1,I=0,H=0,G=1] 
* CE 21: append_all2(A,B,C,D,E,F) = 6+ append_all(G,H,I,J,K):2+ append_all2(L,M,N,O,E,F)+ append(P,Q,E,F,E,F):1
     [D>=O,C>=N,B>=M,D>=I,C>=H,B>=G,L>=1,F>=0,E>=0,I>=0,H>=1,G>=2,L+1=A,Q=0,P=1,K=0,J=1] 
* CE 22: append_all2(A,B,C,D,E,F) = 6+ append_all(G,H,I,J,K):2+ append_all2(L,M,N,O,P,Q)+ append(J,K,R,Q,E,F):2
     [K+Q>=F,D>=O,C>=N,B>=M,F>=Q,E>=J,D>=I,C>=H,B>=G,L>=1,F>=1,Q>=0,K>=1,J>=2,I>=0,H>=1,G>=2,E+1=J+P,E+1=J+R,L+1=A] 

### Cost equations --> "Loop" of append_all2/6 
* CEs [22] --> Loop 19 
* CEs [20,21] --> Loop 20 
* CEs [19] --> Loop 21 

#### Loops of append_all2/6 
* Loop 19: append_all2(A,B,C,D,E,F)->  append_all2(A',B',C',D',E',F')
                  [F>=F',E>=E'+1,D>=D',C>=C',B>=B',F'>=0,E'>=1,F>=1,D>=0,C>=1,B>=2,A>=2,A=A'+1] 
* Loop 20: append_all2(A,B,C,D,E,F)->  append_all2(A',B',C',D',E,F)
                  [D>=D',C>=C',B>=B',F>=0,E>=0,D>=0,C>=0,B>=1,A>=2,A=A'+1] 
* Loop 21: append_all2(A,B,C,D,E,F) [F=0,E=1,D=0,C=0,B=0,A=1] 

### Ranking functions of CR append_all2(A,B,C,D,E,F) 
* RF of phase [19,20]: [A-1]

#### Partial ranking functions of CR append_all2(A,B,C,D,E,F) 
* Partial RF of phase [19,20]:
  - RF of loop [19:1,20:1]:
    A-1

Discarded unfeasible chain [[19,20]]...(Non-terminating chain proved terminating)

### Resulting Chains:append_all2(A,B,C,D,E,F) 
* [[19,20],21]
* [21]


### Merging Chains  append_all2/6 into  External patterns of execution 
* [[21]] --> 1 
* [[21,[19,20]]] --> 2 


### Specialization of cost equations append_all3/7 
* CE 8 is refined into CE [23] 
* CE 7 is refined into CE [24,25,26] 


#### Refined cost equations append_all3/7 
* CE 23: append_all3(A,B,C,D,E,F,G) = 3
     [G=0,F=1,E=0,D=0,C=0,B=0,A=1] 
* CE 24: append_all3(A,B,C,D,E,F,G) = 6+ append_all2(H,I,J,K,L,M):1+ append_all3(N,O,P,Q,R,F,G)+ append(S,T,F,G,F,G):1
     [E>=R,D>=Q,C>=P,B>=O,N>=1,G>=0,F>=0,E>=0,D>=0,C>=0,B>=1,N+1=A,T=0,S=1,M=0,L=1,K=0,J=0,I=0,H=1] 
* CE 25: append_all3(A,B,C,D,E,F,G) = 6+ append_all2(H,I,J,K,L,M):2+ append_all3(N,O,P,Q,R,F,G)+ append(S,T,F,G,F,G):1
     [E>=R,D>=Q,C>=P,B>=O,E>=K,D>=J,C>=I,B>=H,N>=1,G>=0,F>=0,K>=0,J>=0,I>=1,H>=2,N+1=A,T=0,S=1,M=0,L=1] 
* CE 26: append_all3(A,B,C,D,E,F,G) = 6+ append_all2(H,I,J,K,L,M):2+ append_all3(N,O,P,Q,R,S,T)+ append(L,M,U,T,F,G):2
     [M+T>=G,E>=R,D>=Q,C>=P,B>=O,G>=T,F>=L,E>=K,D>=J,C>=I,B>=H,N>=1,G>=1,T>=0,M>=1,L>=2,K>=0,J>=0,I>=1,H>=2,F+1=L+S,F+1=L+U,N+1=A] 

### Cost equations --> "Loop" of append_all3/7 
* CEs [26] --> Loop 22 
* CEs [24,25] --> Loop 23 
* CEs [23] --> Loop 24 

#### Loops of append_all3/7 
* Loop 22: append_all3(A,B,C,D,E,F,G)->  append_all3(A',B',C',D',E',F',G')
                  [G>=G',F>=F'+1,E>=E',D>=D',C>=C',B>=B',G'>=0,F'>=1,G>=1,E>=0,D>=0,C>=1,B>=2,A>=2,A=A'+1] 
* Loop 23: append_all3(A,B,C,D,E,F,G)->  append_all3(A',B',C',D',E',F,G)
                  [E>=E',D>=D',C>=C',B>=B',G>=0,F>=0,E>=0,D>=0,C>=0,B>=1,A>=2,A=A'+1] 
* Loop 24: append_all3(A,B,C,D,E,F,G) [G=0,F=1,E=0,D=0,C=0,B=0,A=1] 

### Ranking functions of CR append_all3(A,B,C,D,E,F,G) 
* RF of phase [22,23]: [A-1]

#### Partial ranking functions of CR append_all3(A,B,C,D,E,F,G) 
* Partial RF of phase [22,23]:
  - RF of loop [22:1,23:1]:
    A-1

Discarded unfeasible chain [[22,23]]...(Non-terminating chain proved terminating)

### Resulting Chains:append_all3(A,B,C,D,E,F,G) 
* [[22,23],24]
* [24]


### Merging Chains  append_all3/7 into  External patterns of execution 
* [[24]] --> 1 
* [[24,[22,23]]] --> 2 


Computing Bounds
=====================================

#### Simplifying cost structure of CE 12 

#### Simplifying cost structure of CE 11 

#### Cost of chains of maxNorm(A,B,C):
* Chain [12]: 0
  with precondition: [A=C,B>=0,A>=B+1] 

* Chain [11]: 0
  with precondition: [C=B,A>=1,C>=A] 


#### Simplifying cost structure of CE 13 

#### Computing cost of phase [13,14] 

#### Simplifying cost structure of CE 15 

#### Simplifying cost structure of CE 14 

#### Cost of loops [13,14] 

 * loop 13:append(A,B,C,D,E,F) -> [append(A',B',C',D',E',F')] 
5
 * loop 14:append(A,B,C,D,E,F) -> [append(A',B',C',D',E',F')] 
5
##### Pending set append(A,B,C,D,E,F)
* Psum in Loop 13: [it(13)=<1]
* Psum in Loop 14: [it(14)=<1]

###### Computing sum for it(13)=<1  in Loop 13 
   - Applying inductive sum strategy 
     - head Candidate: A-1 
       - Loop 14 is collaborative and bounds [it(14)] 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
       - Loop 14 is collaborative and bounds [it(14)] 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(13)+it(14)=<A-1,it(13)+it(14)=<A-1,it(13)+it(14)=<A-A',it(13)+it(14)=<A-A'] 

##### Pending set A
* Psum in Loop 14: [it(14)=<1]

###### Computing sum for it(14)=<1  in Loop 14 
   - Applying inductive sum strategy 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(13)+it(14)=<A-1,it(13)+it(14)=<A-1,it(13)+it(14)=<A-A',it(13)+it(14)=<A-A'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [13,14] 

#### Simplifying cost structure of phase [13,14] 
 * Joined equivalent variables [it(13),it(14)] into it(13)

#### Cost of phase [13,14]:append(A,B,C,D,E,F) -> [append(A',B',C',D',E',F')] 
10*it(13)+0
  Such that:aux(1) =< A
aux(2) =< A-A'
it(13) =< aux(1)
it(13) =< aux(2)

#### Simplifying cost structure of chain [[13,14],15] 
 * Joined equivalent variables [aux(3),aux(1),aux(2)] into aux(3)

#### Cost of chains of append(A,B,C,D,E,F):
* Chain [[13,14],15]: 10*it(13)+2
  Such that:aux(3) =< A
it(13) =< aux(3)

  with precondition: [A+C=E+1,A>=2,B>=1,C>=1,D>=0,F>=1,F>=D,B+D>=F] 

* Chain [15]: 2
  with precondition: [A=1,B=0,C=E,D=F,C>=0,D>=0] 


#### Simplifying cost structure of CE 16 

#### Computing cost of phase [16,17] 
 * Renamed intermediate variables: 
[ (eq(18,1),aux(3))>>s(1), (eq(18,1),it(13))>>s(2)]

#### Simplifying cost structure of CE 18 
 * Renamed intermediate variables: 
[ (it(16),s(1))>>s(3), (it(16),s(2))>>s(4)]

#### Simplifying cost structure of CE 17 

#### Cost of loops [16,17] 

 * loop 16:append_all(A,B,C,D,E) -> [append_all(A',B',C',D',E')] 
10*s(4)+7
  Such that:s(3) =< B
s(4) =< s(3)

 * loop 17:append_all(A,B,C,D,E) -> [append_all(A',B',C',D',E')] 
7
##### Pending set append_all(A,B,C,D,E)
* Psum in Loop 16: [it(16)=<1,s(6)=<B]
* Psum in Loop 17: [it(17)=<1]

###### Computing sum for it(16)=<1  in Loop 16 
   - Applying inductive sum strategy 
     - head Candidate: A-1 
       - Loop 17 is collaborative and bounds [it(17)] 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
       - Loop 17 is collaborative and bounds [it(17)] 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(16)+it(17)=<A-1,it(16)+it(17)=<A-1,it(16)+it(17)=<A-A',it(16)+it(17)=<A-A'] 

##### Pending set A
* Psum in Loop 16: [s(6)=<B]
* Psum in Loop 17: [it(17)=<1]

###### Computing sum for s(6)=<B  in Loop 16 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(4)=<B] 
 * Adding constraints: [s(6)=<it(16)*aux(4)] 

##### Pending set append_all(A,B,C,D,E)
* Pmax/min: [aux(4)=<B]
* Psum in Loop 17: [it(17)=<1]

###### Computing max_min for aux(4)=<B  
   - Found a solution using transitive invariants 
 * Adding constraints:[aux(4)=<B] 

##### Pending set append_all(A,B,C,D,E)
* Psum in Loop 17: [it(17)=<1]

###### Computing sum for it(17)=<1  in Loop 17 
   - Applying inductive sum strategy 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(16)+it(17)=<A-1,it(16)+it(17)=<A-1,it(16)+it(17)=<A-A',it(16)+it(17)=<A-A'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [16,17] 

#### Simplifying cost structure of phase [16,17] 
 * Joined equivalent variables [it(16),it(17)] into it(16)

#### Cost of phase [16,17]:append_all(A,B,C,D,E) -> [append_all(A',B',C',D',E')] 
14*it(16)+10*s(5)+0
  Such that:aux(4) =< B
aux(5) =< A
aux(6) =< A-A'
it(16) =< aux(5)
it(16) =< aux(6)
s(6) =< it(16)*aux(4)
s(5) =< s(6)

#### Simplifying cost structure of chain [[16,17],18] 
 * Joined equivalent variables [aux(7),aux(5),aux(6)] into aux(7)

#### Cost of chains of append_all(A,B,C,D,E):
* Chain [[16,17],18]: 14*it(16)+10*s(5)+3
  Such that:aux(4) =< B
aux(7) =< A
it(16) =< aux(7)
s(6) =< it(16)*aux(4)
s(5) =< s(6)

  with precondition: [A>=2,B>=1,C>=0,D>=1,E>=0] 

* Chain [18]: 3
  with precondition: [A=1,B=0,C=0,D=1,E=0] 


#### Simplifying cost structure of CE 19 

#### Computing cost of phase [19,20] 
 * Renamed intermediate variables: 
[ (eq(22,1),aux(4))>>s(7), (eq(22,1),aux(7))>>s(8), (eq(22,1),it(16))>>s(9), (eq(22,1),s(6))>>s(10), (eq(22,1),s(5))>>s(11)]
 * Renamed intermediate variables: 
[ (eq(22,2),aux(3))>>s(12), (eq(22,2),it(13))>>s(13)]

#### Simplifying cost structure of CE 22 
 * Renamed intermediate variables: 
[ (it(19),s(8))>>s(14), (it(19),s(7))>>s(15), (it(19),s(9))>>s(16), (it(19),s(10))>>s(17), (it(19),s(11))>>s(18), (it(19),s(13))>>s(19)]

#### Simplifying cost structure of CE 20 
 * Renamed intermediate variables: 
[ (eq(21,1),aux(4))>>s(20), (eq(21,1),aux(7))>>s(21), (eq(21,1),it(16))>>s(22), (eq(21,1),s(6))>>s(23), (eq(21,1),s(5))>>s(24)]

#### Simplifying cost structure of CE 21 
 * Renamed intermediate variables: 
[ (it(20),s(21))>>s(25), (it(20),s(20))>>s(26), (it(20),s(22))>>s(27), (it(20),s(23))>>s(28), (it(20),s(24))>>s(29)]

#### Cost of loops [19,20] 

 * loop 19:append_all2(A,B,C,D,E,F) -> [append_all2(A',B',C',D',E',F')] 
14*s(16)+10*s(18)+10*s(19)+11
  Such that:s(14) =< B
s(15) =< C
s(16) =< s(14)
s(17) =< s(16)*s(15)
s(18) =< s(17)

Unbounded itvars
s(19) :  it(19),s(13)

 * loop 20:append_all2(A,B,C,D,E,F) -> [append_all2(A',B',C',D',E',F')] 
14*s(27)+10*s(29)+11
  Such that:s(25) =< B
s(26) =< C
s(27) =< s(25)
s(28) =< s(27)*s(26)
s(29) =< s(28)

##### Pending set append_all2(A,B,C,D,E,F)
* Pmax/min: [s(15)=<C,s(26)=<C]
* Psum in Loop 19: [it(19)=<1,s(34)=<B]
* Psum in Loop 20: [it(20)=<1,s(38)=<B]

###### Computing max_min for s(15)=<C  
   - Found a solution using transitive invariants 
 * Adding constraints:[s(15)=<C] 

##### Pending set append_all2(A,B,C,D,E,F)
* Pmax/min: [s(26)=<C]
* Psum in Loop 19: [it(19)=<1,s(34)=<B]
* Psum in Loop 20: [it(20)=<1,s(38)=<B]

###### Computing max_min for s(26)=<C  
   - Found a solution using cacheing 
 * Adding constraints:[s(26)=<s(15)] 

##### Pending set append_all2(A,B,C,D,E,F)
* Psum in Loop 19: [it(19)=<1,s(34)=<B]
* Psum in Loop 20: [it(20)=<1,s(38)=<B]

###### Computing sum for it(19)=<1  in Loop 19 
   - Applying inductive sum strategy 
     - head Candidate: A-1 
       - Loop 20 is collaborative and bounds [it(20)] 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
       - Loop 20 is collaborative and bounds [it(20)] 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(19)+it(20)=<A-1,it(19)+it(20)=<A-1,it(19)+it(20)=<A-A',it(19)+it(20)=<A-A'] 

##### Pending set append_all2(A,B,C,D,E,F)
* Psum in Loop 19: [s(34)=<B]
* Psum in Loop 20: [it(20)=<1,s(38)=<B]

###### Computing sum for s(34)=<B  in Loop 19 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(8)=<B] 
 * Adding constraints: [s(34)=<it(19)*aux(8)] 

##### Pending set append_all2(A,B,C,D,E,F)
* Pmax/min: [aux(8)=<B]
* Psum in Loop 20: [it(20)=<1,s(38)=<B]

###### Computing max_min for aux(8)=<B  
   - Found a solution using transitive invariants 
 * Adding constraints:[aux(8)=<B] 

##### Pending set append_all2(A,B,C,D,E,F)
* Psum in Loop 20: [it(20)=<1,s(38)=<B]

###### Computing sum for it(20)=<1  in Loop 20 
   - Applying inductive sum strategy 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(19)+it(20)=<A-1,it(19)+it(20)=<A-1,it(19)+it(20)=<A-A',it(19)+it(20)=<A-A'] 

##### Pending set append_all2(A,B,C,D,E,F)
* Psum in Loop 20: [s(38)=<B]

###### Computing sum for s(38)=<B  in Loop 20 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(9)=<B] 
 * Adding constraints: [s(38)=<it(20)*aux(9)] 

##### Pending set append_all2(A,B,C,D,E,F)
* Pmax/min: [aux(9)=<B]

###### Computing max_min for aux(9)=<B  
   - Found a solution using cacheing 
 * Adding constraints:[aux(9)=<aux(8)] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [19,20] 

#### Simplifying cost structure of phase [19,20] 
 * Joined equivalent variables [it(19),it(20)] into it(19)

#### Cost of phase [19,20]:append_all2(A,B,C,D,E,F) -> [append_all2(A',B',C',D',E',F')] 
22*it(19)+14*s(30)+10*s(31)+10*s(32)+14*s(35)+10*s(36)+0
  Such that:aux(8) =< B
s(15) =< C
aux(10) =< A
aux(11) =< A-A'
it(19) =< aux(10)
it(19) =< aux(11)
aux(9) =< aux(8)
s(26) =< s(15)
s(34) =< it(19)*aux(8)
s(38) =< it(19)*aux(9)
s(35) =< s(38)
s(37) =< s(35)*s(26)
s(36) =< s(37)
s(30) =< s(34)
s(33) =< s(30)*s(15)
s(31) =< s(33)

Unbounded itvars
s(32) :  sum(19),s(19)

#### Simplifying cost structure of chain [[19,20],21] 
 * Joined equivalent variables [aux(12),aux(10),aux(11)] into aux(12)

#### Cost of chains of append_all2(A,B,C,D,E,F):
* Chain [[19,20],21]: 22*it(19)+14*s(30)+10*s(31)+10*s(32)+14*s(35)+10*s(36)+3
  Such that:aux(8) =< B
s(15) =< C
aux(12) =< A
it(19) =< aux(12)
aux(9) =< aux(8)
s(26) =< s(15)
s(34) =< it(19)*aux(8)
s(38) =< it(19)*aux(9)
s(35) =< s(38)
s(37) =< s(35)*s(26)
s(36) =< s(37)
s(30) =< s(34)
s(33) =< s(30)*s(15)
s(31) =< s(33)

Unbounded itvars
s(32) :  sum(19),s(19)

  with precondition: [A>=2,B>=1,C>=0,D>=0,E>=1,F>=0] 

* Chain [21]: 3
  with precondition: [A=1,B=0,C=0,D=0,E=1,F=0] 


#### Simplifying cost structure of CE 23 

#### Computing cost of phase [22,23] 
 * Renamed intermediate variables: 
[ (eq(26,1),aux(8))>>s(39), (eq(26,1),s(15))>>s(40), (eq(26,1),aux(12))>>s(41), (eq(26,1),it(19))>>s(42), (eq(26,1),aux(9))>>s(43), (eq(26,1),s(26))>>s(44), (eq(26,1),s(34))>>s(45), (eq(26,1),s(38))>>s(46), (eq(26,1),s(35))>>s(47), (eq(26,1),s(37))>>s(48), (eq(26,1),s(36))>>s(49), (eq(26,1),s(30))>>s(50), (eq(26,1),s(33))>>s(51), (eq(26,1),s(31))>>s(52), (eq(26,1),s(32))>>s(53)]
 * Renamed intermediate variables: 
[ (eq(26,2),aux(3))>>s(54), (eq(26,2),it(13))>>s(55)]

#### Simplifying cost structure of CE 26 
 * Renamed intermediate variables: 
[ (it(22),s(41))>>s(56), (it(22),s(39))>>s(57), (it(22),s(40))>>s(58), (it(22),s(42))>>s(59), (it(22),s(43))>>s(60), (it(22),s(44))>>s(61), (it(22),s(45))>>s(62), (it(22),s(46))>>s(63), (it(22),s(47))>>s(64), (it(22),s(48))>>s(65), (it(22),s(49))>>s(66), (it(22),s(50))>>s(67), (it(22),s(51))>>s(68), (it(22),s(52))>>s(69), (it(22),s(53))>>s(70), (it(22),s(55))>>s(71)]

#### Simplifying cost structure of CE 24 
 * Renamed intermediate variables: 
[ (eq(25,1),aux(8))>>s(72), (eq(25,1),s(15))>>s(73), (eq(25,1),aux(12))>>s(74), (eq(25,1),it(19))>>s(75), (eq(25,1),aux(9))>>s(76), (eq(25,1),s(26))>>s(77), (eq(25,1),s(34))>>s(78), (eq(25,1),s(38))>>s(79), (eq(25,1),s(35))>>s(80), (eq(25,1),s(37))>>s(81), (eq(25,1),s(36))>>s(82), (eq(25,1),s(30))>>s(83), (eq(25,1),s(33))>>s(84), (eq(25,1),s(31))>>s(85), (eq(25,1),s(32))>>s(86)]

#### Simplifying cost structure of CE 25 
 * Renamed intermediate variables: 
[ (it(23),s(74))>>s(87), (it(23),s(72))>>s(88), (it(23),s(73))>>s(89), (it(23),s(75))>>s(90), (it(23),s(76))>>s(91), (it(23),s(77))>>s(92), (it(23),s(78))>>s(93), (it(23),s(79))>>s(94), (it(23),s(80))>>s(95), (it(23),s(81))>>s(96), (it(23),s(82))>>s(97), (it(23),s(83))>>s(98), (it(23),s(84))>>s(99), (it(23),s(85))>>s(100), (it(23),s(86))>>s(101)]

#### Cost of loops [22,23] 

 * loop 22:append_all3(A,B,C,D,E,F,G) -> [append_all3(A',B',C',D',E',F',G')] 
22*s(59)+14*s(64)+10*s(66)+14*s(67)+10*s(69)+10*s(70)+10*s(71)+11
  Such that:s(56) =< B
s(57) =< C
s(58) =< D
s(59) =< s(56)
s(60) =< s(57)
s(61) =< s(58)
s(62) =< s(59)*s(57)
s(63) =< s(59)*s(60)
s(64) =< s(63)
s(65) =< s(64)*s(61)
s(66) =< s(65)
s(67) =< s(62)
s(68) =< s(67)*s(58)
s(69) =< s(68)

Unbounded itvars
s(70) :  it(22),s(53)
s(71) :  it(22),s(55)

 * loop 23:append_all3(A,B,C,D,E,F,G) -> [append_all3(A',B',C',D',E',F',G')] 
22*s(90)+14*s(95)+10*s(97)+14*s(98)+10*s(100)+10*s(101)+11
  Such that:s(87) =< B
s(88) =< C
s(89) =< D
s(90) =< s(87)
s(91) =< s(88)
s(92) =< s(89)
s(93) =< s(90)*s(88)
s(94) =< s(90)*s(91)
s(95) =< s(94)
s(96) =< s(95)*s(92)
s(97) =< s(96)
s(98) =< s(93)
s(99) =< s(98)*s(89)
s(100) =< s(99)

Unbounded itvars
s(101) :  it(23),s(86)

##### Pending set append_all3(A,B,C,D,E,F,G)
* Pmax/min: [s(57)=<C,s(88)=<C,s(58)=<D,s(89)=<D]
* Psum in Loop 22: [it(22)=<1,s(113)=<B]
* Psum in Loop 23: [it(23)=<1,s(124)=<B]

###### Computing max_min for s(57)=<C  
   - Found a solution using transitive invariants 
 * Adding constraints:[s(57)=<C] 

##### Pending set append_all3(A,B,C,D,E,F,G)
* Pmax/min: [s(88)=<C,s(58)=<D,s(89)=<D]
* Psum in Loop 22: [it(22)=<1,s(113)=<B]
* Psum in Loop 23: [it(23)=<1,s(124)=<B]

###### Computing max_min for s(88)=<C  
   - Found a solution using cacheing 
 * Adding constraints:[s(88)=<s(57)] 

##### Pending set append_all3(A,B,C,D,E,F,G)
* Pmax/min: [s(58)=<D,s(89)=<D]
* Psum in Loop 22: [it(22)=<1,s(113)=<B]
* Psum in Loop 23: [it(23)=<1,s(124)=<B]

###### Computing max_min for s(58)=<D  
   - Found a solution using transitive invariants 
 * Adding constraints:[s(58)=<D] 

##### Pending set append_all3(A,B,C,D,E,F,G)
* Pmax/min: [s(89)=<D]
* Psum in Loop 22: [it(22)=<1,s(113)=<B]
* Psum in Loop 23: [it(23)=<1,s(124)=<B]

###### Computing max_min for s(89)=<D  
   - Found a solution using cacheing 
 * Adding constraints:[s(89)=<s(58)] 

##### Pending set append_all3(A,B,C,D,E,F,G)
* Psum in Loop 22: [it(22)=<1,s(113)=<B]
* Psum in Loop 23: [it(23)=<1,s(124)=<B]

###### Computing sum for it(22)=<1  in Loop 22 
   - Applying inductive sum strategy 
     - head Candidate: A-1 
       - Loop 23 is collaborative and bounds [it(23)] 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
       - Loop 23 is collaborative and bounds [it(23)] 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(22)+it(23)=<A-1,it(22)+it(23)=<A-1,it(22)+it(23)=<A-A',it(22)+it(23)=<A-A'] 

##### Pending set append_all3(A,B,C,D,E,F,G)
* Psum in Loop 22: [s(113)=<B]
* Psum in Loop 23: [it(23)=<1,s(124)=<B]

###### Computing sum for s(113)=<B  in Loop 22 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(13)=<B] 
 * Adding constraints: [s(113)=<it(22)*aux(13)] 

##### Pending set append_all3(A,B,C,D,E,F,G)
* Pmax/min: [aux(13)=<B]
* Psum in Loop 23: [it(23)=<1,s(124)=<B]

###### Computing max_min for aux(13)=<B  
   - Found a solution using transitive invariants 
 * Adding constraints:[aux(13)=<B] 

##### Pending set append_all3(A,B,C,D,E,F,G)
* Psum in Loop 23: [it(23)=<1,s(124)=<B]

###### Computing sum for it(23)=<1  in Loop 23 
   - Applying inductive sum strategy 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(22)+it(23)=<A-1,it(22)+it(23)=<A-1,it(22)+it(23)=<A-A',it(22)+it(23)=<A-A'] 

##### Pending set append_all3(A,B,C,D,E,F,G)
* Psum in Loop 23: [s(124)=<B]

###### Computing sum for s(124)=<B  in Loop 23 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(14)=<B] 
 * Adding constraints: [s(124)=<it(23)*aux(14)] 

##### Pending set append_all3(A,B,C,D,E,F,G)
* Pmax/min: [aux(14)=<B]

###### Computing max_min for aux(14)=<B  
   - Found a solution using cacheing 
 * Adding constraints:[aux(14)=<aux(13)] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [22,23] 

#### Simplifying cost structure of phase [22,23] 
 * Joined equivalent variables [s(61),s(89)] into s(61)
 * Joined equivalent variables [s(60),s(88)] into s(60)
 * Joined equivalent variables [s(107),s(108),s(119)] into s(107)
 * Joined equivalent variables [it(22),it(23)] into it(22)

#### Cost of phase [22,23]:append_all3(A,B,C,D,E,F,G) -> [append_all3(A',B',C',D',E',F',G')] 
22*it(22)+22*s(102)+14*s(103)+10*s(104)+14*s(105)+10*s(106)+30*s(107)+22*s(114)+14*s(115)+10*s(116)+14*s(117)+10*s(118)+0
  Such that:aux(13) =< B
s(57) =< C
s(58) =< D
aux(15) =< A
aux(16) =< A-A'
it(22) =< aux(15)
it(22) =< aux(16)
aux(14) =< aux(13)
s(61) =< s(58)
s(60) =< s(57)
s(113) =< it(22)*aux(13)
s(124) =< it(22)*aux(14)
s(114) =< s(124)
s(91) =< s(60)
s(92) =< s(61)
s(121) =< s(114)*s(60)
s(123) =< s(114)*s(91)
s(115) =< s(123)
s(122) =< s(115)*s(92)
s(116) =< s(122)
s(117) =< s(121)
s(120) =< s(117)*s(61)
s(118) =< s(120)
s(102) =< s(113)
s(110) =< s(102)*s(57)
s(112) =< s(102)*s(60)
s(103) =< s(112)
s(111) =< s(103)*s(61)
s(104) =< s(111)
s(105) =< s(110)
s(109) =< s(105)*s(58)
s(106) =< s(109)

Unbounded itvars
s(107) :  sum(22),s(70)

#### Simplifying cost structure of chain [[22,23],24] 
 * Joined equivalent variables [aux(17),aux(15),aux(16)] into aux(17)

#### Cost of chains of append_all3(A,B,C,D,E,F,G):
* Chain [[22,23],24]: 22*it(22)+22*s(102)+14*s(103)+10*s(104)+14*s(105)+10*s(106)+30*s(107)+22*s(114)+14*s(115)+10*s(116)+14*s(117)+10*s(118)+3
  Such that:aux(13) =< B
s(57) =< C
s(58) =< D
aux(17) =< A
it(22) =< aux(17)
aux(14) =< aux(13)
s(61) =< s(58)
s(60) =< s(57)
s(113) =< it(22)*aux(13)
s(124) =< it(22)*aux(14)
s(114) =< s(124)
s(91) =< s(60)
s(92) =< s(61)
s(121) =< s(114)*s(60)
s(123) =< s(114)*s(91)
s(115) =< s(123)
s(122) =< s(115)*s(92)
s(116) =< s(122)
s(117) =< s(121)
s(120) =< s(117)*s(61)
s(118) =< s(120)
s(102) =< s(113)
s(110) =< s(102)*s(57)
s(112) =< s(102)*s(60)
s(103) =< s(112)
s(111) =< s(103)*s(61)
s(104) =< s(111)
s(105) =< s(110)
s(109) =< s(105)*s(58)
s(106) =< s(109)

Unbounded itvars
s(107) :  sum(22),s(70)

  with precondition: [A>=2,B>=1,C>=0,D>=0,E>=0,F>=1,G>=0] 

* Chain [24]: 3
  with precondition: [A=1,B=0,C=0,D=0,E=0,F=1,G=0] 


Closed-form bounds of append(A,B,C,D,E,F): 
-------------------------------------
* Chain [[13,14],15] with precondition: [A+C=E+1,A>=2,B>=1,C>=1,D>=0,F>=1,F>=D,B+D>=F] 
    - Upper bound: 10*A+2 
    - Complexity: n 
* Chain [15] with precondition: [A=1,B=0,C=E,D=F,C>=0,D>=0] 
    - Upper bound: 2 
    - Complexity: constant 

### Maximum cost of append(A,B,C,D,E,F): 10*A+2 
Asymptotic class: n 

Closed-form bounds of append_all(A,B,C,D,E): 
-------------------------------------
* Chain [[16,17],18] with precondition: [A>=2,B>=1,C>=0,D>=1,E>=0] 
    - Upper bound: 14*A+3+10*B*A 
    - Complexity: n^2 
* Chain [18] with precondition: [A=1,B=0,C=0,D=1,E=0] 
    - Upper bound: 3 
    - Complexity: constant 

### Maximum cost of append_all(A,B,C,D,E): 10*B*A+14*A+3 
Asymptotic class: n^2 

Closed-form bounds of append_all2(A,B,C,D,E,F): 
-------------------------------------
* Chain [[19,20],21] with precondition: [A>=2,B>=1,C>=0,D>=0,E>=1,F>=0] 
    - Upper bound: inf 
    - Complexity: infinity 
* Chain [21] with precondition: [A=1,B=0,C=0,D=0,E=1,F=0] 
    - Upper bound: 3 
    - Complexity: constant 

### Maximum cost of append_all2(A,B,C,D,E,F): inf 
Asymptotic class: infinity 

Closed-form bounds of append_all3(A,B,C,D,E,F,G): 
-------------------------------------
* Chain [[22,23],24] with precondition: [A>=2,B>=1,C>=0,D>=0,E>=0,F>=1,G>=0] 
    - Upper bound: inf 
    - Complexity: infinity 
* Chain [24] with precondition: [A=1,B=0,C=0,D=0,E=0,F=1,G=0] 
    - Upper bound: 3 
    - Complexity: constant 

### Maximum cost of append_all3(A,B,C,D,E,F,G): inf 
Asymptotic class: infinity 
* Total analysis performed in 1525 ms.


Cost relation system solved by CoFloCo in 1530 ms.

Method append terminates?: YES

 - l1_1: size of l1 wrt. List<A>
 - l1_2: size of l1 wrt. A
 - l2_1: size of l2 wrt. List<A>
 - l2_2: size of l2 wrt. A
UB for append(l1_1,l1_2,l2_1,l2_2) = 10*l1_1+2

Method append_all terminates?: YES

 - l_1: size of l wrt. List<List<A>>
 - l_2: size of l wrt. List<A>
 - l_3: size of l wrt. A
UB for append_all(l_1,l_2,l_3) = 10*l_2*l_1+14*l_1+3

Method append_all2 terminates?: YES

 - l_1: size of l wrt. List<List<List<A>>>
 - l_2: size of l wrt. List<List<A>>
 - l_3: size of l wrt. List<A>
 - l_4: size of l wrt. A
UB for append_all2(l_1,l_2,l_3,l_4) = inf

Method append_all3 terminates?: YES

 - l_1: size of l wrt. List<List<List<List<A>>>>
 - l_2: size of l wrt. List<List<List<A>>>
 - l_3: size of l wrt. List<List<A>>
 - l_4: size of l wrt. List<A>
 - l_5: size of l wrt. A
UB for append_all3(l_1,l_2,l_3,l_4,l_5) = inf
