
Abs program loaded in 25 ms.

Rule based representation generated in 8 ms.

Rule based representation stored in /tmp/costabs/rbr.rbr

RBR properties stored in /tmp/costabs/rbr.properties

Class invariants generated and loaded in 0 ms.

Abstract compilation performed in 46 ms.

Cost relation system stored in /tmp/costabs/crs.crs

Generated 59 equations 
entry('r1'(A,B,C,D,E,F):[]).
entry('rev'(A,B,C,D):[]).
entry('append'(A,B,C,D,E,F):[]).
entry('f'(A,B,C,D,E,F):[]).
entry('g'(A,B,C,D,E,F,G,H):[]).
entry('p'(A,B,C,D,E,F,G,H):[]).
entry('f2'(A,B,C,D,E,F):[]).
entry('last'(A,B,C,D):[]).
entry('f2p'(A,B,C,D,E,F):[]).
entry('g3'(A,B,C,D,E,F):[]).
entry('f3'(A,B,C,D,E,F):[]).
input_output_vars('and_op'(A,B,C),[A,B],[C]).
input_output_vars('append'(A,B,C,D,E,F),[A,B,C,D],[E,F]).
input_output_vars('case_0'(A,B,C,D,E,F),[A,B,C,D],[E,F]).
input_output_vars('case_1'(A,B,C,D,E,F),[A,B,C,D],[E,F]).
input_output_vars('case_10'(A,B,C,D,E,F,G,H,I),[A,B,C,D,E,F,G],[H,I]).
input_output_vars('case_11'(A,B,C,D,E,F),[A,B,C,D],[E,F]).
input_output_vars('case_12'(A,B,C,D,E,F),[A,B,C,D],[E,F]).
input_output_vars('case_2'(A,B,C,D,E,F),[A,B,C,D],[E,F]).
input_output_vars('case_3'(A,B,C,D,E,F,G,H),[A,B,C,D,E,F],[G,H]).
input_output_vars('case_4'(A,B,C,D,E,F,G,H),[A,B,C,D,E,F],[G,H]).
input_output_vars('case_5'(A,B,C,D,E,F),[A,B,C,D],[E,F]).
input_output_vars('case_6'(A,B,C,D,E,F,G,H,I),[A,B,C,D,E,F,G],[H,I]).
input_output_vars('case_7'(A,B,C,D),[A,B],[C,D]).
input_output_vars('case_8'(A,B,C,D,E,F,G,H,I),[A,B,C,D,E,F,G],[H,I]).
input_output_vars('case_9'(A,B,C,D,E,F),[A,B,C,D],[E,F]).
input_output_vars('eq'(A,B,C),[A,B],[C]).
input_output_vars('f'(A,B,C,D,E,F),[A,B,C,D],[E,F]).
input_output_vars('f2'(A,B,C,D,E,F),[A,B,C,D],[E,F]).
input_output_vars('f2p'(A,B,C,D,E,F),[A,B,C,D],[E,F]).
input_output_vars('f3'(A,B,C,D,E,F),[A,B,C,D],[E,F]).
input_output_vars('g'(A,B,C,D,E,F,G,H),[A,B,C,D,E,F],[G,H]).
input_output_vars('g3'(A,B,C,D,E,F),[A,B,C,D],[E,F]).
input_output_vars('geq'(A,B,C),[A,B],[C]).
input_output_vars('gt'(A,B,C),[A,B],[C]).
input_output_vars('last'(A,B,C,D),[A,B],[C,D]).
input_output_vars('leq'(A,B,C),[A,B],[C]).
input_output_vars('lt'(A,B,C),[A,B],[C]).
input_output_vars('maxNorm'(A,B,C),[A,B],[C]).
input_output_vars('neg'(A,B),[A],[B]).
input_output_vars('neq'(A,B,C),[A,B],[C]).
input_output_vars('or'(A,B,C),[A,B],[C]).
input_output_vars('p'(A,B,C,D,E,F,G,H),[A,B,C,D,E,F],[G,H]).
input_output_vars('r1'(A,B,C,D,E,F),[A,B,C,D],[E,F]).
input_output_vars('rev'(A,B,C,D),[A,B],[C,D]).
eq('eq',[A,B,C],0,[],[A=B,C=1,A>=0,B>=0,C>=0]).
eq('eq',[A,B,C],0,[],[A>=B+1,C=0,A>=0,B>=0,C>=0]).
eq('eq',[A,B,C],0,[],[B>=A+1,C=0,A>=0,B>=0,C>=0]).
eq('neq',[A,B,C],0,[],[A=B,C=0,A>=0,B>=0,C>=0]).
eq('neq',[A,B,C],0,[],[A>=B+1,C=1,A>=0,B>=0,C>=0]).
eq('neq',[A,B,C],0,[],[B>=A+1,C=1,A>=0,B>=0,C>=0]).
eq('lt',[A,B,C],0,[],[B-A>=1,C=1,A>=0,B>=0,C>=0]).
eq('lt',[A,B,C],0,[],[B=<A,C=0,A>=0,B>=0,C>=0]).
eq('leq',[A,B,C],0,[],[A=<B,C=1,A>=0,B>=0,C>=0]).
eq('leq',[A,B,C],0,[],[A-B>=1,C=0,A>=0,B>=0,C>=0]).
eq('gt',[A,B,C],0,[],[A-B>=1,C=1,A>=0,B>=0,C>=0]).
eq('gt',[A,B,C],0,[],[A=<B,C=0,A>=0,B>=0,C>=0]).
eq('geq',[A,B,C],0,[],[B=<A,C=1,A>=0,B>=0,C>=0]).
eq('geq',[A,B,C],0,[],[B-A>=1,C=0,A>=0,B>=0,C>=0]).
eq('neg',[A,B],0,[],[A=0,B=1,A>=0,B>=0]).
eq('neg',[A,B],0,[],[A=1,B=0,A>=0,B>=0]).
eq('and_op',[A,B,C],0,[],[A=0,C=0,A>=0,B>=0,C>=0]).
eq('and_op',[A,B,C],0,[],[A=1,C=B,A>=0,B>=0,C>=0]).
eq('or',[A,B,C],0,[],[A=1,C=1,A>=0,B>=0,C>=0]).
eq('or',[A,B,C],0,[],[A=0,C=B,A>=0,B>=0,C>=0]).
eq('maxNorm',[A,B,A],0,[],[A>=1+B,A>=0,B>=0,A>=0]).
eq('maxNorm',[A,B,B],0,[],[A=<B,A>=0,B>=0,B>=0]).
eq('case_0',[A,B,C,D,C,D],1,[],[B=0,A=1,A>=0,B>=0,C>=0,D>=0,C>=0,D>=0]).
eq('case_0',[A,B,C,D,E,F],4,['maxNorm'(G,D,H),'r1'(I,J,K,H,E,F)],[B>=G,B>=J,A=I+1,I>=1,G>=1,K=C+1,C>=1,G>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0]).
eq('r1',[A,B,C,D,E,F],1,['case_0'(A,B,C,D,E,F)],[A>=0,B>=0,C>=0,D>=0,E>=0,F>=0]).
eq('rev',[A,B,C,D],2,['r1'(A,B,E,F,C,D)],[F=0,E=1,A>=0,B>=0,C>=0,D>=0]).
eq('case_1',[A,B,C,D,C,D],1,[],[B=0,A=1,A>=0,B>=0,C>=0,D>=0,C>=0,D>=0]).
eq('case_1',[A,B,C,D,E,F],4,['append'(G,H,C,D,I,J),'maxNorm'(K,J,F)],[B>=K,B>=H,A=G+1,G>=1,K>=1,E=I+1,I>=1,K>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0]).
eq('append',[A,B,C,D,E,F],1,['case_1'(A,B,C,D,E,F)],[A>=0,B>=0,C>=0,D>=0,E>=0,F>=0]).
eq('case_2',[A,B,C,D,C,D],1,[],[B=0,A=1,A>=0,B>=0,C>=0,D>=0,C>=0,D>=0]).
eq('case_2',[A,B,C,D,E,F],3,['g'(G,H,C,D,A,B,E,F)],[B>=I,B>=H,A=G+1,G>=1,I>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0]).
eq('f',[A,B,C,D,E,F],1,['case_2'(A,B,C,D,E,F)],[A>=0,B>=0,C>=0,D>=0,E>=0,F>=0]).
eq('g',[A,B,C,D,E,F,G,H],2,['append'(C,D,E,F,I,J),'f'(A,B,I,J,G,H)],[A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0]).
eq('case_3',[A,B,C,D,E,F,G,H],2,['p'(A,B,I,J,C,D,G,H)],[F>=K,F>=J,K>=1,E=I+1,I>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0]).
eq('case_4',[A,B,C,D,E,F,G,H],3,['p'(I,J,K,L,A,B,G,H)],[D>=M,D>=L,M>=1,C=K+1,K>=1,J=0,I=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0]).
eq('case_4',[A,B,C,D,E,F,A,B],2,[],[D=0,C=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,A>=0,B>=0]).
eq('case_3',[A,B,C,D,E,F,G,H],3,['case_4'(A,B,C,D,E,F,G,H)],[F=0,E=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0]).
eq('p',[A,B,C,D,E,F,G,H],1,['case_3'(A,B,C,D,E,F,G,H)],[A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0]).
eq('case_5',[A,B,C,D,A,B],1,[],[D=0,C=1,A>=0,B>=0,C>=0,D>=0,A>=0,B>=0]).
eq('case_6',[A,B,C,D,E,F,G,H,I],2,['f2'(C,D,F,G,H,I)],[B=0,A=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0]).
eq('case_6',[A,B,C,D,E,F,G,H,I],3,['f2'(C,D,J,K,H,I)],[B>=L,B>=K,A=J+1,J>=1,L>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0]).
eq('case_5',[A,B,C,D,E,F],3,['case_6'(A,B,C,D,G,H,I,E,F)],[D>=G,D>=I,C=H+1,H>=1,G>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0]).
eq('f2',[A,B,C,D,E,F],1,['case_5'(A,B,C,D,E,F)],[A>=0,B>=0,C>=0,D>=0,E>=0,F>=0]).
eq('case_7',[A,B,C,D],2,[],[B=0,A=1,D=0,C=1,A>=0,B>=0,C>=0,D>=0]).
eq('case_8',[A,B,C,D,E,F,G,H,I],3,['maxNorm'(E,J,I)],[B=0,A=1,J=0,K=1,H=K+1,K>=1,E>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0]).
eq('case_8',[A,B,C,D,E,F,G,A,B],2,[],[B>=H,B>=I,A=J+1,J>=1,H>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,A>=0,B>=0]).
eq('case_7',[A,B,C,D],6,['last'(E,F,G,H),'case_8'(I,J,A,B,K,E,F,L,M)],[B>=K,B>=F,A=E+1,E>=1,K>=1,J=H,I=G,G>=1,D=M,C=L,L>=1,A>=0,B>=0,C>=0,D>=0]).
eq('last',[A,B,C,D],1,['case_7'(A,B,C,D)],[A>=0,B>=0,C>=0,D>=0]).
eq('case_9',[A,B,C,D,A,B],1,[],[D=0,C=1,A>=0,B>=0,C>=0,D>=0,A>=0,B>=0]).
eq('case_10',[A,B,C,D,E,F,G,H,I],2,['last'(C,D,H,I)],[B=0,A=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0]).
eq('case_10',[A,B,C,D,E,F,G,H,I],3,['f2p'(C,D,J,K,H,I)],[B>=L,B>=K,A=J+1,J>=1,L>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0]).
eq('case_9',[A,B,C,D,E,F],3,['case_10'(A,B,C,D,G,H,I,E,F)],[D>=G,D>=I,C=H+1,H>=1,G>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0]).
eq('f2p',[A,B,C,D,E,F],1,['case_9'(A,B,C,D,E,F)],[A>=0,B>=0,C>=0,D>=0,E>=0,F>=0]).
eq('case_11',[A,B,C,D,C,D],1,[],[B=0,A=1,A>=0,B>=0,C>=0,D>=0,C>=0,D>=0]).
eq('case_11',[A,B,C,D,E,F],4,['maxNorm'(G,D,H),'g3'(I,J,K,H,E,F)],[B>=G,B>=J,A=I+1,I>=1,G>=1,K=C+1,C>=1,G>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0]).
eq('g3',[A,B,C,D,E,F],1,['case_11'(A,B,C,D,E,F)],[A>=0,B>=0,C>=0,D>=0,E>=0,F>=0]).
eq('case_12',[A,B,C,D,E,F],3,['g3'(A,B,G,H,E,F)],[D=0,C=1,H=0,G=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0]).
eq('case_12',[A,B,C,D,E,F],4,['maxNorm'(G,B,H),'f3'(I,H,J,K,E,F)],[D>=G,D>=K,C=J+1,J>=1,G>=1,I=A+1,A>=1,G>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0]).
eq('f3',[A,B,C,D,E,F],1,['case_12'(A,B,C,D,E,F)],[A>=0,B>=0,C>=0,D>=0,E>=0,F>=0]).

Preprocessing Cost Relations
=====================================

#### Computed strongly connected components 
0. non_recursive  : [maxNorm/3]
1. recursive [non_tail] : [append/6,case_1/6]
2. recursive  : [case_2/6,f/6,g/8]
3. recursive  : [case_5/6,case_6/9,f2/6]
4. non_recursive  : [case_8/9]
5. recursive [non_tail] : [case_7/4,last/4]
6. recursive  : [case_10/9,case_9/6,f2p/6]
7. recursive  : [case_11/6,g3/6]
8. recursive  : [case_12/6,f3/6]
9. recursive  : [case_3/8,case_4/8,p/8]
10. recursive  : [case_0/6,r1/6]
11. non_recursive  : [rev/4]
* The entry g/8 is not a cutpoint so it becomes a new SCC 12
Warning: the following predicates are never called:[and_op/3,eq/3,geq/3,gt/3,leq/3,lt/3,neg/2,neq/3,or/3]

#### Obtained direct recursion through partial evaluation 
0. SCC is partially evaluated into maxNorm/3
1. SCC is partially evaluated into append/6
2. SCC is partially evaluated into f/6
3. SCC is partially evaluated into f2/6
4. SCC is partially evaluated into case_8/9
5. SCC is partially evaluated into last/4
6. SCC is partially evaluated into f2p/6
7. SCC is partially evaluated into g3/6
8. SCC is partially evaluated into f3/6
9. SCC is partially evaluated into p/8
10. SCC is partially evaluated into r1/6
11. SCC is partially evaluated into rev/4
12. SCC is partially evaluated into g/8

Control-Flow Refinement of Cost Relations
=====================================

### Specialization of cost equations maxNorm/3 
* CE 25 is refined into CE [28] 
* CE 24 is refined into CE [29] 


#### Refined cost equations maxNorm/3 
* CE 28: maxNorm(A,B,B) = 0
     [B>=A,A>=1] 
* CE 29: maxNorm(A,B,A) = 0
     [A>=B+1,B>=0] 

### Cost equations --> "Loop" of maxNorm/3 
* CEs [28] --> Loop 28 
* CEs [29] --> Loop 29 

#### Loops of maxNorm/3 
* Loop 28: maxNorm(A,B,B) [B>=A,A>=1] 
* Loop 29: maxNorm(A,B,A) [A>=B+1,B>=0] 

### Ranking functions of CR maxNorm(A,B,C) 

#### Partial ranking functions of CR maxNorm(A,B,C) 


### Resulting Chains:maxNorm(A,B,C) 
* [29]
* [28]


### Merging Chains  maxNorm/3 into  External patterns of execution 
* [[29]] --> 1 
* [[28]] --> 2 


### Specialization of cost equations append/6 
* CE 5 is refined into CE [30] 
* CE 4 is refined into CE [31,32] 


#### Refined cost equations append/6 
* CE 30: append(A,B,C,D,C,D) = 2
     [D>=0,C>=0,B=0,A=1] 
* CE 31: append(A,B,C,D,E,F) = 5+ append(G,H,C,D,I,J)+ maxNorm(F,J,F):1
     [B>=H,B>=F,F>=J+1,I>=1,G>=1,J>=0,D>=0,C>=0,I+1=E,G+1=A] 
* CE 32: append(A,B,C,D,E,F) = 5+ append(G,H,C,D,I,F)+ maxNorm(J,F,F):2
     [B>=H,F>=J,B>=J,I>=1,G>=1,J>=1,D>=0,C>=0,I+1=E,G+1=A] 

### Cost equations --> "Loop" of append/6 
* CEs [31] --> Loop 30 
* CEs [32] --> Loop 31 
* CEs [30] --> Loop 32 

#### Loops of append/6 
* Loop 30: append(A,B,C,D,E,F)->  append(A',B',C,D,C',D')
                  [F>=D'+1,B>=B',B>=F,D'>=0,E>=2,D>=0,C>=0,A>=2,E=C'+1,A=A'+1] 
* Loop 31: append(A,B,C,D,E,F)->  append(A',B',C,D,C',F)
                  [B>=B',F>=1,E>=2,D>=0,C>=0,B>=1,A>=2,E=C'+1,A=A'+1] 
* Loop 32: append(A,B,C,D,C,D) [D>=0,C>=0,B=0,A=1] 

### Ranking functions of CR append(A,B,C,D,E,F) 
* RF of phase [30,31]: [A-1]

#### Partial ranking functions of CR append(A,B,C,D,E,F) 
* Partial RF of phase [30,31]:
  - RF of loop [30:1,31:1]:
    A-1

Discarded unfeasible chain [[30,31]]...(Non-terminating chain proved terminating)

### Resulting Chains:append(A,B,C,D,E,F) 
* [[30,31],32]
* [32]


### Merging Chains  append/6 into  External patterns of execution 
* [[32]] --> 1 
* [[32,[30,31]]] --> 2 


### Specialization of cost equations f/6 
* CE 7 is refined into CE [33] 
* CE 6 is refined into CE [34,35] 


#### Refined cost equations f/6 
* CE 33: f(A,B,C,D,C,D) = 2
     [D>=0,C>=0,B=0,A=1] 
* CE 34: f(A,B,C,D,E,F) = 6+ append(G,H,A,B,A,B):1+ f(I,J,A,B,E,F)
     [B>=J,J>=0,B>=1,A>=2,F>=0,E>=0,A=I+1,H=0,G=1,D=0,C=1] 
* CE 35: f(A,B,C,D,E,F) = 6+ append(C,D,G,B,H,I):2+ f(J,K,H,I,E,F)
     [B+D>=I,B>=K,I>=B,H>=C+1,K>=0,B>=1,D>=1,C>=2,F>=0,E>=0,H=C+J,H+1=C+G,H+1=A+C] 

### Cost equations --> "Loop" of f/6 
* CEs [35] --> Loop 33 
* CEs [34] --> Loop 34 
* CEs [33] --> Loop 35 

#### Loops of f/6 
* Loop 33: f(A,B,C,D,E,F)->  f(A',B',C',D',E,F)
                  [B+D>=D',B>=B',D'>=B,B'>=0,F>=0,E>=0,D>=1,C>=2,B>=1,A>=2,A+C=C'+1,A=A'+1] 
* Loop 34: f(A,B,C,D,E,F)->  f(A',B',A,B,E,F)
                  [B>=B',B'>=0,F>=0,E>=0,B>=1,A>=2,A=A'+1,D=0,C=1] 
* Loop 35: f(A,B,C,D,C,D) [D>=0,C>=0,B=0,A=1] 

### Ranking functions of CR f(A,B,C,D,E,F) 
* RF of phase [33]: [A-1]

#### Partial ranking functions of CR f(A,B,C,D,E,F) 
* Partial RF of phase [33]:
  - RF of loop [33:1]:
    A-1

Discarded unfeasible chain [[33]]...(Non-terminating chain proved terminating)
Discarded unfeasible chain [34,[33]](Non-terminating chain proved terminating)

### Resulting Chains:f(A,B,C,D,E,F) 
* [[33],35]
* [35]
* [34,[33],35]
* [34,35]


### Merging Chains  f/6 into  External patterns of execution 
* [[35]] --> 1 
* [[35,34]] --> 2 
* [[35,[33],34]] --> 3 
* [[35,[33]]] --> 4 


### Specialization of cost equations f2/6 
* CE 14 is refined into CE [36] 
* CE 13 is refined into CE [37] 
* CE 12 is refined into CE [38] 


#### Refined cost equations f2/6 
* CE 36: f2(A,B,C,D,E,F) = 7+ f2(C,D,G,H,E,F)
     [B>=H,G>=1,F>=0,E>=0,D>=1,C>=2,B>=1,G+1=A] 
* CE 37: f2(A,B,C,D,E,F) = 6+ f2(C,D,G,H,E,F)
     [D>=H,H>=0,F>=0,E>=0,D>=1,C>=2,C=G+1,B=0,A=1] 
* CE 38: f2(A,B,C,D,A,B) = 2
     [B>=0,A>=0,D=0,C=1] 

### Cost equations --> "Loop" of f2/6 
* CEs [38] --> Loop 36 
* CEs [36] --> Loop 37 
* CEs [37] --> Loop 38 

#### Loops of f2/6 
* Loop 36: f2(A,B,C,D,A,B) [B>=0,A>=0,D=0,C=1] 
* Loop 37: f2(A,B,C,D,E,F)->  f2(C,D,A',B',E,F)
                  [B>=B',F>=0,E>=0,D>=1,C>=2,B>=1,A>=2,A=A'+1] 
* Loop 38: f2(A,B,C,D,E,F)->  f2(C,D,A',B',E,F)
                  [D>=B',B'>=0,F>=0,E>=0,D>=1,C>=2,C=A'+1,B=0,A=1] 

### Ranking functions of CR f2(A,B,C,D,E,F) 
* RF of phase [37]: [A+C-3]

#### Partial ranking functions of CR f2(A,B,C,D,E,F) 
* Partial RF of phase [37]:
  - RF of loop [37:1]:
    A+C-3

Discarded unfeasible chain [[37]]...(Non-terminating chain proved terminating)
Discarded unfeasible chain [38,[37]](Non-terminating chain proved terminating)

### Resulting Chains:f2(A,B,C,D,E,F) 
* [[37],36]
* [38,[37],36]
* [38,36]
* [36]


### Merging Chains  f2/6 into  External patterns of execution 
* [[36,38]] --> 1 
* [[36,[37],38]] --> 2 
* [[36]] --> 3 
* [[36,[37]]] --> 4 


### Specialization of cost equations case_8/9 
* CE 27 is refined into CE [39] 
* CE 26 is refined into CE [40] 


#### Refined cost equations case_8/9 
* CE 39: case_8(A,B,C,D,E,F,G,A,B) = 2
     [D>=G,D>=E,G>=0,F>=1,E>=1,B>=1,A>=2,F+1=C] 
* CE 40: case_8(A,B,C,D,E,F,G,H,E) = 3+ maxNorm(E,I,E):1
     [D>=E,D>=G,E>=1,G>=0,F>=1,F+1=C,I=0,H=2,B=0,A=1] 

### Cost equations --> "Loop" of case_8/9 
* CEs [39] --> Loop 39 
* CEs [40] --> Loop 40 

#### Loops of case_8/9 
* Loop 39: case_8(A,B,C,D,E,F,G,A,B) [D>=G,D>=E,G>=0,E>=1,C>=2,B>=1,A>=2,C=F+1] 
* Loop 40: case_8(A,B,C,D,E,F,G,H,E) [D>=G,D>=E,G>=0,E>=1,C>=2,C=F+1,H=2,B=0,A=1] 

### Ranking functions of CR case_8(A,B,C,D,E,F,G,H,I) 

#### Partial ranking functions of CR case_8(A,B,C,D,E,F,G,H,I) 


### Resulting Chains:case_8(A,B,C,D,E,F,G,H,I) 
* [40]
* [39]


### Merging Chains  case_8/9 into  External patterns of execution 
* [[40]] --> 1 
* [[39]] --> 2 


### Specialization of cost equations last/4 
* CE 16 is refined into CE [41] 
* CE 15 is refined into CE [42,43] 


#### Refined cost equations last/4 
* CE 41: last(A,B,C,D) = 3
     [D=0,C=1,B=0,A=1] 
* CE 42: last(A,B,C,D) = 7+ last(E,F,G,H)+ case_8(I,J,K,B,D,E,F,L,D):1
     [B>=D,B>=F,D>=1,F>=0,E>=1,E+1=K,E+1=A,H=0,G=1,L=2,J=0,I=1,C=2] 
* CE 43: last(A,B,C,D) = 7+ last(E,F,C,D)+ case_8(C,D,G,B,H,E,F,C,D):2
     [B>=F,B>=H,D>=1,C>=2,F>=0,E>=1,H>=1,E+1=G,E+1=A] 

### Cost equations --> "Loop" of last/4 
* CEs [43] --> Loop 41 
* CEs [42] --> Loop 42 
* CEs [41] --> Loop 43 

#### Loops of last/4 
* Loop 41: last(A,B,C,D)->  last(A',B',C,D)
                  [B>=B',B'>=0,D>=1,C>=2,B>=1,A>=2,A=A'+1] 
* Loop 42: last(A,B,C,D)->  last(A',B',C',D')
                  [B>=B',B>=D,B'>=0,D>=1,A>=2,A=A'+1,D'=0,C'=1,C=2] 
* Loop 43: last(A,B,C,D) [D=0,C=1,B=0,A=1] 

### Ranking functions of CR last(A,B,C,D) 
* RF of phase [41]: [A-1]

#### Partial ranking functions of CR last(A,B,C,D) 
* Partial RF of phase [41]:
  - RF of loop [41:1]:
    A-1

Discarded unfeasible chain [[41]]...(Non-terminating chain proved terminating)

### Resulting Chains:last(A,B,C,D) 
* [[41],42,43]
* [43]
* [42,43]


### Merging Chains  last/4 into  External patterns of execution 
* [[43]] --> 1 
* [[43,42]] --> 2 
* [[43,42,[41]]] --> 3 


### Specialization of cost equations f2p/6 
* CE 19 is refined into CE [44] 
* CE 18 is refined into CE [45,46] 
* CE 17 is refined into CE [47] 


#### Refined cost equations f2p/6 
* CE 44: f2p(A,B,C,D,A,B) = 2
     [B>=0,A>=0,D=0,C=1] 
* CE 45: f2p(A,B,C,D,E,F) = 6+ last(G,D,H,F):2
     [D>=F,F>=1,H=2,G=2,E=2,C=2,B=0,A=1] 
* CE 46: f2p(A,B,C,D,E,F) = 6+ last(C,D,G,F):3
     [D>=F,F>=1,C>=3,G=2,E=2,B=0,A=1] 
* CE 47: f2p(A,B,C,D,E,F) = 7+ f2p(C,D,G,H,E,F)
     [B>=H,G>=1,F>=0,E>=0,D>=1,C>=2,B>=1,G+1=A] 

### Cost equations --> "Loop" of f2p/6 
* CEs [47] --> Loop 44 
* CEs [44] --> Loop 45 
* CEs [46] --> Loop 46 
* CEs [45] --> Loop 47 

#### Loops of f2p/6 
* Loop 44: f2p(A,B,C,D,E,F)->  f2p(C,D,A',B',E,F)
                  [B>=B',A'>=1,F>=0,E>=0,D>=1,C>=2,B>=1,A'+1=A] 
* Loop 45: f2p(A,B,C,D,A,B) [B>=0,A>=0,D=0,C=1] 
* Loop 46: f2p(A,B,C,D,E,F) [D>=F,F>=1,C>=3,E=2,B=0,A=1] 
* Loop 47: f2p(A,B,C,D,E,F) [D>=F,F>=1,E=2,C=2,B=0,A=1] 

### Ranking functions of CR f2p(A,B,C,D,E,F) 
* RF of phase [44]: [A+C-3]

#### Partial ranking functions of CR f2p(A,B,C,D,E,F) 
* Partial RF of phase [44]:
  - RF of loop [44:1]:
    A+C-3

Discarded unfeasible chain [[44]]...(Non-terminating chain proved terminating)

### Resulting Chains:f2p(A,B,C,D,E,F) 
* [[44],45]
* [47]
* [46]
* [45]


### Merging Chains  f2p/6 into  External patterns of execution 
* [[47]] --> 1 
* [[46]] --> 2 
* [[45]] --> 3 
* [[45,[44]]] --> 4 


### Specialization of cost equations g3/6 
* CE 21 is refined into CE [48] 
* CE 20 is refined into CE [49,50] 


#### Refined cost equations g3/6 
* CE 48: g3(A,B,C,D,C,D) = 2
     [D>=0,C>=0,B=0,A=1] 
* CE 49: g3(A,B,C,D,E,F) = 5+ maxNorm(G,D,G):1+ g3(H,I,J,G,E,F)
     [B>=I,B>=G,G>=D+1,H>=1,D>=0,F>=0,E>=0,C>=1,C+1=J,H+1=A] 
* CE 50: g3(A,B,C,D,E,F) = 5+ maxNorm(G,D,D):2+ g3(H,I,J,D,E,F)
     [B>=I,D>=G,B>=G,H>=1,G>=1,F>=0,E>=0,C>=1,C+1=J,H+1=A] 

### Cost equations --> "Loop" of g3/6 
* CEs [49] --> Loop 48 
* CEs [50] --> Loop 49 
* CEs [48] --> Loop 50 

#### Loops of g3/6 
* Loop 48: g3(A,B,C,D,E,F)->  g3(A',B',C',D',E,F)
                  [B>=D',B>=B',D'>=D+1,F>=0,E>=0,D>=0,C>=1,A>=2,C+1=C',A=A'+1] 
* Loop 49: g3(A,B,C,D,E,F)->  g3(A',B',C',D,E,F)
                  [B>=B',F>=0,E>=0,D>=1,C>=1,B>=1,A>=2,C+1=C',A=A'+1] 
* Loop 50: g3(A,B,C,D,C,D) [D>=0,C>=0,B=0,A=1] 

### Ranking functions of CR g3(A,B,C,D,E,F) 
* RF of phase [48,49]: [A-1]

#### Partial ranking functions of CR g3(A,B,C,D,E,F) 
* Partial RF of phase [48,49]:
  - RF of loop [48:1]:
    B-D
  - RF of loop [48:1,49:1]:
    A-1

Discarded unfeasible chain [[48,49]]...(Non-terminating chain proved terminating)

### Resulting Chains:g3(A,B,C,D,E,F) 
* [[48,49],50]
* [50]


### Merging Chains  g3/6 into  External patterns of execution 
* [[50]] --> 1 
* [[50,[48,49]]] --> 2 


### Specialization of cost equations f3/6 
* CE 23 is refined into CE [51,52] 
* CE 22 is refined into CE [53,54] 


#### Refined cost equations f3/6 
* CE 51: f3(A,B,C,D,E,F) = 4+ g3(G,H,I,J,K,L):1
     [L=0,K=1,J=0,I=1,H=0,G=1,F=0,E=1,D=0,C=1,B=0,A=1] 
* CE 52: f3(A,B,C,D,A,E) = 4+ g3(A,B,F,G,A,E):2
     [E>=1,A>=2,B>=1,G=0,F=1,D=0,C=1] 
* CE 53: f3(A,B,C,D,E,F) = 5+ maxNorm(G,B,G):1+ f3(H,G,I,J,E,F)
     [D>=J,D>=G,G>=B+1,I>=1,B>=0,F>=0,E>=0,A>=1,A+1=H,I+1=C] 
* CE 54: f3(A,B,C,D,E,F) = 5+ maxNorm(G,B,B):2+ f3(H,B,I,J,E,F)
     [D>=J,B>=G,D>=G,I>=1,G>=1,F>=0,E>=0,A>=1,A+1=H,I+1=C] 

### Cost equations --> "Loop" of f3/6 
* CEs [53] --> Loop 51 
* CEs [54] --> Loop 52 
* CEs [52] --> Loop 53 
* CEs [51] --> Loop 54 

#### Loops of f3/6 
* Loop 51: f3(A,B,C,D,E,F)->  f3(A',B',C',D',E,F)
                  [D>=D',D>=B',B'>=B+1,F>=0,E>=0,C>=2,B>=0,A>=1,C=C'+1,A+1=A'] 
* Loop 52: f3(A,B,C,D,E,F)->  f3(A',B,B',C',E,F)
                  [D>=C',F>=0,E>=0,D>=1,C>=2,B>=1,A>=1,C=B'+1,A+1=A'] 
* Loop 53: f3(A,B,C,D,A,E) [E>=1,B>=1,A>=2,D=0,C=1] 
* Loop 54: f3(A,B,C,D,E,F) [F=0,E=1,D=0,C=1,B=0,A=1] 

### Ranking functions of CR f3(A,B,C,D,E,F) 
* RF of phase [51,52]: [C-1]

#### Partial ranking functions of CR f3(A,B,C,D,E,F) 
* Partial RF of phase [51,52]:
  - RF of loop [51:1]:
    -B+D
  - RF of loop [51:1,52:1]:
    C-1

Discarded unfeasible chain [[51,52]]...(Non-terminating chain proved terminating)

### Resulting Chains:f3(A,B,C,D,E,F) 
* [[51,52],53]
* [54]
* [53]


### Merging Chains  f3/6 into  External patterns of execution 
* [[54]] --> 1 
* [[53]] --> 2 
* [[53,[51,52]]] --> 3 


### Specialization of cost equations p/8 
* CE 11 is refined into CE [55] 
* CE 9 is refined into CE [56] 
* CE 10 is refined into CE [57] 


#### Refined cost equations p/8 
* CE 55: p(A,B,C,D,E,F,A,B) = 6
     [B>=0,A>=0,F=0,E=1,D=0,C=1] 
* CE 56: p(A,B,C,D,E,F,G,H) = 3+ p(A,B,I,J,C,D,G,H)
     [F>=J,I>=1,H>=0,G>=0,F>=1,D>=0,C>=0,B>=0,A>=0,I+1=E] 
* CE 57: p(A,B,C,D,E,F,G,H) = 7+ p(I,J,K,L,A,B,G,H)
     [D>=L,K>=1,H>=0,G>=0,D>=1,B>=0,A>=0,K+1=C,J=0,I=1,F=0,E=1] 

### Cost equations --> "Loop" of p/8 
* CEs [56] --> Loop 55 
* CEs [57] --> Loop 56 
* CEs [55] --> Loop 57 

#### Loops of p/8 
* Loop 55: p(A,B,C,D,E,F,G,H)->  p(A,B,A',B',C,D,G,H)
                  [F>=B',H>=0,G>=0,F>=1,E>=2,D>=0,C>=0,B>=0,A>=0,E=A'+1] 
* Loop 56: p(A,B,C,D,E,F,G,H)->  p(A',B',C',D',A,B,G,H)
                  [D>=D',H>=0,G>=0,D>=1,C>=2,B>=0,A>=0,C=C'+1,B'=0,A'=1,F=0,E=1] 
* Loop 57: p(A,B,C,D,E,F,A,B) [B>=0,A>=0,F=0,E=1,D=0,C=1] 

### Ranking functions of CR p(A,B,C,D,E,F,G,H) 
* RF of phase [55,56]: [A+B+C+D+E+F-2,A+2*B+C+2*D+E+2*F-3,A+3*B+C+3*D+E+3*F-4,A+C+E-1]

#### Partial ranking functions of CR p(A,B,C,D,E,F,G,H) 
* Partial RF of phase [55,56]:
  - RF of loop [55:1]:
    C+E-1 depends on loops [56:1] 
  - RF of loop [56:1]:
    C-1 depends on loops [55:1] 

Discarded unfeasible chain [[55,56]]...(Non-terminating chain proved terminating)

### Resulting Chains:p(A,B,C,D,E,F,G,H) 
* [[55,56],57]
* [57]


### Merging Chains  p/8 into  External patterns of execution 
* [[57]] --> 1 
* [[57,[55,56]]] --> 2 


### Specialization of cost equations r1/6 
* CE 2 is refined into CE [58] 
* CE 1 is refined into CE [59,60] 


#### Refined cost equations r1/6 
* CE 58: r1(A,B,C,D,C,D) = 2
     [D>=0,C>=0,B=0,A=1] 
* CE 59: r1(A,B,C,D,E,F) = 5+ maxNorm(G,D,G):1+ r1(H,I,J,G,E,F)
     [B>=I,B>=G,G>=D+1,H>=1,D>=0,F>=0,E>=0,C>=1,C+1=J,H+1=A] 
* CE 60: r1(A,B,C,D,E,F) = 5+ maxNorm(G,D,D):2+ r1(H,I,J,D,E,F)
     [B>=I,D>=G,B>=G,H>=1,G>=1,F>=0,E>=0,C>=1,C+1=J,H+1=A] 

### Cost equations --> "Loop" of r1/6 
* CEs [59] --> Loop 58 
* CEs [60] --> Loop 59 
* CEs [58] --> Loop 60 

#### Loops of r1/6 
* Loop 58: r1(A,B,C,D,E,F)->  r1(A',B',C',D',E,F)
                  [B>=D',B>=B',D'>=D+1,F>=0,E>=0,D>=0,C>=1,A>=2,C+1=C',A=A'+1] 
* Loop 59: r1(A,B,C,D,E,F)->  r1(A',B',C',D,E,F)
                  [B>=B',F>=0,E>=0,D>=1,C>=1,B>=1,A>=2,C+1=C',A=A'+1] 
* Loop 60: r1(A,B,C,D,C,D) [D>=0,C>=0,B=0,A=1] 

### Ranking functions of CR r1(A,B,C,D,E,F) 
* RF of phase [58,59]: [A-1]

#### Partial ranking functions of CR r1(A,B,C,D,E,F) 
* Partial RF of phase [58,59]:
  - RF of loop [58:1]:
    B-D
  - RF of loop [58:1,59:1]:
    A-1

Discarded unfeasible chain [[58,59]]...(Non-terminating chain proved terminating)

### Resulting Chains:r1(A,B,C,D,E,F) 
* [[58,59],60]
* [60]


### Merging Chains  r1/6 into  External patterns of execution 
* [[60]] --> 1 
* [[60,[58,59]]] --> 2 


### Specialization of cost equations rev/4 
* CE 3 is refined into CE [61,62] 


#### Refined cost equations rev/4 
* CE 61: rev(A,B,C,D) = 2+ r1(E,F,G,H,I,J):1
     [J=0,I=1,H=0,G=1,F=0,E=1,D=0,C=1,B=0,A=1] 
* CE 62: rev(A,B,A,C) = 2+ r1(A,B,D,E,A,C):2
     [C>=1,A>=2,B>=1,E=0,D=1] 

### Cost equations --> "Loop" of rev/4 
* CEs [62] --> Loop 61 
* CEs [61] --> Loop 62 

#### Loops of rev/4 
* Loop 61: rev(A,B,A,C) [C>=1,B>=1,A>=2] 
* Loop 62: rev(A,B,C,D) [D=0,C=1,B=0,A=1] 

### Ranking functions of CR rev(A,B,C,D) 

#### Partial ranking functions of CR rev(A,B,C,D) 


### Resulting Chains:rev(A,B,C,D) 
* [62]
* [61]


### Merging Chains  rev/4 into  External patterns of execution 
* [[62]] --> 1 
* [[61]] --> 2 


### Specialization of cost equations g/8 
* CE 8 is refined into CE [63,64,65,66,67,68] 


#### Refined cost equations g/8 
* CE 63: g(A,B,C,D,E,F,E,F) = 2+ append(G,H,E,F,E,F):1+ f(I,J,E,F,E,F):1
     [F>=0,E>=0,J=0,I=1,H=0,G=1,D=0,C=1,B=0,A=1] 
* CE 64: g(A,B,C,D,E,F,G,B) = 2+ append(H,I,J,K,L,M):1+ f(N,B,O,P,Q,B):2
     [B>=1,Q=2,P=0,O=1,N=2,M=0,L=1,K=0,J=1,I=0,H=1,G=2,F=0,E=1,D=0,C=1,A=2] 
* CE 65: g(A,B,C,D,E,F,G,H) = 2+ append(I,J,K,L,M,N):1+ f(A,B,O,P,G,H):3
     [H>=1,G>=0,B>=1,A>=3,P=0,O=1,N=0,M=1,L=0,K=1,J=0,I=1,F=0,E=1,D=0,C=1] 
* CE 66: g(A,B,C,D,E,F,G,H) = 2+ append(I,J,E,F,E,F):1+ f(A,B,E,F,G,H):4
     [H>=1,G>=0,F>=1,E>=2,B>=1,A>=2,J=0,I=1,D=0,C=1] 
* CE 67: g(A,B,C,D,E,F,G,H) = 2+ append(C,D,I,F,G,H):2+ f(J,K,G,H,G,H):1
     [D+F>=H,H>=F,G>=C,H>=1,F>=0,D>=1,C>=2,G+1=C+I,G+1=C+E,K=0,J=1,B=0,A=1] 
* CE 68: g(A,B,C,D,E,F,G,H) = 2+ append(C,D,I,F,J,K):2+ f(A,B,J,K,G,H):4
     [D+F>=K,K>=F,J>=C,H>=1,G>=0,K>=1,B>=1,A>=2,F>=0,D>=1,C>=2,J+1=C+I,J+1=C+E] 

### Cost equations --> "Loop" of g/8 
* CEs [68] --> Loop 63 
* CEs [66] --> Loop 64 
* CEs [65] --> Loop 65 
* CEs [64] --> Loop 66 
* CEs [67] --> Loop 67 
* CEs [63] --> Loop 68 

#### Loops of g/8 
* Loop 63: g(A,B,C,D,E,F,G,H) [H>=1,G>=0,F>=0,E>=1,D>=1,C>=2,B>=1,A>=2] 
* Loop 64: g(A,B,C,D,E,F,G,H) [H>=1,G>=0,F>=1,E>=2,B>=1,A>=2,D=0,C=1] 
* Loop 65: g(A,B,C,D,E,F,G,H) [H>=1,G>=0,B>=1,A>=3,F=0,E=1,D=0,C=1] 
* Loop 66: g(A,B,C,D,E,F,G,B) [B>=1,G=2,F=0,E=1,D=0,C=1,A=2] 
* Loop 67: g(A,B,C,D,E,F,G,H) [D+F>=H,H>=F,H>=1,F>=0,E>=1,D>=1,C>=2,C+E=G+1,B=0,A=1] 
* Loop 68: g(A,B,C,D,E,F,E,F) [F>=0,E>=0,D=0,C=1,B=0,A=1] 

### Ranking functions of CR g(A,B,C,D,E,F,G,H) 

#### Partial ranking functions of CR g(A,B,C,D,E,F,G,H) 


### Resulting Chains:g(A,B,C,D,E,F,G,H) 
* [68]
* [67]
* [66]
* [65]
* [64]
* [63]


### Merging Chains  g/8 into  External patterns of execution 
* [[68]] --> 1 
* [[67]] --> 2 
* [[66]] --> 3 
* [[65]] --> 4 
* [[64]] --> 5 
* [[63]] --> 6 


Computing Bounds
=====================================

#### Simplifying cost structure of CE 29 

#### Simplifying cost structure of CE 28 

#### Cost of chains of maxNorm(A,B,C):
* Chain [29]: 0
  with precondition: [A=C,B>=0,A>=B+1] 

* Chain [28]: 0
  with precondition: [B=C,A>=1,B>=A] 


#### Simplifying cost structure of CE 30 

#### Computing cost of phase [30,31] 

#### Simplifying cost structure of CE 31 

#### Simplifying cost structure of CE 32 

#### Cost of loops [30,31] 

 * loop 30:append(A,B,C,D,E,F) -> [append(A',B',C',D',E',F')] 
5
 * loop 31:append(A,B,C,D,E,F) -> [append(A',B',C',D',E',F')] 
5
##### Pending set append(A,B,C,D,E,F)
* Psum in Loop 30: [it(30)=<1]
* Psum in Loop 31: [it(31)=<1]

###### Computing sum for it(30)=<1  in Loop 30 
   - Applying inductive sum strategy 
     - head Candidate: A-1 
       - Loop 31 is collaborative and bounds [it(31)] 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
       - Loop 31 is collaborative and bounds [it(31)] 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(30)+it(31)=<A-1,it(30)+it(31)=<A-1,it(30)+it(31)=<A-A',it(30)+it(31)=<A-A'] 

##### Pending set A
* Psum in Loop 31: [it(31)=<1]

###### Computing sum for it(31)=<1  in Loop 31 
   - Applying inductive sum strategy 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(30)+it(31)=<A-1,it(30)+it(31)=<A-1,it(30)+it(31)=<A-A',it(30)+it(31)=<A-A'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [30,31] 

#### Simplifying cost structure of phase [30,31] 
 * Joined equivalent variables [it(30),it(31)] into it(30)

#### Cost of phase [30,31]:append(A,B,C,D,E,F) -> [append(A',B',C',D',E',F')] 
10*it(30)+0
  Such that:aux(1) =< A
aux(2) =< A-A'
it(30) =< aux(1)
it(30) =< aux(2)

#### Simplifying cost structure of chain [[30,31],32] 
 * Joined equivalent variables [aux(3),aux(1),aux(2)] into aux(3)

#### Cost of chains of append(A,B,C,D,E,F):
* Chain [[30,31],32]: 10*it(30)+2
  Such that:aux(3) =< A
it(30) =< aux(3)

  with precondition: [A+C=E+1,A>=2,B>=1,C>=1,D>=0,F>=1,F>=D,B+D>=F] 

* Chain [32]: 2
  with precondition: [A=1,B=0,C=E,D=F,C>=0,D>=0] 


#### Simplifying cost structure of CE 33 

#### Computing cost of phase [33] 
 * Renamed intermediate variables: 
[ (eq(35,1),aux(3))>>s(1), (eq(35,1),it(30))>>s(2)]

#### Simplifying cost structure of CE 35 
 * Renamed intermediate variables: 
[ (it(33),s(1))>>s(3), (it(33),s(2))>>s(4)]

#### Cost of loops [33] 

 * loop 33:f(A,B,C,D,E,F) -> [f(A',B',C',D',E',F')] 
10*s(4)+8
  Such that:s(3) =< C
s(4) =< s(3)

##### Pending set f(A,B,C,D,E,F)
* Psum in Loop 33: [it(33)=<1,s(6)=<C]

###### Computing sum for it(33)=<1  in Loop 33 
   - Applying inductive sum strategy 
     - head Candidate: A-1 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(33)=<A-1,it(33)=<A-1,it(33)=<A-A',it(33)=<A-A'] 

##### Pending set A
* Psum in Loop 33: [s(6)=<C]

###### Computing sum for s(6)=<C  in Loop 33 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(4)=<C] 
 * Adding constraints: [s(6)=<it(33)*aux(4)] 

##### Pending set f(A,B,C,D,E,F)
* Pmax/min: [aux(4)=<C]

###### Computing max_min for aux(4)=<C  
   - Applying max/min strategy 
     - Loop 33  increases the expression by [A',A-1] 
 * Adding constraints:[aux(4)=<aux(5)+aux(6),aux(5)=<C] 

##### Pending set f(A,B,C,D,E,F)
* Psum in Loop 33: [aux(6)=<A-1,aux(6)=<A']

###### Computing sum for aux(6)=<A-1  in Loop 33 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(7)=<A-1] 
 * Adding constraints: [aux(6)=<it(33)*aux(7)] 

##### Pending set f(A,B,C,D,E,F)
* Pmax/min: [aux(7)=<A-1]
* Psum in Loop 33: [aux(6)=<A']

###### Computing max_min for aux(7)=<A-1  
   - Found a solution using transitive invariants 
 * Adding constraints:[aux(7)=<A-1] 

##### Pending set f(A,B,C,D,E,F)
* Psum in Loop 33: [aux(6)=<A']

###### Computing sum for aux(6)=<A'  in Loop 33 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(8)=<A-1] 
 * Adding constraints: [aux(6)=<it(33)*aux(8)] 

##### Pending set f(A,B,C,D,E,F)
* Pmax/min: [aux(8)=<A-1]

###### Computing max_min for aux(8)=<A-1  
   - Found a solution using cacheing 
 * Adding constraints:[aux(8)=<aux(7)] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [33] 

#### Simplifying cost structure of phase [33] 
 * Joined equivalent variables [aux(9),aux(7)] into aux(9)

#### Cost of phase [33]:f(A,B,C,D,E,F) -> [f(A',B',C',D',E',F')] 
8*it(33)+10*s(5)+0
  Such that:it(33) =< A-A'
aux(5) =< C
aux(9) =< A
it(33) =< aux(9)
aux(8) =< aux(9)
aux(6) =< it(33)*aux(9)
aux(6) =< it(33)*aux(8)
aux(4) =< aux(5)+aux(6)
s(6) =< it(33)*aux(4)
s(5) =< s(6)

#### Simplifying cost structure of chain [[33],35] 
 * Joined equivalent variables [aux(10),aux(9)] into aux(10)

#### Simplifying cost structure of CE 34 

#### Simplifying cost structure of chain [34,[33],35] 
 * Joined equivalent variables [aux(11),aux(5),aux(10)] into aux(11)

#### Simplifying cost structure of chain [34,35] 

#### Cost of chains of f(A,B,C,D,E,F):
* Chain [[33],35]: 8*it(33)+10*s(5)+2
  Such that:aux(5) =< C
aux(10) =< A
it(33) =< aux(10)
aux(8) =< aux(10)
aux(6) =< it(33)*aux(10)
aux(6) =< it(33)*aux(8)
aux(4) =< aux(5)+aux(6)
s(6) =< it(33)*aux(4)
s(5) =< s(6)

  with precondition: [A>=2,B>=1,C>=2,D>=1,E>=0,F>=1] 

* Chain [35]: 2
  with precondition: [A=1,B=0,C=E,D=F,C>=0,D>=0] 

* Chain [34,[33],35]: 8*it(33)+10*s(5)+10
  Such that:aux(11) =< A
it(33) =< aux(11)
aux(8) =< aux(11)
aux(6) =< it(33)*aux(11)
aux(6) =< it(33)*aux(8)
aux(4) =< aux(11)+aux(6)
s(6) =< it(33)*aux(4)
s(5) =< s(6)

  with precondition: [C=1,D=0,A>=3,B>=1,E>=0,F>=1] 

* Chain [34,35]: 10
  with precondition: [A=2,C=1,D=0,E=2,B=F,B>=1] 


#### Simplifying cost structure of CE 38 

#### Computing cost of phase [37] 

#### Simplifying cost structure of CE 36 

#### Cost of loops [37] 

 * loop 37:f2(A,B,C,D,E,F) -> [f2(A',B',C',D',E',F')] 
7
##### Pending set f2(A,B,C,D,E,F)
* Psum in Loop 37: [it(37)=<1]

###### Computing sum for it(37)=<1  in Loop 37 
   - Applying inductive sum strategy 
     - head Candidate: A+C-3 
     - head Candidate: A+C-3 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A+C-3 
     - tail Candidate: A+C-3 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(37)=<A+C-3,it(37)=<A+C-3,it(37)=<A+C-A'-C',it(37)=<A+C-A'-C'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [37] 

#### Simplifying cost structure of phase [37] 

#### Cost of phase [37]:f2(A,B,C,D,E,F) -> [f2(A',B',C',D',E',F')] 
7*it(37)+0
  Such that:it(37) =< A+C
it(37) =< A+C-A'-C'

#### Simplifying cost structure of chain [[37],36] 

#### Simplifying cost structure of CE 37 

#### Simplifying cost structure of chain [38,[37],36] 

#### Simplifying cost structure of chain [38,36] 

#### Cost of chains of f2(A,B,C,D,E,F):
* Chain [[37],36]: 7*it(37)+2
  Such that:it(37) =< A+C-E

  with precondition: [A>=2,B>=1,C>=2,D>=1,E>=0,F>=1,A+C>=E+2,B+D>=F+1] 

* Chain [38,[37],36]: 7*it(37)+8
  Such that:it(37) =< 2*C-E

  with precondition: [A=1,B=0,C>=3,E>=0,F>=1,2*C>=E+3,2*D>=F+1] 

* Chain [38,36]: 8
  with precondition: [A=1,B=0,C=2,E=2,D=F,D>=1] 

* Chain [36]: 2
  with precondition: [C=1,D=0,A=E,B=F,A>=0,B>=0] 


#### Simplifying cost structure of CE 40 

#### Simplifying cost structure of CE 39 

#### Cost of chains of case_8(A,B,C,D,E,F,G,H,I):
* Chain [40]: 3
  with precondition: [A=1,B=0,H=2,F+1=C,E=I,E>=1,F>=1,G>=0,D>=E,D>=G] 

* Chain [39]: 2
  with precondition: [I=B,F+1=C,A=H,A>=2,E>=1,F>=1,G>=0,I>=1,D>=E,D>=G] 


#### Simplifying cost structure of CE 41 

#### Simplifying cost structure of CE 42 

#### Simplifying cost structure of chain [42,43] 

#### Computing cost of phase [41] 

#### Simplifying cost structure of CE 43 

#### Cost of loops [41] 

 * loop 41:last(A,B,C,D) -> [last(A',B',C',D')] 
9
##### Pending set last(A,B,C,D)
* Psum in Loop 41: [it(41)=<1]

###### Computing sum for it(41)=<1  in Loop 41 
   - Applying inductive sum strategy 
     - head Candidate: A-1 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(41)=<A-1,it(41)=<A-1,it(41)=<A-A',it(41)=<A-A'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [41] 

#### Simplifying cost structure of phase [41] 

#### Cost of phase [41]:last(A,B,C,D) -> [last(A',B',C',D')] 
9*it(41)+0
  Such that:it(41) =< A
it(41) =< A-A'

#### Simplifying cost structure of chain [[41],42,43] 

#### Cost of chains of last(A,B,C,D):
* Chain [[41],42,43]: 9*it(41)+13
  Such that:it(41) =< A

  with precondition: [C=2,A>=3,D>=1,B>=D] 

* Chain [43]: 3
  with precondition: [A=1,B=0,C=1,D=0] 

* Chain [42,43]: 13
  with precondition: [A=2,C=2,D>=1,B>=D] 


#### Simplifying cost structure of CE 44 

#### Computing cost of phase [44] 

#### Simplifying cost structure of CE 47 

#### Cost of loops [44] 

 * loop 44:f2p(A,B,C,D,E,F) -> [f2p(A',B',C',D',E',F')] 
7
##### Pending set f2p(A,B,C,D,E,F)
* Psum in Loop 44: [it(44)=<1]

###### Computing sum for it(44)=<1  in Loop 44 
   - Applying inductive sum strategy 
     - head Candidate: A+C-3 
     - head Candidate: A+C-3 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A+C-3 
     - tail Candidate: A+C-3 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(44)=<A+C-3,it(44)=<A+C-3,it(44)=<A+C-A'-C',it(44)=<A+C-A'-C'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [44] 

#### Simplifying cost structure of phase [44] 

#### Cost of phase [44]:f2p(A,B,C,D,E,F) -> [f2p(A',B',C',D',E',F')] 
7*it(44)+0
  Such that:it(44) =< A+C
it(44) =< A+C-A'-C'

#### Simplifying cost structure of chain [[44],45] 

#### Simplifying cost structure of CE 45 
 * Renamed intermediate variables: 
[ (eq(46,1),it(41))>>s(7)]

#### Simplifying cost structure of CE 46 

#### Cost of chains of f2p(A,B,C,D,E,F):
* Chain [[44],45]: 7*it(44)+2
  Such that:it(44) =< A+C-E

  with precondition: [A>=2,B>=1,C>=2,D>=1,E>=0,F>=1,A+C>=E+2,B+D>=F+1] 

* Chain [47]: 19
  with precondition: [A=1,B=0,C=2,E=2,F>=1,D>=F] 

* Chain [46]: 9*s(7)+19
  Such that:s(7) =< C

  with precondition: [A=1,B=0,E=2,C>=3,F>=1,D>=F] 

* Chain [45]: 2
  with precondition: [C=1,D=0,A=E,B=F,A>=0,B>=0] 


#### Simplifying cost structure of CE 48 

#### Computing cost of phase [48,49] 

#### Simplifying cost structure of CE 49 

#### Simplifying cost structure of CE 50 

#### Cost of loops [48,49] 

 * loop 48:g3(A,B,C,D,E,F) -> [g3(A',B',C',D',E',F')] 
5
 * loop 49:g3(A,B,C,D,E,F) -> [g3(A',B',C',D',E',F')] 
5
##### Pending set g3(A,B,C,D,E,F)
* Psum in Loop 48: [it(48)=<1]
* Psum in Loop 49: [it(49)=<1]

###### Computing sum for it(48)=<1  in Loop 48 
   - Applying inductive sum strategy 
     - head Candidate: A-1 
       - Loop 49 is collaborative and bounds [it(49)] 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: B-D 
       - Loop 49 is collaborative
     - tail Candidate: A-1 
       - Loop 49 is collaborative and bounds [it(49)] 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B-D 
       - Loop 49 is collaborative
 * Adding constraints: [it(48)+it(49)=<A-1,it(48)+it(49)=<A-1,it(48)=<B-D,it(48)+it(49)=<A-A',it(48)+it(49)=<A-A',it(48)=<B-D-B'+D'] 

##### Pending set A
* Psum in Loop 49: [it(49)=<1]

###### Computing sum for it(49)=<1  in Loop 49 
   - Applying inductive sum strategy 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(48)+it(49)=<A-1,it(48)+it(49)=<A-1,it(48)+it(49)=<A-A',it(48)+it(49)=<A-A'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [48,49] 

#### Simplifying cost structure of phase [48,49] 

#### Cost of phase [48,49]:g3(A,B,C,D,E,F) -> [g3(A',B',C',D',E',F')] 
5*it(48)+5*it(49)+0
  Such that:it(48) =< B-D
it(48) =< B-D-B'+D'
aux(12) =< A
aux(13) =< A-A'
it(48) =< aux(12)
it(49) =< aux(12)
it(48) =< aux(13)
it(49) =< aux(13)

#### Simplifying cost structure of chain [[48,49],50] 
 * Joined equivalent variables [aux(14),aux(12),aux(13)] into aux(14)

#### Cost of chains of g3(A,B,C,D,E,F):
* Chain [[48,49],50]: 5*it(48)+5*it(49)+2
  Such that:it(48) =< B-D
it(48) =< B-D+F
aux(14) =< A
it(48) =< aux(14)
it(49) =< aux(14)

  with precondition: [A+C=E+1,A>=2,B>=1,C>=1,D>=0,F>=1,F>=D] 

* Chain [50]: 2
  with precondition: [A=1,B=0,C=E,D=F,C>=0,D>=0] 

 * Renamed intermediate variables: 
[ (eq(52,1),it(48))>>s(8), (eq(52,1),aux(14))>>s(9), (eq(52,1),it(49))>>s(10)]

#### Simplifying cost structure of CE 52 

#### Computing cost of phase [51,52] 

#### Simplifying cost structure of CE 53 

#### Simplifying cost structure of CE 54 

#### Cost of loops [51,52] 

 * loop 51:f3(A,B,C,D,E,F) -> [f3(A',B',C',D',E',F')] 
5
 * loop 52:f3(A,B,C,D,E,F) -> [f3(A',B',C',D',E',F')] 
5
##### Pending set f3(A,B,C,D,E,F)
* Psum in Loop 51: [it(51)=<1]
* Psum in Loop 52: [it(52)=<1]

###### Computing sum for it(51)=<1  in Loop 51 
   - Applying inductive sum strategy 
     - head Candidate: C-1 
       - Loop 52 is collaborative and bounds [it(52)] 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: -B+D 
       - Loop 52 is collaborative
     - tail Candidate: C-1 
       - Loop 52 is collaborative and bounds [it(52)] 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: -B+D 
       - Loop 52 is collaborative
 * Adding constraints: [it(51)+it(52)=<C-1,it(51)+it(52)=<C-1,it(51)=< -B+D,it(51)+it(52)=<C-C',it(51)+it(52)=<C-C',it(51)=< -B+D+B'-D'] 

##### Pending set A
* Psum in Loop 52: [it(52)=<1]

###### Computing sum for it(52)=<1  in Loop 52 
   - Applying inductive sum strategy 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(51)+it(52)=<C-1,it(51)+it(52)=<C-1,it(51)+it(52)=<C-C',it(51)+it(52)=<C-C'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [51,52] 

#### Simplifying cost structure of phase [51,52] 

#### Cost of phase [51,52]:f3(A,B,C,D,E,F) -> [f3(A',B',C',D',E',F')] 
5*it(51)+5*it(52)+0
  Such that:it(51) =< -B+D
it(51) =< -B+D+B'-D'
aux(15) =< C
aux(16) =< C-C'
it(51) =< aux(15)
it(52) =< aux(15)
it(51) =< aux(16)
it(52) =< aux(16)

#### Simplifying cost structure of chain [[51,52],53] 
 * Joined equivalent variables [aux(17),aux(15),aux(16)] into aux(17)

#### Simplifying cost structure of CE 51 

#### Cost of chains of f3(A,B,C,D,E,F):
* Chain [[51,52],53]: 5*it(51)+5*it(52)+5*s(8)+5*s(10)+6
  Such that:s(9) =< A+C
it(51) =< -B+D
s(8) =< B+D
it(51) =< 2*D
aux(17) =< C
s(8) =< s(9)
s(10) =< s(9)
it(51) =< aux(17)
it(52) =< aux(17)

  with precondition: [A+C=E+1,A>=1,B>=0,C>=2,D>=1,F>=1] 

* Chain [54]: 6
  with precondition: [A=1,B=0,C=1,D=0,E=1,F=0] 

* Chain [53]: 5*s(8)+5*s(10)+6
  Such that:s(9) =< A
s(8) =< B
s(8) =< s(9)
s(10) =< s(9)

  with precondition: [C=1,D=0,A=E,A>=2,B>=1,F>=1] 


#### Simplifying cost structure of CE 55 

#### Computing cost of phase [55,56] 

#### Simplifying cost structure of CE 56 

#### Simplifying cost structure of CE 57 

#### Cost of loops [55,56] 

 * loop 55:p(A,B,C,D,E,F,G,H) -> [p(A',B',C',D',E',F',G',H')] 
3
 * loop 56:p(A,B,C,D,E,F,G,H) -> [p(A',B',C',D',E',F',G',H')] 
7
##### Pending set p(A,B,C,D,E,F,G,H)
* Psum in Loop 55: [it(55)=<1]
* Psum in Loop 56: [it(56)=<1]

###### Computing sum for it(55)=<1  in Loop 55 
   - Applying inductive sum strategy 
     - head Candidate: A+C+E-1 
       - Loop 56 is collaborative and bounds [it(56)] 
     - head Candidate: A+B+C+D+E+F-2 
       - Loop 56 is collaborative and bounds [it(56)] 
     - head Candidate: A+2*B+C+2*D+E+2*F-3 
       - Loop 56 is collaborative and bounds [it(56)] 
     - head Candidate: A+3*B+C+3*D+E+3*F-4 
       - Loop 56 is collaborative and bounds [it(56)] 
     - head Candidate: C+E-1 
       - Loop 56 adds an expression [A-2]
     - tail Candidate: A+C+E-1 
       - Loop 56 is collaborative and bounds [it(56)] 
     - tail Candidate: A+B+C+D+E+F-2 
       - Loop 56 is collaborative and bounds [it(56)] 
     - tail Candidate: A+2*B+C+2*D+E+2*F-3 
       - Loop 56 is collaborative and bounds [it(56)] 
     - tail Candidate: A+3*B+C+3*D+E+3*F-4 
       - Loop 56 is collaborative and bounds [it(56)] 
     - tail Candidate: C+E-1 
       - Loop 56 adds an expression [A-2]
 * Adding constraints: [it(55)=<aux(18)+aux(19),it(55)=<aux(20)+aux(21),it(55)+it(56)=<A+C+E-1,it(55)+it(56)=<A+B+C+D+E+F-2,it(55)+it(56)=<A+2*B+C+2*D+E+2*F-3,it(55)+it(56)=<A+3*B+C+3*D+E+3*F-4,aux(19)=<C+E-1,it(55)+it(56)=<A+C+E-A'-C'-E',it(55)+it(56)=<A+B+C+D+E+F-A'-B'-C'-D'-E'-F',it(55)+it(56)=<A+2*B+C+2*D+E+2*F-A'-2*B'-C'-2*D'-E'-2*F',it(55)+it(56)=<A+3*B+C+3*D+E+3*F-A'-3*B'-C'-3*D'-E'-3*F',aux(21)=<C+E-C'-E'] 

##### Pending set A
* Psum in Loop 56: [it(56)=<1,aux(18)=<A-2,aux(20)=<A-2]

###### Computing sum for it(56)=<1  in Loop 56 
   - Applying inductive sum strategy 
     - head Candidate: A+C+E-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A+B+C+D+E+F-2 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A+2*B+C+2*D+E+2*F-3 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A+3*B+C+3*D+E+3*F-4 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: C-1 
       - Loop 55 adds an expression [E-E'-1]
     - tail Candidate: A+C+E-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A+B+C+D+E+F-2 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A+2*B+C+2*D+E+2*F-3 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A+3*B+C+3*D+E+3*F-4 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - Loop 55 adds an expression [E-E'-1]
 * Adding constraints: [it(56)=<aux(22)+aux(23),it(56)=<aux(24)+aux(25),it(55)+it(56)=<A+C+E-1,it(55)+it(56)=<A+B+C+D+E+F-2,it(55)+it(56)=<A+2*B+C+2*D+E+2*F-3,it(55)+it(56)=<A+3*B+C+3*D+E+3*F-4,aux(23)=<C-1,it(55)+it(56)=<A+C+E-A'-C'-E',it(55)+it(56)=<A+B+C+D+E+F-A'-B'-C'-D'-E'-F',it(55)+it(56)=<A+2*B+C+2*D+E+2*F-A'-2*B'-C'-2*D'-E'-2*F',it(55)+it(56)=<A+3*B+C+3*D+E+3*F-A'-3*B'-C'-3*D'-E'-3*F',aux(25)=<C-C'] 

##### Pending set A
* Psum in Loop 55: [aux(22)=<E-E'-1,aux(24)=<E-E'-1]
* Psum in Loop 56: [aux(18)=<A-2,aux(20)=<A-2]

###### Computing sum for aux(22)=<E-E'-1  in Loop 55 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(26)=<E-2,aux(26)=< -C+E-1] 
 * Adding constraints: [aux(22)=<it(55)*aux(26)] 

##### Pending set p(A,B,C,D,E,F,G,H)
* Pmax/min: [aux(26)=< -C+E-1,aux(26)=<E-2]
* Psum in Loop 55: [aux(24)=<E-E'-1]
* Psum in Loop 56: [aux(18)=<A-2,aux(20)=<A-2]

###### Computing max_min for aux(26)=< -C+E-1  
   - Found a solution using transitive invariants 
 * Adding constraints:[aux(26)=<A+C+E-1,aux(26)=<A+C+5*E-9] 

##### Pending set p(A,B,C,D,E,F,G,H)
* Pmax/min: [aux(26)=<E-2]
* Psum in Loop 55: [aux(24)=<E-E'-1]
* Psum in Loop 56: [aux(18)=<A-2,aux(20)=<A-2]

###### Computing max_min for aux(26)=<E-2  
   - Found a solution using transitive invariants 
 * Adding constraints:[aux(26)=<A+C+E-2,aux(26)=<A+C+3*E-6] 

##### Pending set p(A,B,C,D,E,F,G,H)
* Psum in Loop 55: [aux(24)=<E-E'-1]
* Psum in Loop 56: [aux(18)=<A-2,aux(20)=<A-2]

###### Computing sum for aux(24)=<E-E'-1  in Loop 55 
   - Found a solution using cacheing 
 * Adding constraints: [aux(24)=<aux(27),aux(27)=<it(55)*aux(26)] 

##### Pending set p(A,B,C,D,E,F,G,H)
* Psum in Loop 56: [aux(18)=<A-2,aux(20)=<A-2]

###### Computing sum for aux(18)=<A-2  in Loop 56 
   - Applying inductive sum strategy 
     - head Candidate: A-2 
       - Loop 55 is collaborative
     - head Candidate: A-2 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-2 
       - Loop 55 is collaborative
     - tail Candidate: A-2 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [aux(18)=<A-2,aux(18)=<A-2,aux(18)=<A-A',aux(18)=<A-A'] 

##### Pending set p(A,B,C,D,E,F,G,H)
* Psum in Loop 56: [aux(20)=<A-2]

###### Computing sum for aux(20)=<A-2  in Loop 56 
   - Found a solution using cacheing 
 * Adding constraints: [aux(20)=<aux(28),aux(28)=<A-2,aux(28)=<A-2,aux(28)=<A-A',aux(28)=<A-A'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [55,56] 

#### Simplifying cost structure of phase [55,56] 
 * Joined equivalent variables [aux(27),aux(24)] into aux(27)
 * Joined equivalent variables [aux(28),aux(20)] into aux(28)
 * Joined equivalent variables [aux(22),aux(27)] into aux(22)
 * Joined equivalent variables [aux(18),aux(28)] into aux(18)

#### Cost of phase [55,56]:p(A,B,C,D,E,F,G,H) -> [p(A',B',C',D',E',F',G',H')] 
3*it(55)+7*it(56)+0
  Such that:aux(26) =< A+C+3*E
aux(26) =< A+C+5*E
aux(23) =< C
aux(19) =< C+E
aux(21) =< C+E-C'-E'
aux(25) =< C-C'
aux(29) =< A
aux(30) =< A+B+C+D+E+F
aux(31) =< A+B+C+D+E+F-A'-B'-C'-D'-E'-F'
aux(32) =< A+2*B+C+2*D+E+2*F
aux(33) =< A+2*B+C+2*D+E+2*F-A'-2*B'-C'-2*D'-E'-2*F'
aux(34) =< A+3*B+C+3*D+E+3*F
aux(35) =< A+3*B+C+3*D+E+3*F-A'-3*B'-C'-3*D'-E'-3*F'
aux(36) =< A+C+E
aux(37) =< A+C+E-A'-C'-E'
aux(38) =< A-A'
aux(18) =< aux(29)
it(55) =< aux(30)
it(56) =< aux(30)
it(55) =< aux(31)
it(56) =< aux(31)
it(55) =< aux(32)
it(56) =< aux(32)
it(55) =< aux(33)
it(56) =< aux(33)
it(55) =< aux(34)
it(56) =< aux(34)
it(55) =< aux(35)
it(56) =< aux(35)
aux(26) =< aux(36)
it(55) =< aux(36)
it(56) =< aux(36)
it(55) =< aux(37)
it(56) =< aux(37)
aux(18) =< aux(38)
it(55) =< aux(18)+aux(19)
it(55) =< aux(18)+aux(21)
aux(22) =< it(55)*aux(26)
it(56) =< aux(22)+aux(23)
it(56) =< aux(22)+aux(25)

#### Simplifying cost structure of chain [[55,56],57] 
 * Joined equivalent variables [aux(39),aux(23),aux(25)] into aux(39)
 * Joined equivalent variables [aux(40),aux(19),aux(21)] into aux(40)

#### Cost of chains of p(A,B,C,D,E,F,G,H):
* Chain [[55,56],57]: 3*it(55)+7*it(56)+6
  Such that:aux(29) =< A
aux(30) =< A+B+C+D+E+F
aux(31) =< A+B+C+D+E+F-G-H
aux(32) =< A+2*B+C+2*D+E+2*F
aux(33) =< A+2*B+C+2*D+E+2*F-G-2*H
aux(34) =< A+3*B+C+3*D+E+3*F
aux(35) =< A+3*B+C+3*D+E+3*F-G-3*H
aux(36) =< A+C+E
aux(37) =< A+C+E-G
aux(26) =< A+C+3*E
aux(38) =< A-G
aux(39) =< C
aux(40) =< C+E
aux(18) =< aux(29)
it(55) =< aux(30)
it(56) =< aux(30)
it(55) =< aux(31)
it(56) =< aux(31)
it(55) =< aux(32)
it(56) =< aux(32)
it(55) =< aux(33)
it(56) =< aux(33)
it(55) =< aux(34)
it(56) =< aux(34)
it(55) =< aux(35)
it(56) =< aux(35)
aux(26) =< aux(36)
it(55) =< aux(36)
it(56) =< aux(36)
it(55) =< aux(37)
it(56) =< aux(37)
aux(18) =< aux(38)
it(55) =< aux(18)+aux(40)
aux(22) =< it(55)*aux(26)
it(56) =< aux(22)+aux(39)

  with precondition: [B>=0,C>=0,D>=0,E>=1,F>=0,G>=0,H>=0,A>=G,C+E>=3,C+F>=2,D+E>=2,D+F>=1] 

* Chain [57]: 6
  with precondition: [C=1,D=0,E=1,F=0,A=G,B=H,A>=0,B>=0] 


#### Simplifying cost structure of CE 58 

#### Computing cost of phase [58,59] 

#### Simplifying cost structure of CE 59 

#### Simplifying cost structure of CE 60 

#### Cost of loops [58,59] 

 * loop 58:r1(A,B,C,D,E,F) -> [r1(A',B',C',D',E',F')] 
5
 * loop 59:r1(A,B,C,D,E,F) -> [r1(A',B',C',D',E',F')] 
5
##### Pending set r1(A,B,C,D,E,F)
* Psum in Loop 58: [it(58)=<1]
* Psum in Loop 59: [it(59)=<1]

###### Computing sum for it(58)=<1  in Loop 58 
   - Applying inductive sum strategy 
     - head Candidate: A-1 
       - Loop 59 is collaborative and bounds [it(59)] 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: B-D 
       - Loop 59 is collaborative
     - tail Candidate: A-1 
       - Loop 59 is collaborative and bounds [it(59)] 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B-D 
       - Loop 59 is collaborative
 * Adding constraints: [it(58)+it(59)=<A-1,it(58)+it(59)=<A-1,it(58)=<B-D,it(58)+it(59)=<A-A',it(58)+it(59)=<A-A',it(58)=<B-D-B'+D'] 

##### Pending set A
* Psum in Loop 59: [it(59)=<1]

###### Computing sum for it(59)=<1  in Loop 59 
   - Applying inductive sum strategy 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(58)+it(59)=<A-1,it(58)+it(59)=<A-1,it(58)+it(59)=<A-A',it(58)+it(59)=<A-A'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [58,59] 

#### Simplifying cost structure of phase [58,59] 

#### Cost of phase [58,59]:r1(A,B,C,D,E,F) -> [r1(A',B',C',D',E',F')] 
5*it(58)+5*it(59)+0
  Such that:it(58) =< B-D
it(58) =< B-D-B'+D'
aux(41) =< A
aux(42) =< A-A'
it(58) =< aux(41)
it(59) =< aux(41)
it(58) =< aux(42)
it(59) =< aux(42)

#### Simplifying cost structure of chain [[58,59],60] 
 * Joined equivalent variables [aux(43),aux(41),aux(42)] into aux(43)

#### Cost of chains of r1(A,B,C,D,E,F):
* Chain [[58,59],60]: 5*it(58)+5*it(59)+2
  Such that:it(58) =< B-D
it(58) =< B-D+F
aux(43) =< A
it(58) =< aux(43)
it(59) =< aux(43)

  with precondition: [A+C=E+1,A>=2,B>=1,C>=1,D>=0,F>=1,F>=D] 

* Chain [60]: 2
  with precondition: [A=1,B=0,C=E,D=F,C>=0,D>=0] 


#### Simplifying cost structure of CE 61 
 * Renamed intermediate variables: 
[ (eq(62,1),it(58))>>s(11), (eq(62,1),aux(43))>>s(12), (eq(62,1),it(59))>>s(13)]

#### Simplifying cost structure of CE 62 

#### Cost of chains of rev(A,B,C,D):
* Chain [62]: 4
  with precondition: [A=1,B=0,C=1,D=0] 

* Chain [61]: 5*s(11)+5*s(13)+4
  Such that:s(12) =< A
s(11) =< B
s(11) =< s(12)
s(13) =< s(12)

  with precondition: [A=C,A>=2,B>=1,D>=1] 


#### Simplifying cost structure of CE 63 
 * Renamed intermediate variables: 
[ (eq(67,1),aux(3))>>s(14), (eq(67,1),it(30))>>s(15)]

#### Simplifying cost structure of CE 67 

#### Simplifying cost structure of CE 64 
 * Renamed intermediate variables: 
[ (eq(65,2),aux(11))>>s(16), (eq(65,2),it(33))>>s(17), (eq(65,2),aux(8))>>s(18), (eq(65,2),aux(6))>>s(19), (eq(65,2),aux(4))>>s(20), (eq(65,2),s(6))>>s(21), (eq(65,2),s(5))>>s(22)]

#### Simplifying cost structure of CE 65 
 * Renamed intermediate variables: 
[ (eq(66,2),aux(5))>>s(23), (eq(66,2),aux(10))>>s(24), (eq(66,2),it(33))>>s(25), (eq(66,2),aux(8))>>s(26), (eq(66,2),aux(6))>>s(27), (eq(66,2),aux(4))>>s(28), (eq(66,2),s(6))>>s(29), (eq(66,2),s(5))>>s(30)]

#### Simplifying cost structure of CE 66 
 * Renamed intermediate variables: 
[ (eq(68,1),aux(3))>>s(31), (eq(68,1),it(30))>>s(32)]
 * Renamed intermediate variables: 
[ (eq(68,2),aux(5))>>s(33), (eq(68,2),aux(10))>>s(34), (eq(68,2),it(33))>>s(35), (eq(68,2),aux(8))>>s(36), (eq(68,2),aux(6))>>s(37), (eq(68,2),aux(4))>>s(38), (eq(68,2),s(6))>>s(39), (eq(68,2),s(5))>>s(40)]

#### Simplifying cost structure of CE 68 

#### Cost of chains of g(A,B,C,D,E,F,G,H):
* Chain [68]: 6
  with precondition: [A=1,B=0,C=1,D=0,E=G,F=H,E>=0,F>=0] 

* Chain [67]: 10*s(15)+6
  Such that:s(14) =< C
s(15) =< s(14)

  with precondition: [A=1,B=0,C+E=G+1,C>=2,D>=1,E>=1,F>=0,H>=1,H>=F,D+F>=H] 

* Chain [66]: 14
  with precondition: [A=2,C=1,D=0,E=1,F=0,G=2,B=H,B>=1] 

* Chain [65]: 8*s(17)+10*s(22)+14
  Such that:s(16) =< A
s(17) =< s(16)
s(18) =< s(16)
s(19) =< s(17)*s(16)
s(19) =< s(17)*s(18)
s(20) =< s(16)+s(19)
s(21) =< s(17)*s(20)
s(22) =< s(21)

  with precondition: [C=1,D=0,E=1,F=0,A>=3,B>=1,G>=0,H>=1] 

* Chain [64]: 8*s(25)+10*s(30)+6
  Such that:s(24) =< A
s(23) =< E
s(25) =< s(24)
s(26) =< s(24)
s(27) =< s(25)*s(24)
s(27) =< s(25)*s(26)
s(28) =< s(23)+s(27)
s(29) =< s(25)*s(28)
s(30) =< s(29)

  with precondition: [C=1,D=0,A>=2,B>=1,E>=2,F>=1,G>=0,H>=1] 

* Chain [63]: 10*s(32)+8*s(35)+10*s(40)+6
  Such that:s(34) =< A
s(31) =< C
s(33) =< C+E
s(35) =< s(34)
s(36) =< s(34)
s(37) =< s(35)*s(34)
s(37) =< s(35)*s(36)
s(38) =< s(33)+s(37)
s(39) =< s(35)*s(38)
s(40) =< s(39)
s(32) =< s(31)

  with precondition: [A>=2,B>=1,C>=2,D>=1,E>=1,F>=0,G>=0,H>=1] 


Closed-form bounds of r1(A,B,C,D,E,F): 
-------------------------------------
* Chain [[58,59],60] with precondition: [A+C=E+1,A>=2,B>=1,C>=1,D>=0,F>=1,F>=D] 
    - Upper bound: 5*A+2+nat(B-D)*5 
    - Complexity: n 
* Chain [60] with precondition: [A=1,B=0,C=E,D=F,C>=0,D>=0] 
    - Upper bound: 2 
    - Complexity: constant 

### Maximum cost of r1(A,B,C,D,E,F): nat(B-D)*5+5*A+2 
Asymptotic class: n 

Closed-form bounds of rev(A,B,C,D): 
-------------------------------------
* Chain [62] with precondition: [A=1,B=0,C=1,D=0] 
    - Upper bound: 4 
    - Complexity: constant 
* Chain [61] with precondition: [A=C,A>=2,B>=1,D>=1] 
    - Upper bound: 5*A+5*B+4 
    - Complexity: n 

### Maximum cost of rev(A,B,C,D): 5*A+5*B+4 
Asymptotic class: n 

Closed-form bounds of append(A,B,C,D,E,F): 
-------------------------------------
* Chain [[30,31],32] with precondition: [A+C=E+1,A>=2,B>=1,C>=1,D>=0,F>=1,F>=D,B+D>=F] 
    - Upper bound: 10*A+2 
    - Complexity: n 
* Chain [32] with precondition: [A=1,B=0,C=E,D=F,C>=0,D>=0] 
    - Upper bound: 2 
    - Complexity: constant 

### Maximum cost of append(A,B,C,D,E,F): 10*A+2 
Asymptotic class: n 

Closed-form bounds of f(A,B,C,D,E,F): 
-------------------------------------
* Chain [[33],35] with precondition: [A>=2,B>=1,C>=2,D>=1,E>=0,F>=1] 
    - Upper bound: 8*A+2+10*A*A*A+10*A*C 
    - Complexity: n^3 
* Chain [35] with precondition: [A=1,B=0,C=E,D=F,C>=0,D>=0] 
    - Upper bound: 2 
    - Complexity: constant 
* Chain [34,[33],35] with precondition: [C=1,D=0,A>=3,B>=1,E>=0,F>=1] 
    - Upper bound: 8*A+10+10*A*A+10*A*A*A 
    - Complexity: n^3 
* Chain [34,35] with precondition: [A=2,C=1,D=0,E=2,B=F,B>=1] 
    - Upper bound: 10 
    - Complexity: constant 

### Maximum cost of f(A,B,C,D,E,F): max([8,10*A*A*A+8*A+max([10*A*C,10*A*A+8])])+2 
Asymptotic class: n^3 

Closed-form bounds of g(A,B,C,D,E,F,G,H): 
-------------------------------------
* Chain [68] with precondition: [A=1,B=0,C=1,D=0,E=G,F=H,E>=0,F>=0] 
    - Upper bound: 6 
    - Complexity: constant 
* Chain [67] with precondition: [A=1,B=0,C+E=G+1,C>=2,D>=1,E>=1,F>=0,H>=1,H>=F,D+F>=H] 
    - Upper bound: 10*C+6 
    - Complexity: n 
* Chain [66] with precondition: [A=2,C=1,D=0,E=1,F=0,G=2,B=H,B>=1] 
    - Upper bound: 14 
    - Complexity: constant 
* Chain [65] with precondition: [C=1,D=0,E=1,F=0,A>=3,B>=1,G>=0,H>=1] 
    - Upper bound: 8*A+14+10*A*A+10*A*A*A 
    - Complexity: n^3 
* Chain [64] with precondition: [C=1,D=0,A>=2,B>=1,E>=2,F>=1,G>=0,H>=1] 
    - Upper bound: 8*A+6+10*A*A*A+10*A*E 
    - Complexity: n^3 
* Chain [63] with precondition: [A>=2,B>=1,C>=2,D>=1,E>=1,F>=0,G>=0,H>=1] 
    - Upper bound: 8*A+6+10*A*A*A+ (C+E)* (10*A)+10*C 
    - Complexity: n^3 

### Maximum cost of g(A,B,C,D,E,F,G,H): max([10*C,10*A*A*A+8*A+max([10*A*E,10*A*A+8, (C+E)* (10*A)+10*C])])+6 
Asymptotic class: n^3 
 * Joined equivalent variables [aux(44),aux(29),aux(38)] into aux(44)
 * Joined equivalent variables [aux(45),aux(30),aux(31)] into aux(45)
 * Joined equivalent variables [aux(46),aux(32),aux(33)] into aux(46)
 * Joined equivalent variables [aux(47),aux(34),aux(35)] into aux(47)
 * Joined equivalent variables [aux(48),aux(36),aux(37)] into aux(48)
 * Joined equivalent variables [aux(44),aux(18)] into aux(44)

Closed-form bounds of p(A,B,C,D,E,F,G,H): 
-------------------------------------
* Chain [[55,56],57] with precondition: [B>=0,C>=0,D>=0,E>=1,F>=0,G>=0,H>=0,A>=G,C+E>=3,C+F>=2,D+E>=2,D+F>=1] 
    - Upper bound: 10*A+10*B+10*C+10*D+10*E+10*F+6 
    - Complexity: n 
* Chain [57] with precondition: [C=1,D=0,E=1,F=0,A=G,B=H,A>=0,B>=0] 
    - Upper bound: 6 
    - Complexity: constant 

### Maximum cost of p(A,B,C,D,E,F,G,H): 10*A+10*B+10*C+10*D+10*E+10*F+6 
Asymptotic class: n 

Closed-form bounds of f2(A,B,C,D,E,F): 
-------------------------------------
* Chain [[37],36] with precondition: [A>=2,B>=1,C>=2,D>=1,E>=0,F>=1,A+C>=E+2,B+D>=F+1] 
    - Upper bound: 7*A+7*C+2 
    - Complexity: n 
* Chain [38,[37],36] with precondition: [A=1,B=0,C>=3,E>=0,F>=1,2*C>=E+3,2*D>=F+1] 
    - Upper bound: 14*C+8 
    - Complexity: n 
* Chain [38,36] with precondition: [A=1,B=0,C=2,E=2,D=F,D>=1] 
    - Upper bound: 8 
    - Complexity: constant 
* Chain [36] with precondition: [C=1,D=0,A=E,B=F,A>=0,B>=0] 
    - Upper bound: 2 
    - Complexity: constant 

### Maximum cost of f2(A,B,C,D,E,F): max([14*C+6,7*A+7*C])+2 
Asymptotic class: n 

Closed-form bounds of last(A,B,C,D): 
-------------------------------------
* Chain [[41],42,43] with precondition: [C=2,A>=3,D>=1,B>=D] 
    - Upper bound: 9*A+13 
    - Complexity: n 
* Chain [43] with precondition: [A=1,B=0,C=1,D=0] 
    - Upper bound: 3 
    - Complexity: constant 
* Chain [42,43] with precondition: [A=2,C=2,D>=1,B>=D] 
    - Upper bound: 13 
    - Complexity: constant 

### Maximum cost of last(A,B,C,D): 9*A+13 
Asymptotic class: n 

Closed-form bounds of f2p(A,B,C,D,E,F): 
-------------------------------------
* Chain [[44],45] with precondition: [A>=2,B>=1,C>=2,D>=1,E>=0,F>=1,A+C>=E+2,B+D>=F+1] 
    - Upper bound: 7*A+7*C+2 
    - Complexity: n 
* Chain [47] with precondition: [A=1,B=0,C=2,E=2,F>=1,D>=F] 
    - Upper bound: 19 
    - Complexity: constant 
* Chain [46] with precondition: [A=1,B=0,E=2,C>=3,F>=1,D>=F] 
    - Upper bound: 9*C+19 
    - Complexity: n 
* Chain [45] with precondition: [C=1,D=0,A=E,B=F,A>=0,B>=0] 
    - Upper bound: 2 
    - Complexity: constant 

### Maximum cost of f2p(A,B,C,D,E,F): max([9*C+17,7*A+7*C])+2 
Asymptotic class: n 

Closed-form bounds of g3(A,B,C,D,E,F): 
-------------------------------------
* Chain [[48,49],50] with precondition: [A+C=E+1,A>=2,B>=1,C>=1,D>=0,F>=1,F>=D] 
    - Upper bound: 5*A+2+nat(B-D)*5 
    - Complexity: n 
* Chain [50] with precondition: [A=1,B=0,C=E,D=F,C>=0,D>=0] 
    - Upper bound: 2 
    - Complexity: constant 

### Maximum cost of g3(A,B,C,D,E,F): nat(B-D)*5+5*A+2 
Asymptotic class: n 

Closed-form bounds of f3(A,B,C,D,E,F): 
-------------------------------------
* Chain [[51,52],53] with precondition: [A+C=E+1,A>=1,B>=0,C>=2,D>=1,F>=1] 
    - Upper bound: 5*A+5*B+10*C+5*D+6+nat(-B+D)*5 
    - Complexity: n 
* Chain [54] with precondition: [A=1,B=0,C=1,D=0,E=1,F=0] 
    - Upper bound: 6 
    - Complexity: constant 
* Chain [53] with precondition: [C=1,D=0,A=E,A>=2,B>=1,F>=1] 
    - Upper bound: 5*A+5*B+6 
    - Complexity: n 

### Maximum cost of f3(A,B,C,D,E,F): max([5*A+5*B,5*A+5*B+10*C+5*D+nat(-B+D)*5])+6 
Asymptotic class: n 
* Total analysis performed in 4142 ms.


Cost relation system solved by CoFloCo in 4151 ms.

Method r1 terminates?: YES

 - ls_1: size of ls wrt. List<A>
 - ls_2: size of ls wrt. A
 - a_1: size of a wrt. List<A>
 - a_2: size of a wrt. A
UB for r1(ls_1,ls_2,a_1,a_2) = nat(ls_2-a_2)*5+5*ls_1+2

Method rev terminates?: YES

 - ls_1: size of ls wrt. List<A>
 - ls_2: size of ls wrt. A
UB for rev(ls_1,ls_2) = 5*ls_1+5*ls_2+4

Method append terminates?: YES

 - l1_1: size of l1 wrt. List<A>
 - l1_2: size of l1 wrt. A
 - l2_1: size of l2 wrt. List<A>
 - l2_2: size of l2 wrt. A
UB for append(l1_1,l1_2,l2_1,l2_2) = 10*l1_1+2

Method f terminates?: YES

 - i_1: size of i wrt. List<A>
 - i_2: size of i wrt. A
 - x_1: size of x wrt. List<A>
 - x_2: size of x wrt. A
UB for f(i_1,i_2,x_1,x_2) = max([8,10*i_1*i_1*i_1+8*i_1+max([10*i_1*x_1,10*i_1*i_1+8])])+2

Method g terminates?: YES

 - a_1: size of a wrt. List<A>
 - a_2: size of a wrt. A
 - b_1: size of b wrt. List<A>
 - b_2: size of b wrt. A
 - c_1: size of c wrt. List<A>
 - c_2: size of c wrt. A
UB for g(a_1,a_2,b_1,b_2,c_1,c_2) = max([10*b_1,10*a_1*a_1*a_1+8*a_1+max([10*a_1*c_1,10*a_1*a_1+8, (b_1+c_1)* (10*a_1)+10*b_1])])+6

Method p terminates?: YES

 - m_1: size of m wrt. List<A>
 - m_2: size of m wrt. A
 - n_1: size of n wrt. List<A>
 - n_2: size of n wrt. A
 - r_1: size of r wrt. List<A>
 - r_2: size of r wrt. A
UB for p(m_1,m_2,n_1,n_2,r_1,r_2) = 10*m_1+10*m_2+10*n_1+10*n_2+10*r_1+10*r_2+6

Method f2 terminates?: YES

 - x_1: size of x wrt. List<A>
 - x_2: size of x wrt. A
 - y_1: size of y wrt. List<A>
 - y_2: size of y wrt. A
UB for f2(x_1,x_2,y_1,y_2) = max([14*y_1+6,7*x_1+7*y_1])+2

Method last terminates?: YES

 - l_1: size of l wrt. List<A>
 - l_2: size of l wrt. A
UB for last(l_1,l_2) = 9*l_1+13

Method f2p terminates?: YES

 - x_1: size of x wrt. List<A>
 - x_2: size of x wrt. A
 - y_1: size of y wrt. List<A>
 - y_2: size of y wrt. A
UB for f2p(x_1,x_2,y_1,y_2) = max([9*y_1+17,7*x_1+7*y_1])+2

Method g3 terminates?: YES

 - c_1: size of c wrt. List<A>
 - c_2: size of c wrt. A
 - d_1: size of d wrt. List<A>
 - d_2: size of d wrt. A
UB for g3(c_1,c_2,d_1,d_2) = nat(c_2-d_2)*5+5*c_1+2

Method f3 terminates?: YES

 - a_1: size of a wrt. List<A>
 - a_2: size of a wrt. A
 - b_1: size of b wrt. List<A>
 - b_2: size of b wrt. A
UB for f3(a_1,a_2,b_1,b_2) = max([5*a_1+5*a_2,5*a_1+5*a_2+10*b_1+5*b_2+nat(-a_2+b_2)*5])+6
