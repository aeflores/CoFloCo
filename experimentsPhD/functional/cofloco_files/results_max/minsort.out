
Abs program loaded in 15 ms.

Rule based representation generated in 1 ms.

Rule based representation stored in /tmp/costabs/rbr.rbr

RBR properties stored in /tmp/costabs/rbr.properties

Class invariants generated and loaded in 0 ms.

Abstract compilation performed in 5 ms.

Cost relation system stored in /tmp/costabs/crs.crs

Generated 32 equations 
entry('findMin'(A,B,C,D):[]).
entry('minSort'(A,B,C,D):[]).
input_output_vars('and_op'(A,B,C),[A,B],[C]).
input_output_vars('case_0'(A,B,C,D),[A,B],[C,D]).
input_output_vars('case_1'(A,B,C,D,E,F,G,H,I),[A,B,C,D,E,F,G],[H,I]).
input_output_vars('case_2'(A,B,C,D,E,F,G,H,I,J),[A,B,C,D,E,F,G,H],[I,J]).
input_output_vars('case_3'(A,B,C,D,E,F),[A,B,C,D],[E,F]).
input_output_vars('eq'(A,B,C),[A,B],[C]).
input_output_vars('findMin'(A,B,C,D),[A,B],[C,D]).
input_output_vars('geq'(A,B,C),[A,B],[C]).
input_output_vars('gt'(A,B,C),[A,B],[C]).
input_output_vars('leq'(A,B,C),[A,B],[C]).
input_output_vars('lt'(A,B,C),[A,B],[C]).
input_output_vars('maxNorm'(A,B,C),[A,B],[C]).
input_output_vars('minSort'(A,B,C,D),[A,B],[C,D]).
input_output_vars('neg'(A,B),[A],[B]).
input_output_vars('neq'(A,B,C),[A,B],[C]).
input_output_vars('or'(A,B,C),[A,B],[C]).
eq('eq',[A,B,C],0,[],[A=B,C=1,A>=0,B>=0,C>=0]).
eq('eq',[A,B,C],0,[],[A>=B+1,C=0,A>=0,B>=0,C>=0]).
eq('eq',[A,B,C],0,[],[B>=A+1,C=0,A>=0,B>=0,C>=0]).
eq('neq',[A,B,C],0,[],[A=B,C=0,A>=0,B>=0,C>=0]).
eq('neq',[A,B,C],0,[],[A>=B+1,C=1,A>=0,B>=0,C>=0]).
eq('neq',[A,B,C],0,[],[B>=A+1,C=1,A>=0,B>=0,C>=0]).
eq('lt',[A,B,C],0,[],[B-A>=1,C=1,A>=0,B>=0,C>=0]).
eq('lt',[A,B,C],0,[],[B=<A,C=0,A>=0,B>=0,C>=0]).
eq('leq',[A,B,C],0,[],[A=<B,C=1,A>=0,B>=0,C>=0]).
eq('leq',[A,B,C],0,[],[A-B>=1,C=0,A>=0,B>=0,C>=0]).
eq('gt',[A,B,C],0,[],[A-B>=1,C=1,A>=0,B>=0,C>=0]).
eq('gt',[A,B,C],0,[],[A=<B,C=0,A>=0,B>=0,C>=0]).
eq('geq',[A,B,C],0,[],[B=<A,C=1,A>=0,B>=0,C>=0]).
eq('geq',[A,B,C],0,[],[B-A>=1,C=0,A>=0,B>=0,C>=0]).
eq('neg',[A,B],0,[],[A=0,B=1,A>=0,B>=0]).
eq('neg',[A,B],0,[],[A=1,B=0,A>=0,B>=0]).
eq('and_op',[A,B,C],0,[],[A=0,C=0,A>=0,B>=0,C>=0]).
eq('and_op',[A,B,C],0,[],[A=1,C=B,A>=0,B>=0,C>=0]).
eq('or',[A,B,C],0,[],[A=1,C=1,A>=0,B>=0,C>=0]).
eq('or',[A,B,C],0,[],[A=0,C=B,A>=0,B>=0,C>=0]).
eq('maxNorm',[A,B,A],0,[],[A>=1+B,A>=0,B>=0,A>=0]).
eq('maxNorm',[A,B,B],0,[],[A=<B,A>=0,B>=0,B>=0]).
eq('case_0',[A,B,C,D],2,[],[A=1,C=1,A>=0,B>=0,C>=0,D>=0]).
eq('case_1',[A,B,C,D,E,F,G,H,I],3,[],[A=1,J=1,I>=E,I>=K,H=J+1,J>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0]).
eq('case_2',[A,B,C,D,E,F,G,H,I,J],3,[],[F>=C+1,K>=F,K>=H,L=G+1,G>=1,J>=C,J>=K,I=L+1,L>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0]).
eq('case_2',[A,B,C,D,E,F,G,H,I,J],3,[],[C>=F,K>=C,K>=H,L=G+1,G>=1,J>=F,J>=K,I=L+1,L>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0]).
eq('case_1',[A,B,C,D,E,F,G,H,I],3,['case_2'(C,D,E,F,G,J,K,L,H,I)],[B>=J,B>=L,A=K+1,K>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0]).
eq('case_0',[A,B,C,D],4,['findMin'(E,F,G,H),'case_1'(G,H,A,B,I,E,F,C,D)],[B>=I,B>=F,A=E+1,E>=1,A>=0,B>=0,C>=0,D>=0]).
eq('findMin',[A,B,C,D],1,['case_0'(A,B,C,D)],[A>=0,B>=0,C>=0,D>=0]).
eq('case_3',[A,B,C,D,E,F],2,[],[A=1,E=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0]).
eq('case_3',[A,B,C,D,E,F],4,['minSort'(G,H,I,J)],[B>=K,B>=H,A=G+1,G>=1,F>=K,F>=J,E=I+1,I>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0]).
eq('minSort',[A,B,C,D],2,['findMin'(A,B,E,F),'case_3'(E,F,A,B,C,D)],[A>=0,B>=0,C>=0,D>=0]).

Preprocessing Cost Relations
=====================================

#### Computed strongly connected components 
0. non_recursive  : [case_2/10]
1. non_recursive  : [case_1/9]
2. recursive [non_tail] : [case_0/4,findMin/4]
3. recursive  : [case_3/6,minSort/4]
Warning: the following predicates are never called:[and_op/3,eq/3,geq/3,gt/3,leq/3,lt/3,maxNorm/3,neg/2,neq/3,or/3]

#### Obtained direct recursion through partial evaluation 
0. SCC is partially evaluated into case_2/10
1. SCC is partially evaluated into case_1/9
2. SCC is partially evaluated into findMin/4
3. SCC is partially evaluated into minSort/4

Control-Flow Refinement of Cost Relations
=====================================

### Specialization of cost equations case_2/10 
* CE 8 is refined into CE [9] 
* CE 7 is refined into CE [10] 


#### Refined cost equations case_2/10 
* CE 9: case_2(A,B,C,D,E,F,G,H,I,J) = 3
     [J>=H,C>=F,B>=E,J>=C,B>=C,H>=0,G>=1,F>=0,E>=0,D>=1,G+2=I,D+1=A] 
* CE 10: case_2(A,B,C,D,E,F,G,H,I,J) = 3
     [J>=H,J>=F,B>=E,F>=C+1,B>=C,H>=0,G>=1,E>=0,D>=1,C>=0,G+2=I,D+1=A] 

### Cost equations --> "Loop" of case_2/10 
* CEs [9] --> Loop 9 
* CEs [10] --> Loop 10 

#### Loops of case_2/10 
* Loop 9: case_2(A,B,C,D,E,F,G,H,I,J) [J>=H,C>=F,B>=E,J>=C,B>=C,H>=0,G>=1,F>=0,E>=0,A>=2,G+2=I,A=D+1] 
* Loop 10: case_2(A,B,C,D,E,F,G,H,I,J) [J>=H,J>=F,B>=E,F>=C+1,B>=C,H>=0,G>=1,E>=0,C>=0,A>=2,G+2=I,A=D+1] 

### Ranking functions of CR case_2(A,B,C,D,E,F,G,H,I,J) 

#### Partial ranking functions of CR case_2(A,B,C,D,E,F,G,H,I,J) 


### Resulting Chains:case_2(A,B,C,D,E,F,G,H,I,J) 
* [10]
* [9]


### Merging Chains  case_2/10 into  External patterns of execution 
* [[10]] --> 1 
* [[9]] --> 2 


### Specialization of cost equations case_1/9 
* CE 6 is refined into CE [11,12] 
* CE 5 is refined into CE [13] 


#### Refined cost equations case_1/9 
* CE 11: case_1(A,B,C,D,E,F,G,H,I) = 3+ case_2(J,D,E,F,G,K,L,M,H,I):1
     [I>=M,B>=M,I>=K,B>=K,D>=G,K>=E+1,D>=E,H>=3,M>=0,G>=0,F>=1,E>=0,H=L+2,F+1=J,F+1=C,H=A+1] 
* CE 12: case_1(A,B,C,D,E,F,G,H,I) = 3+ case_2(J,D,E,F,G,K,L,M,H,I):2
     [I>=M,B>=M,E>=K,B>=K,D>=G,I>=E,D>=E,H>=3,M>=0,K>=0,G>=0,F>=1,H=L+2,F+1=J,F+1=C,H=A+1] 
* CE 13: case_1(A,B,C,D,E,F,G,H,I) = 3
     [D>=G,I>=E,D>=E,G>=0,F>=1,E>=0,B>=0,F+1=C,H=2,A=1] 

### Cost equations --> "Loop" of case_1/9 
* CEs [11,12] --> Loop 11 
* CEs [13] --> Loop 12 

#### Loops of case_1/9 
* Loop 11: case_1(A,B,C,D,E,F,G,H,I) [D>=G,I>=E,D>=E,G>=0,E>=0,C>=2,B>=0,A>=2,A+1=H,C=F+1] 
* Loop 12: case_1(A,B,C,D,E,F,G,H,I) [D>=G,I>=E,D>=E,G>=0,E>=0,C>=2,B>=0,C=F+1,H=2,A=1] 

### Ranking functions of CR case_1(A,B,C,D,E,F,G,H,I) 

#### Partial ranking functions of CR case_1(A,B,C,D,E,F,G,H,I) 


### Resulting Chains:case_1(A,B,C,D,E,F,G,H,I) 
* [12]
* [11]


### Merging Chains  case_1/9 into  External patterns of execution 
* [[12]] --> 1 
* [[11]] --> 2 


### Specialization of cost equations findMin/4 
* CE 2 is refined into CE [14] 
* CE 1 is refined into CE [15,16] 


#### Refined cost equations findMin/4 
* CE 14: findMin(A,B,C,D) = 3
     [D>=0,B>=0,C=1,A=1] 
* CE 15: findMin(A,B,C,D) = 5+ findMin(E,F,G,H)+ case_1(I,H,J,B,K,E,F,L,D):1
     [B>=F,D>=K,B>=K,F>=0,E>=1,K>=0,H>=0,E+1=J,E+1=A,G=1,L=2,I=1,C=2] 
* CE 16: findMin(A,B,C,D) = 5+ findMin(E,F,G,H)+ case_1(I,H,J,B,K,E,F,C,D):2
     [B>=F,D>=K,B>=K,C>=3,F>=0,E>=1,K>=0,H>=0,C=G+1,E+1=J,C=I+1,E+1=A] 

### Cost equations --> "Loop" of findMin/4 
* CEs [16] --> Loop 13 
* CEs [15] --> Loop 14 
* CEs [14] --> Loop 15 

#### Loops of findMin/4 
* Loop 13: findMin(A,B,C,D)->  findMin(A',B',C',D')
                  [B>=B',D'>=0,B'>=0,D>=0,C>=3,A>=2,C=C'+1,A=A'+1] 
* Loop 14: findMin(A,B,C,D)->  findMin(A',B',C',D')
                  [B>=B',D'>=0,B'>=0,D>=0,A>=2,A=A'+1,C'=1,C=2] 
* Loop 15: findMin(A,B,C,D) [D>=0,B>=0,C=1,A=1] 

### Ranking functions of CR findMin(A,B,C,D) 
* RF of phase [13]: [A-1]

#### Partial ranking functions of CR findMin(A,B,C,D) 
* Partial RF of phase [13]:
  - RF of loop [13:1]:
    A-1

Discarded unfeasible chain [[13]]...(Non-terminating chain proved terminating)

### Resulting Chains:findMin(A,B,C,D) 
* [[13],14,15]
* [15]
* [14,15]


### Merging Chains  findMin/4 into  External patterns of execution 
* [[15]] --> 1 
* [[15,14]] --> 2 
* [[15,14,[13]]] --> 3 


### Specialization of cost equations minSort/4 
* CE 4 is refined into CE [17] 
* CE 3 is refined into CE [18,19] 


#### Refined cost equations minSort/4 
* CE 17: minSort(A,B,C,D) = 4+ findMin(E,B,F,G):1
     [G>=0,B>=0,D>=0,F=1,E=1,C=1,A=1] 
* CE 18: minSort(A,B,C,D) = 6+ findMin(E,B,F,G):2+ minSort(H,I,J,K)
     [D>=K,G>=I,J>=1,G>=0,B>=0,D>=0,J+1=C,H=1,F=2,E=2,A=2] 
* CE 19: minSort(A,B,C,D) = 6+ findMin(A,B,A,E):3+ minSort(F,G,H,I)
     [D>=I,E>=G,H>=1,E>=0,A>=3,B>=0,D>=0,A=F+1,H+1=C] 

### Cost equations --> "Loop" of minSort/4 
* CEs [19] --> Loop 16 
* CEs [18] --> Loop 17 
* CEs [17] --> Loop 18 

#### Loops of minSort/4 
* Loop 16: minSort(A,B,C,D)->  minSort(A',B',C',D')
                  [D>=D',D>=0,C>=2,B>=0,A>=3,C=C'+1,A=A'+1] 
* Loop 17: minSort(A,B,C,D)->  minSort(A',B',C',D')
                  [D>=D',D>=0,C>=2,B>=0,C=C'+1,A'=1,A=2] 
* Loop 18: minSort(A,B,C,D) [D>=0,B>=0,C=1,A=1] 

### Ranking functions of CR minSort(A,B,C,D) 
* RF of phase [16]: [A-2]

#### Partial ranking functions of CR minSort(A,B,C,D) 
* Partial RF of phase [16]:
  - RF of loop [16:1]:
    A-2

Discarded unfeasible chain [[16]]...(Non-terminating chain proved terminating)

### Resulting Chains:minSort(A,B,C,D) 
* [[16],17,18]
* [18]
* [17,18]


### Merging Chains  minSort/4 into  External patterns of execution 
* [[18]] --> 1 
* [[18,17]] --> 2 
* [[18,17,[16]]] --> 3 


Computing Bounds
=====================================

#### Simplifying cost structure of CE 10 

#### Simplifying cost structure of CE 9 

#### Cost of chains of case_2(A,B,C,D,E,F,G,H,I,J):
* Chain [10]: 3
  with precondition: [D+1=A,G+2=I,C>=0,D>=1,E>=0,G>=1,H>=0,B>=C,F>=C+1,B>=E,J>=F,J>=H] 

* Chain [9]: 3
  with precondition: [D+1=A,G+2=I,D>=1,E>=0,F>=0,G>=1,H>=0,B>=C,J>=C,B>=E,C>=F,J>=H] 


#### Simplifying cost structure of CE 13 

#### Simplifying cost structure of CE 11 

#### Simplifying cost structure of CE 12 

#### Cost of chains of case_1(A,B,C,D,E,F,G,H,I):
* Chain [12]: 3
  with precondition: [A=1,H=2,F+1=C,B>=0,E>=0,F>=1,G>=0,D>=E,I>=E,D>=G] 

* Chain [11]: 6
  with precondition: [H=A+1,F+1=C,B>=0,E>=0,F>=1,G>=0,H>=3,D>=E,I>=E,D>=G] 


#### Simplifying cost structure of CE 14 

#### Simplifying cost structure of CE 15 

#### Simplifying cost structure of chain [14,15] 

#### Computing cost of phase [13] 

#### Simplifying cost structure of CE 16 

#### Cost of loops [13] 

 * loop 13:findMin(A,B,C,D) -> [findMin(A',B',C',D')] 
11
##### Pending set findMin(A,B,C,D)
* Psum in Loop 13: [it(13)=<1]

###### Computing sum for it(13)=<1  in Loop 13 
   - Applying inductive sum strategy 
     - head Candidate: A-1 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(13)=<A-1,it(13)=<A-1,it(13)=<A-A',it(13)=<A-A'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [13] 

#### Simplifying cost structure of phase [13] 

#### Cost of phase [13]:findMin(A,B,C,D) -> [findMin(A',B',C',D')] 
11*it(13)+0
  Such that:it(13) =< A
it(13) =< A-A'

#### Simplifying cost structure of chain [[13],14,15] 

#### Cost of chains of findMin(A,B,C,D):
* Chain [[13],14,15]: 11*it(13)+11
  Such that:it(13) =< C

  with precondition: [A=C,A>=3,B>=0,D>=0] 

* Chain [15]: 3
  with precondition: [A=1,C=1,B>=0,D>=0] 

* Chain [14,15]: 11
  with precondition: [A=2,C=2,B>=0,D>=0] 


#### Simplifying cost structure of CE 17 

#### Simplifying cost structure of CE 18 

#### Simplifying cost structure of chain [17,18] 

#### Computing cost of phase [16] 
 * Renamed intermediate variables: 
[ (eq(19,1),it(13))>>s(1)]

#### Simplifying cost structure of CE 19 
 * Renamed intermediate variables: 
[ (it(16),s(1))>>s(2)]

#### Cost of loops [16] 

 * loop 16:minSort(A,B,C,D) -> [minSort(A',B',C',D')] 
11*s(2)+17
  Such that:s(2) =< A'+1

##### Pending set minSort(A,B,C,D)
* Psum in Loop 16: [it(16)=<1,s(3)=<A'+1]

###### Computing sum for it(16)=<1  in Loop 16 
   - Applying inductive sum strategy 
     - head Candidate: A-2 
     - head Candidate: A-2 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-2 
     - tail Candidate: A-2 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(16)=<A-2,it(16)=<A-2,it(16)=<A-A',it(16)=<A-A'] 

##### Pending set A
* Psum in Loop 16: [s(3)=<A'+1]

###### Computing sum for s(3)=<A'+1  in Loop 16 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(1)=<A] 
 * Adding constraints: [s(3)=<it(16)*aux(1)] 

##### Pending set minSort(A,B,C,D)
* Pmax/min: [aux(1)=<A]

###### Computing max_min for aux(1)=<A  
   - Found a solution using transitive invariants 
 * Adding constraints:[aux(1)=<A] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [16] 

#### Simplifying cost structure of phase [16] 
 * Joined equivalent variables [aux(2),aux(1)] into aux(2)

#### Cost of phase [16]:minSort(A,B,C,D) -> [minSort(A',B',C',D')] 
17*it(16)+11*s(3)+0
  Such that:it(16) =< A-A'
aux(2) =< A
it(16) =< aux(2)
s(3) =< it(16)*aux(2)

#### Simplifying cost structure of chain [[16],17,18] 
 * Joined equivalent variables [aux(3),aux(2)] into aux(3)

#### Cost of chains of minSort(A,B,C,D):
* Chain [[16],17,18]: 17*it(16)+11*s(3)+24
  Such that:aux(3) =< A
it(16) =< aux(3)
s(3) =< it(16)*aux(3)

  with precondition: [A=C,A>=3,B>=0,D>=0] 

* Chain [18]: 7
  with precondition: [A=1,C=1,B>=0,D>=0] 

* Chain [17,18]: 24
  with precondition: [A=2,C=2,B>=0,D>=0] 


Closed-form bounds of findMin(A,B,C,D): 
-------------------------------------
* Chain [[13],14,15] with precondition: [A=C,A>=3,B>=0,D>=0] 
    - Upper bound: 11*A+11 
    - Complexity: n 
* Chain [15] with precondition: [A=1,C=1,B>=0,D>=0] 
    - Upper bound: 3 
    - Complexity: constant 
* Chain [14,15] with precondition: [A=2,C=2,B>=0,D>=0] 
    - Upper bound: 11 
    - Complexity: constant 

### Maximum cost of findMin(A,B,C,D): 11*A+11 
Asymptotic class: n 

Closed-form bounds of minSort(A,B,C,D): 
-------------------------------------
* Chain [[16],17,18] with precondition: [A=C,A>=3,B>=0,D>=0] 
    - Upper bound: 17*A+24+11*A*A 
    - Complexity: n^2 
* Chain [18] with precondition: [A=1,C=1,B>=0,D>=0] 
    - Upper bound: 7 
    - Complexity: constant 
* Chain [17,18] with precondition: [A=2,C=2,B>=0,D>=0] 
    - Upper bound: 24 
    - Complexity: constant 

### Maximum cost of minSort(A,B,C,D): max([17,17*A+17+11*A*A])+7 
Asymptotic class: n^2 
* Total analysis performed in 209 ms.


Cost relation system solved by CoFloCo in 210 ms.

Method findMin terminates?: YES

 - l_1: size of l wrt. List<Rat>
 - l_2: size of l wrt. Rat
UB for findMin(l_1,l_2) = 11*l_1+11

Method minSort terminates?: YES

 - l_1: size of l wrt. List<Rat>
 - l_2: size of l wrt. Rat
UB for minSort(l_1,l_2) = max([17,17*l_1+17+11*l_1*l_1])+7
