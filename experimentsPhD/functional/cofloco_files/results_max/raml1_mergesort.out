
Abs program loaded in 18 ms.

Rule based representation generated in 6 ms.

Rule based representation stored in /tmp/costabs/rbr.rbr

RBR properties stored in /tmp/costabs/rbr.properties

Class invariants generated and loaded in 0 ms.

Abstract compilation performed in 43 ms.

Cost relation system stored in /tmp/costabs/crs.crs

Generated 45 equations 
entry('msplit'(A,B,C,D,E):[]).
entry('merge'(A,B,C,D,E,F):[]).
entry('mergesortBuggy'(A,B,C,D):[]).
entry('mergesort'(A,B,C,D):[]).
input_output_vars('and_op'(A,B,C),[A,B],[C]).
input_output_vars('case_0'(A,B,C,D,E),[A,B],[C,D,E]).
input_output_vars('case_1'(A,B,C,D,E,F,G,H),[A,B,C,D,E],[F,G,H]).
input_output_vars('case_10'(A,B,C,D,E,F,G,H,I,J,K,L,M),[A,B,C,D,E,F,G,H,I,J,K],[L,M]).
input_output_vars('case_2'(A,B,C,D,E,F,G,H,I,J,K,L,M,N),[A,B,C,D,E,F,G,H,I,J,K],[L,M,N]).
input_output_vars('case_3'(A,B,C,D,E,F),[A,B,C,D],[E,F]).
input_output_vars('case_4'(A,B,C,D,E,F,G,H,I),[A,B,C,D,E,F,G],[H,I]).
input_output_vars('case_5'(A,B,C,D,E,F,G,H,I,J,K,L),[A,B,C,D,E,F,G,H,I,J],[K,L]).
input_output_vars('case_6'(A,B,C,D),[A,B],[C,D]).
input_output_vars('case_7'(A,B,C,D,E,F,G,H,I,J),[A,B,C,D,E,F,G,H],[I,J]).
input_output_vars('case_8'(A,B,C,D),[A,B],[C,D]).
input_output_vars('case_9'(A,B,C,D,E,F,G),[A,B,C,D,E],[F,G]).
input_output_vars('eq'(A,B,C),[A,B],[C]).
input_output_vars('geq'(A,B,C),[A,B],[C]).
input_output_vars('gt'(A,B,C),[A,B],[C]).
input_output_vars('leq'(A,B,C),[A,B],[C]).
input_output_vars('lt'(A,B,C),[A,B],[C]).
input_output_vars('maxNorm'(A,B,C),[A,B],[C]).
input_output_vars('merge'(A,B,C,D,E,F),[A,B,C,D],[E,F]).
input_output_vars('mergesort'(A,B,C,D),[A,B],[C,D]).
input_output_vars('mergesortBuggy'(A,B,C,D),[A,B],[C,D]).
input_output_vars('msplit'(A,B,C,D,E),[A,B],[C,D,E]).
input_output_vars('neg'(A,B),[A],[B]).
input_output_vars('neq'(A,B,C),[A,B],[C]).
input_output_vars('or'(A,B,C),[A,B],[C]).
eq('eq',[A,B,C],0,[],[A=B,C=1,A>=0,B>=0,C>=0]).
eq('eq',[A,B,C],0,[],[A>=B+1,C=0,A>=0,B>=0,C>=0]).
eq('eq',[A,B,C],0,[],[B>=A+1,C=0,A>=0,B>=0,C>=0]).
eq('neq',[A,B,C],0,[],[A=B,C=0,A>=0,B>=0,C>=0]).
eq('neq',[A,B,C],0,[],[A>=B+1,C=1,A>=0,B>=0,C>=0]).
eq('neq',[A,B,C],0,[],[B>=A+1,C=1,A>=0,B>=0,C>=0]).
eq('lt',[A,B,C],0,[],[B-A>=1,C=1,A>=0,B>=0,C>=0]).
eq('lt',[A,B,C],0,[],[B=<A,C=0,A>=0,B>=0,C>=0]).
eq('leq',[A,B,C],0,[],[A=<B,C=1,A>=0,B>=0,C>=0]).
eq('leq',[A,B,C],0,[],[A-B>=1,C=0,A>=0,B>=0,C>=0]).
eq('gt',[A,B,C],0,[],[A-B>=1,C=1,A>=0,B>=0,C>=0]).
eq('gt',[A,B,C],0,[],[A=<B,C=0,A>=0,B>=0,C>=0]).
eq('geq',[A,B,C],0,[],[B=<A,C=1,A>=0,B>=0,C>=0]).
eq('geq',[A,B,C],0,[],[B-A>=1,C=0,A>=0,B>=0,C>=0]).
eq('neg',[A,B],0,[],[A=0,B=1,A>=0,B>=0]).
eq('neg',[A,B],0,[],[A=1,B=0,A>=0,B>=0]).
eq('and_op',[A,B,C],0,[],[A=0,C=0,A>=0,B>=0,C>=0]).
eq('and_op',[A,B,C],0,[],[A=1,C=B,A>=0,B>=0,C>=0]).
eq('or',[A,B,C],0,[],[A=1,C=1,A>=0,B>=0,C>=0]).
eq('or',[A,B,C],0,[],[A=0,C=B,A>=0,B>=0,C>=0]).
eq('maxNorm',[A,B,A],0,[],[A>=1+B,A>=0,B>=0,A>=0]).
eq('maxNorm',[A,B,B],0,[],[A=<B,A>=0,B>=0,B>=0]).
eq('case_0',[A,B,C,D,E],4,['maxNorm'(F,G,D)],[A=1,F=1,G=1,E>=H,E>=I,C=1,G>=1,F>=1,A>=0,B>=0,C>=0,D>=0,E>=0]).
eq('case_1',[A,B,C,D,E,F,G,H],5,['maxNorm'(I,J,G)],[D=1,K=1,L>=C,L>=M,I=K+1,K>=1,J=1,H>=L,H>=N,F=1,J>=1,I>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0]).
eq('case_2',[A,B,C,D,E,F,G,H,I,J,K,L,M,N],4,['maxNorm'(O,P,M)],[C>=Q,C>=R,B>=S,B>=T,A=1,T>=1,S>=1,U>=F,U>=Q,O=S+1,S>=1,V>=I,V>=R,P=T+1,T>=1,N>=U,N>=V,L=1,P>=1,O>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0,M>=0,N>=0]).
eq('case_1',[A,B,C,D,E,F,G,H],6,['msplit'(I,J,K,L,M),'case_2'(N,O,P,A,B,C,D,E,Q,I,J,R,S,T)],[E>=Q,E>=J,D=I+1,I>=1,P=M,O=L,N=K,K>=1,H=T,G=S,F=R,R>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0]).
eq('case_0',[A,B,C,D,E],3,['case_1'(A,B,F,G,H,C,D,E)],[B>=F,B>=H,A=G+1,G>=1,A>=0,B>=0,C>=0,D>=0,E>=0]).
eq('msplit',[A,B,C,D,E],1,['case_0'(A,B,C,D,E)],[A>=0,B>=0,C>=0,D>=0,E>=0]).
eq('case_3',[A,B,C,D,C,D],1,[],[A=1,A>=0,B>=0,C>=0,D>=0,C>=0,D>=0]).
eq('case_4',[A,B,C,D,E,F,G,H,I],2,[],[C=1,I>=E,I>=G,H=F+1,F>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0]).
eq('case_5',[A,B,C,D,E,F,G,H,I,J,K,L],4,['merge'(F,G,M,N,O,P)],[H>=E+1,N>=H,N>=J,M=I+1,I>=1,L>=E,L>=P,K=O+1,O>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0]).
eq('case_5',[A,B,C,D,E,F,G,H,I,J,K,L],4,['merge'(M,N,I,J,O,P)],[E>=H,N>=E,N>=G,M=F+1,F>=1,L>=H,L>=P,K=O+1,O>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0]).
eq('case_4',[A,B,C,D,E,F,G,H,I],3,['case_5'(A,B,C,D,E,F,G,J,K,L,H,I)],[D>=J,D>=L,C=K+1,K>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0]).
eq('case_3',[A,B,C,D,E,F],3,['case_4'(A,B,C,D,G,H,I,E,F)],[B>=G,B>=I,A=H+1,H>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0]).
eq('merge',[A,B,C,D,E,F],1,['case_3'(A,B,C,D,E,F)],[A>=0,B>=0,C>=0,D>=0,E>=0,F>=0]).
eq('case_6',[A,B,C,D],2,[],[A=1,C=1,A>=0,B>=0,C>=0,D>=0]).
eq('case_7',[A,B,C,D,E,F,G,H,I,J],4,['mergesortBuggy'(K,L,M,N),'mergesortBuggy'(O,P,Q,R),'merge'(M,N,Q,R,I,J)],[C>=L,C>=P,B>=K,B>=O,A=1,O>=1,K>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0]).
eq('case_6',[A,B,C,D],6,['msplit'(A,B,E,F,G),'case_7'(H,I,J,A,B,K,L,M,N,O)],[B>=K,B>=M,A=L+1,L>=1,J=G,I=F,H=E,E>=1,D=O,C=N,N>=1,A>=0,B>=0,C>=0,D>=0]).
eq('mergesortBuggy',[A,B,C,D],1,['case_6'(A,B,C,D)],[A>=0,B>=0,C>=0,D>=0]).
eq('case_8',[A,B,C,D],2,[],[A=1,C=1,A>=0,B>=0,C>=0,D>=0]).
eq('case_9',[A,B,C,D,E,F,G],2,[],[D=1,G>=C,G>=E,F=D+1,D>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0]).
eq('case_10',[A,B,C,D,E,F,G,H,I,J,K,L,M],4,['mergesort'(N,O,P,Q),'mergesort'(R,S,T,U),'merge'(P,Q,T,U,L,M)],[C>=O,C>=S,B>=N,B>=R,A=1,R>=1,N>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0,M>=0]).
eq('case_9',[A,B,C,D,E,F,G],8,['msplit'(H,I,J,K,L),'case_10'(M,N,O,A,B,C,D,E,P,Q,R,S,T)],[E>=P,E>=R,D=Q+1,Q>=1,U>=P,U>=R,V=Q+1,Q>=1,I>=C,I>=U,H=V+1,V>=1,O=L,N=K,M=J,J>=1,G=T,F=S,S>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0]).
eq('case_8',[A,B,C,D],3,['case_9'(A,B,E,F,G,C,D)],[B>=E,B>=G,A=F+1,F>=1,A>=0,B>=0,C>=0,D>=0]).
eq('mergesort',[A,B,C,D],1,['case_8'(A,B,C,D)],[A>=0,B>=0,C>=0,D>=0]).

Preprocessing Cost Relations
=====================================

#### Computed strongly connected components 
0. recursive  : [case_3/6,case_4/9,case_5/12,merge/6]
1. non_recursive  : [maxNorm/3]
2. non_recursive  : [case_2/14]
3. recursive [non_tail] : [case_0/5,case_1/8,msplit/5]
4. recursive [non_tail,multiple] : [case_10/13,case_8/4,case_9/7,mergesort/4]
5. recursive [non_tail,multiple] : [case_6/4,case_7/10,mergesortBuggy/4]
Warning: the following predicates are never called:[and_op/3,eq/3,geq/3,gt/3,leq/3,lt/3,neg/2,neq/3,or/3]

#### Obtained direct recursion through partial evaluation 
0. SCC is partially evaluated into merge/6
1. SCC is partially evaluated into maxNorm/3
2. SCC is completely evaluated into other SCCs
3. SCC is partially evaluated into msplit/5
4. SCC is partially evaluated into mergesort/4
5. SCC is partially evaluated into mergesortBuggy/4

Control-Flow Refinement of Cost Relations
=====================================

### Specialization of cost equations merge/6 
* CE 4 is refined into CE [15] 
* CE 7 is refined into CE [16] 
* CE 6 is refined into CE [17] 
* CE 5 is refined into CE [18] 


#### Refined cost equations merge/6 
* CE 15: merge(A,B,C,D,A,E) = 6
     [E>=0,D>=0,B>=0,A>=2,C=1] 
* CE 16: merge(A,B,C,D,C,D) = 2
     [D>=0,C>=0,B>=0,A=1] 
* CE 17: merge(A,B,C,D,E,F) = 11+ merge(A,G,H,I,J,K)
     [F>=K,D>=I,J>=1,I>=0,H>=1,G>=0,F>=0,B>=0,A>=2,J+1=E,H+1=C] 
* CE 18: merge(A,B,C,D,E,F) = 11+ merge(G,H,C,I,J,K)
     [F>=K,B>=H,J>=1,I>=1,H>=0,G>=1,F>=0,D>=1,C>=2,J+1=E,G+1=A] 

### Cost equations --> "Loop" of merge/6 
* CEs [17] --> Loop 15 
* CEs [18] --> Loop 16 
* CEs [15] --> Loop 17 
* CEs [16] --> Loop 18 

#### Loops of merge/6 
* Loop 15: merge(A,B,C,D,E,F)->  merge(A,A',B',C',D',E')
                  [F>=E',D>=C',C'>=0,A'>=0,F>=0,E>=2,C>=2,B>=0,A>=2,E=D'+1,C=B'+1] 
* Loop 16: merge(A,B,C,D,E,F)->  merge(A',B',C,C',D',E')
                  [F>=E',B>=B',C'>=1,B'>=0,F>=0,E>=2,D>=1,C>=2,A>=2,E=D'+1,A=A'+1] 
* Loop 17: merge(A,B,C,D,A,E) [E>=0,D>=0,B>=0,A>=2,C=1] 
* Loop 18: merge(A,B,C,D,C,D) [D>=0,C>=0,B>=0,A=1] 

### Ranking functions of CR merge(A,B,C,D,E,F) 
* RF of phase [15,16]: [A+C-3]

#### Partial ranking functions of CR merge(A,B,C,D,E,F) 
* Partial RF of phase [15,16]:
  - RF of loop [15:1]:
    C-1
  - RF of loop [16:1]:
    A-1

Discarded unfeasible chain [[15,16]]...(Non-terminating chain proved terminating)

### Resulting Chains:merge(A,B,C,D,E,F) 
* [[15,16],18]
* [[15,16],17]
* [18]
* [17]


### Merging Chains  merge/6 into  External patterns of execution 
* [[18]] --> 1 
* [[17]] --> 2 
* [[17,[15,16]],[18,[15,16]]] --> 3 


### Specialization of cost equations maxNorm/3 
* CE 14 is refined into CE [19] 
* CE 13 is refined into CE [20] 


#### Refined cost equations maxNorm/3 
* CE 19: maxNorm(A,B,B) = 0
     [B>=A,A>=1] 
* CE 20: maxNorm(A,B,A) = 0
     [A>=B+1,B>=1] 

### Cost equations --> "Loop" of maxNorm/3 
* CEs [19] --> Loop 19 
* CEs [20] --> Loop 20 

#### Loops of maxNorm/3 
* Loop 19: maxNorm(A,B,B) [B>=A,A>=1] 
* Loop 20: maxNorm(A,B,A) [A>=B+1,B>=1] 

### Ranking functions of CR maxNorm(A,B,C) 

#### Partial ranking functions of CR maxNorm(A,B,C) 


### Resulting Chains:maxNorm(A,B,C) 
* [20]
* [19]


### Merging Chains  maxNorm/3 into  External patterns of execution 
* [[20]] --> 1 
* [[19]] --> 2 


### Specialization of cost equations msplit/5 
* CE 3 is refined into CE [21,22] 
* CE 2 is refined into CE [23] 
* CE 1 is refined into CE [24] 


#### Refined cost equations msplit/5 
* CE 21: msplit(A,B,C,D,E) = 14+ msplit(F,G,H,I,J)+ maxNorm(D,K,D):1
     [B>=G,I+1>=D,D>=K+1,J>=0,G>=0,K>=2,E>=0,A>=3,A=F+2,H=1,C=1] 
* CE 22: msplit(A,B,C,D,E) = 14+ msplit(F,G,H,I,J)+ maxNorm(K,D,D):2
     [B>=G,I+1>=D,D>=K,J>=0,G>=0,K>=2,E>=0,A>=3,A=F+2,H=1,C=1] 
* CE 23: msplit(A,B,C,D,E) = 9+ maxNorm(F,G,H):1
     [E>=0,B>=0,H=2,G=1,F=2,D=2,C=1,A=2] 
* CE 24: msplit(A,B,C,D,E) = 5+ maxNorm(F,G,H):2
     [E>=0,B>=0,H=1,G=1,F=1,D=1,C=1,A=1] 

### Cost equations --> "Loop" of msplit/5 
* CEs [23] --> Loop 21 
* CEs [24] --> Loop 22 
* CEs [21,22] --> Loop 23 

#### Loops of msplit/5 
* Loop 21: msplit(A,B,C,D,E) [E>=0,B>=0,D=2,C=1,A=2] 
* Loop 22: msplit(A,B,C,D,E) [E>=0,B>=0,D=1,C=1,A=1] 
* Loop 23: msplit(A,B,C,D,E)->  msplit(A',B',C',D',E')
                  [B>=B',D'+1>=D,E'>=0,B'>=0,E>=0,D>=2,A>=3,A=A'+2,C'=1,C=1] 

### Ranking functions of CR msplit(A,B,C,D,E) 
* RF of phase [23]: [A/2-1]

#### Partial ranking functions of CR msplit(A,B,C,D,E) 
* Partial RF of phase [23]:
  - RF of loop [23:1]:
    A/2-1

Discarded unfeasible chain [[23]]...(Non-terminating chain proved terminating)

### Resulting Chains:msplit(A,B,C,D,E) 
* [[23],22]
* [[23],21]
* [22]
* [21]


### Merging Chains  msplit/5 into  External patterns of execution 
* [[22]] --> 1 
* [[21]] --> 2 
* [[21,[23]]] --> 3 
* [[22,[23]]] --> 4 


### Specialization of cost equations mergesort/4 
* CE 12 is refined into CE [25] 
* CE 10 is refined into CE [26] 
* CE 11 is refined into CE [27,28,29,30,31,32] 


#### Refined cost equations mergesort/4 
* CE 25: mergesort(A,B,C,D) = 6
     [D>=0,B>=0,C=2,A=2] 
* CE 26: mergesort(A,B,C,D) = 3
     [D>=0,B>=0,C=1,A=1] 
* CE 27: mergesort(A,B,C,D) = 16+ msplit(A,E,F,G,H):3+ mergesort(I,J,K,L)+ mergesort(M,N,C,D)+ merge(O,L,C,D,C,D):1
     [H>=N,G>=M,H>=J,G>=I,A+2>=2*G,M>=1,I>=1,D>=0,C>=1,L>=0,H>=0,G>=2,E>=0,A>=4,B>=0,K=1,O=1,F=1] 
* CE 28: mergesort(A,B,C,D) = 16+ msplit(A,E,F,G,H):3+ mergesort(I,J,C,K)+ mergesort(L,M,N,O)+ merge(C,K,P,O,C,D):2
     [H>=M,G>=L,H>=J,G>=I,A+2>=2*G,L>=1,I>=1,D>=0,C>=2,O>=0,K>=0,H>=0,G>=2,E>=0,A>=4,B>=0,N=1,P=1,F=1] 
* CE 29: mergesort(A,B,C,D) = 16+ msplit(A,E,F,G,H):3+ mergesort(I,J,K,L)+ mergesort(M,N,O,P)+ merge(K,L,Q,P,C,D):3
     [H>=N,G>=M,H>=J,G>=I,C>=K+1,A+2>=2*G,M>=1,I>=1,D>=0,P>=0,L>=0,K>=2,H>=0,G>=2,E>=0,A>=4,B>=0,C+1=K+O,C+1=K+Q,F=1] 
* CE 30: mergesort(A,B,C,D) = 16+ msplit(A,E,F,G,H):4+ mergesort(I,J,K,L)+ mergesort(M,N,C,D)+ merge(O,L,C,D,C,D):1
     [H>=N,G>=M,H>=J,G>=I,A+1>=2*G,M>=1,I>=1,D>=0,C>=1,L>=0,H>=0,G>=2,E>=0,B>=0,K=1,O=1,F=1] 
* CE 31: mergesort(A,B,C,D) = 16+ msplit(A,E,F,G,H):4+ mergesort(I,J,C,K)+ mergesort(L,M,N,O)+ merge(C,K,P,O,C,D):2
     [H>=M,G>=L,H>=J,G>=I,A+1>=2*G,L>=1,I>=1,D>=0,C>=2,O>=0,K>=0,H>=0,G>=2,E>=0,B>=0,N=1,P=1,F=1] 
* CE 32: mergesort(A,B,C,D) = 16+ msplit(A,E,F,G,H):4+ mergesort(I,J,K,L)+ mergesort(M,N,O,P)+ merge(K,L,Q,P,C,D):3
     [H>=N,G>=M,H>=J,G>=I,C>=K+1,A+1>=2*G,M>=1,I>=1,D>=0,P>=0,L>=0,K>=2,H>=0,G>=2,E>=0,B>=0,C+1=K+O,C+1=K+Q,F=1] 

### Cost equations --> "Loop" of mergesort/4 
* CEs [29] --> Loop 24 
* CEs [32] --> Loop 25 
* CEs [28] --> Loop 26 
* CEs [31] --> Loop 27 
* CEs [27] --> Loop 28 
* CEs [30] --> Loop 29 
* CEs [25] --> Loop 30 
* CEs [26] --> Loop 31 

#### Loops of mergesort/4 
* Loop 24: mergesort(A,B,C,D)->  mergesort(A',B',C',D')  mergesort(A'2,B'2,C'2,D'2)
                  [C>=C'+1,A+2>=2*A'2,A+2>=2*A',D'2>=0,A'2>=1,D'>=0,C'>=2,A'>=1,D>=0,B>=0,A>=4,C'+C'2=C+1] 
* Loop 25: mergesort(A,B,C,D)->  mergesort(A',B',C',D')  mergesort(A'2,B'2,C'2,D'2)
                  [C>=C'+1,A+1>=2*A'2,A+1>=2*A',D'2>=0,A'2>=1,D'>=0,C'>=2,A'>=1,D>=0,B>=0,A>=3,C'+C'2=C+1] 
* Loop 26: mergesort(A,B,C,D)->  mergesort(A',B',C,C')  mergesort(A'2,B'2,C'2,D'2)
                  [A+2>=2*A'2,A+2>=2*A',D'2>=0,A'2>=1,C'>=0,A'>=1,D>=0,C>=2,B>=0,A>=4,C'2=1] 
* Loop 27: mergesort(A,B,C,D)->  mergesort(A',B',C,C')  mergesort(A'2,B'2,C'2,D'2)
                  [A+1>=2*A'2,A+1>=2*A',D'2>=0,A'2>=1,C'>=0,A'>=1,D>=0,C>=2,B>=0,A>=3,C'2=1] 
* Loop 28: mergesort(A,B,C,D)->  mergesort(A',B',C',D')  mergesort(A'2,B'2,C,D)
                  [A+2>=2*A'2,A+2>=2*A',A'2>=1,D'>=0,A'>=1,D>=0,C>=1,B>=0,A>=4,C'=1] 
* Loop 29: mergesort(A,B,C,D)->  mergesort(A',B',C',D')  mergesort(A'2,B'2,C,D)
                  [A+1>=2*A'2,A+1>=2*A',A'2>=1,D'>=0,A'>=1,D>=0,C>=1,B>=0,A>=3,C'=1] 
* Loop 30: mergesort(A,B,C,D) [D>=0,B>=0,C=2,A=2] 
* Loop 31: mergesort(A,B,C,D) [D>=0,B>=0,C=1,A=1] 

### Ranking functions of CR mergesort(A,B,C,D) 
* RF of phase [24,25,26,27,28,29]: [A-2,2*A-5]

#### Partial ranking functions of CR mergesort(A,B,C,D) 
* Partial RF of phase [24,25,26,27,28,29]:
  - RF of loop [24:1,24:2,26:1,26:2,28:1,28:2]:
    A-3
  - RF of loop [25:1,25:2,27:1,27:2,29:1,29:2]:
    A-2

Discarded unfeasible chain [multiple([24,25,26,27,28,29],[[],[31],[30]])]...(Non-terminating chain proved terminating)
Remaining chain: [multiple([24,25,26,27,28,29],[[31],[30]])]

### Resulting Chains:mergesort(A,B,C,D) 
* [31]
* [30]
* [multiple([24,25,26,27,28,29],[[31],[30]])]


### Merging Chains  mergesort/4 into  External patterns of execution 
* [[31]] --> 1 
* [[30]] --> 2 
* [[multiple([24,25,26,27,28,29],[[31],[30]])]] --> 3 


### Specialization of cost equations mergesortBuggy/4 
* CE 9 is refined into CE [33,34,35,36,37,38,39,40,41] 
* CE 8 is refined into CE [42] 


#### Refined cost equations mergesortBuggy/4 
* CE 33: mergesortBuggy(A,B,C,D) = 11+ msplit(E,B,F,G,H):2+ mergesortBuggy(I,J,K,L)+ mergesortBuggy(M,N,C,D)+ merge(O,L,C,D,C,D):1
     [H>=N,H>=J,M>=1,I>=1,D>=0,C>=1,L>=0,H>=0,B>=0,2>=M,2>=I,K=1,O=1,G=2,F=1,E=2,A=2] 
* CE 34: mergesortBuggy(A,B,C,D) = 11+ msplit(E,B,F,G,H):2+ mergesortBuggy(I,J,C,K)+ mergesortBuggy(L,M,N,O)+ merge(C,K,P,O,C,D):2
     [H>=M,H>=J,L>=1,I>=1,D>=0,C>=2,O>=0,K>=0,H>=0,B>=0,2>=L,2>=I,N=1,P=1,G=2,F=1,E=2,A=2] 
* CE 35: mergesortBuggy(A,B,C,D) = 11+ msplit(E,B,F,G,H):2+ mergesortBuggy(I,J,K,L)+ mergesortBuggy(M,N,O,P)+ merge(K,L,Q,P,C,D):3
     [H>=N,H>=J,C>=K+1,M>=1,I>=1,D>=0,P>=0,L>=0,K>=2,H>=0,B>=0,2>=M,2>=I,C+1=K+O,C+1=K+Q,G=2,F=1,E=2,A=2] 
* CE 36: mergesortBuggy(A,B,C,D) = 11+ msplit(A,B,E,F,G):3+ mergesortBuggy(H,I,J,K)+ mergesortBuggy(L,M,C,D)+ merge(N,K,C,D,C,D):1
     [G>=M,F>=L,G>=I,F>=H,A+2>=2*F,L>=1,H>=1,D>=0,C>=1,K>=0,G>=0,F>=2,B>=0,A>=4,J=1,N=1,E=1] 
* CE 37: mergesortBuggy(A,B,C,D) = 11+ msplit(A,B,E,F,G):3+ mergesortBuggy(H,I,C,J)+ mergesortBuggy(K,L,M,N)+ merge(C,J,O,N,C,D):2
     [G>=L,F>=K,G>=I,F>=H,A+2>=2*F,K>=1,H>=1,D>=0,C>=2,N>=0,J>=0,G>=0,F>=2,B>=0,A>=4,M=1,O=1,E=1] 
* CE 38: mergesortBuggy(A,B,C,D) = 11+ msplit(A,B,E,F,G):3+ mergesortBuggy(H,I,J,K)+ mergesortBuggy(L,M,N,O)+ merge(J,K,P,O,C,D):3
     [G>=M,F>=L,G>=I,F>=H,C>=J+1,A+2>=2*F,L>=1,H>=1,D>=0,O>=0,K>=0,J>=2,G>=0,F>=2,B>=0,A>=4,C+1=J+N,C+1=J+P,E=1] 
* CE 39: mergesortBuggy(A,B,C,D) = 11+ msplit(A,B,E,F,G):4+ mergesortBuggy(H,I,J,K)+ mergesortBuggy(L,M,C,D)+ merge(N,K,C,D,C,D):1
     [G>=M,F>=L,G>=I,F>=H,A+1>=2*F,L>=1,H>=1,D>=0,C>=1,K>=0,G>=0,F>=2,B>=0,J=1,N=1,E=1] 
* CE 40: mergesortBuggy(A,B,C,D) = 11+ msplit(A,B,E,F,G):4+ mergesortBuggy(H,I,C,J)+ mergesortBuggy(K,L,M,N)+ merge(C,J,O,N,C,D):2
     [G>=L,F>=K,G>=I,F>=H,A+1>=2*F,K>=1,H>=1,D>=0,C>=2,N>=0,J>=0,G>=0,F>=2,B>=0,M=1,O=1,E=1] 
* CE 41: mergesortBuggy(A,B,C,D) = 11+ msplit(A,B,E,F,G):4+ mergesortBuggy(H,I,J,K)+ mergesortBuggy(L,M,N,O)+ merge(J,K,P,O,C,D):3
     [G>=M,F>=L,G>=I,F>=H,C>=J+1,A+1>=2*F,L>=1,H>=1,D>=0,O>=0,K>=0,J>=2,G>=0,F>=2,B>=0,C+1=J+N,C+1=J+P,E=1] 
* CE 42: mergesortBuggy(A,B,C,D) = 3
     [D>=0,B>=0,C=1,A=1] 

### Cost equations --> "Loop" of mergesortBuggy/4 
* CEs [42] --> Loop 32 
* CEs [38] --> Loop 33 
* CEs [41] --> Loop 34 
* CEs [37] --> Loop 35 
* CEs [40] --> Loop 36 
* CEs [36] --> Loop 37 
* CEs [39] --> Loop 38 
* CEs [35] --> Loop 39 
* CEs [34] --> Loop 40 
* CEs [33] --> Loop 41 

#### Loops of mergesortBuggy/4 
* Loop 32: mergesortBuggy(A,B,C,D) [D>=0,B>=0,C=1,A=1] 
* Loop 33: mergesortBuggy(A,B,C,D)->  mergesortBuggy(A',B',C',D')  mergesortBuggy(A'2,B'2,C'2,D'2)
                  [C>=C'+1,A+2>=2*A'2,A+2>=2*A',D'2>=0,A'2>=1,D'>=0,C'>=2,A'>=1,D>=0,B>=0,A>=4,C'+C'2=C+1] 
* Loop 34: mergesortBuggy(A,B,C,D)->  mergesortBuggy(A',B',C',D')  mergesortBuggy(A'2,B'2,C'2,D'2)
                  [C>=C'+1,A+1>=2*A'2,A+1>=2*A',D'2>=0,A'2>=1,D'>=0,C'>=2,A'>=1,D>=0,B>=0,A>=3,C'+C'2=C+1] 
* Loop 35: mergesortBuggy(A,B,C,D)->  mergesortBuggy(A',B',C,C')  mergesortBuggy(A'2,B'2,C'2,D'2)
                  [A+2>=2*A'2,A+2>=2*A',D'2>=0,A'2>=1,C'>=0,A'>=1,D>=0,C>=2,B>=0,A>=4,C'2=1] 
* Loop 36: mergesortBuggy(A,B,C,D)->  mergesortBuggy(A',B',C,C')  mergesortBuggy(A'2,B'2,C'2,D'2)
                  [A+1>=2*A'2,A+1>=2*A',D'2>=0,A'2>=1,C'>=0,A'>=1,D>=0,C>=2,B>=0,A>=3,C'2=1] 
* Loop 37: mergesortBuggy(A,B,C,D)->  mergesortBuggy(A',B',C',D')  mergesortBuggy(A'2,B'2,C,D)
                  [A+2>=2*A'2,A+2>=2*A',A'2>=1,D'>=0,A'>=1,D>=0,C>=1,B>=0,A>=4,C'=1] 
* Loop 38: mergesortBuggy(A,B,C,D)->  mergesortBuggy(A',B',C',D')  mergesortBuggy(A'2,B'2,C,D)
                  [A+1>=2*A'2,A+1>=2*A',A'2>=1,D'>=0,A'>=1,D>=0,C>=1,B>=0,A>=3,C'=1] 
* Loop 39: mergesortBuggy(A,B,C,D)->  mergesortBuggy(A',B',C',D')  mergesortBuggy(A'2,B'2,C'2,D'2)
                  [C>=C'+1,D'2>=0,A'2>=1,D'>=0,C'>=2,A'>=1,D>=0,B>=0,2>=A'2,2>=A',C'+C'2=C+1,A=2] 
* Loop 40: mergesortBuggy(A,B,C,D)->  mergesortBuggy(A',B',C,C')  mergesortBuggy(A'2,B'2,C'2,D'2)
                  [D'2>=0,A'2>=1,C'>=0,A'>=1,D>=0,C>=2,B>=0,2>=A'2,2>=A',C'2=1,A=2] 
* Loop 41: mergesortBuggy(A,B,C,D)->  mergesortBuggy(A',B',C',D')  mergesortBuggy(A'2,B'2,C,D)
                  [A'2>=1,D'>=0,A'>=1,D>=0,C>=1,B>=0,2>=A'2,2>=A',C'=1,A=2] 

### Ranking functions of CR mergesortBuggy(A,B,C,D) 
* RF of phase [33,34,35,36,37,38]: [A-2,2*A-5]

#### Partial ranking functions of CR mergesortBuggy(A,B,C,D) 
* Partial RF of phase [33,34,35,36,37,38]:
  - RF of loop [33:1,33:2,35:1,35:2,37:1,37:2]:
    A-3
  - RF of loop [34:1,34:2,36:1,36:2,38:1,38:2]:
    A-2

Discarded unfeasible chain [multiple([33,34,35,36,37,38],[[],[multiple([39,40,41],[[],[32]])],[32]])]...(Non-terminating chain proved terminating)
Remaining chain: [multiple([33,34,35,36,37,38],[[multiple([39,40,41],[[],[32]])],[32]])]...

### Resulting Chains:mergesortBuggy(A,B,C,D) 
* [multiple([39,40,41],[[],[32]])]...
* [32]
* [multiple([33,34,35,36,37,38],[[multiple([39,40,41],[[],[32]])],[32]])]...


### Merging Chains  mergesortBuggy/4 into  External patterns of execution 
* [[32]] --> 1 
* [[multiple([39,40,41],[[],[32]])]] --> 2 
* [[multiple([33,34,35,36,37,38],[[multiple([39,40,41],[[],[32]])],[32]])]] --> 3 


Computing Bounds
=====================================

#### Simplifying cost structure of CE 16 

#### Computing cost of phase [15,16] 

#### Simplifying cost structure of CE 17 

#### Simplifying cost structure of CE 18 

#### Cost of loops [15,16] 

 * loop 15:merge(A,B,C,D,E,F) -> [merge(A',B',C',D',E',F')] 
11
 * loop 16:merge(A,B,C,D,E,F) -> [merge(A',B',C',D',E',F')] 
11
##### Pending set merge(A,B,C,D,E,F)
* Psum in Loop 15: [it(15)=<1]
* Psum in Loop 16: [it(16)=<1]

###### Computing sum for it(15)=<1  in Loop 15 
   - Applying inductive sum strategy 
     - head Candidate: A+C-3 
       - Loop 16 is collaborative and bounds [it(16)] 
     - head Candidate: C-1 
       - Loop 16 is collaborative
     - tail Candidate: A+C-3 
       - Loop 16 is collaborative and bounds [it(16)] 
     - tail Candidate: C-1 
       - Loop 16 is collaborative
 * Adding constraints: [it(15)+it(16)=<A+C-3,it(15)=<C-1,it(15)+it(16)=<A+C-A'-C',it(15)=<C-C'] 

##### Pending set A
* Psum in Loop 16: [it(16)=<1]

###### Computing sum for it(16)=<1  in Loop 16 
   - Applying inductive sum strategy 
     - head Candidate: A+C-3 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A-1 
       - Loop 15 is collaborative
     - tail Candidate: A+C-3 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
       - Loop 15 is collaborative
 * Adding constraints: [it(15)+it(16)=<A+C-3,it(16)=<A-1,it(15)+it(16)=<A+C-A'-C',it(16)=<A-A'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [15,16] 

#### Simplifying cost structure of phase [15,16] 

#### Cost of phase [15,16]:merge(A,B,C,D,E,F) -> [merge(A',B',C',D',E',F')] 
11*it(15)+11*it(16)+0
  Such that:it(16) =< A
it(16) =< A-A'
it(15) =< C
it(15) =< C-C'
aux(1) =< A+C
aux(2) =< A+C-A'-C'
it(15) =< aux(1)
it(16) =< aux(1)
it(15) =< aux(2)
it(16) =< aux(2)

#### Simplifying cost structure of chain [[15,16],18] 
 * Joined equivalent variables [aux(3),aux(1),aux(2)] into aux(3)

#### Simplifying cost structure of CE 15 

#### Found solution for phase  [15,16] in the cache 

#### Cost of phase [15,16]:merge(A,B,C,D,E,F) -> [merge(A',B',C',D',E',F')] 
11*it(15)+11*it(16)+0
  Such that:it(16) =< A
it(16) =< A-A'
it(15) =< C
it(15) =< C-C'
aux(1) =< A+C
aux(2) =< A+C-A'-C'
it(15) =< aux(1)
it(16) =< aux(1)
it(15) =< aux(2)
it(16) =< aux(2)

#### Simplifying cost structure of chain [[15,16],17] 
 * Renamed intermediate variables: 
[ (ch([[15,16],17]),it(16))>>s(1), (ch([[15,16],17]),it(15))>>s(2), (ch([[15,16],17]),aux(2))>>s(3), (ch([[15,16],17]),aux(1))>>s(4)]
 * Renamed intermediate variables: 
[ (ch([[15,16],18]),it(16))>>s(5), (ch([[15,16],18]),it(15))>>s(6), (ch([[15,16],18]),aux(3))>>s(7)]

#### Cost of chains of merge(A,B,C,D,E,F):
* Chain [[15,16],18]: 11*it(15)+11*it(16)+2
  Such that:it(16) =< A
it(15) =< C
aux(3) =< A+C
it(15) =< aux(3)
it(16) =< aux(3)

  with precondition: [A+C=E+1,A>=2,B>=0,C>=2,D>=1,F>=1] 

* Chain [[15,16],17]: 11*it(15)+11*it(16)+6
  Such that:it(16) =< -C+E
it(15) =< C
aux(2) =< E
aux(1) =< E+1
it(15) =< aux(1)
it(16) =< aux(1)
it(15) =< aux(2)
it(16) =< aux(2)

  with precondition: [A+C=E+1,A>=2,B>=0,C>=2,D>=0,F>=0] 

* Chain [18]: 2
  with precondition: [A=1,C=E,D=F,B>=0,C>=0,D>=0] 

* Chain [17]: 6
  with precondition: [C=1,A=E,A>=2,B>=0,D>=0,F>=0] 


#### Simplifying cost structure of CE 20 

#### Simplifying cost structure of CE 19 

#### Cost of chains of maxNorm(A,B,C):
* Chain [20]: 0
  with precondition: [A=C,B>=1,A>=B+1] 

* Chain [19]: 0
  with precondition: [B=C,A>=1,B>=A] 


#### Simplifying cost structure of CE 24 

#### Computing cost of phase [23] 

#### Simplifying cost structure of CE 21 

#### Simplifying cost structure of CE 22 

#### Cost of loops [23] 

 * loop 23:msplit(A,B,C,D,E) -> [msplit(A',B',C',D',E')] 
14
##### Pending set msplit(A,B,C,D,E)
* Psum in Loop 23: [it(23)=<1]

###### Computing sum for it(23)=<1  in Loop 23 
   - Applying inductive sum strategy 
     - head Candidate: A/2-1 
     - head Candidate: A/2-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A/2-1 
     - tail Candidate: A/2-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(23)=<A/2-1,it(23)=<A/2-1,it(23)=<A/2-A'/2,it(23)=<A/2-A'/2] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [23] 

#### Simplifying cost structure of phase [23] 

#### Cost of phase [23]:msplit(A,B,C,D,E) -> [msplit(A',B',C',D',E')] 
14*it(23)+0
  Such that:it(23) =< A/2
it(23) =< A/2-A'/2

#### Simplifying cost structure of chain [[23],22] 

#### Simplifying cost structure of CE 23 

#### Found solution for phase  [23] in the cache 

#### Cost of phase [23]:msplit(A,B,C,D,E) -> [msplit(A',B',C',D',E')] 
14*it(23)+0
  Such that:it(23) =< A/2
it(23) =< A/2-A'/2

#### Simplifying cost structure of chain [[23],21] 

#### Cost of chains of msplit(A,B,C,D,E):
* Chain [[23],22]: 14*it(23)+5
  Such that:it(23) =< A/2

  with precondition: [C=1,B>=0,D>=2,E>=0,A+1>=2*D] 

* Chain [[23],21]: 14*it(23)+9
  Such that:it(23) =< A/2

  with precondition: [C=1,A>=4,B>=0,D>=2,E>=0,A+2>=2*D] 

* Chain [22]: 5
  with precondition: [A=1,C=1,D=1,B>=0,E>=0] 

* Chain [21]: 9
  with precondition: [A=2,C=1,D=2,B>=0,E>=0] 


#### Simplifying cost structure of CE 26 

#### Simplifying cost structure of CE 25 

#### Computing cost of chain [multiple([24,25,26,27,28,29],[[31],[30]])] with multiple recursion
 * Renamed intermediate variables: 
[ (eq(29,1),it(23))>>s(8)]
 * Renamed intermediate variables: 
[ (eq(29,2),s(5))>>s(9), (eq(29,2),s(7))>>s(10), (eq(29,2),s(1))>>s(11), (eq(29,2),s(3))>>s(12), (eq(29,2),s(4))>>s(13), (eq(29,2),aux(4))>>s(14), (eq(29,2),s(2))>>s(15), (eq(29,2),s(6))>>s(16)]

#### Simplifying cost structure of CE 29 
 * Renamed intermediate variables: 
[ (it(24),s(8))>>s(17), (it(24),s(9))>>s(18), (it(24),s(11))>>s(19), (it(24),s(15))>>s(20), (it(24),s(16))>>s(21)]
 * Renamed intermediate variables: 
[ (eq(32,1),it(23))>>s(22)]
 * Renamed intermediate variables: 
[ (eq(32,2),s(5))>>s(23), (eq(32,2),s(7))>>s(24), (eq(32,2),s(1))>>s(25), (eq(32,2),s(3))>>s(26), (eq(32,2),s(4))>>s(27), (eq(32,2),aux(4))>>s(28), (eq(32,2),s(2))>>s(29), (eq(32,2),s(6))>>s(30)]

#### Simplifying cost structure of CE 32 
 * Renamed intermediate variables: 
[ (it(25),s(22))>>s(31), (it(25),s(23))>>s(32), (it(25),s(25))>>s(33), (it(25),s(29))>>s(34), (it(25),s(30))>>s(35)]
 * Renamed intermediate variables: 
[ (eq(28,1),it(23))>>s(36)]

#### Simplifying cost structure of CE 28 
 * Renamed intermediate variables: 
[ (it(26),s(36))>>s(37)]
 * Renamed intermediate variables: 
[ (eq(31,1),it(23))>>s(38)]

#### Simplifying cost structure of CE 31 
 * Renamed intermediate variables: 
[ (it(27),s(38))>>s(39)]
 * Renamed intermediate variables: 
[ (eq(27,1),it(23))>>s(40)]

#### Simplifying cost structure of CE 27 
 * Renamed intermediate variables: 
[ (it(28),s(40))>>s(41)]
 * Renamed intermediate variables: 
[ (eq(30,1),it(23))>>s(42)]

#### Simplifying cost structure of CE 30 
 * Renamed intermediate variables: 
[ (it(29),s(42))>>s(43)]

#### Cost of loops [24,25,26,27,28,29] 

 * loop 24:mergesort(A,B,C,D) -> [mergesort(A',B',C',D'),mergesort(A'2,B'2,C'2,D'2)] 
14*s(17)+11*s(18)+11*s(19)+11*s(20)+11*s(21)+31
  Such that:s(17) =< A/2

Unbounded itvars
s(18) :  it(24),s(9)
s(19) :  it(24),s(11)
s(20) :  it(24),s(15)
s(21) :  it(24),s(16)

 * loop 25:mergesort(A,B,C,D) -> [mergesort(A',B',C',D'),mergesort(A'2,B'2,C'2,D'2)] 
14*s(31)+11*s(32)+11*s(33)+11*s(34)+11*s(35)+27
  Such that:s(31) =< A/2

Unbounded itvars
s(32) :  it(25),s(23)
s(33) :  it(25),s(25)
s(34) :  it(25),s(29)
s(35) :  it(25),s(30)

 * loop 26:mergesort(A,B,C,D) -> [mergesort(A',B',C',D'),mergesort(A'2,B'2,C'2,D'2)] 
14*s(37)+31
  Such that:s(37) =< A/2

 * loop 27:mergesort(A,B,C,D) -> [mergesort(A',B',C',D'),mergesort(A'2,B'2,C'2,D'2)] 
14*s(39)+27
  Such that:s(39) =< A/2

 * loop 28:mergesort(A,B,C,D) -> [mergesort(A',B',C',D'),mergesort(A'2,B'2,C'2,D'2)] 
14*s(41)+27
  Such that:s(41) =< A/2

 * loop 29:mergesort(A,B,C,D) -> [mergesort(A',B',C',D'),mergesort(A'2,B'2,C'2,D'2)] 
14*s(43)+23
  Such that:s(43) =< A/2

##### Pending set mergesort(A,B,C,D)
* Psum in Loop 24: [it(24)=<1,s(44)=<A/2]
* Psum in Loop 25: [it(25)=<1,s(49)=<A/2]
* Psum in Loop 26: [it(26)=<1,s(54)=<A/2]
* Psum in Loop 27: [it(27)=<1,s(55)=<A/2]
* Psum in Loop 28: [it(28)=<1,s(56)=<A/2]
* Psum in Loop 29: [it(29)=<1,s(57)=<A/2]
* Psum in Chain-Tail [30]: [it([30])=<1]
* Psum in Chain-Tail [31]: [it([31])=<1]

###### Computing sum for it(24)=<1  in Loop 24 
   - Applying inductive sum strategy 
     - head Candidate: A-3 
       - Loop 25 is collaborative
       - Loop 26 is collaborative and bounds [it(26)] 
       - Loop 27 is collaborative
       - Loop 28 is collaborative and bounds [it(28)] 
       - Loop 29 is collaborative
       - Chain [31] is ignored
       - Chain [30] is ignored
     - tail Candidate: A-3 
       - Loop 25 is collaborative and bounds [it(25)] 
       - Loop 26 is collaborative and bounds [it(26)] 
       - Loop 27 is collaborative and bounds [it(27)] 
       - Loop 28 is collaborative and bounds [it(28)] 
       - Loop 29 is collaborative and bounds [it(29)] 
       - Chain-Tail [31] adds a constant 2/1 
       - Chain-Tail [30] adds a constant 1/1 
 * Adding constraints: [it(24)+it(25)+it(26)+it(27)+it(28)+it(29)=<it([30])+it([31])*2+aux(5),it(24)+it(26)+it(28)=<A-3,aux(5)=<A-3] 

##### Pending set A
* Psum in Loop 24: [s(44)=<A/2]
* Psum in Loop 25: [it(25)=<1,s(49)=<A/2]
* Psum in Loop 26: [it(26)=<1,s(54)=<A/2]
* Psum in Loop 27: [it(27)=<1,s(55)=<A/2]
* Psum in Loop 28: [it(28)=<1,s(56)=<A/2]
* Psum in Loop 29: [it(29)=<1,s(57)=<A/2]
* Psum in Chain-Tail [30]: [it([30])=<1]
* Psum in Chain-Tail [31]: [it([31])=<1]

###### Computing sum for s(44)=<A/2  in Loop 24 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(6)=<A/2] 
 * Adding constraints: [s(44)=<it(24)*aux(6)] 

##### Pending set mergesort(A,B,C,D)
* Pmax/min: [aux(6)=<A/2]
* Psum in Loop 25: [it(25)=<1,s(49)=<A/2]
* Psum in Loop 26: [it(26)=<1,s(54)=<A/2]
* Psum in Loop 27: [it(27)=<1,s(55)=<A/2]
* Psum in Loop 28: [it(28)=<1,s(56)=<A/2]
* Psum in Loop 29: [it(29)=<1,s(57)=<A/2]
* Psum in Chain-Tail [30]: [it([30])=<1]
* Psum in Chain-Tail [31]: [it([31])=<1]

###### Computing max_min for aux(6)=<A/2  
   - Found a solution using transitive invariants 
 * Adding constraints:[aux(6)=<A/2] 

##### Pending set mergesort(A,B,C,D)
* Psum in Loop 25: [it(25)=<1,s(49)=<A/2]
* Psum in Loop 26: [it(26)=<1,s(54)=<A/2]
* Psum in Loop 27: [it(27)=<1,s(55)=<A/2]
* Psum in Loop 28: [it(28)=<1,s(56)=<A/2]
* Psum in Loop 29: [it(29)=<1,s(57)=<A/2]
* Psum in Chain-Tail [30]: [it([30])=<1]
* Psum in Chain-Tail [31]: [it([31])=<1]

###### Computing sum for it(25)=<1  in Loop 25 
   - Applying inductive sum strategy 
     - head Candidate: A-2 
       - Loop 24 is collaborative
       - Loop 26 is collaborative
       - Loop 27 is collaborative and bounds [it(27)] 
       - Loop 28 is collaborative
       - Loop 29 is collaborative and bounds [it(29)] 
       - Chain [31] is ignored
       - Chain-Tail [30] is collaborative
     - tail Candidate: A-2 
       - Loop 24 is collaborative
       - Loop 26 is collaborative
       - Loop 27 is collaborative and bounds [it(27)] 
       - Loop 28 is collaborative
       - Loop 29 is collaborative and bounds [it(29)] 
       - Chain-Tail [31] adds a constant 1/1 
       - Chain-Tail [30] is collaborative
 * Adding constraints: [it(25)+it(27)+it(29)=<it([31])+aux(7),it(25)+it(27)+it(29)=<A-2,aux(7)=<A-2] 

##### Pending set mergesort(A,B,C,D)
* Psum in Loop 25: [s(49)=<A/2]
* Psum in Loop 26: [it(26)=<1,s(54)=<A/2]
* Psum in Loop 27: [it(27)=<1,s(55)=<A/2]
* Psum in Loop 28: [it(28)=<1,s(56)=<A/2]
* Psum in Loop 29: [it(29)=<1,s(57)=<A/2]
* Psum in Chain-Tail [30]: [it([30])=<1]
* Psum in Chain-Tail [31]: [it([31])=<1]

###### Computing sum for s(49)=<A/2  in Loop 25 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(8)=<A/2] 
 * Adding constraints: [s(49)=<it(25)*aux(8)] 

##### Pending set mergesort(A,B,C,D)
* Pmax/min: [aux(8)=<A/2]
* Psum in Loop 26: [it(26)=<1,s(54)=<A/2]
* Psum in Loop 27: [it(27)=<1,s(55)=<A/2]
* Psum in Loop 28: [it(28)=<1,s(56)=<A/2]
* Psum in Loop 29: [it(29)=<1,s(57)=<A/2]
* Psum in Chain-Tail [30]: [it([30])=<1]
* Psum in Chain-Tail [31]: [it([31])=<1]

###### Computing max_min for aux(8)=<A/2  
   - Found a solution using cacheing 
 * Adding constraints:[aux(8)=<aux(6)] 

##### Pending set mergesort(A,B,C,D)
* Psum in Loop 26: [it(26)=<1,s(54)=<A/2]
* Psum in Loop 27: [it(27)=<1,s(55)=<A/2]
* Psum in Loop 28: [it(28)=<1,s(56)=<A/2]
* Psum in Loop 29: [it(29)=<1,s(57)=<A/2]
* Psum in Chain-Tail [30]: [it([30])=<1]
* Psum in Chain-Tail [31]: [it([31])=<1]

###### Computing sum for it(26)=<1  in Loop 26 
   - Applying inductive sum strategy 
     - head Candidate: A-3 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-3 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(24)+it(25)+it(26)+it(27)+it(28)+it(29)=<it([30])+it([31])*2+aux(9),it(24)+it(26)+it(28)=<A-3,aux(9)=<A-3] 

##### Pending set mergesort(A,B,C,D)
* Psum in Loop 26: [s(54)=<A/2]
* Psum in Loop 27: [it(27)=<1,s(55)=<A/2]
* Psum in Loop 28: [it(28)=<1,s(56)=<A/2]
* Psum in Loop 29: [it(29)=<1,s(57)=<A/2]
* Psum in Chain-Tail [30]: [it([30])=<1]
* Psum in Chain-Tail [31]: [it([31])=<1]

###### Computing sum for s(54)=<A/2  in Loop 26 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(10)=<A/2] 
 * Adding constraints: [s(54)=<it(26)*aux(10)] 

##### Pending set mergesort(A,B,C,D)
* Pmax/min: [aux(10)=<A/2]
* Psum in Loop 27: [it(27)=<1,s(55)=<A/2]
* Psum in Loop 28: [it(28)=<1,s(56)=<A/2]
* Psum in Loop 29: [it(29)=<1,s(57)=<A/2]
* Psum in Chain-Tail [30]: [it([30])=<1]
* Psum in Chain-Tail [31]: [it([31])=<1]

###### Computing max_min for aux(10)=<A/2  
   - Found a solution using cacheing 
 * Adding constraints:[aux(10)=<aux(6)] 

##### Pending set mergesort(A,B,C,D)
* Psum in Loop 27: [it(27)=<1,s(55)=<A/2]
* Psum in Loop 28: [it(28)=<1,s(56)=<A/2]
* Psum in Loop 29: [it(29)=<1,s(57)=<A/2]
* Psum in Chain-Tail [30]: [it([30])=<1]
* Psum in Chain-Tail [31]: [it([31])=<1]

###### Computing sum for it(27)=<1  in Loop 27 
   - Applying inductive sum strategy 
     - head Candidate: A-2 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-2 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(25)+it(27)+it(29)=<it([31])+aux(11),it(25)+it(27)+it(29)=<A-2,aux(11)=<A-2] 

##### Pending set mergesort(A,B,C,D)
* Psum in Loop 27: [s(55)=<A/2]
* Psum in Loop 28: [it(28)=<1,s(56)=<A/2]
* Psum in Loop 29: [it(29)=<1,s(57)=<A/2]
* Psum in Chain-Tail [30]: [it([30])=<1]
* Psum in Chain-Tail [31]: [it([31])=<1]

###### Computing sum for s(55)=<A/2  in Loop 27 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(12)=<A/2] 
 * Adding constraints: [s(55)=<it(27)*aux(12)] 

##### Pending set mergesort(A,B,C,D)
* Pmax/min: [aux(12)=<A/2]
* Psum in Loop 28: [it(28)=<1,s(56)=<A/2]
* Psum in Loop 29: [it(29)=<1,s(57)=<A/2]
* Psum in Chain-Tail [30]: [it([30])=<1]
* Psum in Chain-Tail [31]: [it([31])=<1]

###### Computing max_min for aux(12)=<A/2  
   - Found a solution using cacheing 
 * Adding constraints:[aux(12)=<aux(6)] 

##### Pending set mergesort(A,B,C,D)
* Psum in Loop 28: [it(28)=<1,s(56)=<A/2]
* Psum in Loop 29: [it(29)=<1,s(57)=<A/2]
* Psum in Chain-Tail [30]: [it([30])=<1]
* Psum in Chain-Tail [31]: [it([31])=<1]

###### Computing sum for it(28)=<1  in Loop 28 
   - Applying inductive sum strategy 
     - head Candidate: A-3 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-3 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(24)+it(25)+it(26)+it(27)+it(28)+it(29)=<it([30])+it([31])*2+aux(13),it(24)+it(26)+it(28)=<A-3,aux(13)=<A-3] 

##### Pending set mergesort(A,B,C,D)
* Psum in Loop 28: [s(56)=<A/2]
* Psum in Loop 29: [it(29)=<1,s(57)=<A/2]
* Psum in Chain-Tail [30]: [it([30])=<1]
* Psum in Chain-Tail [31]: [it([31])=<1]

###### Computing sum for s(56)=<A/2  in Loop 28 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(14)=<A/2] 
 * Adding constraints: [s(56)=<it(28)*aux(14)] 

##### Pending set mergesort(A,B,C,D)
* Pmax/min: [aux(14)=<A/2]
* Psum in Loop 29: [it(29)=<1,s(57)=<A/2]
* Psum in Chain-Tail [30]: [it([30])=<1]
* Psum in Chain-Tail [31]: [it([31])=<1]

###### Computing max_min for aux(14)=<A/2  
   - Found a solution using cacheing 
 * Adding constraints:[aux(14)=<aux(6)] 

##### Pending set mergesort(A,B,C,D)
* Psum in Loop 29: [it(29)=<1,s(57)=<A/2]
* Psum in Chain-Tail [30]: [it([30])=<1]
* Psum in Chain-Tail [31]: [it([31])=<1]

###### Computing sum for it(29)=<1  in Loop 29 
   - Applying inductive sum strategy 
     - head Candidate: A-2 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-2 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(25)+it(27)+it(29)=<it([31])+aux(15),it(25)+it(27)+it(29)=<A-2,aux(15)=<A-2] 

##### Pending set mergesort(A,B,C,D)
* Psum in Loop 29: [s(57)=<A/2]
* Psum in Chain-Tail [30]: [it([30])=<1]
* Psum in Chain-Tail [31]: [it([31])=<1]

###### Computing sum for s(57)=<A/2  in Loop 29 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(16)=<A/2] 
 * Adding constraints: [s(57)=<it(29)*aux(16)] 

##### Pending set mergesort(A,B,C,D)
* Pmax/min: [aux(16)=<A/2]
* Psum in Chain-Tail [30]: [it([30])=<1]
* Psum in Chain-Tail [31]: [it([31])=<1]

###### Computing max_min for aux(16)=<A/2  
   - Found a solution using cacheing 
 * Adding constraints:[aux(16)=<aux(6)] 

##### Pending set mergesort(A,B,C,D)
* Psum in Chain-Tail [30]: [it([30])=<1]
* Psum in Chain-Tail [31]: [it([31])=<1]

###### Computing sum for it([30])=<1  in Chain-Tail [30] 
   - Applying inductive sum strategy 
     - head Candidate: 1 
       - Loop 24 adds a constant 1/1 
       - Loop 25 adds a constant 1/1 
       - Loop 26 adds a constant 1/1 
       - Loop 27 adds a constant 1/1 
       - Loop 28 adds a constant 1/1 
       - Loop 29 adds a constant 1/1 
       - Chain-Tail [31] is collaborative and bounds [it([31])] 
     - tail Candidate: 1 
       - Loop 24 adds a constant 1/1 
       - Loop 25 adds a constant 1/1 
       - Loop 26 adds a constant 1/1 
       - Loop 27 adds a constant 1/1 
       - Loop 28 adds a constant 1/1 
       - Loop 29 adds a constant 1/1 
       - Chain-Tail [31] is collaborative and bounds [it([31])] 
 * Adding constraints: [it([30])+it([31])=<it(29)+it(28)+it(27)+it(26)+it(25)+it(24)+aux(17),it([30])+it([31])=<it(29)+it(28)+it(27)+it(26)+it(25)+it(24)+aux(18),aux(17)=<1,aux(18)=<1] 

##### Pending set mergesort(A,B,C,D)
* Psum in Chain-Tail [31]: [it([31])=<1]

###### Computing sum for it([31])=<1  in Chain-Tail [31] 
   - Applying inductive sum strategy 
     - head Candidate: 1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: 1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it([30])+it([31])=<it(29)+it(28)+it(27)+it(26)+it(25)+it(24)+aux(19),it([30])+it([31])=<it(29)+it(28)+it(27)+it(26)+it(25)+it(24)+aux(20),aux(19)=<1,aux(20)=<1] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [24,25,26,27,28,29,[31],[30]] 
Found a cycle in the non-final constraints
 Removed possibly redundant constraints to solve a cycle in the cost structure 
it(24)+it(25)+it(26)+it(27)+it(28)+it(29)=<it([30])+it([31])*2+aux(5)
it(25)+it(27)+it(29)=<it([31])+aux(7)
it(24)+it(25)+it(26)+it(27)+it(28)+it(29)=<it([30])+it([31])*2+aux(9)
it(25)+it(27)+it(29)=<it([31])+aux(11)
it(24)+it(25)+it(26)+it(27)+it(28)+it(29)=<it([30])+it([31])*2+aux(13)
it(25)+it(27)+it(29)=<it([31])+aux(15)

#### Simplifying cost structure of phase [24,25,26,27,28,29,[31],[30]] 
 * Joined equivalent variables [aux(21),aux(17),aux(18),aux(19),aux(20)] into aux(21)
 * Joined equivalent variables [aux(22),aux(5),aux(7),aux(9),aux(11),aux(13),aux(15)] into aux(22)
 * Joined equivalent variables [aux(8),aux(10),aux(12),aux(14),aux(16)] into aux(8)
 * Joined equivalent variables [it([30]),it([31])] into it([30])
 * Joined equivalent variables [s(45),s(46),s(47),s(48),s(50),s(51),s(52),s(53)] into s(45)
 * Joined equivalent variables [it(24),it(25),it(26),it(27),it(28),it(29)] into it(24)
 * Joined equivalent variables [s(49),s(54),s(55),s(56),s(57)] into s(49)

#### Cost of phase [24,25,26,27,28,29]:mergesort(A,B,C,D) -> [] 
166*it(24)+9*it([30])+14*s(44)+88*s(45)+70*s(49)+0
  Such that:aux(6) =< A/2
aux(21) =< 1
aux(22) =< A
it(24) =< aux(22)
aux(8) =< aux(6)
it([30]) =< it(24)+it(24)+it(24)+it(24)+it(24)+it(24)+aux(21)
s(49) =< it(24)*aux(8)
s(44) =< it(24)*aux(6)

Unbounded itvars
s(45) :  sum(24),s(18)

#### Cost of chains of mergesort(A,B,C,D):
* Chain [31]: 3
  with precondition: [A=1,C=1,B>=0,D>=0] 

* Chain [30]: 6
  with precondition: [A=2,C=2,B>=0,D>=0] 

* Chain [multiple([24,25,26,27,28,29],[[31],[30]])]: 166*it(24)+9*it([30])+14*s(44)+88*s(45)+70*s(49)+0
  Such that:aux(6) =< A/2
aux(21) =< 1
aux(22) =< A
it(24) =< aux(22)
aux(8) =< aux(6)
it([30]) =< it(24)+it(24)+it(24)+it(24)+it(24)+it(24)+aux(21)
s(49) =< it(24)*aux(8)
s(44) =< it(24)*aux(6)

Unbounded itvars
s(45) :  sum(24),s(18)

  with precondition: [A>=3,B>=0,C>=1,D>=0] 


#### Simplifying cost structure of CE 42 

#### Computing cost of chain [multiple([39,40,41],[[],[32]])] with multiple recursion
 * Renamed intermediate variables: 
[ (eq(35,2),s(5))>>s(58), (eq(35,2),s(7))>>s(59), (eq(35,2),s(1))>>s(60), (eq(35,2),s(3))>>s(61), (eq(35,2),s(4))>>s(62), (eq(35,2),aux(4))>>s(63), (eq(35,2),s(2))>>s(64), (eq(35,2),s(6))>>s(65)]

#### Simplifying cost structure of CE 35 
 * Renamed intermediate variables: 
[ (it(39),s(58))>>s(66), (it(39),s(60))>>s(67), (it(39),s(64))>>s(68), (it(39),s(65))>>s(69)]

#### Simplifying cost structure of CE 34 

#### Simplifying cost structure of CE 33 

#### Cost of loops [39,40,41] 

 * loop 39:mergesortBuggy(A,B,C,D) -> [mergesortBuggy(A',B',C',D'),mergesortBuggy(A'2,B'2,C'2,D'2)] 
11*s(66)+11*s(67)+11*s(68)+11*s(69)+26
Unbounded itvars
s(66) :  it(39),s(58)
s(67) :  it(39),s(60)
s(68) :  it(39),s(64)
s(69) :  it(39),s(65)

 * loop 40:mergesortBuggy(A,B,C,D) -> [mergesortBuggy(A',B',C',D'),mergesortBuggy(A'2,B'2,C'2,D'2)] 
26
 * loop 41:mergesortBuggy(A,B,C,D) -> [mergesortBuggy(A',B',C',D'),mergesortBuggy(A'2,B'2,C'2,D'2)] 
22
##### Pending set mergesortBuggy(A,B,C,D)
* Psum in Loop 39: [it(39)=<1]
* Psum in Loop 40: [it(40)=<1]
* Psum in Loop 41: [it(41)=<1]
* Psum in Chain-Tail [32]: [it([32])=<1]

###### Computing sum for it(39)=<1  in Loop 39 
   - Applying inductive sum strategy 
   - No strategy succeeded 
 * Adding constraints: [] 

##### Pending set A
* Psum in Loop 40: [it(40)=<1]
* Psum in Loop 41: [it(41)=<1]
* Psum in Chain-Tail [32]: [it([32])=<1]

###### Computing sum for it(40)=<1  in Loop 40 
   - Applying inductive sum strategy 
   - No strategy succeeded 
 * Adding constraints: [] 

##### Pending set A
* Psum in Loop 41: [it(41)=<1]
* Psum in Chain-Tail [32]: [it([32])=<1]

###### Computing sum for it(41)=<1  in Loop 41 
   - Applying inductive sum strategy 
   - No strategy succeeded 
 * Adding constraints: [] 

##### Pending set A
* Psum in Chain-Tail [32]: [it([32])=<1]

###### Computing sum for it([32])=<1  in Chain-Tail [32] 
   - Applying inductive sum strategy 
     - head Candidate: 1 
       - Loop 39 adds a constant 1/1 
       - Loop 40 adds a constant 1/1 
       - Loop 41 adds a constant 1/1 
 * Adding constraints: [it([32])=<it(41)+it(40)+it(39)+aux(23),aux(23)=<1] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [39,40,41,[32]] 

#### Simplifying cost structure of phase [39,40,41,[32]] 
 * Joined equivalent variables [it(39),it(40),it(41),s(70),s(71),s(72),s(73)] into it(39)

#### Cost of phase [39,40,41]:mergesortBuggy(A,B,C,D) -> [] 
118*it(39)+3*it([32])+0
Unbounded itvars
it(39) :  it(39)
it([32]) :  it([32])

#### Computing cost of chain [multiple([33,34,35,36,37,38],[[multiple([39,40,41],[[],[32]])],[32]])] with multiple recursion
 * Renamed intermediate variables: 
[ (eq(38,1),it(23))>>s(74)]
 * Renamed intermediate variables: 
[ (eq(38,2),s(5))>>s(75), (eq(38,2),s(7))>>s(76), (eq(38,2),s(1))>>s(77), (eq(38,2),s(3))>>s(78), (eq(38,2),s(4))>>s(79), (eq(38,2),aux(4))>>s(80), (eq(38,2),s(2))>>s(81), (eq(38,2),s(6))>>s(82)]

#### Simplifying cost structure of CE 38 
 * Renamed intermediate variables: 
[ (it(33),s(74))>>s(83), (it(33),s(75))>>s(84), (it(33),s(77))>>s(85), (it(33),s(81))>>s(86), (it(33),s(82))>>s(87)]
 * Renamed intermediate variables: 
[ (eq(41,1),it(23))>>s(88)]
 * Renamed intermediate variables: 
[ (eq(41,2),s(5))>>s(89), (eq(41,2),s(7))>>s(90), (eq(41,2),s(1))>>s(91), (eq(41,2),s(3))>>s(92), (eq(41,2),s(4))>>s(93), (eq(41,2),aux(4))>>s(94), (eq(41,2),s(2))>>s(95), (eq(41,2),s(6))>>s(96)]

#### Simplifying cost structure of CE 41 
 * Renamed intermediate variables: 
[ (it(34),s(88))>>s(97), (it(34),s(89))>>s(98), (it(34),s(91))>>s(99), (it(34),s(95))>>s(100), (it(34),s(96))>>s(101)]
 * Renamed intermediate variables: 
[ (eq(37,1),it(23))>>s(102)]

#### Simplifying cost structure of CE 37 
 * Renamed intermediate variables: 
[ (it(35),s(102))>>s(103)]
 * Renamed intermediate variables: 
[ (eq(40,1),it(23))>>s(104)]

#### Simplifying cost structure of CE 40 
 * Renamed intermediate variables: 
[ (it(36),s(104))>>s(105)]
 * Renamed intermediate variables: 
[ (eq(36,1),it(23))>>s(106)]

#### Simplifying cost structure of CE 36 
 * Renamed intermediate variables: 
[ (it(37),s(106))>>s(107)]
 * Renamed intermediate variables: 
[ (eq(39,1),it(23))>>s(108)]

#### Simplifying cost structure of CE 39 
 * Renamed intermediate variables: 
[ (it(38),s(108))>>s(109)]

#### Cost of loops [33,34,35,36,37,38] 

 * loop 33:mergesortBuggy(A,B,C,D) -> [mergesortBuggy(A',B',C',D'),mergesortBuggy(A'2,B'2,C'2,D'2)] 
14*s(83)+11*s(84)+11*s(85)+11*s(86)+11*s(87)+26
  Such that:s(83) =< A/2

Unbounded itvars
s(84) :  it(33),s(75)
s(85) :  it(33),s(77)
s(86) :  it(33),s(81)
s(87) :  it(33),s(82)

 * loop 34:mergesortBuggy(A,B,C,D) -> [mergesortBuggy(A',B',C',D'),mergesortBuggy(A'2,B'2,C'2,D'2)] 
14*s(97)+11*s(98)+11*s(99)+11*s(100)+11*s(101)+22
  Such that:s(97) =< A/2

Unbounded itvars
s(98) :  it(34),s(89)
s(99) :  it(34),s(91)
s(100) :  it(34),s(95)
s(101) :  it(34),s(96)

 * loop 35:mergesortBuggy(A,B,C,D) -> [mergesortBuggy(A',B',C',D'),mergesortBuggy(A'2,B'2,C'2,D'2)] 
14*s(103)+26
  Such that:s(103) =< A/2

 * loop 36:mergesortBuggy(A,B,C,D) -> [mergesortBuggy(A',B',C',D'),mergesortBuggy(A'2,B'2,C'2,D'2)] 
14*s(105)+22
  Such that:s(105) =< A/2

 * loop 37:mergesortBuggy(A,B,C,D) -> [mergesortBuggy(A',B',C',D'),mergesortBuggy(A'2,B'2,C'2,D'2)] 
14*s(107)+22
  Such that:s(107) =< A/2

 * loop 38:mergesortBuggy(A,B,C,D) -> [mergesortBuggy(A',B',C',D'),mergesortBuggy(A'2,B'2,C'2,D'2)] 
14*s(109)+18
  Such that:s(109) =< A/2

##### Pending set mergesortBuggy(A,B,C,D)
* Psum in Loop 33: [it(33)=<1,s(110)=<A/2]
* Psum in Loop 34: [it(34)=<1,s(115)=<A/2]
* Psum in Loop 35: [it(35)=<1,s(120)=<A/2]
* Psum in Loop 36: [it(36)=<1,s(121)=<A/2]
* Psum in Loop 37: [it(37)=<1,s(122)=<A/2]
* Psum in Loop 38: [it(38)=<1,s(123)=<A/2]
* Psum in Chain-Tail [32]: [it([32])=<1]
* Psum in Chain-Tail [multiple([39,40,41],[[],[32]])]: [it([multiple([39,40,41],[[],[32]])])=<1]

###### Computing sum for it(33)=<1  in Loop 33 
   - Applying inductive sum strategy 
     - head Candidate: A-3 
       - Loop 34 is collaborative
       - Loop 35 is collaborative and bounds [it(35)] 
       - Loop 36 is collaborative
       - Loop 37 is collaborative and bounds [it(37)] 
       - Loop 38 is collaborative
       - Chain [multiple([39,40,41],[[],[32]])] is ignored
       - Chain [32] is ignored
     - tail Candidate: A-3 
       - Loop 34 is collaborative and bounds [it(34)] 
       - Loop 35 is collaborative and bounds [it(35)] 
       - Loop 36 is collaborative and bounds [it(36)] 
       - Loop 37 is collaborative and bounds [it(37)] 
       - Loop 38 is collaborative and bounds [it(38)] 
       - Chain-Tail [multiple([39,40,41],[[],[32]])] adds a constant 1/1 
       - Chain-Tail [32] adds a constant 2/1 
 * Adding constraints: [it(33)+it(34)+it(35)+it(36)+it(37)+it(38)=<it([32])*2+it([multiple([39,40,41],[[],[32]])])+aux(24),it(33)+it(35)+it(37)=<A-3,aux(24)=<A-3] 

##### Pending set A
* Psum in Loop 33: [s(110)=<A/2]
* Psum in Loop 34: [it(34)=<1,s(115)=<A/2]
* Psum in Loop 35: [it(35)=<1,s(120)=<A/2]
* Psum in Loop 36: [it(36)=<1,s(121)=<A/2]
* Psum in Loop 37: [it(37)=<1,s(122)=<A/2]
* Psum in Loop 38: [it(38)=<1,s(123)=<A/2]
* Psum in Chain-Tail [32]: [it([32])=<1]
* Psum in Chain-Tail [multiple([39,40,41],[[],[32]])]: [it([multiple([39,40,41],[[],[32]])])=<1]

###### Computing sum for s(110)=<A/2  in Loop 33 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(25)=<A/2] 
 * Adding constraints: [s(110)=<it(33)*aux(25)] 

##### Pending set mergesortBuggy(A,B,C,D)
* Pmax/min: [aux(25)=<A/2]
* Psum in Loop 34: [it(34)=<1,s(115)=<A/2]
* Psum in Loop 35: [it(35)=<1,s(120)=<A/2]
* Psum in Loop 36: [it(36)=<1,s(121)=<A/2]
* Psum in Loop 37: [it(37)=<1,s(122)=<A/2]
* Psum in Loop 38: [it(38)=<1,s(123)=<A/2]
* Psum in Chain-Tail [32]: [it([32])=<1]
* Psum in Chain-Tail [multiple([39,40,41],[[],[32]])]: [it([multiple([39,40,41],[[],[32]])])=<1]

###### Computing max_min for aux(25)=<A/2  
   - Found a solution using transitive invariants 
 * Adding constraints:[aux(25)=<A/2] 

##### Pending set mergesortBuggy(A,B,C,D)
* Psum in Loop 34: [it(34)=<1,s(115)=<A/2]
* Psum in Loop 35: [it(35)=<1,s(120)=<A/2]
* Psum in Loop 36: [it(36)=<1,s(121)=<A/2]
* Psum in Loop 37: [it(37)=<1,s(122)=<A/2]
* Psum in Loop 38: [it(38)=<1,s(123)=<A/2]
* Psum in Chain-Tail [32]: [it([32])=<1]
* Psum in Chain-Tail [multiple([39,40,41],[[],[32]])]: [it([multiple([39,40,41],[[],[32]])])=<1]

###### Computing sum for it(34)=<1  in Loop 34 
   - Applying inductive sum strategy 
     - head Candidate: A-2 
       - Loop 33 is collaborative
       - Loop 35 is collaborative
       - Loop 36 is collaborative and bounds [it(36)] 
       - Loop 37 is collaborative
       - Loop 38 is collaborative and bounds [it(38)] 
       - Chain-Tail [multiple([39,40,41],[[],[32]])] is collaborative
       - Chain [32] is ignored
     - tail Candidate: A-2 
       - Loop 33 is collaborative
       - Loop 35 is collaborative
       - Loop 36 is collaborative and bounds [it(36)] 
       - Loop 37 is collaborative
       - Loop 38 is collaborative and bounds [it(38)] 
       - Chain-Tail [multiple([39,40,41],[[],[32]])] is collaborative
       - Chain-Tail [32] adds a constant 1/1 
 * Adding constraints: [it(34)+it(36)+it(38)=<it([32])+aux(26),it(34)+it(36)+it(38)=<A-2,aux(26)=<A-2] 

##### Pending set mergesortBuggy(A,B,C,D)
* Psum in Loop 34: [s(115)=<A/2]
* Psum in Loop 35: [it(35)=<1,s(120)=<A/2]
* Psum in Loop 36: [it(36)=<1,s(121)=<A/2]
* Psum in Loop 37: [it(37)=<1,s(122)=<A/2]
* Psum in Loop 38: [it(38)=<1,s(123)=<A/2]
* Psum in Chain-Tail [32]: [it([32])=<1]
* Psum in Chain-Tail [multiple([39,40,41],[[],[32]])]: [it([multiple([39,40,41],[[],[32]])])=<1]

###### Computing sum for s(115)=<A/2  in Loop 34 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(27)=<A/2] 
 * Adding constraints: [s(115)=<it(34)*aux(27)] 

##### Pending set mergesortBuggy(A,B,C,D)
* Pmax/min: [aux(27)=<A/2]
* Psum in Loop 35: [it(35)=<1,s(120)=<A/2]
* Psum in Loop 36: [it(36)=<1,s(121)=<A/2]
* Psum in Loop 37: [it(37)=<1,s(122)=<A/2]
* Psum in Loop 38: [it(38)=<1,s(123)=<A/2]
* Psum in Chain-Tail [32]: [it([32])=<1]
* Psum in Chain-Tail [multiple([39,40,41],[[],[32]])]: [it([multiple([39,40,41],[[],[32]])])=<1]

###### Computing max_min for aux(27)=<A/2  
   - Found a solution using cacheing 
 * Adding constraints:[aux(27)=<aux(25)] 

##### Pending set mergesortBuggy(A,B,C,D)
* Psum in Loop 35: [it(35)=<1,s(120)=<A/2]
* Psum in Loop 36: [it(36)=<1,s(121)=<A/2]
* Psum in Loop 37: [it(37)=<1,s(122)=<A/2]
* Psum in Loop 38: [it(38)=<1,s(123)=<A/2]
* Psum in Chain-Tail [32]: [it([32])=<1]
* Psum in Chain-Tail [multiple([39,40,41],[[],[32]])]: [it([multiple([39,40,41],[[],[32]])])=<1]

###### Computing sum for it(35)=<1  in Loop 35 
   - Applying inductive sum strategy 
     - head Candidate: A-3 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-3 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(33)+it(34)+it(35)+it(36)+it(37)+it(38)=<it([32])*2+it([multiple([39,40,41],[[],[32]])])+aux(28),it(33)+it(35)+it(37)=<A-3,aux(28)=<A-3] 

##### Pending set mergesortBuggy(A,B,C,D)
* Psum in Loop 35: [s(120)=<A/2]
* Psum in Loop 36: [it(36)=<1,s(121)=<A/2]
* Psum in Loop 37: [it(37)=<1,s(122)=<A/2]
* Psum in Loop 38: [it(38)=<1,s(123)=<A/2]
* Psum in Chain-Tail [32]: [it([32])=<1]
* Psum in Chain-Tail [multiple([39,40,41],[[],[32]])]: [it([multiple([39,40,41],[[],[32]])])=<1]

###### Computing sum for s(120)=<A/2  in Loop 35 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(29)=<A/2] 
 * Adding constraints: [s(120)=<it(35)*aux(29)] 

##### Pending set mergesortBuggy(A,B,C,D)
* Pmax/min: [aux(29)=<A/2]
* Psum in Loop 36: [it(36)=<1,s(121)=<A/2]
* Psum in Loop 37: [it(37)=<1,s(122)=<A/2]
* Psum in Loop 38: [it(38)=<1,s(123)=<A/2]
* Psum in Chain-Tail [32]: [it([32])=<1]
* Psum in Chain-Tail [multiple([39,40,41],[[],[32]])]: [it([multiple([39,40,41],[[],[32]])])=<1]

###### Computing max_min for aux(29)=<A/2  
   - Found a solution using cacheing 
 * Adding constraints:[aux(29)=<aux(25)] 

##### Pending set mergesortBuggy(A,B,C,D)
* Psum in Loop 36: [it(36)=<1,s(121)=<A/2]
* Psum in Loop 37: [it(37)=<1,s(122)=<A/2]
* Psum in Loop 38: [it(38)=<1,s(123)=<A/2]
* Psum in Chain-Tail [32]: [it([32])=<1]
* Psum in Chain-Tail [multiple([39,40,41],[[],[32]])]: [it([multiple([39,40,41],[[],[32]])])=<1]

###### Computing sum for it(36)=<1  in Loop 36 
   - Applying inductive sum strategy 
     - head Candidate: A-2 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-2 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(34)+it(36)+it(38)=<it([32])+aux(30),it(34)+it(36)+it(38)=<A-2,aux(30)=<A-2] 

##### Pending set mergesortBuggy(A,B,C,D)
* Psum in Loop 36: [s(121)=<A/2]
* Psum in Loop 37: [it(37)=<1,s(122)=<A/2]
* Psum in Loop 38: [it(38)=<1,s(123)=<A/2]
* Psum in Chain-Tail [32]: [it([32])=<1]
* Psum in Chain-Tail [multiple([39,40,41],[[],[32]])]: [it([multiple([39,40,41],[[],[32]])])=<1]

###### Computing sum for s(121)=<A/2  in Loop 36 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(31)=<A/2] 
 * Adding constraints: [s(121)=<it(36)*aux(31)] 

##### Pending set mergesortBuggy(A,B,C,D)
* Pmax/min: [aux(31)=<A/2]
* Psum in Loop 37: [it(37)=<1,s(122)=<A/2]
* Psum in Loop 38: [it(38)=<1,s(123)=<A/2]
* Psum in Chain-Tail [32]: [it([32])=<1]
* Psum in Chain-Tail [multiple([39,40,41],[[],[32]])]: [it([multiple([39,40,41],[[],[32]])])=<1]

###### Computing max_min for aux(31)=<A/2  
   - Found a solution using cacheing 
 * Adding constraints:[aux(31)=<aux(25)] 

##### Pending set mergesortBuggy(A,B,C,D)
* Psum in Loop 37: [it(37)=<1,s(122)=<A/2]
* Psum in Loop 38: [it(38)=<1,s(123)=<A/2]
* Psum in Chain-Tail [32]: [it([32])=<1]
* Psum in Chain-Tail [multiple([39,40,41],[[],[32]])]: [it([multiple([39,40,41],[[],[32]])])=<1]

###### Computing sum for it(37)=<1  in Loop 37 
   - Applying inductive sum strategy 
     - head Candidate: A-3 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-3 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(33)+it(34)+it(35)+it(36)+it(37)+it(38)=<it([32])*2+it([multiple([39,40,41],[[],[32]])])+aux(32),it(33)+it(35)+it(37)=<A-3,aux(32)=<A-3] 

##### Pending set mergesortBuggy(A,B,C,D)
* Psum in Loop 37: [s(122)=<A/2]
* Psum in Loop 38: [it(38)=<1,s(123)=<A/2]
* Psum in Chain-Tail [32]: [it([32])=<1]
* Psum in Chain-Tail [multiple([39,40,41],[[],[32]])]: [it([multiple([39,40,41],[[],[32]])])=<1]

###### Computing sum for s(122)=<A/2  in Loop 37 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(33)=<A/2] 
 * Adding constraints: [s(122)=<it(37)*aux(33)] 

##### Pending set mergesortBuggy(A,B,C,D)
* Pmax/min: [aux(33)=<A/2]
* Psum in Loop 38: [it(38)=<1,s(123)=<A/2]
* Psum in Chain-Tail [32]: [it([32])=<1]
* Psum in Chain-Tail [multiple([39,40,41],[[],[32]])]: [it([multiple([39,40,41],[[],[32]])])=<1]

###### Computing max_min for aux(33)=<A/2  
   - Found a solution using cacheing 
 * Adding constraints:[aux(33)=<aux(25)] 

##### Pending set mergesortBuggy(A,B,C,D)
* Psum in Loop 38: [it(38)=<1,s(123)=<A/2]
* Psum in Chain-Tail [32]: [it([32])=<1]
* Psum in Chain-Tail [multiple([39,40,41],[[],[32]])]: [it([multiple([39,40,41],[[],[32]])])=<1]

###### Computing sum for it(38)=<1  in Loop 38 
   - Applying inductive sum strategy 
     - head Candidate: A-2 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-2 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(34)+it(36)+it(38)=<it([32])+aux(34),it(34)+it(36)+it(38)=<A-2,aux(34)=<A-2] 

##### Pending set mergesortBuggy(A,B,C,D)
* Psum in Loop 38: [s(123)=<A/2]
* Psum in Chain-Tail [32]: [it([32])=<1]
* Psum in Chain-Tail [multiple([39,40,41],[[],[32]])]: [it([multiple([39,40,41],[[],[32]])])=<1]

###### Computing sum for s(123)=<A/2  in Loop 38 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(35)=<A/2] 
 * Adding constraints: [s(123)=<it(38)*aux(35)] 

##### Pending set mergesortBuggy(A,B,C,D)
* Pmax/min: [aux(35)=<A/2]
* Psum in Chain-Tail [32]: [it([32])=<1]
* Psum in Chain-Tail [multiple([39,40,41],[[],[32]])]: [it([multiple([39,40,41],[[],[32]])])=<1]

###### Computing max_min for aux(35)=<A/2  
   - Found a solution using cacheing 
 * Adding constraints:[aux(35)=<aux(25)] 

##### Pending set mergesortBuggy(A,B,C,D)
* Psum in Chain-Tail [32]: [it([32])=<1]
* Psum in Chain-Tail [multiple([39,40,41],[[],[32]])]: [it([multiple([39,40,41],[[],[32]])])=<1]

###### Computing sum for it([32])=<1  in Chain-Tail [32] 
   - Applying inductive sum strategy 
     - head Candidate: 1 
       - Loop 33 adds a constant 1/1 
       - Loop 34 adds a constant 1/1 
       - Loop 35 adds a constant 1/1 
       - Loop 36 adds a constant 1/1 
       - Loop 37 adds a constant 1/1 
       - Loop 38 adds a constant 1/1 
       - Chain-Tail [multiple([39,40,41],[[],[32]])] is collaborative and bounds [it([multiple([39,40,41],[[],[32]])])] 
     - tail Candidate: 1 
       - Loop 33 adds a constant 1/1 
       - Loop 34 adds a constant 1/1 
       - Loop 35 adds a constant 1/1 
       - Loop 36 adds a constant 1/1 
       - Loop 37 adds a constant 1/1 
       - Loop 38 adds a constant 1/1 
       - Chain-Tail [multiple([39,40,41],[[],[32]])] is collaborative and bounds [it([multiple([39,40,41],[[],[32]])])] 
 * Adding constraints: [it([32])+it([multiple([39,40,41],[[],[32]])])=<it(38)+it(37)+it(36)+it(35)+it(34)+it(33)+aux(36),it([32])+it([multiple([39,40,41],[[],[32]])])=<it(38)+it(37)+it(36)+it(35)+it(34)+it(33)+aux(37),aux(36)=<1,aux(37)=<1] 

##### Pending set mergesortBuggy(A,B,C,D)
* Psum in Chain-Tail [multiple([39,40,41],[[],[32]])]: [it([multiple([39,40,41],[[],[32]])])=<1]

###### Computing sum for it([multiple([39,40,41],[[],[32]])])=<1  in Chain-Tail [multiple([39,40,41],[[],[32]])] 
   - Applying inductive sum strategy 
     - head Candidate: 1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: 1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it([32])+it([multiple([39,40,41],[[],[32]])])=<it(38)+it(37)+it(36)+it(35)+it(34)+it(33)+aux(38),it([32])+it([multiple([39,40,41],[[],[32]])])=<it(38)+it(37)+it(36)+it(35)+it(34)+it(33)+aux(39),aux(38)=<1,aux(39)=<1] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [33,34,35,36,37,38,[multiple([39,40,41],[[],[32]])],[32]] 
Found a cycle in the non-final constraints
 Removed possibly redundant constraints to solve a cycle in the cost structure 
it(33)+it(34)+it(35)+it(36)+it(37)+it(38)=<it([32])*2+it([multiple([39,40,41],[[],[32]])])+aux(24)
it(34)+it(36)+it(38)=<it([32])+aux(26)
it(33)+it(34)+it(35)+it(36)+it(37)+it(38)=<it([32])*2+it([multiple([39,40,41],[[],[32]])])+aux(28)
it(34)+it(36)+it(38)=<it([32])+aux(30)
it(33)+it(34)+it(35)+it(36)+it(37)+it(38)=<it([32])*2+it([multiple([39,40,41],[[],[32]])])+aux(32)
it(34)+it(36)+it(38)=<it([32])+aux(34)

#### Simplifying cost structure of phase [33,34,35,36,37,38,[multiple([39,40,41],[[],[32]])],[32]] 
 * Joined equivalent variables [aux(40),aux(36),aux(37),aux(38),aux(39)] into aux(40)
 * Joined equivalent variables [aux(41),aux(24),aux(26),aux(28),aux(30),aux(32),aux(34)] into aux(41)
 * Joined equivalent variables [aux(27),aux(29),aux(31),aux(33),aux(35)] into aux(27)
 * Joined equivalent variables [s(111),s(112),s(113),s(114),s(116),s(117),s(118),s(119),s(124),s(125)] into s(111)
 * Joined equivalent variables [it(33),it(34),it(35),it(36),it(37),it(38)] into it(33)
 * Joined equivalent variables [s(115),s(120),s(121),s(122),s(123)] into s(115)

#### Cost of phase [33,34,35,36,37,38]:mergesortBuggy(A,B,C,D) -> [] 
136*it(33)+3*it([32])+14*s(110)+209*s(111)+70*s(115)+0
  Such that:aux(25) =< A/2
aux(40) =< 1
aux(41) =< A
it(33) =< aux(41)
aux(27) =< aux(25)
it([32]) =< it(33)+it(33)+it(33)+it(33)+it(33)+it(33)+aux(40)
s(115) =< it(33)*aux(27)
s(110) =< it(33)*aux(25)

Unbounded itvars
s(111) :  sum(33),s(84)

#### Cost of chains of mergesortBuggy(A,B,C,D):
* Chain [multiple([39,40,41],[[],[32]])]...: 118*it(39)+3*it([32])+0
Unbounded itvars
it(39) :  it(39)
it([32]) :  it([32])

  with precondition: [A=2,B>=0,C>=1,D>=0] 

* Chain [32]: 3
  with precondition: [A=1,C=1,B>=0,D>=0] 

* Chain [multiple([33,34,35,36,37,38],[[multiple([39,40,41],[[],[32]])],[32]])]...: 136*it(33)+3*it([32])+14*s(110)+209*s(111)+70*s(115)+0
  Such that:aux(25) =< A/2
aux(40) =< 1
aux(41) =< A
it(33) =< aux(41)
aux(27) =< aux(25)
it([32]) =< it(33)+it(33)+it(33)+it(33)+it(33)+it(33)+aux(40)
s(115) =< it(33)*aux(27)
s(110) =< it(33)*aux(25)

Unbounded itvars
s(111) :  sum(33),s(84)

  with precondition: [A>=3,B>=0,C>=1,D>=0] 


Closed-form bounds of msplit(A,B,C,D,E): 
-------------------------------------
* Chain [[23],22] with precondition: [C=1,B>=0,D>=2,E>=0,A+1>=2*D] 
    - Upper bound: 7*A+5 
    - Complexity: n 
* Chain [[23],21] with precondition: [C=1,A>=4,B>=0,D>=2,E>=0,A+2>=2*D] 
    - Upper bound: 7*A+9 
    - Complexity: n 
* Chain [22] with precondition: [A=1,C=1,D=1,B>=0,E>=0] 
    - Upper bound: 5 
    - Complexity: constant 
* Chain [21] with precondition: [A=2,C=1,D=2,B>=0,E>=0] 
    - Upper bound: 9 
    - Complexity: constant 

### Maximum cost of msplit(A,B,C,D,E): 7*A+9 
Asymptotic class: n 
 * Joined equivalent variables [aux(42),aux(1),aux(2)] into aux(42)

Closed-form bounds of merge(A,B,C,D,E,F): 
-------------------------------------
* Chain [[15,16],18] with precondition: [A+C=E+1,A>=2,B>=0,C>=2,D>=1,F>=1] 
    - Upper bound: 11*A+11*C+2 
    - Complexity: n 
* Chain [[15,16],17] with precondition: [A+C=E+1,A>=2,B>=0,C>=2,D>=0,F>=0] 
    - Upper bound: 11*A+11*C+6 
    - Complexity: n 
* Chain [18] with precondition: [A=1,C=E,D=F,B>=0,C>=0,D>=0] 
    - Upper bound: 2 
    - Complexity: constant 
* Chain [17] with precondition: [C=1,A=E,A>=2,B>=0,D>=0,F>=0] 
    - Upper bound: 6 
    - Complexity: constant 

### Maximum cost of merge(A,B,C,D,E,F): 11*A+11*C+6 
Asymptotic class: n 
 * Joined equivalent variables [it(39),it([32])] into it(39)

Closed-form bounds of mergesortBuggy(A,B,C,D): 
-------------------------------------
* Chain [multiple([39,40,41],[[],[32]])]... with precondition: [A=2,B>=0,C>=1,D>=0] 
    - Upper bound: inf 
    - Complexity: infinity 
* Chain [32] with precondition: [A=1,C=1,B>=0,D>=0] 
    - Upper bound: 3 
    - Complexity: constant 
* Chain [multiple([33,34,35,36,37,38],[[multiple([39,40,41],[[],[32]])],[32]])]... with precondition: [A>=3,B>=0,C>=1,D>=0] 
    - Upper bound: inf 
    - Complexity: infinity 

### Maximum cost of mergesortBuggy(A,B,C,D): inf 
Asymptotic class: infinity 

Closed-form bounds of mergesort(A,B,C,D): 
-------------------------------------
* Chain [31] with precondition: [A=1,C=1,B>=0,D>=0] 
    - Upper bound: 3 
    - Complexity: constant 
* Chain [30] with precondition: [A=2,C=2,B>=0,D>=0] 
    - Upper bound: 6 
    - Complexity: constant 
* Chain [multiple([24,25,26,27,28,29],[[31],[30]])] with precondition: [A>=3,B>=0,C>=1,D>=0] 
    - Upper bound: inf 
    - Complexity: infinity 

### Maximum cost of mergesort(A,B,C,D): inf 
Asymptotic class: infinity 
* Total analysis performed in 3672 ms.


Cost relation system solved by CoFloCo in 3678 ms.

Method msplit terminates?: YES

 - l_1: size of l wrt. List<Rat>
 - l_2: size of l wrt. Rat
UB for msplit(l_1,l_2) = 7*l_1+9

Method merge terminates?: YES

 - l1_1: size of l1 wrt. List<Rat>
 - l1_2: size of l1 wrt. Rat
 - l2_1: size of l2 wrt. List<Rat>
 - l2_2: size of l2 wrt. Rat
UB for merge(l1_1,l1_2,l2_1,l2_2) = 11*l1_1+11*l2_1+6

Method mergesortBuggy terminates?: YES

 - l_1: size of l wrt. List<Rat>
 - l_2: size of l wrt. Rat
UB for mergesortBuggy(l_1,l_2) = inf

Method mergesort terminates?: YES

 - l_1: size of l wrt. List<Rat>
 - l_2: size of l wrt. Rat
UB for mergesort(l_1,l_2) = inf
