
Abs program loaded in 6 ms.

Rule based representation generated in 2 ms.

Rule based representation stored in /tmp/costabs/rbr.rbr

RBR properties stored in /tmp/costabs/rbr.properties

Class invariants generated and loaded in 0 ms.

Abstract compilation performed in 22 ms.

Cost relation system stored in /tmp/costabs/crs.crs

Generated 56 equations 
entry('dfs'(A,B,C,D,E,F):[]).
entry('make_btree'(A,B,C,D):[]).
entry('append_rev'(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O):[]).
entry('revL'(A,B,C,D,E,F,G,H,I,J):[]).
entry('bfs'(A,B,C,D,E,F):[]).
input_output_vars('and_op'(A,B,C),[A,B],[C]).
input_output_vars('append_rev'(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O),[A,B,C,D,E,F,G,H,I,J],[K,L,M,N,O]).
input_output_vars('bfs'(A,B,C,D,E,F),[A,B,C],[D,E,F]).
input_output_vars('bfs_aux'(A,B,C,D,E,F,G,H,I),[A,B,C,D,E,F,G],[H,I]).
input_output_vars('case_0'(A,B,C,D,E,F,G),[A,B,C,D],[E,F,G]).
input_output_vars('case_1'(A,B,C,D,E,F,G,H,I,J,K,L),[A,B,C,D,E,F,G,H,I],[J,K,L]).
input_output_vars('case_10'(A,B,C,D,E,F,G,H,I),[A,B,C,D,E,F,G],[H,I]).
input_output_vars('case_11'(A,B,C,D,E,F,G,H,I,J,K,L,M,N),[A,B,C,D,E,F,G,H,I,J,K,L],[M,N]).
input_output_vars('case_12'(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S),[A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q],[R,S]).
input_output_vars('case_13'(A,B,C,D,E,F,G,H),[A,B,C,D,E],[F,G,H]).
input_output_vars('case_2'(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q),[A,B,C,D,E,F,G,H,I,J,K,L,M,N],[O,P,Q]).
input_output_vars('case_3'(A,B,C,D,E),[A,B],[C,D,E]).
input_output_vars('case_4'(A,B,C,D,E,F,G,H),[A,B,C,D,E],[F,G,H]).
input_output_vars('case_5'(A,B,C,D,E,F,G,H,I,J,K,L,M,N),[A,B,C,D,E,F,G,H,I,J,K],[L,M,N]).
input_output_vars('case_6'(A,B,C,D),[A,B],[C,D]).
input_output_vars('case_7'(A,B,C,D,E,F,G,H,I,J),[A,B,C,D,E,F,G,H],[I,J]).
input_output_vars('case_8'(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O),[A,B,C,D,E,F,G,H,I,J],[K,L,M,N,O]).
input_output_vars('case_9'(A,B,C,D,E,F,G,H,I),[A,B,C,D,E,F,G],[H,I]).
input_output_vars('dfs'(A,B,C,D,E,F),[A,B,C],[D,E,F]).
input_output_vars('dfs_aux'(A,B,C,D,E,F,G),[A,B,C,D],[E,F,G]).
input_output_vars('eq'(A,B,C),[A,B],[C]).
input_output_vars('geq'(A,B,C),[A,B],[C]).
input_output_vars('gt'(A,B,C),[A,B],[C]).
input_output_vars('leq'(A,B,C),[A,B],[C]).
input_output_vars('lt'(A,B,C),[A,B],[C]).
input_output_vars('make_btree'(A,B,C,D),[A,B],[C,D]).
input_output_vars('maxNorm'(A,B,C),[A,B],[C]).
input_output_vars('neg'(A,B),[A],[B]).
input_output_vars('neq'(A,B,C),[A,B],[C]).
input_output_vars('or'(A,B,C),[A,B],[C]).
input_output_vars('revL'(A,B,C,D,E,F,G,H,I,J),[A,B,C,D,E],[F,G,H,I,J]).
input_output_vars('split'(A,B,C,D,E),[A,B],[C,D,E]).
eq('eq',[A,B,C],0,[],[A=B,C=1,A>=0,B>=0,C>=0]).
eq('eq',[A,B,C],0,[],[A>=B+1,C=0,A>=0,B>=0,C>=0]).
eq('eq',[A,B,C],0,[],[B>=A+1,C=0,A>=0,B>=0,C>=0]).
eq('neq',[A,B,C],0,[],[A=B,C=0,A>=0,B>=0,C>=0]).
eq('neq',[A,B,C],0,[],[A>=B+1,C=1,A>=0,B>=0,C>=0]).
eq('neq',[A,B,C],0,[],[B>=A+1,C=1,A>=0,B>=0,C>=0]).
eq('lt',[A,B,C],0,[],[B-A>=1,C=1,A>=0,B>=0,C>=0]).
eq('lt',[A,B,C],0,[],[B=<A,C=0,A>=0,B>=0,C>=0]).
eq('leq',[A,B,C],0,[],[A=<B,C=1,A>=0,B>=0,C>=0]).
eq('leq',[A,B,C],0,[],[A-B>=1,C=0,A>=0,B>=0,C>=0]).
eq('gt',[A,B,C],0,[],[A-B>=1,C=1,A>=0,B>=0,C>=0]).
eq('gt',[A,B,C],0,[],[A=<B,C=0,A>=0,B>=0,C>=0]).
eq('geq',[A,B,C],0,[],[B=<A,C=1,A>=0,B>=0,C>=0]).
eq('geq',[A,B,C],0,[],[B-A>=1,C=0,A>=0,B>=0,C>=0]).
eq('neg',[A,B],0,[],[A=0,B=1,A>=0,B>=0]).
eq('neg',[A,B],0,[],[A=1,B=0,A>=0,B>=0]).
eq('and_op',[A,B,C],0,[],[A=0,C=0,A>=0,B>=0,C>=0]).
eq('and_op',[A,B,C],0,[],[A=1,C=B,A>=0,B>=0,C>=0]).
eq('or',[A,B,C],0,[],[A=1,C=1,A>=0,B>=0,C>=0]).
eq('or',[A,B,C],0,[],[A=0,C=B,A>=0,B>=0,C>=0]).
eq('maxNorm',[A,B,A],0,[],[A>=1+B,A>=0,B>=0,A>=0]).
eq('maxNorm',[A,B,B],0,[],[A=<B,A>=0,B>=0,B>=0]).
eq('case_0',[A,B,C,D,E,F,G],2,[],[C=0,A=1,G=0,E=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0]).
eq('case_1',[A,B,C,D,E,F,G,H,I,J,K,L],2,['dfs_aux'(G,H,I,D,J,K,L)],[F=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0]).
eq('case_2',[A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q],2,[],[J=D,Q=F,P=E,O=1,F>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0,M>=0,N>=0,O>=0,P>=0,Q>=0]).
eq('case_2',[A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q],4,['maxNorm'(N,I,R),'maxNorm'(L,R,S),'dfs_aux'(T,U,S,D,O,P,Q)],[J>=D+1,V>=M,V>=H,W=G+1,G>=1,N>=1,U>=K,U>=V,T=W+1,W>=1,L>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0,M>=0,N>=0,O>=0,P>=0,Q>=0]).
eq('case_1',[A,B,C,D,E,F,G,H,I,J,K,L],3,['case_2'(A,B,C,D,E,F,G,H,I,M,N,O,P,Q,J,K,L)],[E>=M,E>=N,E>=P,F=Q+O+1,Q>=1,O>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0]).
eq('case_0',[A,B,C,D,E,F,G],3,['case_1'(A,B,C,D,H,I,J,K,L,E,F,G)],[C>=I,C>=L,B>=H,B>=K,A=J+1,J>=1,I>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0]).
eq('dfs_aux',[A,B,C,D,E,F,G],1,['case_0'(A,B,C,D,E,F,G)],[A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0]).
eq('dfs',[A,B,C,D,E,F],3,['maxNorm'(B,G,H),'dfs_aux'(I,J,H,C,D,E,F)],[G=0,K=1,J>=A,J>=L,I=K+1,K>=1,B>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0]).
eq('case_3',[A,B,C,D,E],4,['maxNorm'(F,G,D)],[A=1,F=1,G=1,E>=H,E>=I,C=1,G>=1,F>=1,A>=0,B>=0,C>=0,D>=0,E>=0]).
eq('case_4',[A,B,C,D,E,F,G,H],5,['maxNorm'(I,J,G)],[D=1,K=1,L>=C,L>=M,I=K+1,K>=1,J=1,H>=L,H>=N,F=1,J>=1,I>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0]).
eq('case_5',[A,B,C,D,E,F,G,H,I,J,K,L,M,N],4,['maxNorm'(O,P,M)],[C>=Q,C>=R,B>=S,B>=T,A=1,T>=1,S>=1,U>=F,U>=Q,O=S+1,S>=1,V>=I,V>=R,P=T+1,T>=1,N>=U,N>=V,L=1,P>=1,O>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0,M>=0,N>=0]).
eq('case_4',[A,B,C,D,E,F,G,H],6,['split'(I,J,K,L,M),'case_5'(N,O,P,A,B,C,D,E,Q,I,J,R,S,T)],[E>=Q,E>=J,D=I+1,I>=1,P=M,O=L,N=K,K>=1,H=T,G=S,F=R,R>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0]).
eq('case_3',[A,B,C,D,E],3,['case_4'(A,B,F,G,H,C,D,E)],[B>=F,B>=H,A=G+1,G>=1,A>=0,B>=0,C>=0,D>=0,E>=0]).
eq('split',[A,B,C,D,E],1,['case_3'(A,B,C,D,E)],[A>=0,B>=0,C>=0,D>=0,E>=0]).
eq('case_6',[A,B,C,D],2,[],[A=1,D=1,A>=0,B>=0,C>=0,D>=0]).
eq('case_7',[A,B,C,D,E,F,G,H,I,J],4,['make_btree'(K,L,M,N),'make_btree'(O,P,Q,R)],[C>=L,C>=P,B>=K,B>=O,A=1,O>=1,K>=1,I>=F,I>=M,I>=Q,J=R+N+1,R>=1,N>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0]).
eq('case_6',[A,B,C,D],6,['split'(E,F,G,H,I),'case_7'(J,K,L,A,B,M,E,F,N,O)],[B>=M,B>=F,A=E+1,E>=1,L=I,K=H,J=G,G>=1,D=O,C=N,O>=1,A>=0,B>=0,C>=0,D>=0]).
eq('make_btree',[A,B,C,D],1,['case_6'(A,B,C,D)],[A>=0,B>=0,C>=0,D>=0]).
eq('case_8',[A,B,C,D,E,F,G,H,I,J,A,B,C,D,E],1,[],[J=0,I=1,H=0,F=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,A>=0,B>=0,C>=0,D>=0,E>=0]).
eq('case_8',[A,B,C,D,E,F,G,H,I,J,K,L,M,N,O],4,['maxNorm'(P,E,Q),'maxNorm'(R,C,S),'append_rev'(T,U,S,V,Q,W,X,Y,Z,A1,K,L,M,N,O)],[J>=P,J>=A1,H>=R,H>=Y,G>=B1,G>=X,I=Z+1,F=W+1,Z>=1,W>=1,P>=1,R>=1,U>=B1,U>=B,V=D+1,T=A+1,D>=1,A>=1,P>=1,R>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0,M>=0,N>=0,O>=0]).
eq('append_rev',[A,B,C,D,E,F,G,H,I,J,K,L,M,N,O],1,['case_8'(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O)],[A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0,M>=0,N>=0,O>=0]).
eq('revL',[A,B,C,D,E,F,G,H,I,J],2,['append_rev'(K,L,M,N,O,A,B,C,D,E,F,G,H,I,J)],[O=0,N=1,M=0,K=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0]).
eq('case_10',[A,B,C,D,E,F,G,H,I],2,[],[F=0,D=1,I=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0]).
eq('case_10',[A,B,C,D,E,F,G,H,I],5,['revL'(D,E,F,J,K,L,M,N,O,P),'bfs_aux'(L,M,N,Q,R,S,G,H,I)],[F>=T,F>=U,E>=V,E>=W,D=X+1,X>=1,T>=1,S=0,Q=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0]).
eq('case_9',[A,B,C,D,E,F,G,H,I],2,['case_10'(A,B,C,D,E,F,G,H,I)],[C=0,A=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0]).
eq('case_11',[A,B,C,D,E,F,G,H,I,J,K,L,M,N],2,['bfs_aux'(J,K,L,D,E,F,G,M,N)],[I=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0,M>=0,N>=0]).
eq('case_12',[A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S],2,[],[G=M,R>=M,R>=N,R>=P,S=Q+O+1,Q>=1,O>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0,M>=0,N>=0,O>=0,P>=0,Q>=0,R>=0,S>=0]).
eq('case_12',[A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S],4,['maxNorm'(O,F,T),'maxNorm'(Q,T,U),'bfs_aux'(J,K,L,V,W,U,G,R,S)],[G>=M+1,X>=N,X>=E,Y=D+1,D>=1,O>=1,W>=P,W>=X,V=Y+1,Y>=1,Q>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0,M>=0,N>=0,O>=0,P>=0,Q>=0,R>=0,S>=0]).
eq('case_11',[A,B,C,D,E,F,G,H,I,J,K,L,M,N],3,['case_12'(A,B,C,D,E,F,G,H,I,J,K,L,O,P,Q,R,S,M,N)],[H>=O,H>=P,H>=R,I=S+Q+1,S>=1,Q>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0,M>=0,N>=0]).
eq('case_9',[A,B,C,D,E,F,G,H,I],3,['case_11'(A,B,C,D,E,F,G,J,K,L,M,N,H,I)],[C>=K,C>=N,B>=J,B>=M,A=L+1,L>=1,K>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0]).
eq('bfs_aux',[A,B,C,D,E,F,G,H,I],1,['case_9'(A,B,C,D,E,F,G,H,I)],[A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0]).
eq('case_13',[A,B,C,D,E,F,G,H],2,[],[B=1,H=0,F=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0]).
eq('case_13',[A,B,C,D,E,F,G,H],4,[],[A>=E,A>=I,A>=J,B=K+L+1,K>=1,L>=1,M>=E,M>=I,M>=J,N=K+L+1,K>=1,L>=1,H=N,G=M,F=1,N>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0]).
eq('bfs',[A,B,C,D,E,F],5,['maxNorm'(B,G,H),'bfs_aux'(I,J,H,K,L,M,C,N,O),'case_13'(N,O,A,B,C,D,E,F)],[G=0,P=1,J>=A,J>=Q,I=P+1,P>=1,B>=1,M=0,K=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0]).

Preprocessing Cost Relations
=====================================

#### Computed strongly connected components 
0. non_recursive  : [maxNorm/3]
1. recursive  : [append_rev/15,case_8/15]
2. non_recursive  : [revL/10]
3. recursive  : [bfs_aux/9,case_10/9,case_11/14,case_12/19,case_9/9]
4. non_recursive  : [case_13/8]
5. non_recursive  : [bfs/6]
6. recursive  : [case_0/7,case_1/12,case_2/17,dfs_aux/7]
7. non_recursive  : [dfs/6]
8. non_recursive  : [case_5/14]
9. recursive [non_tail] : [case_3/5,case_4/8,split/5]
10. recursive [multiple] : [case_6/4,case_7/10,make_btree/4]
Warning: the following predicates are never called:[and_op/3,eq/3,geq/3,gt/3,leq/3,lt/3,neg/2,neq/3,or/3]

#### Obtained direct recursion through partial evaluation 
0. SCC is partially evaluated into maxNorm/3
1. SCC is partially evaluated into append_rev/15
2. SCC is partially evaluated into revL/10
3. SCC is partially evaluated into bfs_aux/9
4. SCC is partially evaluated into case_13/8
5. SCC is partially evaluated into bfs/6
6. SCC is partially evaluated into dfs_aux/7
7. SCC is partially evaluated into dfs/6
8. SCC is completely evaluated into other SCCs
9. SCC is partially evaluated into split/5
10. SCC is partially evaluated into make_btree/4

Control-Flow Refinement of Cost Relations
=====================================

### Specialization of cost equations maxNorm/3 
* CE 9 is refined into CE [24] 
* CE 8 is refined into CE [25] 


#### Refined cost equations maxNorm/3 
* CE 24: maxNorm(A,B,B) = 0
     [B>=A,A>=1] 
* CE 25: maxNorm(A,B,A) = 0
     [A>=B+1,B>=0] 

### Cost equations --> "Loop" of maxNorm/3 
* CEs [24] --> Loop 24 
* CEs [25] --> Loop 25 

#### Loops of maxNorm/3 
* Loop 24: maxNorm(A,B,B) [B>=A,A>=1] 
* Loop 25: maxNorm(A,B,A) [A>=B+1,B>=0] 

### Ranking functions of CR maxNorm(A,B,C) 

#### Partial ranking functions of CR maxNorm(A,B,C) 


### Resulting Chains:maxNorm(A,B,C) 
* [25]
* [24]


### Merging Chains  maxNorm/3 into  External patterns of execution 
* [[25]] --> 1 
* [[24]] --> 2 


### Specialization of cost equations append_rev/15 
* CE 5 is refined into CE [26] 
* CE 4 is refined into CE [27,28,29,30] 


#### Refined cost equations append_rev/15 
* CE 26: append_rev(A,B,C,D,E,F,G,H,I,J,A,B,C,D,E) = 2
     [G>=0,E>=0,D>=0,C>=0,B>=0,A>=0,J=0,I=1,H=0,F=1] 
* CE 27: append_rev(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O) = 5+ maxNorm(P,E,P):1+ maxNorm(Q,C,Q):1+ append_rev(R,S,Q,T,P,U,V,W,X,Y,K,L,M,N,O)
     [J>=Y,H>=W,G>=V,H>=Q,Q>=C+1,J>=P,P>=E+1,S>=B,X>=1,U>=1,C>=0,E>=0,O>=0,N>=0,M>=0,L>=0,K>=0,G>=0,D>=1,B>=0,A>=1,D+1=T,A+1=R,X+1=I,U+1=F] 
* CE 28: append_rev(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O) = 5+ maxNorm(P,E,P):1+ maxNorm(Q,C,C):2+ append_rev(R,S,C,T,P,U,V,W,X,Y,K,L,M,N,O)
     [J>=Y,H>=W,G>=V,C>=Q,H>=Q,J>=P,P>=E+1,S>=B,X>=1,U>=1,Q>=1,E>=0,O>=0,N>=0,M>=0,L>=0,K>=0,G>=0,D>=1,B>=0,A>=1,D+1=T,A+1=R,X+1=I,U+1=F] 
* CE 29: append_rev(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O) = 5+ maxNorm(P,E,E):2+ maxNorm(Q,C,Q):1+ append_rev(R,S,Q,T,E,U,V,W,X,Y,K,L,M,N,O)
     [J>=Y,H>=W,G>=V,H>=Q,Q>=C+1,E>=P,J>=P,S>=B,X>=1,U>=1,C>=0,P>=1,O>=0,N>=0,M>=0,L>=0,K>=0,G>=0,D>=1,B>=0,A>=1,D+1=T,A+1=R,X+1=I,U+1=F] 
* CE 30: append_rev(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O) = 5+ maxNorm(P,E,E):2+ maxNorm(Q,C,C):2+ append_rev(R,S,C,T,E,U,V,W,X,Y,K,L,M,N,O)
     [J>=Y,H>=W,G>=V,C>=Q,H>=Q,E>=P,J>=P,S>=B,X>=1,U>=1,Q>=1,P>=1,O>=0,N>=0,M>=0,L>=0,K>=0,G>=0,D>=1,B>=0,A>=1,D+1=T,A+1=R,X+1=I,U+1=F] 

### Cost equations --> "Loop" of append_rev/15 
* CEs [27] --> Loop 26 
* CEs [29] --> Loop 27 
* CEs [28] --> Loop 28 
* CEs [30] --> Loop 29 
* CEs [26] --> Loop 30 

#### Loops of append_rev/15 
* Loop 26: append_rev(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O)->  append_rev(A',B',C',D',E',F',G',H',I',J',K,L,M,N,O)
                  [J>=J',H>=H',G>=G',J>=E',H>=C',E'>=E+1,C'>=C+1,B'>=B,O>=0,N>=0,M>=0,L>=0,K>=0,I>=2,G>=0,F>=2,E>=0,D>=1,C>=0,B>=0,A>=1,I=I'+1,F=F'+1,D+1=D',A+1=A'] 
* Loop 27: append_rev(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O)->  append_rev(A',B',C',D',E,E',F',G',H',I',K,L,M,N,O)
                  [J>=I',H>=G',G>=F',H>=C',C'>=C+1,B'>=B,O>=0,N>=0,M>=0,L>=0,K>=0,J>=1,I>=2,G>=0,F>=2,E>=1,D>=1,C>=0,B>=0,A>=1,I=H'+1,F=E'+1,D+1=D',A+1=A'] 
* Loop 28: append_rev(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O)->  append_rev(A',B',C,C',D',E',F',G',H',I',K,L,M,N,O)
                  [J>=I',H>=G',G>=F',J>=D',D'>=E+1,B'>=B,O>=0,N>=0,M>=0,L>=0,K>=0,I>=2,H>=1,G>=0,F>=2,E>=0,D>=1,C>=1,B>=0,A>=1,I=H'+1,F=E'+1,D+1=C',A+1=A'] 
* Loop 29: append_rev(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O)->  append_rev(A',B',C,C',E,D',E',F',G',H',K,L,M,N,O)
                  [J>=H',H>=F',G>=E',B'>=B,O>=0,N>=0,M>=0,L>=0,K>=0,J>=1,I>=2,H>=1,G>=0,F>=2,E>=1,D>=1,C>=1,B>=0,A>=1,I=G'+1,F=D'+1,D+1=C',A+1=A'] 
* Loop 30: append_rev(A,B,C,D,E,F,G,H,I,J,A,B,C,D,E) [G>=0,E>=0,D>=0,C>=0,B>=0,A>=0,J=0,I=1,H=0,F=1] 

### Ranking functions of CR append_rev(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O) 
* RF of phase [26,27,28,29]: [F-1,I-1]

#### Partial ranking functions of CR append_rev(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O) 
* Partial RF of phase [26,27,28,29]:
  - RF of loop [26:1,27:1]:
    -C+H
  - RF of loop [26:1,27:1,28:1,29:1]:
    F-1
    I-1
  - RF of loop [26:1,28:1]:
    -E+J

Discarded unfeasible chain [[26,27,28,29]]...(Non-terminating chain proved terminating)

### Resulting Chains:append_rev(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O) 
* [[26,27,28,29],30]
* [30]


### Merging Chains  append_rev/15 into  External patterns of execution 
* [[30]] --> 1 
* [[30,[26,27,28,29]]] --> 2 


### Specialization of cost equations revL/10 
* CE 6 is refined into CE [31,32] 


#### Refined cost equations revL/10 
* CE 31: revL(A,B,C,D,E,F,G,H,I,J) = 2+ append_rev(K,G,L,M,N,O,B,P,Q,R,S,G,T,U,V):1
     [G>=0,B>=0,V=0,U=1,T=0,S=1,R=0,Q=1,P=0,O=1,N=0,M=1,L=0,K=1,J=0,I=1,H=0,F=1,E=0,D=1,C=0,A=1] 
* CE 32: revL(A,B,C,A,D,A,E,F,A,G) = 2+ append_rev(H,I,J,K,L,A,B,C,A,D,A,E,F,A,G):2
     [E>=I,G>=1,F>=1,D>=1,A>=2,C>=1,B>=0,I>=0,L=0,K=1,J=0,H=1] 

### Cost equations --> "Loop" of revL/10 
* CEs [32] --> Loop 31 
* CEs [31] --> Loop 32 

#### Loops of revL/10 
* Loop 31: revL(A,B,C,A,D,A,E,F,A,G) [G>=1,F>=1,E>=0,D>=1,C>=1,B>=0,A>=2] 
* Loop 32: revL(A,B,C,D,E,F,G,H,I,J) [G>=0,B>=0,J=0,I=1,H=0,F=1,E=0,D=1,C=0,A=1] 

### Ranking functions of CR revL(A,B,C,D,E,F,G,H,I,J) 

#### Partial ranking functions of CR revL(A,B,C,D,E,F,G,H,I,J) 


### Resulting Chains:revL(A,B,C,D,E,F,G,H,I,J) 
* [32]
* [31]


### Merging Chains  revL/10 into  External patterns of execution 
* [[32]] --> 1 
* [[31]] --> 2 


### Specialization of cost equations bfs_aux/9 
* CE 18 is refined into CE [33] 
* CE 21 is refined into CE [34] 
* CE 17 is refined into CE [35] 
* CE 19 is refined into CE [36,37,38,39] 
* CE 20 is refined into CE [40] 


#### Refined cost equations bfs_aux/9 
* CE 33: bfs_aux(A,B,C,D,E,F,G,H,I) = 9
     [C>=I,H>=G,B>=G,I>=3,G>=0,F>=0,E>=0,D>=1,A>=2] 
* CE 34: bfs_aux(A,B,C,D,E,F,G,H,I) = 5
     [H>=0,G>=0,E>=0,B>=0,I=1,F=0,D=1,C=0,A=1] 
* CE 35: bfs_aux(A,B,C,D,E,F,G,H,I) = 6+ bfs_aux(J,K,L,D,E,F,G,H,I)
     [C>=L,B>=K,L>=0,K>=0,J>=1,I>=0,H>=0,G>=0,F>=0,E>=0,D>=1,C>=1,J+1=A] 
* CE 36: bfs_aux(A,B,C,D,E,F,G,H,I) = 11+ maxNorm(J,F,J):1+ maxNorm(K,J,K):1+ bfs_aux(L,M,N,O,P,K,G,H,I)
     [C>=J+K+1,C>=N,B>=M,K>=J+1,J>=F+1,P>=E,N>=0,M>=0,L>=1,F>=0,I>=0,H>=0,G>=1,E>=0,D>=1,D+2=O,L+1=A] 
* CE 37: bfs_aux(A,B,C,D,E,F,G,H,I) = 11+ maxNorm(J,F,J):1+ maxNorm(K,J,J):2+ bfs_aux(L,M,N,O,P,J,G,H,I)
     [C>=J+K+1,C>=N,B>=M,J>=K,J>=F+1,P>=E,N>=0,M>=0,L>=1,K>=1,F>=0,I>=0,H>=0,G>=1,E>=0,D>=1,D+2=O,L+1=A] 
* CE 38: bfs_aux(A,B,C,D,E,F,G,H,I) = 11+ maxNorm(J,F,F):2+ maxNorm(K,F,K):1+ bfs_aux(L,M,N,O,P,K,G,H,I)
     [C>=J+K+1,C>=N,B>=M,K>=F+1,F>=J,P>=E,N>=0,M>=0,L>=1,J>=1,I>=0,H>=0,G>=1,E>=0,D>=1,D+2=O,L+1=A] 
* CE 39: bfs_aux(A,B,C,D,E,F,G,H,I) = 11+ maxNorm(J,F,F):2+ maxNorm(K,F,F):2+ bfs_aux(L,M,N,O,P,F,G,H,I)
     [C>=J+K+1,C>=N,B>=M,F>=K,F>=J,P>=E,N>=0,M>=0,L>=1,K>=1,J>=1,I>=0,H>=0,G>=1,E>=0,D>=1,D+2=O,L+1=A] 
* CE 40: bfs_aux(A,B,C,D,E,F,G,H,I) = 8+ revL(D,E,F,D,J,D,K,L,D,M):2+ bfs_aux(D,K,L,N,O,P,G,H,I)
     [M>=1,L>=1,K>=0,J>=1,D>=2,F>=1,E>=0,I>=0,H>=0,G>=0,B>=0,P=0,N=1,C=0,A=1] 

### Cost equations --> "Loop" of bfs_aux/9 
* CEs [35] --> Loop 33 
* CEs [36,37,38] --> Loop 34 
* CEs [39] --> Loop 35 
* CEs [40] --> Loop 36 
* CEs [33] --> Loop 37 
* CEs [34] --> Loop 38 

#### Loops of bfs_aux/9 
* Loop 33: bfs_aux(A,B,C,D,E,F,G,H,I)->  bfs_aux(A',B',C',D,E,F,G,H,I)
                  [C>=C',B>=B',C'>=0,B'>=0,I>=0,H>=0,G>=0,F>=0,E>=0,D>=1,C>=1,A>=2,A=A'+1] 
* Loop 34: bfs_aux(A,B,C,D,E,F,G,H,I)->  bfs_aux(A',B',C',D',E',F',G,H,I)
                  [C>=F'+2,C>=C',B>=B',F'>=F+1,E'>=E,C'>=0,B'>=0,I>=0,H>=0,G>=1,F>=0,E>=0,D>=1,A>=2,D+2=D',A=A'+1] 
* Loop 35: bfs_aux(A,B,C,D,E,F,G,H,I)->  bfs_aux(A',B',C',D',E',F,G,H,I)
                  [C>=C',B>=B',E'>=E,C'>=0,B'>=0,I>=0,H>=0,G>=1,F>=1,E>=0,D>=1,C>=3,A>=2,D+2=D',A=A'+1] 
* Loop 36: bfs_aux(A,B,C,D,E,F,G,H,I)->  bfs_aux(D,A',B',C',D',E',G,H,I)
                  [B'>=1,A'>=0,I>=0,H>=0,G>=0,F>=1,E>=0,D>=2,B>=0,E'=0,C'=1,C=0,A=1] 
* Loop 37: bfs_aux(A,B,C,D,E,F,G,H,I) [C>=I,H>=G,B>=G,I>=3,G>=0,F>=0,E>=0,D>=1,A>=2] 
* Loop 38: bfs_aux(A,B,C,D,E,F,G,H,I) [H>=0,G>=0,E>=0,B>=0,I=1,F=0,D=1,C=0,A=1] 

### Ranking functions of CR bfs_aux(A,B,C,D,E,F,G,H,I) 

#### Partial ranking functions of CR bfs_aux(A,B,C,D,E,F,G,H,I) 
* Partial RF of phase [33,34,35,36]:
  - RF of loop [33:1,34:1,35:1]:
    A-1 depends on loops [36:1] 
  - RF of loop [34:1]:
    C-F-2 depends on loops [36:1] 
  - RF of loop [36:1]:
    -A+2 depends on loops [33:1,34:1,35:1] 
    -C+1 depends on loops [33:1,34:1,35:1] 
    D-1 depends on loops [34:1,35:1] 
    F depends on loops [34:1] 


### Resulting Chains:bfs_aux(A,B,C,D,E,F,G,H,I) 
* [[33,34,35,36]]...
* [[33,34,35,36],38]
* [[33,34,35,36],37]
* [37]


### Merging Chains  bfs_aux/9 into  External patterns of execution 
* [[38,[33,34,35,36]]] --> 1 
* [[37,[33,34,35,36]]] --> 2 
* [[37]] --> 3 
* [[[33,34,35,36]]] --> 4 


### Specialization of cost equations case_13/8 
* CE 23 is refined into CE [41] 
* CE 22 is refined into CE [42] 


#### Refined cost equations case_13/8 
* CE 41: case_13(A,B,C,D,E,F,G,B) = 4
     [G>=E,A>=E,E>=0,D>=1,C>=0,B>=3,F=1] 
* CE 42: case_13(A,B,C,D,E,F,G,H) = 2
     [G>=0,E>=0,D>=1,C>=0,A>=0,H=0,F=1,B=1] 

### Cost equations --> "Loop" of case_13/8 
* CEs [41] --> Loop 39 
* CEs [42] --> Loop 40 

#### Loops of case_13/8 
* Loop 39: case_13(A,B,C,D,E,F,G,B) [G>=E,A>=E,E>=0,D>=1,C>=0,B>=3,F=1] 
* Loop 40: case_13(A,B,C,D,E,F,G,H) [G>=0,E>=0,D>=1,C>=0,A>=0,H=0,F=1,B=1] 

### Ranking functions of CR case_13(A,B,C,D,E,F,G,H) 

#### Partial ranking functions of CR case_13(A,B,C,D,E,F,G,H) 


### Resulting Chains:case_13(A,B,C,D,E,F,G,H) 
* [40]
* [39]


### Merging Chains  case_13/8 into  External patterns of execution 
* [[40]] --> 1 
* [[39]] --> 2 


### Specialization of cost equations bfs/6 
* CE 7 is refined into CE [43,44,45,46,47] 


#### Refined cost equations bfs/6 
* CE 43: bfs(A,B,C,D,E,F) = 5+ maxNorm(B,G,B):1+ bfs_aux(H,I,B,J,K,L,C,M,N):1+ case_13(M,O,A,B,C,P,E,Q):1
     [I>=A,E>=0,C>=0,B>=1,A>=0,M>=0,K>=0,Q=0,P=1,O=1,N=1,L=0,J=1,H=2,G=0,F=0,D=1] 
* CE 44: bfs(A,B,C,D,E,F) = 5+ maxNorm(B,G,B):1+ bfs_aux(H,I,B,J,K,L,C,M,F):2+ case_13(M,F,A,B,C,N,E,F):2
     [E>=C,M>=C,I>=A,F>=3,C>=1,B>=3,A>=0,K>=0,N=1,L=0,J=1,H=2,G=0,D=1] 
* CE 45: bfs(A,B,C,D,E,F) = 5+ maxNorm(B,G,B):1+ bfs_aux(H,I,B,J,K,L,C,M,F):3+ case_13(M,F,A,B,C,N,E,F):2
     [B>=F,E>=C,M>=C,I>=C,I>=A,F>=3,C>=0,A>=0,K>=0,N=1,L=0,J=1,H=2,G=0,D=1] 
* CE 46: bfs(A,B,C,D,E,F) = 5+ maxNorm(B,G,B):1+ bfs_aux(H,I,B,J,K,L,C,M,N):4+ case_13(M,O,A,B,C,P,E,Q):1
     [I>=A,E>=0,C>=0,B>=1,A>=0,M>=0,K>=0,Q=0,P=1,O=1,N=1,L=0,J=1,H=2,G=0,F=0,D=1] 
* CE 47: bfs(A,B,C,D,E,F) = 5+ maxNorm(B,G,B):1+ bfs_aux(H,I,B,J,K,L,C,M,F):4+ case_13(M,F,A,B,C,N,E,F):2
     [E>=C,M>=C,I>=A,F>=3,C>=0,B>=1,A>=0,K>=0,N=1,L=0,J=1,H=2,G=0,D=1] 

### Cost equations --> "Loop" of bfs/6 
* CEs [47] --> Loop 41 
* CEs [46] --> Loop 42 
* CEs [45] --> Loop 43 
* CEs [44] --> Loop 44 
* CEs [43] --> Loop 45 

#### Loops of bfs/6 
* Loop 41: bfs(A,B,C,D,E,F) [E>=C,F>=3,C>=0,B>=1,A>=0,D=1] 
* Loop 42: bfs(A,B,C,D,E,F) [E>=0,C>=0,B>=1,A>=0,F=0,D=1] 
* Loop 43: bfs(A,B,C,D,E,F) [B>=F,E>=C,F>=3,C>=0,A>=0,D=1] 
* Loop 44: bfs(A,B,C,D,E,F) [E>=C,F>=3,C>=1,B>=3,A>=0,D=1] 
* Loop 45: bfs(A,B,C,D,E,F) [E>=0,C>=0,B>=1,A>=0,F=0,D=1] 

### Ranking functions of CR bfs(A,B,C,D,E,F) 

#### Partial ranking functions of CR bfs(A,B,C,D,E,F) 


### Resulting Chains:bfs(A,B,C,D,E,F) 
* [45]
* [44]
* [43]
* [42]...
* [41]...


### Merging Chains  bfs/6 into  External patterns of execution 
* [[45]] --> 1 
* [[44]] --> 2 
* [[43]] --> 3 
* [[42]] --> 4 
* [[41]] --> 5 


### Specialization of cost equations dfs_aux/7 
* CE 11 is refined into CE [48] 
* CE 13 is refined into CE [49] 
* CE 12 is refined into CE [50,51,52,53] 
* CE 10 is refined into CE [54] 


#### Refined cost equations dfs_aux/7 
* CE 48: dfs_aux(A,B,C,D,E,F,G) = 9
     [C>=G,B>=F,F>=D,G>=3,D>=0,A>=2,E=1] 
* CE 49: dfs_aux(A,B,C,D,E,F,G) = 3
     [F>=0,D>=0,B>=0,G=0,E=1,C=0,A=1] 
* CE 50: dfs_aux(A,B,C,D,E,F,G) = 11+ maxNorm(H,I,H):1+ maxNorm(J,H,J):1+ dfs_aux(K,L,J,D,E,F,G)
     [C>=H+J+1,J>=H+1,H>=I+1,B>=D+1,L>=0,I>=0,G>=0,F>=0,E>=0,D>=0,A>=2,A+1=K] 
* CE 51: dfs_aux(A,B,C,D,E,F,G) = 11+ maxNorm(H,I,H):1+ maxNorm(J,H,H):2+ dfs_aux(K,L,H,D,E,F,G)
     [C>=H+J+1,H>=J,H>=I+1,B>=D+1,L>=0,J>=1,I>=0,G>=0,F>=0,E>=0,D>=0,A>=2,A+1=K] 
* CE 52: dfs_aux(A,B,C,D,E,F,G) = 11+ maxNorm(H,I,I):2+ maxNorm(J,I,J):1+ dfs_aux(K,L,J,D,E,F,G)
     [C>=H+J+1,J>=I+1,I>=H,B>=D+1,L>=0,H>=1,G>=0,F>=0,E>=0,D>=0,A>=2,A+1=K] 
* CE 53: dfs_aux(A,B,C,D,E,F,G) = 11+ maxNorm(H,I,I):2+ maxNorm(J,I,I):2+ dfs_aux(K,L,I,D,E,F,G)
     [C>=H+J+1,C>=I,I>=J,I>=H,B>=D+1,L>=0,J>=1,H>=1,G>=0,F>=0,E>=0,D>=0,A>=2,A+1=K] 
* CE 54: dfs_aux(A,B,C,D,E,F,G) = 6+ dfs_aux(H,I,J,D,E,F,G)
     [C>=J,B>=I,J>=0,I>=0,H>=1,G>=0,F>=0,E>=0,D>=0,C>=1,H+1=A] 

### Cost equations --> "Loop" of dfs_aux/7 
* CEs [50,51,52,53] --> Loop 46 
* CEs [54] --> Loop 47 
* CEs [48] --> Loop 48 
* CEs [49] --> Loop 49 

#### Loops of dfs_aux/7 
* Loop 46: dfs_aux(A,B,C,D,E,F,G)->  dfs_aux(A',B',C',D,E,F,G)
                  [C>=C',B>=D+1,C'>=1,B'>=0,G>=0,F>=0,E>=0,D>=0,C>=3,A>=2,A+1=A'] 
* Loop 47: dfs_aux(A,B,C,D,E,F,G)->  dfs_aux(A',B',C',D,E,F,G)
                  [C>=C',B>=B',C'>=0,B'>=0,G>=0,F>=0,E>=0,D>=0,C>=1,A>=2,A=A'+1] 
* Loop 48: dfs_aux(A,B,C,D,E,F,G) [C>=G,B>=F,F>=D,G>=3,D>=0,A>=2,E=1] 
* Loop 49: dfs_aux(A,B,C,D,E,F,G) [F>=0,D>=0,B>=0,G=0,E=1,C=0,A=1] 

### Ranking functions of CR dfs_aux(A,B,C,D,E,F,G) 

#### Partial ranking functions of CR dfs_aux(A,B,C,D,E,F,G) 
* Partial RF of phase [46,47]:
  - RF of loop [47:1]:
    A-1 depends on loops [46:1] 


### Resulting Chains:dfs_aux(A,B,C,D,E,F,G) 
* [[46,47]]...
* [[46,47],49]
* [[46,47],48]
* [48]


### Merging Chains  dfs_aux/7 into  External patterns of execution 
* [[49,[46,47]]] --> 1 
* [[48,[46,47]]] --> 2 
* [[48]] --> 3 
* [[[46,47]]] --> 4 


### Specialization of cost equations dfs/6 
* CE 1 is refined into CE [55,56,57,58] 


#### Refined cost equations dfs/6 
* CE 55: dfs(A,B,C,D,E,F) = 3+ maxNorm(B,G,B):1+ dfs_aux(H,I,B,C,J,E,K):1
     [I>=A,E>=0,C>=0,B>=1,A>=0,K=0,J=1,H=2,G=0,F=0,D=1] 
* CE 56: dfs(A,B,C,D,E,F) = 3+ maxNorm(B,G,B):1+ dfs_aux(H,I,B,C,J,E,F):2
     [B>=F,E>=C,I>=C+1,I>=A,F>=3,C>=0,A>=0,J=1,H=2,G=0,D=1] 
* CE 57: dfs(A,B,C,D,E,F) = 3+ maxNorm(B,G,B):1+ dfs_aux(H,I,B,C,J,E,F):3
     [B>=F,I>=E,E>=C,I>=A,F>=3,C>=0,A>=0,J=1,H=2,G=0,D=1] 
* CE 58: dfs(A,B,C,D,E,F) = 3+ maxNorm(B,G,B):1+ dfs_aux(H,I,B,C,D,E,F):4
     [I>=A,F>=0,E>=0,D>=0,C>=0,B>=1,A>=0,H=2,G=0] 

### Cost equations --> "Loop" of dfs/6 
* CEs [58] --> Loop 50 
* CEs [56,57] --> Loop 51 
* CEs [55] --> Loop 52 

#### Loops of dfs/6 
* Loop 50: dfs(A,B,C,D,E,F) [F>=0,E>=0,D>=0,C>=0,B>=1,A>=0] 
* Loop 51: dfs(A,B,C,D,E,F) [B>=F,E>=C,F>=3,C>=0,A>=0,D=1] 
* Loop 52: dfs(A,B,C,D,E,F) [E>=0,C>=0,B>=1,A>=0,F=0,D=1] 

### Ranking functions of CR dfs(A,B,C,D,E,F) 

#### Partial ranking functions of CR dfs(A,B,C,D,E,F) 


### Resulting Chains:dfs(A,B,C,D,E,F) 
* [52]
* [51]
* [50]...


### Merging Chains  dfs/6 into  External patterns of execution 
* [[52]] --> 1 
* [[51]] --> 2 
* [[50]] --> 3 


### Specialization of cost equations split/5 
* CE 16 is refined into CE [59,60] 
* CE 15 is refined into CE [61] 
* CE 14 is refined into CE [62] 


#### Refined cost equations split/5 
* CE 59: split(A,B,C,D,E) = 14+ split(F,G,H,I,J)+ maxNorm(D,K,D):1
     [B>=G,I+1>=D,D>=K+1,J>=0,G>=0,K>=2,E>=0,A>=3,A=F+2,H=1,C=1] 
* CE 60: split(A,B,C,D,E) = 14+ split(F,G,H,I,J)+ maxNorm(K,D,D):2
     [B>=G,I+1>=D,D>=K,J>=0,G>=0,K>=2,E>=0,A>=3,A=F+2,H=1,C=1] 
* CE 61: split(A,B,C,D,E) = 9+ maxNorm(F,G,H):1
     [E>=0,B>=0,H=2,G=1,F=2,D=2,C=1,A=2] 
* CE 62: split(A,B,C,D,E) = 5+ maxNorm(F,G,H):2
     [E>=0,B>=0,H=1,G=1,F=1,D=1,C=1,A=1] 

### Cost equations --> "Loop" of split/5 
* CEs [61] --> Loop 53 
* CEs [62] --> Loop 54 
* CEs [59,60] --> Loop 55 

#### Loops of split/5 
* Loop 53: split(A,B,C,D,E) [E>=0,B>=0,D=2,C=1,A=2] 
* Loop 54: split(A,B,C,D,E) [E>=0,B>=0,D=1,C=1,A=1] 
* Loop 55: split(A,B,C,D,E)->  split(A',B',C',D',E')
                  [B>=B',D'+1>=D,E'>=0,B'>=0,E>=0,D>=2,A>=3,A=A'+2,C'=1,C=1] 

### Ranking functions of CR split(A,B,C,D,E) 
* RF of phase [55]: [A/2-1]

#### Partial ranking functions of CR split(A,B,C,D,E) 
* Partial RF of phase [55]:
  - RF of loop [55:1]:
    A/2-1

Discarded unfeasible chain [[55]]...(Non-terminating chain proved terminating)

### Resulting Chains:split(A,B,C,D,E) 
* [[55],54]
* [[55],53]
* [54]
* [53]


### Merging Chains  split/5 into  External patterns of execution 
* [[54]] --> 1 
* [[53]] --> 2 
* [[53,[55]]] --> 3 
* [[54,[55]]] --> 4 


### Specialization of cost equations make_btree/4 
* CE 3 is refined into CE [63,64,65,66] 
* CE 2 is refined into CE [67] 


#### Refined cost equations make_btree/4 
* CE 63: make_btree(A,B,C,D) = 11+ split(E,F,G,H,I):1+ make_btree(J,K,L,M)+ make_btree(N,O,P,Q)
     [C>=P,I>=O,C>=L,I>=K,B>=F,Q>=1,M>=1,I>=0,F>=0,C>=0,M+Q+1=D,N=1,J=1,H=1,G=1,E=1,A=2] 
* CE 64: make_btree(A,B,C,D) = 11+ split(E,F,G,H,I):2+ make_btree(J,K,L,M)+ make_btree(N,O,P,Q)
     [C>=P,I>=O,C>=L,I>=K,B>=F,Q>=1,N>=1,M>=1,J>=1,I>=0,F>=0,C>=0,2>=N,2>=J,M+Q+1=D,H=2,G=1,E=2,A=3] 
* CE 65: make_btree(A,B,C,D) = 11+ split(E,F,G,H,I):3+ make_btree(J,K,L,M)+ make_btree(N,O,P,Q)
     [C>=P,I>=O,H>=N,C>=L,I>=K,H>=J,B>=F,E+2>=2*H,Q>=1,N>=1,M>=1,J>=1,I>=0,H>=2,F>=0,E>=4,C>=0,M+Q+1=D,E+1=A,G=1] 
* CE 66: make_btree(A,B,C,D) = 11+ split(E,F,G,H,I):4+ make_btree(J,K,L,M)+ make_btree(N,O,P,Q)
     [C>=P,I>=O,H>=N,C>=L,I>=K,H>=J,B>=F,E+1>=2*H,Q>=1,N>=1,M>=1,J>=1,I>=0,H>=2,F>=0,C>=0,M+Q+1=D,E+1=A,G=1] 
* CE 67: make_btree(A,B,C,D) = 3
     [C>=0,B>=0,D=1,A=1] 

### Cost equations --> "Loop" of make_btree/4 
* CEs [67] --> Loop 56 
* CEs [65] --> Loop 57 
* CEs [66] --> Loop 58 
* CEs [64] --> Loop 59 
* CEs [63] --> Loop 60 

#### Loops of make_btree/4 
* Loop 56: make_btree(A,B,C,D) [C>=0,B>=0,D=1,A=1] 
* Loop 57: make_btree(A,B,C,D)->  make_btree(A',B',C',D')  make_btree(A'2,B'2,C'2,D'2)
                  [C>=C'2,D>=D'+2,C>=C',A+1>=2*A'2,A+1>=2*A',A'2>=1,D'>=1,A'>=1,C>=0,B>=0,A>=5,D'+D'2+1=D] 
* Loop 58: make_btree(A,B,C,D)->  make_btree(A',B',C',D')  make_btree(A'2,B'2,C'2,D'2)
                  [C>=C'2,D>=D'+2,C>=C',A>=2*A'2,A>=2*A',A'2>=1,D'>=1,A'>=1,C>=0,B>=0,A>=4,D'+D'2+1=D] 
* Loop 59: make_btree(A,B,C,D)->  make_btree(A',B',C',D')  make_btree(A'2,B'2,C'2,D'2)
                  [C>=C'2,D>=D'+2,C>=C',A'2>=1,D'>=1,A'>=1,C>=0,B>=0,2>=A'2,2>=A',D'+D'2+1=D,A=3] 
* Loop 60: make_btree(A,B,C,D)->  make_btree(A',B',C',D')  make_btree(A'2,B'2,C'2,D'2)
                  [C>=C'2,D>=D'+2,C>=C',D'>=1,C>=0,B>=0,D'+D'2+1=D,A'2=1,A'=1,A=2] 

### Ranking functions of CR make_btree(A,B,C,D) 
* RF of phase [57,58]: [A/2-3/2,2/3*A-7/3]

#### Partial ranking functions of CR make_btree(A,B,C,D) 
* Partial RF of phase [57,58]:
  - RF of loop [57:1,57:2]:
    A/2-2
  - RF of loop [58:1,58:2]:
    A-3
    A/2-3/2

Discarded unfeasible chain [multiple([57,58],[[],[multiple(60,[[56]])],[multiple(59,[[multiple(60,[[56]])],[56]])],[56]])]...(Non-terminating chain proved terminating)
Remaining chain: [multiple([57,58],[[multiple(60,[[56]])],[multiple(59,[[multiple(60,[[56]])],[56]])],[56]])]

### Resulting Chains:make_btree(A,B,C,D) 
* [multiple(60,[[56]])]
* [multiple(59,[[multiple(60,[[56]])],[56]])]
* [56]
* [multiple([57,58],[[multiple(60,[[56]])],[multiple(59,[[multiple(60,[[56]])],[56]])],[56]])]


### Merging Chains  make_btree/4 into  External patterns of execution 
* [[56]] --> 1 
* [[multiple(60,[[56]])]] --> 2 
* [[multiple(59,[[multiple(60,[[56]])],[56]])]] --> 3 
* [[multiple([57,58],[[multiple(60,[[56]])],[multiple(59,[[multiple(60,[[56]])],[56]])],[56]])]] --> 4 


Computing Bounds
=====================================

#### Simplifying cost structure of CE 25 

#### Simplifying cost structure of CE 24 

#### Cost of chains of maxNorm(A,B,C):
* Chain [25]: 0
  with precondition: [A=C,B>=0,A>=B+1] 

* Chain [24]: 0
  with precondition: [B=C,A>=1,B>=A] 


#### Simplifying cost structure of CE 26 

#### Computing cost of phase [26,27,28,29] 

#### Simplifying cost structure of CE 27 

#### Simplifying cost structure of CE 29 

#### Simplifying cost structure of CE 28 

#### Simplifying cost structure of CE 30 

#### Cost of loops [26,27,28,29] 

 * loop 26:append_rev(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O) -> [append_rev(A',B',C',D',E',F',G',H',I',J',K',L',M',N',O')] 
5
 * loop 27:append_rev(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O) -> [append_rev(A',B',C',D',E',F',G',H',I',J',K',L',M',N',O')] 
5
 * loop 28:append_rev(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O) -> [append_rev(A',B',C',D',E',F',G',H',I',J',K',L',M',N',O')] 
5
 * loop 29:append_rev(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O) -> [append_rev(A',B',C',D',E',F',G',H',I',J',K',L',M',N',O')] 
5
##### Pending set append_rev(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O)
* Psum in Loop 26: [it(26)=<1]
* Psum in Loop 27: [it(27)=<1]
* Psum in Loop 28: [it(28)=<1]
* Psum in Loop 29: [it(29)=<1]

###### Computing sum for it(26)=<1  in Loop 26 
   - Applying inductive sum strategy 
     - head Candidate: I-1 
       - Loop 27 is collaborative and bounds [it(27)] 
       - Loop 28 is collaborative and bounds [it(28)] 
       - Loop 29 is collaborative and bounds [it(29)] 
     - head Candidate: F-1 
       - Loop 27 is collaborative and bounds [it(27)] 
       - Loop 28 is collaborative and bounds [it(28)] 
       - Loop 29 is collaborative and bounds [it(29)] 
     - head Candidate: F-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: I-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: -C+H 
       - Loop 27 is collaborative and bounds [it(27)] 
       - Loop 28 is collaborative
       - Loop 29 is collaborative
     - head Candidate: -E+J 
       - Loop 27 is collaborative
       - Loop 28 is collaborative and bounds [it(28)] 
       - Loop 29 is collaborative
     - tail Candidate: I-1 
       - Loop 27 is collaborative and bounds [it(27)] 
       - Loop 28 is collaborative and bounds [it(28)] 
       - Loop 29 is collaborative and bounds [it(29)] 
     - tail Candidate: F-1 
       - Loop 27 is collaborative and bounds [it(27)] 
       - Loop 28 is collaborative and bounds [it(28)] 
       - Loop 29 is collaborative and bounds [it(29)] 
     - tail Candidate: F-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: I-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: -C+H 
       - Loop 27 is collaborative and bounds [it(27)] 
       - Loop 28 is collaborative
       - Loop 29 is collaborative
     - tail Candidate: -E+J 
       - Loop 27 is collaborative
       - Loop 28 is collaborative and bounds [it(28)] 
       - Loop 29 is collaborative
 * Adding constraints: [it(26)+it(27)+it(28)+it(29)=<I-1,it(26)+it(27)+it(28)+it(29)=<F-1,it(26)+it(27)+it(28)+it(29)=<F-1,it(26)+it(27)+it(28)+it(29)=<I-1,it(26)+it(27)=< -C+H,it(26)+it(28)=< -E+J,it(26)+it(27)+it(28)+it(29)=<I-I',it(26)+it(27)+it(28)+it(29)=<F-F',it(26)+it(27)+it(28)+it(29)=<F-F',it(26)+it(27)+it(28)+it(29)=<I-I',it(26)+it(27)=< -C+H+C'-H',it(26)+it(28)=< -E+J+E'-J'] 

##### Pending set A
* Psum in Loop 27: [it(27)=<1]
* Psum in Loop 28: [it(28)=<1]
* Psum in Loop 29: [it(29)=<1]

###### Computing sum for it(27)=<1  in Loop 27 
   - Applying inductive sum strategy 
     - head Candidate: I-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: F-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: F-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: I-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: -C+H 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: I-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: F-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: F-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: I-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: -C+H 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(26)+it(27)+it(28)+it(29)=<I-1,it(26)+it(27)+it(28)+it(29)=<F-1,it(26)+it(27)+it(28)+it(29)=<F-1,it(26)+it(27)+it(28)+it(29)=<I-1,it(26)+it(27)=< -C+H,it(26)+it(27)+it(28)+it(29)=<I-I',it(26)+it(27)+it(28)+it(29)=<F-F',it(26)+it(27)+it(28)+it(29)=<F-F',it(26)+it(27)+it(28)+it(29)=<I-I',it(26)+it(27)=< -C+H+C'-H'] 

##### Pending set A
* Psum in Loop 28: [it(28)=<1]
* Psum in Loop 29: [it(29)=<1]

###### Computing sum for it(28)=<1  in Loop 28 
   - Applying inductive sum strategy 
     - head Candidate: I-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: F-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: F-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: I-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: -E+J 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: I-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: F-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: F-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: I-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: -E+J 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(26)+it(27)+it(28)+it(29)=<I-1,it(26)+it(27)+it(28)+it(29)=<F-1,it(26)+it(27)+it(28)+it(29)=<F-1,it(26)+it(27)+it(28)+it(29)=<I-1,it(26)+it(28)=< -E+J,it(26)+it(27)+it(28)+it(29)=<I-I',it(26)+it(27)+it(28)+it(29)=<F-F',it(26)+it(27)+it(28)+it(29)=<F-F',it(26)+it(27)+it(28)+it(29)=<I-I',it(26)+it(28)=< -E+J+E'-J'] 

##### Pending set A
* Psum in Loop 29: [it(29)=<1]

###### Computing sum for it(29)=<1  in Loop 29 
   - Applying inductive sum strategy 
     - head Candidate: I-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: F-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: F-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: I-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: I-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: F-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: F-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: I-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(26)+it(27)+it(28)+it(29)=<I-1,it(26)+it(27)+it(28)+it(29)=<F-1,it(26)+it(27)+it(28)+it(29)=<F-1,it(26)+it(27)+it(28)+it(29)=<I-1,it(26)+it(27)+it(28)+it(29)=<I-I',it(26)+it(27)+it(28)+it(29)=<F-F',it(26)+it(27)+it(28)+it(29)=<F-F',it(26)+it(27)+it(28)+it(29)=<I-I'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [26,27,28,29] 

#### Simplifying cost structure of phase [26,27,28,29] 

#### Cost of phase [26,27,28,29]:append_rev(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O) -> [append_rev(A',B',C',D',E',F',G',H',I',J',K',L',M',N',O')] 
5*it(26)+5*it(27)+5*it(28)+5*it(29)+0
  Such that:aux(1) =< -C+H
aux(2) =< -C+H+C'-H'
aux(3) =< -E+J
aux(4) =< -E+J+E'-J'
aux(5) =< F
aux(6) =< F-F'
aux(7) =< I
aux(8) =< I-I'
it(26) =< aux(1)
it(27) =< aux(1)
it(26) =< aux(2)
it(27) =< aux(2)
it(26) =< aux(3)
it(28) =< aux(3)
it(26) =< aux(4)
it(28) =< aux(4)
it(26) =< aux(5)
it(27) =< aux(5)
it(28) =< aux(5)
it(29) =< aux(5)
it(26) =< aux(6)
it(27) =< aux(6)
it(28) =< aux(6)
it(29) =< aux(6)
it(26) =< aux(7)
it(27) =< aux(7)
it(28) =< aux(7)
it(29) =< aux(7)
it(26) =< aux(8)
it(27) =< aux(8)
it(28) =< aux(8)
it(29) =< aux(8)

#### Simplifying cost structure of chain [[26,27,28,29],30] 
 * Joined equivalent variables [aux(9),aux(6),aux(8)] into aux(9)
 * Joined equivalent variables [aux(10),aux(5),aux(7)] into aux(10)

#### Cost of chains of append_rev(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O):
* Chain [[26,27,28,29],30]: 5*it(26)+5*it(27)+5*it(28)+5*it(29)+2
  Such that:aux(1) =< -C+H
aux(2) =< -C+H+M
aux(3) =< -E+J
aux(4) =< -E+J+O
aux(9) =< -D+N
aux(10) =< -D+N+1
it(26) =< aux(1)
it(27) =< aux(1)
it(26) =< aux(2)
it(27) =< aux(2)
it(26) =< aux(3)
it(28) =< aux(3)
it(26) =< aux(4)
it(28) =< aux(4)
it(26) =< aux(10)
it(27) =< aux(10)
it(28) =< aux(10)
it(29) =< aux(10)
it(26) =< aux(9)
it(27) =< aux(9)
it(28) =< aux(9)
it(29) =< aux(9)

  with precondition: [F=I,A+F=K+1,D+F=N+1,A>=1,B>=0,C>=0,D>=1,E>=0,F>=2,G>=0,H>=1,J>=1,M>=1,O>=1,L>=B,M>=C,O>=E] 

* Chain [30]: 2
  with precondition: [F=1,H=0,I=1,J=0,A=K,B=L,C=M,D=N,E=O,A>=0,B>=0,C>=0,D>=0,E>=0,G>=0] 


#### Simplifying cost structure of CE 31 
 * Renamed intermediate variables: 
[ (eq(32,1),aux(1))>>s(1), (eq(32,1),aux(2))>>s(2), (eq(32,1),aux(3))>>s(3), (eq(32,1),aux(4))>>s(4), (eq(32,1),aux(9))>>s(5), (eq(32,1),aux(10))>>s(6), (eq(32,1),it(26))>>s(7), (eq(32,1),it(27))>>s(8), (eq(32,1),it(28))>>s(9), (eq(32,1),it(29))>>s(10)]

#### Simplifying cost structure of CE 32 
 * Joined equivalent variables [aux(11),s(5),s(6)] into aux(11)

#### Cost of chains of revL(A,B,C,D,E,F,G,H,I,J):
* Chain [32]: 4
  with precondition: [A=1,C=0,D=1,E=0,F=1,H=0,I=1,J=0,B>=0,G>=0] 

* Chain [31]: 5*s(7)+5*s(8)+5*s(9)+5*s(10)+4
  Such that:s(1) =< C
s(3) =< E
aux(11) =< D
s(7) =< s(1)
s(8) =< s(1)
s(7) =< s(3)
s(9) =< s(3)
s(7) =< aux(11)
s(8) =< aux(11)
s(9) =< aux(11)
s(10) =< aux(11)

  with precondition: [A=D,A=F,A=I,A>=2,B>=0,C>=1,E>=1,G>=0,H>=1,J>=1] 


#### Computing cost of phase [33,34,35,36] 

#### Simplifying cost structure of CE 35 

#### Simplifying cost structure of CE 36 

#### Simplifying cost structure of CE 37 

#### Simplifying cost structure of CE 38 

#### Simplifying cost structure of CE 39 
 * Renamed intermediate variables: 
[ (eq(40,1),s(1))>>s(11), (eq(40,1),s(3))>>s(12), (eq(40,1),aux(11))>>s(13), (eq(40,1),s(7))>>s(14), (eq(40,1),s(8))>>s(15), (eq(40,1),s(9))>>s(16), (eq(40,1),s(10))>>s(17)]

#### Simplifying cost structure of CE 40 
 * Renamed intermediate variables: 
[ (it(36),s(11))>>s(18), (it(36),s(13))>>s(19), (it(36),s(14))>>s(20), (it(36),s(15))>>s(21), (it(36),s(16))>>s(22), (it(36),s(17))>>s(23)]

#### Cost of loops [33,34,35,36] 

 * loop 33:bfs_aux(A,B,C,D,E,F,G,H,I) -> [bfs_aux(A',B',C',D',E',F',G',H',I')] 
6
 * loop 34:bfs_aux(A,B,C,D,E,F,G,H,I) -> [bfs_aux(A',B',C',D',E',F',G',H',I')] 
11
 * loop 35:bfs_aux(A,B,C,D,E,F,G,H,I) -> [bfs_aux(A',B',C',D',E',F',G',H',I')] 
11
 * loop 36:bfs_aux(A,B,C,D,E,F,G,H,I) -> [bfs_aux(A',B',C',D',E',F',G',H',I')] 
5*s(20)+5*s(21)+5*s(22)+5*s(23)+12
  Such that:s(18) =< F
s(19) =< A'
s(20) =< s(18)
s(21) =< s(18)
s(20) =< s(19)
s(21) =< s(19)
s(22) =< s(19)
s(23) =< s(19)

##### Pending set bfs_aux(A,B,C,D,E,F,G,H,I)
* Psum in Loop 33: [it(33)=<1]
* Psum in Loop 34: [it(34)=<1]
* Psum in Loop 35: [it(35)=<1]
* Psum in Loop 36: [it(36)=<1,s(29)=<F,s(28)=<A']

###### Computing sum for it(33)=<1  in Loop 33 
   - Applying inductive sum strategy 
     - head Candidate: A-1 
       - Loop 34 is collaborative and bounds [it(34)] 
       - Loop 35 is collaborative and bounds [it(35)] 
       - Loop 36 adds an expression [D-1]
     - tail Candidate: A-1 
       - Loop 34 is collaborative and bounds [it(34)] 
       - Loop 35 is collaborative and bounds [it(35)] 
       - Loop 36 adds an expression [D-1]
 * Adding constraints: [it(33)+it(34)+it(35)=<aux(12)+aux(13),it(33)+it(34)+it(35)=<aux(14)+aux(15),aux(13)=<A-1,aux(15)=<A-A'] 

##### Pending set A
* Psum in Loop 34: [it(34)=<1]
* Psum in Loop 35: [it(35)=<1]
* Psum in Loop 36: [it(36)=<1,s(29)=<F,s(28)=<A',aux(12)=<D-1,aux(14)=<D-1]

###### Computing sum for it(34)=<1  in Loop 34 
   - Applying inductive sum strategy 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: C-F-2 
       - Loop 33 is collaborative
       - Loop 35 is collaborative
       - Loop 36 has undefined behavior 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-F-2 
       - Loop 33 is collaborative
       - Loop 35 is collaborative
       - Loop 36 has undefined behavior 
 * Adding constraints: [it(33)+it(34)+it(35)=<aux(12)+aux(16),it(33)+it(34)+it(35)=<aux(14)+aux(17),aux(16)=<A-1,aux(17)=<A-A'] 

##### Pending set A
* Psum in Loop 35: [it(35)=<1]
* Psum in Loop 36: [it(36)=<1,s(29)=<F,s(28)=<A',aux(12)=<D-1,aux(14)=<D-1]

###### Computing sum for it(35)=<1  in Loop 35 
   - Applying inductive sum strategy 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(33)+it(34)+it(35)=<aux(12)+aux(18),it(33)+it(34)+it(35)=<aux(14)+aux(19),aux(18)=<A-1,aux(19)=<A-A'] 

##### Pending set A
* Psum in Loop 36: [it(36)=<1,s(29)=<F,s(28)=<A',aux(12)=<D-1,aux(14)=<D-1]

###### Computing sum for it(36)=<1  in Loop 36 
   - Applying inductive sum strategy 
     - head Candidate: -A+2 
       - Loop 33 adds a constant 1/1 
       - Loop 34 adds a constant 1/1 
       - Loop 35 adds a constant 1/1 
     - head Candidate: -C+1 
       - Loop 33 has a reset to  [1]
       - Loop 34 has a reset to  [1]
       - Loop 35 has a reset to  [1]
     - head Candidate: D-1 
       - Loop 33 is collaborative
       - Loop 34 adds a constant 2/1 
       - Loop 35 adds a constant 2/1 
     - head Candidate: F 
       - Loop 33 is collaborative
       - Loop 34 adds an expression [C-2]
       - Loop 35 is collaborative
     - tail Candidate: -A+2 
       - Loop 33 adds a constant 1/1 
       - Loop 34 adds a constant 1/1 
       - Loop 35 adds a constant 1/1 
     - tail Candidate: -C+1 
       - Loop 33 has undefined behavior 
     - tail Candidate: D-1 
       - Loop 33 is collaborative
       - Loop 34 adds a constant 2/1 
       - Loop 35 adds a constant 2/1 
     - tail Candidate: F 
       - Loop 33 is collaborative
       - Loop 34 adds an expression [C-2]
       - Loop 35 is collaborative
 * Adding constraints: [it(36)=<it(35)+it(34)+it(33)+aux(20),it(36)=<aux(23)+aux(22)+aux(21)+aux(24),it(36)=<it(35)*2+it(34)*2+aux(25),it(36)=<aux(26)+aux(27),it(36)=<it(35)+it(34)+it(33)+aux(28),it(36)=<it(35)*2+it(34)*2+aux(29),it(36)=<aux(30)+aux(31),aux(20)=< -A+2,aux(24)=< -C+1,aux(25)=<D-1,aux(27)=<F,aux(28)=< -A+A',aux(29)=<D-D',aux(31)=<F-F'] 

##### Pending set A
* Psum in Loop 33: [aux(21)=<1]
* Psum in Loop 34: [aux(22)=<1,aux(26)=<C-2,aux(30)=<C-2]
* Psum in Loop 35: [aux(23)=<1]
* Psum in Loop 36: [s(29)=<F,s(28)=<A',aux(12)=<D-1,aux(14)=<D-1]

###### Computing sum for aux(21)=<1  in Loop 33 
   - Found a solution using cacheing 
 * Adding constraints: [aux(21)=<aux(32),aux(32)+it(34)+it(35)=<aux(12)+aux(13),aux(32)+it(34)+it(35)=<aux(14)+aux(15)] 

##### Pending set A
* Psum in Loop 34: [aux(22)=<1,aux(26)=<C-2,aux(30)=<C-2]
* Psum in Loop 35: [aux(23)=<1]
* Psum in Loop 36: [s(29)=<F,s(28)=<A',aux(12)=<D-1,aux(14)=<D-1]

###### Computing sum for aux(22)=<1  in Loop 34 
   - Found a solution using cacheing 
 * Adding constraints: [aux(22)=<aux(33),aux(33)+it(33)+it(35)=<aux(12)+aux(16),aux(33)+it(33)+it(35)=<aux(14)+aux(17)] 

##### Pending set A
* Psum in Loop 34: [aux(26)=<C-2,aux(30)=<C-2]
* Psum in Loop 35: [aux(23)=<1]
* Psum in Loop 36: [s(29)=<F,s(28)=<A',aux(12)=<D-1,aux(14)=<D-1]

###### Computing sum for aux(26)=<C-2  in Loop 34 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(34)=<C-2] 
 * Adding constraints: [aux(26)=<it(34)*aux(34)] 

##### Pending set bfs_aux(A,B,C,D,E,F,G,H,I)
* Pmax/min: [aux(34)=<C-2]
* Psum in Loop 34: [aux(30)=<C-2]
* Psum in Loop 35: [aux(23)=<1]
* Psum in Loop 36: [s(29)=<F,s(28)=<A',aux(12)=<D-1,aux(14)=<D-1]

###### Computing max_min for aux(34)=<C-2  
   - Applying max/min strategy 
     - Loop 33 does not increase the expression
     - Loop 34 does not increase the expression
     - Loop 35 does not increase the expression
     - Loop 36  increases the expression by [C'] 
 * Adding constraints:[aux(34)=<aux(35)+aux(36),aux(35)=<C-2] 

##### Pending set bfs_aux(A,B,C,D,E,F,G,H,I)
* Psum in Loop 34: [aux(30)=<C-2]
* Psum in Loop 35: [aux(23)=<1]
* Psum in Loop 36: [s(29)=<F,s(28)=<A',aux(12)=<D-1,aux(14)=<D-1,aux(36)=<C']

###### Computing sum for aux(30)=<C-2  in Loop 34 
   - Found a solution using cacheing 
 * Adding constraints: [aux(30)=<aux(37),aux(37)=<it(34)*aux(34)] 

##### Pending set bfs_aux(A,B,C,D,E,F,G,H,I)
* Psum in Loop 35: [aux(23)=<1]
* Psum in Loop 36: [s(29)=<F,s(28)=<A',aux(12)=<D-1,aux(14)=<D-1,aux(36)=<C']

###### Computing sum for aux(23)=<1  in Loop 35 
   - Found a solution using cacheing 
 * Adding constraints: [aux(23)=<aux(38),aux(38)+it(33)+it(34)=<aux(12)+aux(18),aux(38)+it(33)+it(34)=<aux(14)+aux(19)] 

##### Pending set bfs_aux(A,B,C,D,E,F,G,H,I)
* Psum in Loop 36: [s(29)=<F,s(28)=<A',aux(12)=<D-1,aux(14)=<D-1,aux(36)=<C']

###### Computing sum for s(29)=<F  in Loop 36 
   - Applying inductive sum strategy 
     - head Candidate: F 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: F 
       - The candidate was classified before. We reuse its previous classification 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(41)=<F] 
 * Adding constraints: [s(29)=<it(36)*aux(41),s(29)=<aux(26)+aux(39),s(29)=<aux(30)+aux(40),aux(39)=<F,aux(40)=<F-F'] 

##### Pending set bfs_aux(A,B,C,D,E,F,G,H,I)
* Pmax/min: [aux(41)=<F]
* Psum in Loop 36: [s(28)=<A',aux(12)=<D-1,aux(14)=<D-1,aux(36)=<C']

###### Computing max_min for aux(41)=<F  
   - Applying max/min strategy 
     - Loop 33 does not increase the expression
     - Loop 34  increases the expression by [F',C-2] 
     - Loop 35 does not increase the expression
     - Loop 36 does not increase the expression
 * Adding constraints:[aux(41)=<aux(42)+aux(43),aux(42)=<F] 

##### Pending set bfs_aux(A,B,C,D,E,F,G,H,I)
* Psum in Loop 34: [aux(43)=<C-2,aux(43)=<F']
* Psum in Loop 36: [s(28)=<A',aux(12)=<D-1,aux(14)=<D-1,aux(36)=<C']

###### Computing sum for aux(43)=<C-2  in Loop 34 
   - Found a solution using cacheing 
 * Adding constraints: [aux(43)=<aux(44),aux(44)=<it(34)*aux(34)] 

##### Pending set bfs_aux(A,B,C,D,E,F,G,H,I)
* Psum in Loop 34: [aux(43)=<F']
* Psum in Loop 36: [s(28)=<A',aux(12)=<D-1,aux(14)=<D-1,aux(36)=<C']

###### Computing sum for aux(43)=<F'  in Loop 34 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(45)=<C-2] 
 * Adding constraints: [aux(43)=<it(34)*aux(45)] 

##### Pending set bfs_aux(A,B,C,D,E,F,G,H,I)
* Pmax/min: [aux(45)=<C-2]
* Psum in Loop 36: [s(28)=<A',aux(12)=<D-1,aux(14)=<D-1,aux(36)=<C']

###### Computing max_min for aux(45)=<C-2  
   - Found a solution using cacheing 
 * Adding constraints:[aux(45)=<aux(34)] 

##### Pending set bfs_aux(A,B,C,D,E,F,G,H,I)
* Psum in Loop 36: [s(28)=<A',aux(12)=<D-1,aux(14)=<D-1,aux(36)=<C']

###### Computing sum for s(28)=<A'  in Loop 36 
   - Applying inductive sum strategy 
     - head Candidate: -A+D+1 
       - Loop 33 adds a constant 1/1 
       - Loop 34 adds a constant 3/1 
       - Loop 35 adds a constant 3/1 
     - head Candidate: -C+D 
       - Loop 33 has a reset to  [D]
       - Loop 34 has a reset to  [D+2]
       - Loop 35 has a reset to  [D+2]
     - tail Candidate: -A+D+1 
       - Loop 33 adds a constant 1/1 
       - Loop 34 adds a constant 3/1 
       - Loop 35 adds a constant 3/1 
     - tail Candidate: -C+D 
       - Loop 33 has undefined behavior 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(52)=<D] 
 * Adding constraints: [s(28)=<it(36)*aux(52),s(28)=<it(35)*3+it(34)*3+it(33)+aux(46),s(28)=<aux(49)+aux(48)+aux(47)+aux(50),s(28)=<it(35)*3+it(34)*3+it(33)+aux(51),aux(46)=< -A+D+1,aux(50)=< -C+D,aux(51)=< -A+D+A'-D'] 

##### Pending set bfs_aux(A,B,C,D,E,F,G,H,I)
* Pmax/min: [aux(52)=<D]
* Psum in Loop 33: [aux(47)=<D]
* Psum in Loop 34: [aux(48)=<D+2]
* Psum in Loop 35: [aux(49)=<D+2]
* Psum in Loop 36: [aux(12)=<D-1,aux(14)=<D-1,aux(36)=<C']

###### Computing max_min for aux(52)=<D  
   - Applying max/min strategy 
     - Loop 33 does not increase the expression
     - Loop 34  increases the expression by 2/1 
     - Loop 35  increases the expression by 2/1 
     - Loop 36 does not increase the expression
 * Adding constraints:[aux(52)=<aux(53)+it(34)*2+it(35)*2,aux(53)=<D] 

##### Pending set bfs_aux(A,B,C,D,E,F,G,H,I)
* Psum in Loop 33: [aux(47)=<D]
* Psum in Loop 34: [aux(48)=<D+2]
* Psum in Loop 35: [aux(49)=<D+2]
* Psum in Loop 36: [aux(12)=<D-1,aux(14)=<D-1,aux(36)=<C']

###### Computing sum for aux(47)=<D  in Loop 33 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(54)=<D] 
 * Adding constraints: [aux(47)=<it(33)*aux(54)] 

##### Pending set bfs_aux(A,B,C,D,E,F,G,H,I)
* Pmax/min: [aux(54)=<D]
* Psum in Loop 34: [aux(48)=<D+2]
* Psum in Loop 35: [aux(49)=<D+2]
* Psum in Loop 36: [aux(12)=<D-1,aux(14)=<D-1,aux(36)=<C']

###### Computing max_min for aux(54)=<D  
   - Found a solution using cacheing 
 * Adding constraints:[aux(54)=<aux(52)] 

##### Pending set bfs_aux(A,B,C,D,E,F,G,H,I)
* Psum in Loop 34: [aux(48)=<D+2]
* Psum in Loop 35: [aux(49)=<D+2]
* Psum in Loop 36: [aux(12)=<D-1,aux(14)=<D-1,aux(36)=<C']

###### Computing sum for aux(48)=<D+2  in Loop 34 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(55)=<D+2] 
 * Adding constraints: [aux(48)=<it(34)*aux(55)] 

##### Pending set bfs_aux(A,B,C,D,E,F,G,H,I)
* Pmax/min: [aux(55)=<D+2]
* Psum in Loop 35: [aux(49)=<D+2]
* Psum in Loop 36: [aux(12)=<D-1,aux(14)=<D-1,aux(36)=<C']

###### Computing max_min for aux(55)=<D+2  
   - Found a solution using cacheing 
 * Adding constraints:[aux(55)=<aux(52)+2] 

##### Pending set bfs_aux(A,B,C,D,E,F,G,H,I)
* Psum in Loop 35: [aux(49)=<D+2]
* Psum in Loop 36: [aux(12)=<D-1,aux(14)=<D-1,aux(36)=<C']

###### Computing sum for aux(49)=<D+2  in Loop 35 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(56)=<D+2] 
 * Adding constraints: [aux(49)=<it(35)*aux(56)] 

##### Pending set bfs_aux(A,B,C,D,E,F,G,H,I)
* Pmax/min: [aux(56)=<D+2]
* Psum in Loop 36: [aux(12)=<D-1,aux(14)=<D-1,aux(36)=<C']

###### Computing max_min for aux(56)=<D+2  
   - Found a solution using cacheing 
 * Adding constraints:[aux(56)=<aux(52)+2] 

##### Pending set bfs_aux(A,B,C,D,E,F,G,H,I)
* Psum in Loop 36: [aux(12)=<D-1,aux(14)=<D-1,aux(36)=<C']

###### Computing sum for aux(12)=<D-1  in Loop 36 
   - Applying inductive sum strategy 
     - head Candidate: D-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: D-1 
       - The candidate was classified before. We reuse its previous classification 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(59)=<D-1] 
 * Adding constraints: [aux(12)=<it(36)*aux(59),aux(12)=<it(35)*2+it(34)*2+aux(57),aux(12)=<it(35)*2+it(34)*2+aux(58),aux(57)=<D-1,aux(58)=<D-D'] 

##### Pending set bfs_aux(A,B,C,D,E,F,G,H,I)
* Pmax/min: [aux(59)=<D-1]
* Psum in Loop 36: [aux(14)=<D-1,aux(36)=<C']

###### Computing max_min for aux(59)=<D-1  
   - Found a solution using cacheing 
 * Adding constraints:[aux(59)=<aux(52)-1] 

##### Pending set bfs_aux(A,B,C,D,E,F,G,H,I)
* Psum in Loop 36: [aux(14)=<D-1,aux(36)=<C']

###### Computing sum for aux(14)=<D-1  in Loop 36 
   - Found a solution using cacheing 
 * Adding constraints: [aux(14)=<aux(60),aux(60)=<it(36)*aux(59),aux(60)=<it(35)*2+it(34)*2+aux(57),aux(60)=<it(35)*2+it(34)*2+aux(58)] 

##### Pending set bfs_aux(A,B,C,D,E,F,G,H,I)
* Psum in Loop 36: [aux(36)=<C']

###### Computing sum for aux(36)=<C'  in Loop 36 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [] 
 * Adding constraints: [aux(36)=<it(36)*aux(61)] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [33,34,35,36] 
Found a cycle in the non-final constraints
Could not solve cycle in cost structure.
 Discarded constraints:  
aux(59)=<aux(52)-1
aux(56)=<aux(52)+2
aux(55)=<aux(52)+2
aux(54)=<aux(52)
aux(52)=<aux(53)+it(34)*2+it(35)*2
aux(45)=<aux(34)
aux(41)=<aux(42)+aux(43)
aux(34)=<aux(35)+aux(36)
aux(36)=<it(36)*aux(61)
aux(60)=<it(35)*2+it(34)*2+aux(58)
aux(60)=<it(35)*2+it(34)*2+aux(57)
aux(60)=<it(36)*aux(59)
aux(14)=<aux(60)
aux(12)=<it(35)*2+it(34)*2+aux(58)
aux(12)=<it(35)*2+it(34)*2+aux(57)
aux(12)=<it(36)*aux(59)
aux(49)=<it(35)*aux(56)
aux(48)=<it(34)*aux(55)
aux(47)=<it(33)*aux(54)
s(28)=<it(35)*3+it(34)*3+it(33)+aux(51)
s(28)=<aux(49)+aux(48)+aux(47)+aux(50)
s(28)=<it(35)*3+it(34)*3+it(33)+aux(46)
s(28)=<it(36)*aux(52)
aux(43)=<it(34)*aux(45)
aux(44)=<it(34)*aux(34)
aux(43)=<aux(44)
s(29)=<aux(30)+aux(40)
s(29)=<aux(26)+aux(39)
s(29)=<it(36)*aux(41)
aux(38)+it(33)+it(34)=<aux(14)+aux(19)
aux(38)+it(33)+it(34)=<aux(12)+aux(18)
aux(23)=<aux(38)
aux(37)=<it(34)*aux(34)
aux(30)=<aux(37)
aux(26)=<it(34)*aux(34)
aux(33)+it(33)+it(35)=<aux(14)+aux(17)
aux(33)+it(33)+it(35)=<aux(12)+aux(16)
aux(22)=<aux(33)
aux(32)+it(34)+it(35)=<aux(14)+aux(15)
aux(32)+it(34)+it(35)=<aux(12)+aux(13)
aux(21)=<aux(32)
it(36)=<aux(30)+aux(31)
it(36)=<it(35)*2+it(34)*2+aux(29)
it(36)=<it(35)+it(34)+it(33)+aux(28)
it(36)=<aux(26)+aux(27)
it(36)=<it(35)*2+it(34)*2+aux(25)
it(36)=<aux(23)+aux(22)+aux(21)+aux(24)
it(36)=<it(35)+it(34)+it(33)+aux(20)
it(33)+it(34)+it(35)=<aux(14)+aux(19)
it(33)+it(34)+it(35)=<aux(12)+aux(18)
it(33)+it(34)+it(35)=<aux(14)+aux(17)
it(33)+it(34)+it(35)=<aux(12)+aux(16)
it(33)+it(34)+it(35)=<aux(14)+aux(15)
it(33)+it(34)+it(35)=<aux(12)+aux(13)

#### Simplifying cost structure of phase [33,34,35,36] 
 * Joined equivalent variables [aux(62),aux(13),aux(16),aux(18)] into aux(62)
 * Joined equivalent variables [aux(63),aux(15),aux(17),aux(19)] into aux(63)
 * Joined equivalent variables [aux(64),aux(25),aux(53),aux(57)] into aux(64)
 * Joined equivalent variables [aux(65),aux(29),aux(58)] into aux(65)
 * Joined equivalent variables [aux(66),aux(27),aux(39),aux(42)] into aux(66)
 * Joined equivalent variables [aux(67),aux(31),aux(40)] into aux(67)
 * Joined equivalent variables [it(33),it(34),it(35),it(36)] into it(33)
 * Joined equivalent variables [s(26),s(27)] into s(26)
 * Joined equivalent variables [s(24),s(25)] into s(24)

#### Cost of phase [33,34,35,36]:bfs_aux(A,B,C,D,E,F,G,H,I) -> [bfs_aux(A',B',C',D',E',F',G',H',I')] 
40*it(33)+10*s(24)+10*s(26)+0
Unbounded itvars
it(33) :  it(33)
s(24) :  sum(36),s(20)
s(26) :  sum(36),s(22)

#### Simplifying cost structure of chain [[33,34,35,36]] 
 * Joined equivalent variables [it(33),s(24),s(26)] into it(33)

#### Simplifying cost structure of CE 34 

#### Found solution for phase  [33,34,35,36] in the cache 

#### Cost of phase [33,34,35,36]:bfs_aux(A,B,C,D,E,F,G,H,I) -> [bfs_aux(A',B',C',D',E',F',G',H',I')] 
40*it(33)+10*s(24)+10*s(26)+0
Unbounded itvars
it(33) :  it(33)
s(24) :  sum(36),s(20)
s(26) :  sum(36),s(22)

#### Simplifying cost structure of chain [[33,34,35,36],38] 
 * Joined equivalent variables [it(33),s(24),s(26)] into it(33)

#### Simplifying cost structure of CE 33 

#### Found solution for phase  [33,34,35,36] in the cache 

#### Cost of phase [33,34,35,36]:bfs_aux(A,B,C,D,E,F,G,H,I) -> [bfs_aux(A',B',C',D',E',F',G',H',I')] 
40*it(33)+10*s(24)+10*s(26)+0
Unbounded itvars
it(33) :  it(33)
s(24) :  sum(36),s(20)
s(26) :  sum(36),s(22)

#### Simplifying cost structure of chain [[33,34,35,36],37] 
 * Joined equivalent variables [it(33),s(24),s(26)] into it(33)

#### Cost of chains of bfs_aux(A,B,C,D,E,F,G,H,I):
* Chain [[33,34,35,36]]...: 60*it(33)+0
Unbounded itvars
it(33) :  it(33)

  with precondition: [C+D>=2,C+F>=1,C>=0,A>=1,G>=0,A+D>=3,A+F>=2,F>=0,D>=1,B>=0,E>=0,H>=0,I>=0] 

* Chain [[33,34,35,36],38]: 60*it(33)+5
Unbounded itvars
it(33) :  it(33)

  with precondition: [I=1,A>=1,B>=0,C>=0,D>=1,E>=0,F>=0,G>=0,H>=0,A+D>=3,A+F>=2,C+D>=2,C+F>=1] 

* Chain [[33,34,35,36],37]: 60*it(33)+9
Unbounded itvars
it(33) :  it(33)

  with precondition: [A>=1,B>=0,C>=0,D>=1,E>=0,F>=0,G>=0,I>=3,H>=G,A+D>=3,A+F>=2,C+3*D>=6,C+3*F>=3,A+G+2*D>=5,A+G+2*F>=3] 

* Chain [37]: 9
  with precondition: [A>=2,D>=1,E>=0,F>=0,G>=0,I>=3,B>=G,H>=G,C>=I] 


#### Simplifying cost structure of CE 42 

#### Simplifying cost structure of CE 41 

#### Cost of chains of case_13(A,B,C,D,E,F,G,H):
* Chain [40]: 2
  with precondition: [B=1,F=1,H=0,A>=0,C>=0,D>=1,E>=0,G>=0] 

* Chain [39]: 4
  with precondition: [F=1,H=B,C>=0,D>=1,E>=0,H>=3,A>=E,G>=E] 

 * Renamed intermediate variables: 
[ (eq(43,2),it(33))>>s(30)]

#### Simplifying cost structure of CE 43 
 * Renamed intermediate variables: 
[ (eq(44,2),it(33))>>s(31)]

#### Simplifying cost structure of CE 44 

#### Simplifying cost structure of CE 45 
 * Renamed intermediate variables: 
[ (eq(46,2),it(33))>>s(32)]

#### Simplifying cost structure of CE 46 
 * Renamed intermediate variables: 
[ (eq(47,2),it(33))>>s(33)]

#### Simplifying cost structure of CE 47 

#### Cost of chains of bfs(A,B,C,D,E,F):
* Chain [45]: 60*s(30)+12
Unbounded itvars
s(30) :  eq(43,2),it(33)

  with precondition: [D=1,F=0,A>=0,B>=1,C>=0,E>=0] 

* Chain [44]: 60*s(31)+18
Unbounded itvars
s(31) :  eq(44,2),it(33)

  with precondition: [D=1,A>=0,B>=3,C>=1,F>=3,E>=C] 

* Chain [43]: 18
  with precondition: [D=1,A>=0,C>=0,F>=3,E>=C,B>=F] 

* Chain [42]...: 60*s(32)+7
Unbounded itvars
s(32) :  eq(46,2),it(33)

  with precondition: [D=1,F=0,A>=0,B>=1,C>=0,E>=0] 

* Chain [41]...: 60*s(33)+9
Unbounded itvars
s(33) :  eq(47,2),it(33)

  with precondition: [D=1,A>=0,B>=1,C>=0,F>=3,E>=C] 


#### Computing cost of phase [46,47] 

#### Simplifying cost structure of CE 50 

#### Simplifying cost structure of CE 51 

#### Simplifying cost structure of CE 52 

#### Simplifying cost structure of CE 53 

#### Simplifying cost structure of CE 54 

#### Cost of loops [46,47] 

 * loop 46:dfs_aux(A,B,C,D,E,F,G) -> [dfs_aux(A',B',C',D',E',F',G')] 
11
 * loop 47:dfs_aux(A,B,C,D,E,F,G) -> [dfs_aux(A',B',C',D',E',F',G')] 
6
##### Pending set dfs_aux(A,B,C,D,E,F,G)
* Psum in Loop 46: [it(46)=<1]
* Psum in Loop 47: [it(47)=<1]

###### Computing sum for it(46)=<1  in Loop 46 
   - Applying inductive sum strategy 
   - No strategy succeeded 
 * Adding constraints: [] 

##### Pending set A
* Psum in Loop 47: [it(47)=<1]

###### Computing sum for it(47)=<1  in Loop 47 
   - Applying inductive sum strategy 
     - head Candidate: A-1 
       - Loop 46 adds a constant 1/1 
     - tail Candidate: A-1 
       - Loop 46 adds a constant 1/1 
 * Adding constraints: [it(47)=<it(46)+aux(68),it(47)=<it(46)+aux(69),aux(68)=<A-1,aux(69)=<A-A'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [46,47] 

#### Simplifying cost structure of phase [46,47] 

#### Cost of phase [46,47]:dfs_aux(A,B,C,D,E,F,G) -> [dfs_aux(A',B',C',D',E',F',G')] 
11*it(46)+6*it(47)+0
Unbounded itvars
it(46) :  it(46)
it(47) :  it(47)

#### Simplifying cost structure of chain [[46,47]] 
 * Joined equivalent variables [it(46),it(47)] into it(46)

#### Simplifying cost structure of CE 49 

#### Found solution for phase  [46,47] in the cache 

#### Cost of phase [46,47]:dfs_aux(A,B,C,D,E,F,G) -> [dfs_aux(A',B',C',D',E',F',G')] 
11*it(46)+6*it(47)+0
Unbounded itvars
it(46) :  it(46)
it(47) :  it(47)

#### Simplifying cost structure of chain [[46,47],49] 
 * Joined equivalent variables [it(46),it(47)] into it(46)

#### Simplifying cost structure of CE 48 

#### Found solution for phase  [46,47] in the cache 

#### Cost of phase [46,47]:dfs_aux(A,B,C,D,E,F,G) -> [dfs_aux(A',B',C',D',E',F',G')] 
11*it(46)+6*it(47)+0
Unbounded itvars
it(46) :  it(46)
it(47) :  it(47)

#### Simplifying cost structure of chain [[46,47],48] 
 * Joined equivalent variables [it(46),it(47)] into it(46)

#### Cost of chains of dfs_aux(A,B,C,D,E,F,G):
* Chain [[46,47]]...: 17*it(46)+0
Unbounded itvars
it(46) :  it(46)

  with precondition: [C>=1,B>=0,A>=2,D>=0,E>=0,F>=0,G>=0] 

* Chain [[46,47],49]: 17*it(46)+3
Unbounded itvars
it(46) :  it(46)

  with precondition: [E=1,G=0,A>=2,B>=0,C>=1,D>=0,F>=0] 

* Chain [[46,47],48]: 17*it(46)+9
Unbounded itvars
it(46) :  it(46)

  with precondition: [E=1,A>=2,D>=0,G>=3,B>=D,F>=D,C>=G,A+B>=D+3] 

* Chain [48]: 9
  with precondition: [E=1,A>=2,D>=0,G>=3,F>=D,B>=F,C>=G] 

 * Renamed intermediate variables: 
[ (eq(55,2),it(46))>>s(34)]

#### Simplifying cost structure of CE 55 
 * Renamed intermediate variables: 
[ (eq(56,2),it(46))>>s(35)]

#### Simplifying cost structure of CE 56 

#### Simplifying cost structure of CE 57 
 * Renamed intermediate variables: 
[ (eq(58,2),it(46))>>s(36)]

#### Simplifying cost structure of CE 58 

#### Cost of chains of dfs(A,B,C,D,E,F):
* Chain [52]: 17*s(34)+6
Unbounded itvars
s(34) :  eq(55,2),it(46)

  with precondition: [D=1,F=0,A>=0,B>=1,C>=0,E>=0] 

* Chain [51]: 1*aux(70)+0
Unbounded itvars
aux(70) :  aux(70)

  with precondition: [D=1,A>=0,C>=0,F>=3,E>=C,B>=F] 

* Chain [50]...: 17*s(36)+3
Unbounded itvars
s(36) :  eq(58,2),it(46)

  with precondition: [A>=0,B>=1,C>=0,D>=0,E>=0,F>=0] 


#### Simplifying cost structure of CE 62 

#### Computing cost of phase [55] 

#### Simplifying cost structure of CE 59 

#### Simplifying cost structure of CE 60 

#### Cost of loops [55] 

 * loop 55:split(A,B,C,D,E) -> [split(A',B',C',D',E')] 
14
##### Pending set split(A,B,C,D,E)
* Psum in Loop 55: [it(55)=<1]

###### Computing sum for it(55)=<1  in Loop 55 
   - Applying inductive sum strategy 
     - head Candidate: A/2-1 
     - head Candidate: A/2-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A/2-1 
     - tail Candidate: A/2-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(55)=<A/2-1,it(55)=<A/2-1,it(55)=<A/2-A'/2,it(55)=<A/2-A'/2] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [55] 

#### Simplifying cost structure of phase [55] 

#### Cost of phase [55]:split(A,B,C,D,E) -> [split(A',B',C',D',E')] 
14*it(55)+0
  Such that:it(55) =< A/2
it(55) =< A/2-A'/2

#### Simplifying cost structure of chain [[55],54] 

#### Simplifying cost structure of CE 61 

#### Found solution for phase  [55] in the cache 

#### Cost of phase [55]:split(A,B,C,D,E) -> [split(A',B',C',D',E')] 
14*it(55)+0
  Such that:it(55) =< A/2
it(55) =< A/2-A'/2

#### Simplifying cost structure of chain [[55],53] 

#### Cost of chains of split(A,B,C,D,E):
* Chain [[55],54]: 14*it(55)+5
  Such that:it(55) =< A/2

  with precondition: [C=1,B>=0,D>=2,E>=0,A+1>=2*D] 

* Chain [[55],53]: 14*it(55)+9
  Such that:it(55) =< A/2

  with precondition: [C=1,A>=4,B>=0,D>=2,E>=0,A+2>=2*D] 

* Chain [54]: 5
  with precondition: [A=1,C=1,D=1,B>=0,E>=0] 

* Chain [53]: 9
  with precondition: [A=2,C=1,D=2,B>=0,E>=0] 


#### Simplifying cost structure of CE 67 

#### Simplifying cost structure of CE 63 

#### Simplifying cost structure of chain [multiple(60,[[56]])] 

#### Simplifying cost structure of CE 64 

#### Simplifying cost structure of chain [multiple(59,[[multiple(60,[[56]])],[56]])] 

#### Computing cost of chain [multiple([57,58],[[multiple(60,[[56]])],[multiple(59,[[multiple(60,[[56]])],[56]])],[56]])] with multiple recursion
 * Renamed intermediate variables: 
[ (eq(65,1),it(55))>>s(37)]

#### Simplifying cost structure of CE 65 
 * Renamed intermediate variables: 
[ (it(57),s(37))>>s(38)]
 * Renamed intermediate variables: 
[ (eq(66,1),it(55))>>s(39)]

#### Simplifying cost structure of CE 66 
 * Renamed intermediate variables: 
[ (it(58),s(39))>>s(40)]

#### Cost of loops [57,58] 

 * loop 57:make_btree(A,B,C,D) -> [make_btree(A',B',C',D'),make_btree(A'2,B'2,C'2,D'2)] 
14*s(38)+20
  Such that:s(38) =< A/2

 * loop 58:make_btree(A,B,C,D) -> [make_btree(A',B',C',D'),make_btree(A'2,B'2,C'2,D'2)] 
14*s(40)+16
  Such that:s(40) =< A/2

##### Pending set make_btree(A,B,C,D)
* Psum in Loop 57: [it(57)=<1,s(41)=<A/2]
* Psum in Loop 58: [it(58)=<1,s(42)=<A/2]
* Psum in Chain-Tail [56]: [it([56])=<1]
* Psum in Chain-Tail [multiple(59,[[multiple(60,[[56]])],[56]])]: [it([multiple(59,[[multiple(60,[[56]])],[56]])])=<1]
* Psum in Chain-Tail [multiple(60,[[56]])]: [it([multiple(60,[[56]])])=<1]

###### Computing sum for it(57)=<1  in Loop 57 
   - Applying inductive sum strategy 
     - head Candidate: A/2-3/2 
       - Loop 58 is collaborative
       - Chain [multiple(60,[[56]])] is ignored
       - Chain-Tail [multiple(59,[[multiple(60,[[56]])],[56]])] is collaborative
       - Chain [56] is ignored
     - tail Candidate: A/2-3/2 
       - Loop 58 is collaborative and bounds [it(58)] 
       - Chain-Tail [multiple(60,[[56]])] adds a constant 1/2 
       - Chain-Tail [multiple(59,[[multiple(60,[[56]])],[56]])] is collaborative
       - Chain-Tail [56] adds a constant 1/1 
 * Adding constraints: [it(57)+it(58)=<it([56])+it([multiple(60,[[56]])])* (1/2)+aux(71),it(57)=<A/2-3/2,aux(71)=<A/2-3/2] 

##### Pending set A
* Psum in Loop 57: [s(41)=<A/2]
* Psum in Loop 58: [it(58)=<1,s(42)=<A/2]
* Psum in Chain-Tail [56]: [it([56])=<1]
* Psum in Chain-Tail [multiple(59,[[multiple(60,[[56]])],[56]])]: [it([multiple(59,[[multiple(60,[[56]])],[56]])])=<1]
* Psum in Chain-Tail [multiple(60,[[56]])]: [it([multiple(60,[[56]])])=<1]

###### Computing sum for s(41)=<A/2  in Loop 57 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(72)=<A/2] 
 * Adding constraints: [s(41)=<it(57)*aux(72)] 

##### Pending set make_btree(A,B,C,D)
* Pmax/min: [aux(72)=<A/2]
* Psum in Loop 58: [it(58)=<1,s(42)=<A/2]
* Psum in Chain-Tail [56]: [it([56])=<1]
* Psum in Chain-Tail [multiple(59,[[multiple(60,[[56]])],[56]])]: [it([multiple(59,[[multiple(60,[[56]])],[56]])])=<1]
* Psum in Chain-Tail [multiple(60,[[56]])]: [it([multiple(60,[[56]])])=<1]

###### Computing max_min for aux(72)=<A/2  
   - Found a solution using transitive invariants 
 * Adding constraints:[aux(72)=<A/2] 

##### Pending set make_btree(A,B,C,D)
* Psum in Loop 58: [it(58)=<1,s(42)=<A/2]
* Psum in Chain-Tail [56]: [it([56])=<1]
* Psum in Chain-Tail [multiple(59,[[multiple(60,[[56]])],[56]])]: [it([multiple(59,[[multiple(60,[[56]])],[56]])])=<1]
* Psum in Chain-Tail [multiple(60,[[56]])]: [it([multiple(60,[[56]])])=<1]

###### Computing sum for it(58)=<1  in Loop 58 
   - Applying inductive sum strategy 
     - head Candidate: A-1 
       - Loop 57 is collaborative
       - Chain-Tail [multiple(60,[[56]])] is collaborative and bounds [it([multiple(60,[[56]])])] 
       - Chain-Tail [multiple(59,[[multiple(60,[[56]])],[56]])] is collaborative and bounds [it([multiple(59,[[multiple(60,[[56]])],[56]])])] 
       - Chain-Tail [56] is collaborative
     - head Candidate: A/2-1 
       - Loop 57 is collaborative
       - Chain-Tail [multiple(60,[[56]])] is collaborative
       - Chain-Tail [multiple(59,[[multiple(60,[[56]])],[56]])] is collaborative
       - Chain [56] is ignored
     - tail Candidate: A-1 
       - Loop 57 is collaborative
       - Chain-Tail [multiple(60,[[56]])] is collaborative and bounds [it([multiple(60,[[56]])])] 
       - Chain-Tail [multiple(59,[[multiple(60,[[56]])],[56]])] is collaborative and bounds [it([multiple(59,[[multiple(60,[[56]])],[56]])])] 
       - Chain-Tail [56] is collaborative
     - tail Candidate: A/2-1 
       - Loop 57 is collaborative
       - Chain-Tail [multiple(60,[[56]])] is collaborative
       - Chain-Tail [multiple(59,[[multiple(60,[[56]])],[56]])] is collaborative
       - Chain-Tail [56] adds a constant 1/2 
 * Adding constraints: [it(58)=<it([56])* (1/2)+aux(73),it(58)+it([multiple(59,[[multiple(60,[[56]])],[56]])])+it([multiple(60,[[56]])])=<A-1,it(58)=<A/2-1,it(58)+it([multiple(59,[[multiple(60,[[56]])],[56]])])+it([multiple(60,[[56]])])=<A-1,aux(73)=<A/2-1] 

##### Pending set make_btree(A,B,C,D)
* Psum in Loop 58: [s(42)=<A/2]
* Psum in Chain-Tail [56]: [it([56])=<1]
* Psum in Chain-Tail [multiple(59,[[multiple(60,[[56]])],[56]])]: [it([multiple(59,[[multiple(60,[[56]])],[56]])])=<1]
* Psum in Chain-Tail [multiple(60,[[56]])]: [it([multiple(60,[[56]])])=<1]

###### Computing sum for s(42)=<A/2  in Loop 58 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(74)=<A/2] 
 * Adding constraints: [s(42)=<it(58)*aux(74)] 

##### Pending set make_btree(A,B,C,D)
* Pmax/min: [aux(74)=<A/2]
* Psum in Chain-Tail [56]: [it([56])=<1]
* Psum in Chain-Tail [multiple(59,[[multiple(60,[[56]])],[56]])]: [it([multiple(59,[[multiple(60,[[56]])],[56]])])=<1]
* Psum in Chain-Tail [multiple(60,[[56]])]: [it([multiple(60,[[56]])])=<1]

###### Computing max_min for aux(74)=<A/2  
   - Found a solution using cacheing 
 * Adding constraints:[aux(74)=<aux(72)] 

##### Pending set make_btree(A,B,C,D)
* Psum in Chain-Tail [56]: [it([56])=<1]
* Psum in Chain-Tail [multiple(59,[[multiple(60,[[56]])],[56]])]: [it([multiple(59,[[multiple(60,[[56]])],[56]])])=<1]
* Psum in Chain-Tail [multiple(60,[[56]])]: [it([multiple(60,[[56]])])=<1]

###### Computing sum for it([56])=<1  in Chain-Tail [56] 
   - Applying inductive sum strategy 
     - head Candidate: 1 
       - Loop 57 adds a constant 1/1 
       - Loop 58 adds a constant 1/1 
       - Chain-Tail [multiple(60,[[56]])] is collaborative and bounds [it([multiple(60,[[56]])])] 
       - Chain-Tail [multiple(59,[[multiple(60,[[56]])],[56]])] is collaborative and bounds [it([multiple(59,[[multiple(60,[[56]])],[56]])])] 
     - tail Candidate: 1 
       - Loop 57 adds a constant 1/1 
       - Loop 58 adds a constant 1/1 
       - Chain-Tail [multiple(60,[[56]])] is collaborative and bounds [it([multiple(60,[[56]])])] 
       - Chain-Tail [multiple(59,[[multiple(60,[[56]])],[56]])] is collaborative and bounds [it([multiple(59,[[multiple(60,[[56]])],[56]])])] 
 * Adding constraints: [it([56])+it([multiple(59,[[multiple(60,[[56]])],[56]])])+it([multiple(60,[[56]])])=<it(58)+it(57)+aux(75),it([56])+it([multiple(59,[[multiple(60,[[56]])],[56]])])+it([multiple(60,[[56]])])=<it(58)+it(57)+aux(76),aux(75)=<1,aux(76)=<1] 

##### Pending set make_btree(A,B,C,D)
* Psum in Chain-Tail [multiple(59,[[multiple(60,[[56]])],[56]])]: [it([multiple(59,[[multiple(60,[[56]])],[56]])])=<1]
* Psum in Chain-Tail [multiple(60,[[56]])]: [it([multiple(60,[[56]])])=<1]

###### Computing sum for it([multiple(59,[[multiple(60,[[56]])],[56]])])=<1  in Chain-Tail [multiple(59,[[multiple(60,[[56]])],[56]])] 
   - Applying inductive sum strategy 
     - head Candidate: A/2-1/2 
       - Loop 57 is collaborative
       - Loop 58 is collaborative
       - Chain-Tail [multiple(60,[[56]])] is collaborative
       - Chain-Tail [56] is collaborative
     - tail Candidate: A/2-1/2 
       - Loop 57 is collaborative
       - Loop 58 is collaborative
       - Chain-Tail [multiple(60,[[56]])] is collaborative
       - Chain-Tail [56] is collaborative
 * Adding constraints: [it([multiple(59,[[multiple(60,[[56]])],[56]])])=<A/2-1/2,it([multiple(59,[[multiple(60,[[56]])],[56]])])=<A/2-1/2] 

##### Pending set make_btree(A,B,C,D)
* Psum in Chain-Tail [multiple(60,[[56]])]: [it([multiple(60,[[56]])])=<1]

###### Computing sum for it([multiple(60,[[56]])])=<1  in Chain-Tail [multiple(60,[[56]])] 
   - Applying inductive sum strategy 
     - head Candidate: A-1 
       - Loop 57 is collaborative
       - Loop 58 is collaborative
       - Chain-Tail [multiple(59,[[multiple(60,[[56]])],[56]])] is collaborative
       - Chain-Tail [56] is collaborative
     - tail Candidate: A-1 
       - Loop 57 is collaborative
       - Loop 58 is collaborative
       - Chain-Tail [multiple(59,[[multiple(60,[[56]])],[56]])] is collaborative
       - Chain-Tail [56] is collaborative
 * Adding constraints: [it([multiple(60,[[56]])])=<A-1,it([multiple(60,[[56]])])=<A-1] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [57,58,[multiple(60,[[56]])],[multiple(59,[[multiple(60,[[56]])],[56]])],[56]] 
Found a cycle in the non-final constraints
 Removed possibly redundant constraints to solve a cycle in the cost structure 
it(57)+it(58)=<it([56])+it([multiple(60,[[56]])])* (1/2)+aux(71)
it(58)=<it([56])* (1/2)+aux(73)

#### Simplifying cost structure of phase [57,58,[multiple(60,[[56]])],[multiple(59,[[multiple(60,[[56]])],[56]])],[56]] 
 * Joined equivalent variables [aux(77),aux(75),aux(76)] into aux(77)
 * Joined equivalent variables [aux(79),aux(71),aux(72),aux(73)] into aux(79)

#### Cost of phase [57,58]:make_btree(A,B,C,D) -> [] 
20*it(57)+16*it(58)+3*it([56])+64*it([multiple(59,[[multiple(60,[[56]])],[56]])])+22*it([multiple(60,[[56]])])+14*s(41)+14*s(42)+0
  Such that:aux(77) =< 1
aux(78) =< A
aux(79) =< A/2
it(58) =< aux(78)
it([multiple(59,[[multiple(60,[[56]])],[56]])]) =< aux(78)
it([multiple(60,[[56]])]) =< aux(78)
it(57) =< aux(79)
it(58) =< aux(79)
it([multiple(59,[[multiple(60,[[56]])],[56]])]) =< aux(79)
aux(74) =< aux(79)
it([56]) =< it(58)+it(57)+aux(77)
it([multiple(59,[[multiple(60,[[56]])],[56]])]) =< it(58)+it(57)+aux(77)
it([multiple(60,[[56]])]) =< it(58)+it(57)+aux(77)
s(42) =< it(58)*aux(74)
s(41) =< it(57)*aux(79)

#### Cost of chains of make_btree(A,B,C,D):
* Chain [multiple(60,[[56]])]: 22
  with precondition: [A=2,D=3,B>=0,C>=0] 

* Chain [multiple(59,[[multiple(60,[[56]])],[56]])]: 64
  with precondition: [A=3,7>=D,B>=0,C>=0,D>=3] 

* Chain [56]: 3
  with precondition: [A=1,D=1,B>=0,C>=0] 

* Chain [multiple([57,58],[[multiple(60,[[56]])],[multiple(59,[[multiple(60,[[56]])],[56]])],[56]])]: 20*it(57)+16*it(58)+3*it([56])+64*it([multiple(59,[[multiple(60,[[56]])],[56]])])+22*it([multiple(60,[[56]])])+14*s(41)+14*s(42)+0
  Such that:aux(77) =< 1
aux(78) =< A
aux(79) =< A/2
it(58) =< aux(78)
it([multiple(59,[[multiple(60,[[56]])],[56]])]) =< aux(78)
it([multiple(60,[[56]])]) =< aux(78)
it(57) =< aux(79)
it(58) =< aux(79)
it([multiple(59,[[multiple(60,[[56]])],[56]])]) =< aux(79)
aux(74) =< aux(79)
it([56]) =< it(58)+it(57)+aux(77)
it([multiple(59,[[multiple(60,[[56]])],[56]])]) =< it(58)+it(57)+aux(77)
it([multiple(60,[[56]])]) =< it(58)+it(57)+aux(77)
s(42) =< it(58)*aux(74)
s(41) =< it(57)*aux(79)

  with precondition: [A>=4,B>=0,C>=0,D>=3] 


Closed-form bounds of dfs(A,B,C,D,E,F): 
-------------------------------------
* Chain [52] with precondition: [D=1,F=0,A>=0,B>=1,C>=0,E>=0] 
    - Upper bound: inf 
    - Complexity: infinity 
* Chain [51] with precondition: [D=1,A>=0,C>=0,F>=3,E>=C,B>=F] 
    - Upper bound: inf 
    - Complexity: infinity 
* Chain [50]... with precondition: [A>=0,B>=1,C>=0,D>=0,E>=0,F>=0] 
    - Upper bound: inf 
    - Complexity: infinity 

### Maximum cost of dfs(A,B,C,D,E,F): inf 
Asymptotic class: infinity 

Closed-form bounds of make_btree(A,B,C,D): 
-------------------------------------
* Chain [multiple(60,[[56]])] with precondition: [A=2,D=3,B>=0,C>=0] 
    - Upper bound: 22 
    - Complexity: constant 
* Chain [multiple(59,[[multiple(60,[[56]])],[56]])] with precondition: [A=3,7>=D,B>=0,C>=0,D>=3] 
    - Upper bound: 64 
    - Complexity: constant 
* Chain [56] with precondition: [A=1,D=1,B>=0,C>=0] 
    - Upper bound: 3 
    - Complexity: constant 
* Chain [multiple([57,58],[[multiple(60,[[56]])],[multiple(59,[[multiple(60,[[56]])],[56]])],[56]])] with precondition: [A>=4,B>=0,C>=0,D>=3] 
    - Upper bound: 233/2*A+3+7*A*A+A/2* (7*A) 
    - Complexity: n^2 

### Maximum cost of make_btree(A,B,C,D): max([61,233/2*A+7*A*A+A/2* (7*A)])+3 
Asymptotic class: n^2 
 * Joined equivalent variables [aux(80),aux(9),aux(10)] into aux(80)

Closed-form bounds of append_rev(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O): 
-------------------------------------
* Chain [[26,27,28,29],30] with precondition: [F=I,A+F=K+1,D+F=N+1,A>=1,B>=0,C>=0,D>=1,E>=0,F>=2,G>=0,H>=1,J>=1,M>=1,O>=1,L>=B,M>=C,O>=E] 
    - Upper bound: 5*F+2+nat(-C+H)*10+nat(-E+J)*5 
    - Complexity: n 
* Chain [30] with precondition: [F=1,H=0,I=1,J=0,A=K,B=L,C=M,D=N,E=O,A>=0,B>=0,C>=0,D>=0,E>=0,G>=0] 
    - Upper bound: 2 
    - Complexity: constant 

### Maximum cost of append_rev(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O): nat(-C+H)*10+5*F+nat(-E+J)*5+2 
Asymptotic class: n 

Closed-form bounds of revL(A,B,C,D,E,F,G,H,I,J): 
-------------------------------------
* Chain [32] with precondition: [A=1,C=0,D=1,E=0,F=1,H=0,I=1,J=0,B>=0,G>=0] 
    - Upper bound: 4 
    - Complexity: constant 
* Chain [31] with precondition: [A=D,A=F,A=I,A>=2,B>=0,C>=1,E>=1,G>=0,H>=1,J>=1] 
    - Upper bound: 10*C+5*D+5*E+4 
    - Complexity: n 

### Maximum cost of revL(A,B,C,D,E,F,G,H,I,J): 10*C+5*D+5*E+4 
Asymptotic class: n 

Closed-form bounds of bfs(A,B,C,D,E,F): 
-------------------------------------
* Chain [45] with precondition: [D=1,F=0,A>=0,B>=1,C>=0,E>=0] 
    - Upper bound: inf 
    - Complexity: infinity 
* Chain [44] with precondition: [D=1,A>=0,B>=3,C>=1,F>=3,E>=C] 
    - Upper bound: inf 
    - Complexity: infinity 
* Chain [43] with precondition: [D=1,A>=0,C>=0,F>=3,E>=C,B>=F] 
    - Upper bound: 18 
    - Complexity: constant 
* Chain [42]... with precondition: [D=1,F=0,A>=0,B>=1,C>=0,E>=0] 
    - Upper bound: inf 
    - Complexity: infinity 
* Chain [41]... with precondition: [D=1,A>=0,B>=1,C>=0,F>=3,E>=C] 
    - Upper bound: inf 
    - Complexity: infinity 

### Maximum cost of bfs(A,B,C,D,E,F): inf 
Asymptotic class: infinity 
* Total analysis performed in 4497 ms.


Cost relation system solved by CoFloCo in 4501 ms.

Method dfs terminates?: YES

 - t_1: size of t wrt. Rat
 - t_2: size of t wrt. Btree
 - x_1: size of x wrt. Rat
UB for dfs(t_1,t_2,x_1) = inf

Method make_btree terminates?: YES

 - l_1: size of l wrt. List<Rat>
 - l_2: size of l wrt. Rat
UB for make_btree(l_1,l_2) = max([61,233/2*l_1+7*l_1*l_1+l_1/2* (7*l_1)])+3

Method append_rev terminates?: YES

 - acc_1: size of acc wrt. List<Btree>
 - acc_2: size of acc wrt. Rat
 - acc_3: size of acc wrt. Btree
 - acc_4: size of acc wrt. List<A>
 - acc_5: size of acc wrt. A
 - l_1: size of l wrt. List<Btree>
 - l_2: size of l wrt. Rat
 - l_3: size of l wrt. Btree
 - l_4: size of l wrt. List<A>
 - l_5: size of l wrt. A
UB for append_rev(acc_1,acc_2,acc_3,acc_4,acc_5,l_1,l_2,l_3,l_4,l_5) = nat(-acc_3+l_3)*10+5*l_1+nat(-acc_5+l_5)*5+2

Method revL terminates?: YES

 - l_1: size of l wrt. List<Btree>
 - l_2: size of l wrt. Rat
 - l_3: size of l wrt. Btree
 - l_4: size of l wrt. List<A>
 - l_5: size of l wrt. A
UB for revL(l_1,l_2,l_3,l_4,l_5) = 10*l_3+5*l_4+5*l_5+4

Method bfs terminates?: YES

 - t_1: size of t wrt. Rat
 - t_2: size of t wrt. Btree
 - x_1: size of x wrt. Rat
UB for bfs(t_1,t_2,x_1) = inf
