
Abs program loaded in 12 ms.

Rule based representation generated in 1 ms.

Rule based representation stored in /tmp/costabs/rbr.rbr

RBR properties stored in /tmp/costabs/rbr.properties

Class invariants generated and loaded in 0 ms.

Abstract compilation performed in 7 ms.

Cost relation system stored in /tmp/costabs/crs.crs

Generated 35 equations 
entry('leqL'(A,B,C,D,E):[]).
entry('insertL'(A,B,C,D,E,F,G,H):[]).
entry('isortlist'(A,B,C,D,E,F):[]).
input_output_vars('and_op'(A,B,C),[A,B],[C]).
input_output_vars('case_0'(A,B,C,D,E),[A,B,C,D],[E]).
input_output_vars('case_1'(A,B,C,D,E,F,G,H),[A,B,C,D,E,F,G],[H]).
input_output_vars('case_2'(A,B,C,D,E,F,G,H),[A,B,C,D,E],[F,G,H]).
input_output_vars('case_3'(A,B,C,D,E,F,G,H,I,J,K,L,M,N),[A,B,C,D,E,F,G,H,I,J,K],[L,M,N]).
input_output_vars('case_4'(A,B,C,D,E,F),[A,B,C],[D,E,F]).
input_output_vars('eq'(A,B,C),[A,B],[C]).
input_output_vars('geq'(A,B,C),[A,B],[C]).
input_output_vars('gt'(A,B,C),[A,B],[C]).
input_output_vars('insertL'(A,B,C,D,E,F,G,H),[A,B,C,D,E],[F,G,H]).
input_output_vars('isortlist'(A,B,C,D,E,F),[A,B,C],[D,E,F]).
input_output_vars('leq'(A,B,C),[A,B],[C]).
input_output_vars('leqL'(A,B,C,D,E),[A,B,C,D],[E]).
input_output_vars('lt'(A,B,C),[A,B],[C]).
input_output_vars('maxNorm'(A,B,C),[A,B],[C]).
input_output_vars('neg'(A,B),[A],[B]).
input_output_vars('neq'(A,B,C),[A,B],[C]).
input_output_vars('or'(A,B,C),[A,B],[C]).
eq('eq',[A,B,C],0,[],[A=B,C=1,A>=0,B>=0,C>=0]).
eq('eq',[A,B,C],0,[],[A>=B+1,C=0,A>=0,B>=0,C>=0]).
eq('eq',[A,B,C],0,[],[B>=A+1,C=0,A>=0,B>=0,C>=0]).
eq('neq',[A,B,C],0,[],[A=B,C=0,A>=0,B>=0,C>=0]).
eq('neq',[A,B,C],0,[],[A>=B+1,C=1,A>=0,B>=0,C>=0]).
eq('neq',[A,B,C],0,[],[B>=A+1,C=1,A>=0,B>=0,C>=0]).
eq('lt',[A,B,C],0,[],[B-A>=1,C=1,A>=0,B>=0,C>=0]).
eq('lt',[A,B,C],0,[],[B=<A,C=0,A>=0,B>=0,C>=0]).
eq('leq',[A,B,C],0,[],[A=<B,C=1,A>=0,B>=0,C>=0]).
eq('leq',[A,B,C],0,[],[A-B>=1,C=0,A>=0,B>=0,C>=0]).
eq('gt',[A,B,C],0,[],[A-B>=1,C=1,A>=0,B>=0,C>=0]).
eq('gt',[A,B,C],0,[],[A=<B,C=0,A>=0,B>=0,C>=0]).
eq('geq',[A,B,C],0,[],[B=<A,C=1,A>=0,B>=0,C>=0]).
eq('geq',[A,B,C],0,[],[B-A>=1,C=0,A>=0,B>=0,C>=0]).
eq('neg',[A,B],0,[],[A=0,B=1,A>=0,B>=0]).
eq('neg',[A,B],0,[],[A=1,B=0,A>=0,B>=0]).
eq('and_op',[A,B,C],0,[],[A=0,C=0,A>=0,B>=0,C>=0]).
eq('and_op',[A,B,C],0,[],[A=1,C=B,A>=0,B>=0,C>=0]).
eq('or',[A,B,C],0,[],[A=1,C=1,A>=0,B>=0,C>=0]).
eq('or',[A,B,C],0,[],[A=0,C=B,A>=0,B>=0,C>=0]).
eq('maxNorm',[A,B,A],0,[],[A>=1+B,A>=0,B>=0,A>=0]).
eq('maxNorm',[A,B,B],0,[],[A=<B,A>=0,B>=0,B>=0]).
eq('case_0',[A,B,C,D,E],2,[],[A=1,E=1,A>=0,B>=0,C>=0,D>=0,E>=0]).
eq('case_1',[A,B,C,D,E,F,G,H],2,[],[C=1,H=0,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0]).
eq('case_1',[A,B,C,D,E,F,G,H],5,['leq'(E,I,J),'leqL'(F,G,K,L,M),'and_op'(J,M,H)],[D>=I,D>=L,C=K+1,K>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0]).
eq('case_0',[A,B,C,D,E],3,['case_1'(A,B,C,D,F,G,H,E)],[B>=F,B>=H,A=G+1,G>=1,A>=0,B>=0,C>=0,D>=0,E>=0]).
eq('leqL',[A,B,C,D,E],1,['case_0'(A,B,C,D,E)],[A>=0,B>=0,C>=0,D>=0,E>=0]).
eq('case_2',[A,B,C,D,E,F,G,H],3,['maxNorm'(A,I,G)],[D=0,C=1,I=0,J=1,H>=B,H>=K,F=J+1,J>=1,A>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0]).
eq('case_3',[A,B,C,D,E,F,G,H,I,J,K,L,M,N],3,['insertL'(B,C,I,J,K,O,P,Q),'maxNorm'(G,P,M)],[A=1,N>=H,N>=Q,L=O+1,O>=1,G>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0,M>=0,N>=0]).
eq('case_3',[A,B,C,D,E,F,G,H,I,J,K,L,M,N],4,['maxNorm'(G,J,O),'maxNorm'(B,O,M)],[A=0,P>=H,P>=K,Q=I+1,I>=1,G>=1,N>=C,N>=P,L=Q+1,Q>=1,B>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0,M>=0,N>=0]).
eq('case_2',[A,B,C,D,E,F,G,H],4,['leqL'(I,J,A,B,K),'case_3'(K,A,B,C,D,E,I,J,L,M,N,F,G,H)],[E>=J,E>=N,D>=I,D>=M,C=L+1,L>=1,I>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0]).
eq('insertL',[A,B,C,D,E,F,G,H],1,['case_2'(A,B,C,D,E,F,G,H)],[A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0]).
eq('case_4',[A,B,C,D,E,F],2,[],[B=0,A=1,E=0,D=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0]).
eq('case_4',[A,B,C,D,E,F],4,['isortlist'(G,H,I,J,K,L),'insertL'(M,N,J,K,L,D,E,F)],[C>=N,C>=I,B>=M,B>=H,A=G+1,G>=1,M>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0]).
eq('isortlist',[A,B,C,D,E,F],1,['case_4'(A,B,C,D,E,F)],[A>=0,B>=0,C>=0,D>=0,E>=0,F>=0]).

Preprocessing Cost Relations
=====================================

#### Computed strongly connected components 
0. non_recursive  : [maxNorm/3]
1. non_recursive  : [and_op/3]
2. non_recursive  : [leq/3]
3. recursive [non_tail] : [case_0/5,case_1/8,leqL/5]
4. recursive [non_tail] : [case_2/8,case_3/14,insertL/8]
5. recursive [non_tail] : [case_4/6,isortlist/6]
Warning: the following predicates are never called:[eq/3,geq/3,gt/3,lt/3,neg/2,neq/3,or/3]

#### Obtained direct recursion through partial evaluation 
0. SCC is partially evaluated into maxNorm/3
1. SCC is partially evaluated into and_op/3
2. SCC is partially evaluated into leq/3
3. SCC is partially evaluated into leqL/5
4. SCC is partially evaluated into insertL/8
5. SCC is partially evaluated into isortlist/6

Control-Flow Refinement of Cost Relations
=====================================

### Specialization of cost equations maxNorm/3 
* CE 14 is refined into CE [15] 
* CE 13 is refined into CE [16] 


#### Refined cost equations maxNorm/3 
* CE 15: maxNorm(A,B,B) = 0
     [B>=A,A>=1] 
* CE 16: maxNorm(A,B,A) = 0
     [A>=B+1,B>=0] 

### Cost equations --> "Loop" of maxNorm/3 
* CEs [15] --> Loop 15 
* CEs [16] --> Loop 16 

#### Loops of maxNorm/3 
* Loop 15: maxNorm(A,B,B) [B>=A,A>=1] 
* Loop 16: maxNorm(A,B,A) [A>=B+1,B>=0] 

### Ranking functions of CR maxNorm(A,B,C) 

#### Partial ranking functions of CR maxNorm(A,B,C) 


### Resulting Chains:maxNorm(A,B,C) 
* [16]
* [15]


### Merging Chains  maxNorm/3 into  External patterns of execution 
* [[16]] --> 1 
* [[15]] --> 2 


### Specialization of cost equations and_op/3 
* CE 12 is refined into CE [17] 
* CE 11 is refined into CE [18] 


#### Refined cost equations and_op/3 
* CE 17: and_op(A,B,B) = 0
     [B>=0,A=1] 
* CE 18: and_op(A,B,C) = 0
     [B>=0,C=0,A=0] 

### Cost equations --> "Loop" of and_op/3 
* CEs [17] --> Loop 17 
* CEs [18] --> Loop 18 

#### Loops of and_op/3 
* Loop 17: and_op(A,B,B) [B>=0,A=1] 
* Loop 18: and_op(A,B,C) [B>=0,C=0,A=0] 

### Ranking functions of CR and_op(A,B,C) 

#### Partial ranking functions of CR and_op(A,B,C) 


### Resulting Chains:and_op(A,B,C) 
* [18]
* [17]


### Merging Chains  and_op/3 into  External patterns of execution 
* [[18]] --> 1 
* [[17]] --> 2 


### Specialization of cost equations leq/3 
* CE 9 is refined into CE [19] 
* CE 10 is refined into CE [20] 


#### Refined cost equations leq/3 
* CE 19: leq(A,B,C) = 0
     [B>=A,A>=0,C=1] 
* CE 20: leq(A,B,C) = 0
     [A>=B+1,B>=0,C=0] 

### Cost equations --> "Loop" of leq/3 
* CEs [19] --> Loop 19 
* CEs [20] --> Loop 20 

#### Loops of leq/3 
* Loop 19: leq(A,B,C) [B>=A,A>=0,C=1] 
* Loop 20: leq(A,B,C) [A>=B+1,B>=0,C=0] 

### Ranking functions of CR leq(A,B,C) 

#### Partial ranking functions of CR leq(A,B,C) 


### Resulting Chains:leq(A,B,C) 
* [20]
* [19]


### Merging Chains  leq/3 into  External patterns of execution 
* [[20]] --> 1 
* [[19]] --> 2 


### Specialization of cost equations leqL/5 
* CE 3 is refined into CE [21,22] 
* CE 2 is refined into CE [23] 
* CE 1 is refined into CE [24] 


#### Refined cost equations leqL/5 
* CE 21: leqL(A,B,C,D,E) = 9+ leq(F,G,H):1+ leqL(I,J,K,L,M)+ and_op(N,M,O):1
     [D>=L,B>=J,F>=G+1,D>=G,B>=F,K>=1,J>=0,I>=1,M>=0,G>=0,K+1=C,I+1=A,O=0,N=0,H=0,E=0] 
* CE 22: leqL(A,B,C,D,E) = 9+ leq(F,G,H):2+ leqL(I,J,K,L,E)+ and_op(M,E,E):2
     [D>=L,B>=J,D>=G,G>=F,B>=F,K>=1,J>=0,I>=1,E>=0,F>=0,K+1=C,I+1=A,M=1,H=1] 
* CE 23: leqL(A,B,C,D,E) = 6
     [D>=0,B>=0,A>=2,E=0,C=1] 
* CE 24: leqL(A,B,C,D,E) = 3
     [D>=0,C>=0,B>=0,E=1,A=1] 

### Cost equations --> "Loop" of leqL/5 
* CEs [23] --> Loop 21 
* CEs [24] --> Loop 22 
* CEs [22] --> Loop 23 
* CEs [21] --> Loop 24 

#### Loops of leqL/5 
* Loop 21: leqL(A,B,C,D,E) [D>=0,B>=0,A>=2,E=0,C=1] 
* Loop 22: leqL(A,B,C,D,E) [D>=0,C>=0,B>=0,E=1,A=1] 
* Loop 23: leqL(A,B,C,D,E)->  leqL(A',B',C',D',E)
                  [D>=D',B>=B',B'>=0,E>=0,D>=0,C>=2,A>=2,C=C'+1,A=A'+1] 
* Loop 24: leqL(A,B,C,D,E)->  leqL(A',B',C',D',E')
                  [D>=D',B>=B',E'>=0,B'>=0,D>=0,C>=2,B>=1,A>=2,C=C'+1,A=A'+1,E=0] 

### Ranking functions of CR leqL(A,B,C,D,E) 
* RF of phase [23,24]: [A-1,C-1]

#### Partial ranking functions of CR leqL(A,B,C,D,E) 
* Partial RF of phase [23,24]:
  - RF of loop [23:1,24:1]:
    A-1
    C-1

Discarded unfeasible chain [[23,24]]...(Non-terminating chain proved terminating)

### Resulting Chains:leqL(A,B,C,D,E) 
* [[23,24],22]
* [[23,24],21]
* [22]
* [21]


### Merging Chains  leqL/5 into  External patterns of execution 
* [[22]] --> 1 
* [[21]] --> 2 
* [[21,[23,24]]] --> 3 
* [[22,[23,24]]] --> 4 


### Specialization of cost equations insertL/8 
* CE 6 is refined into CE [25,26,27,28,29,30,31,32] 
* CE 4 is refined into CE [33] 
* CE 5 is refined into CE [34,35,36,37] 


#### Refined cost equations insertL/8 
* CE 25: insertL(A,B,C,D,E,F,G,H) = 9+ leqL(G,I,J,B,K):2+ maxNorm(G,L,G):1+ maxNorm(M,G,G):2
     [D>=G,G>=L+1,H>=B,H>=I,E>=I,G>=2,L>=0,B>=0,I>=0,F>=3,F=C+1,M=1,K=0,J=1,A=1] 
* CE 26: insertL(A,B,C,D,E,F,G,H) = 9+ leqL(I,J,K,B,L):2+ maxNorm(I,G,G):2+ maxNorm(M,G,G):2
     [D>=G,G>=I,H>=B,H>=J,E>=J,I>=2,B>=0,J>=0,F>=3,F=C+1,M=1,L=0,K=1,A=1] 
* CE 27: insertL(A,B,C,D,E,F,G,H) = 9+ leqL(G,I,A,B,J):3+ maxNorm(G,K,G):1+ maxNorm(A,G,G):2
     [D>=G,G>=A+1,G>=K+1,H>=B,H>=I,E>=I,A>=2,K>=0,B>=0,I>=0,F>=3,F=C+1,J=0] 
* CE 28: insertL(A,B,C,D,E,F,G,H) = 9+ leqL(I,J,A,B,K):3+ maxNorm(I,G,G):2+ maxNorm(A,G,G):2
     [D>=G,I>=A+1,G>=I,H>=B,H>=J,E>=J,A>=2,B>=0,J>=0,F>=3,F=C+1,K=0] 
* CE 29: insertL(A,B,C,D,E,F,A,G) = 9+ leqL(H,I,A,B,J):4+ maxNorm(H,K,H):1+ maxNorm(A,H,A):1
     [A>=H+1,D>=H,H>=K+1,G>=B,G>=I,E>=I,H>=2,K>=0,B>=0,I>=1,F>=3,F=C+1,J=0] 
* CE 30: insertL(A,B,C,D,E,F,A,G) = 9+ leqL(A,H,A,B,I):4+ maxNorm(A,J,A):1+ maxNorm(A,A,A):2
     [D>=A,A>=J+1,G>=B,G>=H,E>=H,A>=2,J>=0,B>=0,H>=1,F>=3,F=C+1,I=0] 
* CE 31: insertL(A,B,C,D,E,F,A,G) = 9+ leqL(H,I,A,B,J):4+ maxNorm(H,K,K):2+ maxNorm(A,K,A):1
     [A>=K+1,D>=K,K>=H,G>=B,G>=I,E>=I,H>=2,B>=0,I>=1,F>=3,F=C+1,J=0] 
* CE 32: insertL(A,B,C,D,E,F,G,H) = 9+ leqL(I,J,A,B,K):4+ maxNorm(I,G,G):2+ maxNorm(A,G,G):2
     [D>=G,G>=A,A>=I,H>=B,H>=J,E>=J,I>=2,B>=0,J>=1,F>=3,F=C+1,K=0] 
* CE 33: insertL(A,B,C,D,E,F,A,G) = 4+ maxNorm(A,H,A):1
     [G>=B,A>=1,E>=0,B>=0,H=0,F=2,D=0,C=1] 
* CE 34: insertL(A,B,C,D,E,F,G,H) = 8+ leqL(I,J,A,B,K):1+ insertL(A,B,L,M,N,O,P,Q)+ maxNorm(R,S,T):1
     [H>=Q,E>=N,D>=M,H>=J,E>=J,O>=1,N>=0,M>=0,L>=1,B>=0,A>=0,J>=0,D>=1,O+1=F,L+1=C,P=0,T=1,S=0,R=1,K=1,I=1,G=1] 
* CE 35: insertL(A,B,C,D,E,F,G,H) = 8+ leqL(I,J,A,B,K):1+ insertL(A,B,L,M,N,O,G,P)+ maxNorm(Q,G,G):2
     [H>=P,E>=N,D>=M,H>=J,E>=J,O>=1,N>=0,M>=0,L>=1,G>=1,B>=0,A>=0,J>=0,D>=1,O+1=F,L+1=C,Q=1,K=1,I=1] 
* CE 36: insertL(A,B,C,D,E,F,G,H) = 8+ leqL(G,I,A,B,J):4+ insertL(A,B,K,L,M,N,O,P)+ maxNorm(G,O,G):1
     [H>=P,E>=M,D>=L,A>=G,D>=G,G>=O+1,H>=I,E>=I,N>=1,M>=0,L>=0,K>=1,G>=2,O>=0,B>=0,I>=0,N+1=F,K+1=C,J=1] 
* CE 37: insertL(A,B,C,D,E,F,G,H) = 8+ leqL(I,J,A,B,K):4+ insertL(A,B,L,M,N,O,G,P)+ maxNorm(I,G,G):2
     [H>=P,E>=N,D>=M,G>=I,A>=I,D>=I,H>=J,E>=J,O>=1,N>=0,M>=0,L>=1,I>=2,B>=0,J>=0,O+1=F,L+1=C,K=1] 

### Cost equations --> "Loop" of insertL/8 
* CEs [36] --> Loop 25 
* CEs [35,37] --> Loop 26 
* CEs [34] --> Loop 27 
* CEs [27,28] --> Loop 28 
* CEs [29,31] --> Loop 29 
* CEs [30,32] --> Loop 30 
* CEs [33] --> Loop 31 
* CEs [25,26] --> Loop 32 

#### Loops of insertL/8 
* Loop 25: insertL(A,B,C,D,E,F,G,H)->  insertL(A,B,A',B',C',D',E',F')
                  [H>=F',G>=E'+1,E>=C',D>=B',D>=G,A>=G,E'>=0,C'>=0,B'>=0,H>=0,G>=2,F>=2,C>=2,B>=0,F=D'+1,C=A'+1] 
* Loop 26: insertL(A,B,C,D,E,F,G,H)->  insertL(A,B,A',B',C',D',G,E')
                  [H>=E',E>=C',D>=B',C'>=0,B'>=0,H>=0,G>=1,F>=2,D>=1,C>=2,B>=0,A>=0,F=D'+1,C=A'+1] 
* Loop 27: insertL(A,B,C,D,E,F,G,H)->  insertL(A,B,A',B',C',D',E',F')
                  [H>=F',E>=C',D>=B',C'>=0,B'>=0,H>=0,F>=2,D>=1,C>=2,B>=0,A>=0,F=D'+1,C=A'+1,E'=0,G=1] 
* Loop 28: insertL(A,B,C,D,E,F,G,H) [D>=G,H>=B,G>=A+1,E>=0,C>=2,B>=0,A>=2,C+1=F] 
* Loop 29: insertL(A,B,C,D,E,F,A,G) [G>=B,G>=1,E>=1,D>=2,C>=2,B>=0,A>=3,C+1=F] 
* Loop 30: insertL(A,B,C,D,E,F,G,H) [D>=G,H>=B,G>=A,H>=1,E>=1,C>=2,B>=0,A>=2,C+1=F] 
* Loop 31: insertL(A,B,C,D,E,F,A,G) [G>=B,E>=0,B>=0,A>=1,F=2,D=0,C=1] 
* Loop 32: insertL(A,B,C,D,E,F,G,H) [D>=G,H>=B,G>=2,E>=0,C>=2,B>=0,C+1=F,A=1] 

### Ranking functions of CR insertL(A,B,C,D,E,F,G,H) 
* RF of phase [25,26]: [C-1]

#### Partial ranking functions of CR insertL(A,B,C,D,E,F,G,H) 
* Partial RF of phase [25,26]:
  - RF of loop [25:1,26:1]:
    C-1

Discarded unfeasible chain [[25,26]]...(Non-terminating chain proved terminating)

### Resulting Chains:insertL(A,B,C,D,E,F,G,H) 
* [[25,26],32]
* [[25,26],31]
* [[25,26],30]
* [[25,26],29]
* [[25,26],28]
* [32]
* [31]
* [30]
* [29]
* [28]


### Merging Chains  insertL/8 into  External patterns of execution 
* [[32],[32,[25,26]]] --> 1 
* [[31]] --> 2 
* [[29],[29,[25,26]],[31,[25,26]]] --> 3 
* [[28],[28,[25,26]]] --> 4 
* [[30],[30,[25,26]]] --> 5 


### Specialization of cost equations isortlist/6 
* CE 8 is refined into CE [38] 
* CE 7 is refined into CE [39,40,41,42,43] 


#### Refined cost equations isortlist/6 
* CE 38: isortlist(A,B,C,D,E,F) = 3
     [F>=0,C>=0,E=0,D=1,B=0,A=1] 
* CE 39: isortlist(A,B,C,D,E,F) = 5+ isortlist(G,H,I,J,K,L)+ insertL(M,N,O,K,L,D,E,F):1
     [C>=I,B>=H,K>=E,F>=N,C>=N,G>=1,E>=2,D>=3,L>=0,N>=0,B>=1,D=J+1,D=O+1,G+1=A,M=1] 
* CE 40: isortlist(A,B,C,D,E,F) = 5+ isortlist(G,H,I,J,K,L)+ insertL(E,M,N,O,L,P,E,F):2
     [C>=I,B>=H,B>=E,F>=M,C>=M,G>=1,E>=1,L>=0,M>=0,G+1=A,K=0,J=1,P=2,O=0,N=1,D=2] 
* CE 41: isortlist(A,B,C,D,E,F) = 5+ isortlist(G,H,I,J,K,L)+ insertL(E,M,N,K,L,D,E,F):3
     [C>=I,B>=H,B>=E,F>=M,C>=M,G>=1,E>=1,D>=3,L>=0,K>=1,M>=0,D=J+1,D=N+1,G+1=A] 
* CE 42: isortlist(A,B,C,D,E,F) = 5+ isortlist(G,H,I,J,K,L)+ insertL(M,N,O,K,L,D,E,F):4
     [C>=I,B>=H,K>=E,F>=N,C>=N,E>=M+1,B>=M,G>=1,D>=3,L>=0,N>=0,M>=2,D=J+1,D=O+1,G+1=A] 
* CE 43: isortlist(A,B,C,D,E,F) = 5+ isortlist(G,H,I,J,K,L)+ insertL(M,N,O,K,L,D,E,F):5
     [C>=I,B>=H,K>=E,F>=N,C>=N,E>=M,B>=M,G>=1,F>=1,D>=3,L>=1,N>=0,M>=2,D=J+1,D=O+1,G+1=A] 

### Cost equations --> "Loop" of isortlist/6 
* CEs [41] --> Loop 33 
* CEs [39,42,43] --> Loop 34 
* CEs [40] --> Loop 35 
* CEs [38] --> Loop 36 

#### Loops of isortlist/6 
* Loop 33: isortlist(A,B,C,D,E,F)->  isortlist(A',B',C',D',E',F')
                  [C>=C',B>=B',B>=E,F'>=0,E'>=1,F>=0,E>=1,D>=3,C>=0,A>=2,D=D'+1,A=A'+1] 
* Loop 34: isortlist(A,B,C,D,E,F)->  isortlist(A',B',C',D',E',F')
                  [C>=C',B>=B',E'>=E,F'>=0,F>=0,E>=2,D>=3,C>=0,B>=1,A>=2,D=D'+1,A=A'+1] 
* Loop 35: isortlist(A,B,C,D,E,F)->  isortlist(A',B',C',D',E',F')
                  [C>=C',B>=B',B>=E,F'>=0,F>=0,E>=1,C>=0,A>=2,A=A'+1,E'=0,D'=1,D=2] 
* Loop 36: isortlist(A,B,C,D,E,F) [F>=0,C>=0,E=0,D=1,B=0,A=1] 

### Ranking functions of CR isortlist(A,B,C,D,E,F) 
* RF of phase [33,34]: [A-1]

#### Partial ranking functions of CR isortlist(A,B,C,D,E,F) 
* Partial RF of phase [33,34]:
  - RF of loop [33:1,34:1]:
    A-1

Discarded unfeasible chain [[33,34]]...(Non-terminating chain proved terminating)

### Resulting Chains:isortlist(A,B,C,D,E,F) 
* [[33,34],35,36]
* [36]
* [35,36]


### Merging Chains  isortlist/6 into  External patterns of execution 
* [[36]] --> 1 
* [[36,35]] --> 2 
* [[36,35,[33,34]]] --> 3 


Computing Bounds
=====================================

#### Simplifying cost structure of CE 16 

#### Simplifying cost structure of CE 15 

#### Cost of chains of maxNorm(A,B,C):
* Chain [16]: 0
  with precondition: [A=C,B>=0,A>=B+1] 

* Chain [15]: 0
  with precondition: [B=C,A>=1,B>=A] 


#### Simplifying cost structure of CE 18 

#### Simplifying cost structure of CE 17 

#### Cost of chains of and_op(A,B,C):
* Chain [18]: 0
  with precondition: [A=0,C=0,B>=0] 

* Chain [17]: 0
  with precondition: [A=1,C=B,C>=0] 


#### Simplifying cost structure of CE 20 

#### Simplifying cost structure of CE 19 

#### Cost of chains of leq(A,B,C):
* Chain [20]: 0
  with precondition: [C=0,B>=0,A>=B+1] 

* Chain [19]: 0
  with precondition: [C=1,A>=0,B>=A] 


#### Simplifying cost structure of CE 24 

#### Computing cost of phase [23,24] 

#### Simplifying cost structure of CE 22 

#### Simplifying cost structure of CE 21 

#### Cost of loops [23,24] 

 * loop 23:leqL(A,B,C,D,E) -> [leqL(A',B',C',D',E')] 
9
 * loop 24:leqL(A,B,C,D,E) -> [leqL(A',B',C',D',E')] 
9
##### Pending set leqL(A,B,C,D,E)
* Psum in Loop 23: [it(23)=<1]
* Psum in Loop 24: [it(24)=<1]

###### Computing sum for it(23)=<1  in Loop 23 
   - Applying inductive sum strategy 
     - head Candidate: C-1 
       - Loop 24 is collaborative and bounds [it(24)] 
     - head Candidate: A-1 
       - Loop 24 is collaborative and bounds [it(24)] 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - Loop 24 is collaborative and bounds [it(24)] 
     - tail Candidate: A-1 
       - Loop 24 is collaborative and bounds [it(24)] 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(23)+it(24)=<C-1,it(23)+it(24)=<A-1,it(23)+it(24)=<A-1,it(23)+it(24)=<C-1,it(23)+it(24)=<C-C',it(23)+it(24)=<A-A',it(23)+it(24)=<A-A',it(23)+it(24)=<C-C'] 

##### Pending set A
* Psum in Loop 24: [it(24)=<1]

###### Computing sum for it(24)=<1  in Loop 24 
   - Applying inductive sum strategy 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(23)+it(24)=<C-1,it(23)+it(24)=<A-1,it(23)+it(24)=<A-1,it(23)+it(24)=<C-1,it(23)+it(24)=<C-C',it(23)+it(24)=<A-A',it(23)+it(24)=<A-A',it(23)+it(24)=<C-C'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [23,24] 

#### Simplifying cost structure of phase [23,24] 
 * Joined equivalent variables [it(23),it(24)] into it(23)

#### Cost of phase [23,24]:leqL(A,B,C,D,E) -> [leqL(A',B',C',D',E')] 
18*it(23)+0
  Such that:aux(1) =< A
aux(2) =< A-A'
aux(3) =< C
aux(4) =< C-C'
it(23) =< aux(1)
it(23) =< aux(2)
it(23) =< aux(3)
it(23) =< aux(4)

#### Simplifying cost structure of chain [[23,24],22] 
 * Joined equivalent variables [aux(5),aux(1),aux(2),aux(4)] into aux(5)

#### Simplifying cost structure of CE 23 

#### Found solution for phase  [23,24] in the cache 

#### Cost of phase [23,24]:leqL(A,B,C,D,E) -> [leqL(A',B',C',D',E')] 
18*it(23)+0
  Such that:aux(1) =< A
aux(2) =< A-A'
aux(3) =< C
aux(4) =< C-C'
it(23) =< aux(1)
it(23) =< aux(2)
it(23) =< aux(3)
it(23) =< aux(4)

#### Simplifying cost structure of chain [[23,24],21] 
 * Joined equivalent variables [aux(6),aux(2),aux(3),aux(4)] into aux(6)

#### Cost of chains of leqL(A,B,C,D,E):
* Chain [[23,24],22]: 18*it(23)+3
  Such that:aux(3) =< C
aux(5) =< A
it(23) =< aux(5)
it(23) =< aux(3)

  with precondition: [1>=E,A>=2,D>=0,E>=0,C>=A,B+E>=1] 

* Chain [[23,24],21]: 18*it(23)+6
  Such that:aux(1) =< A
aux(6) =< C
it(23) =< aux(1)
it(23) =< aux(6)

  with precondition: [E=0,B>=0,C>=2,D>=0,A>=C+1] 

* Chain [22]: 3
  with precondition: [A=1,E=1,B>=0,C>=0,D>=0] 

* Chain [21]: 6
  with precondition: [C=1,E=0,A>=2,B>=0,D>=0] 


#### Simplifying cost structure of CE 25 

#### Simplifying cost structure of CE 26 

#### Computing cost of phase [25,26] 
 * The following loops are unfeasible in this instance of the phase [25,26] : [25] 

#### Simplifying cost structure of CE 35 
 * Renamed intermediate variables: 
[ (eq(37,1),aux(3))>>s(1), (eq(37,1),aux(5))>>s(2), (eq(37,1),it(23))>>s(3)]

#### Simplifying cost structure of CE 37 
 * Joined equivalent variables [aux(7),s(1)] into aux(7)
 * Renamed intermediate variables: 
[ (it(26),s(2))>>s(4), (it(26),aux(7))>>s(5), (it(26),s(3))>>s(6)]

#### Cost of loops [26] 

 * loop 26:insertL(A,B,C,D,E,F,G,H) -> [insertL(A',B',C',D',E',F',G',H')] 
18*s(6)+11
  Such that:s(4) =< D
s(5) =< A'
s(4) =< s(5)
s(6) =< s(4)
s(6) =< s(5)

##### Pending set insertL(A,B,C,D,E,F,G,H)
* Psum in Loop 26: [it(26)=<1,s(9)=<D,s(8)=<A']

###### Computing sum for it(26)=<1  in Loop 26 
   - Applying inductive sum strategy 
     - head Candidate: C-1 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(26)=<C-1,it(26)=<C-1,it(26)=<C-C',it(26)=<C-C'] 

##### Pending set A
* Psum in Loop 26: [s(9)=<D,s(8)=<A']

###### Computing sum for s(9)=<D  in Loop 26 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(8)=<D] 
 * Adding constraints: [s(9)=<it(26)*aux(8)] 

##### Pending set insertL(A,B,C,D,E,F,G,H)
* Pmax/min: [aux(8)=<D]
* Psum in Loop 26: [s(8)=<A']

###### Computing max_min for aux(8)=<D  
   - Found a solution using transitive invariants 
 * Adding constraints:[aux(8)=<D] 

##### Pending set insertL(A,B,C,D,E,F,G,H)
* Psum in Loop 26: [s(8)=<A']

###### Computing sum for s(8)=<A'  in Loop 26 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(9)=<A] 
 * Adding constraints: [s(8)=<it(26)*aux(9)] 

##### Pending set insertL(A,B,C,D,E,F,G,H)
* Pmax/min: [aux(9)=<A]

###### Computing max_min for aux(9)=<A  
   - Found a solution using transitive invariants 
 * Adding constraints:[aux(9)=<A] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [26] 

#### Simplifying cost structure of phase [26] 

#### Cost of phase [25,26]:insertL(A,B,C,D,E,F,G,H) -> [insertL(A',B',C',D',E',F',G',H')] 
11*it(26)+18*s(7)+0
  Such that:aux(9) =< A
it(26) =< C
it(26) =< C-C'
aux(8) =< D
s(8) =< it(26)*aux(9)
s(9) =< it(26)*aux(8)
s(9) =< s(8)
s(7) =< s(9)
s(7) =< s(8)

#### Simplifying cost structure of chain [[25,26],32] 

#### Simplifying cost structure of CE 33 

#### Found solution for phase  [25,26] in the cache 

#### Cost of phase [25,26]:insertL(A,B,C,D,E,F,G,H) -> [insertL(A',B',C',D',E',F',G',H')] 
11*it(26)+18*s(7)+0
  Such that:aux(9) =< A
it(26) =< C
it(26) =< C-C'
aux(8) =< D
s(8) =< it(26)*aux(9)
s(9) =< it(26)*aux(8)
s(9) =< s(8)
s(7) =< s(9)
s(7) =< s(8)

#### Simplifying cost structure of chain [[25,26],31] 
 * Renamed intermediate variables: 
[ (eq(30,1),aux(3))>>s(10), (eq(30,1),aux(5))>>s(11), (eq(30,1),it(23))>>s(12)]

#### Simplifying cost structure of CE 30 
 * Joined equivalent variables [aux(10),s(10),s(11)] into aux(10)
 * Renamed intermediate variables: 
[ (eq(32,1),aux(3))>>s(13), (eq(32,1),aux(5))>>s(14), (eq(32,1),it(23))>>s(15)]

#### Simplifying cost structure of CE 32 
 * Joined equivalent variables [aux(11),s(13),s(14)] into aux(11)
 * Joined equivalent variables [aux(12),aux(10),aux(11)] into aux(12)
 * Joined equivalent variables [s(12),s(15)] into s(12)

#### Found solution for phase  [25,26] in the cache 

#### Cost of phase [25,26]:insertL(A,B,C,D,E,F,G,H) -> [insertL(A',B',C',D',E',F',G',H')] 
11*it(26)+18*s(7)+0
  Such that:aux(9) =< A
it(26) =< C
it(26) =< C-C'
aux(8) =< D
s(8) =< it(26)*aux(9)
s(9) =< it(26)*aux(8)
s(9) =< s(8)
s(7) =< s(9)
s(7) =< s(8)

#### Simplifying cost structure of chain [[25,26],30] 
 * Joined equivalent variables [aux(13),aux(9),aux(12)] into aux(13)
 * Renamed intermediate variables: 
[ (eq(29,1),aux(3))>>s(16), (eq(29,1),aux(5))>>s(17), (eq(29,1),it(23))>>s(18)]

#### Simplifying cost structure of CE 29 
 * Joined equivalent variables [aux(14),s(16)] into aux(14)
 * Renamed intermediate variables: 
[ (eq(31,1),aux(3))>>s(19), (eq(31,1),aux(5))>>s(20), (eq(31,1),it(23))>>s(21)]

#### Simplifying cost structure of CE 31 
 * Joined equivalent variables [aux(15),s(19)] into aux(15)
 * Joined equivalent variables [aux(16),aux(14),aux(15)] into aux(16)
 * Joined equivalent variables [s(17),s(20)] into s(17)
 * Joined equivalent variables [s(18),s(21)] into s(18)

#### Found solution for phase  [25,26] in the cache 

#### Cost of phase [25,26]:insertL(A,B,C,D,E,F,G,H) -> [insertL(A',B',C',D',E',F',G',H')] 
11*it(26)+18*s(7)+0
  Such that:aux(9) =< A
it(26) =< C
it(26) =< C-C'
aux(8) =< D
s(8) =< it(26)*aux(9)
s(9) =< it(26)*aux(8)
s(9) =< s(8)
s(7) =< s(9)
s(7) =< s(8)

#### Simplifying cost structure of chain [[25,26],29] 
 * Joined equivalent variables [aux(18),aux(9),aux(16)] into aux(18)
 * Joined equivalent variables [aux(19),aux(8),aux(17)] into aux(19)
 * Renamed intermediate variables: 
[ (eq(27,1),aux(1))>>s(22), (eq(27,1),aux(6))>>s(23), (eq(27,1),it(23))>>s(24)]

#### Simplifying cost structure of CE 27 
 * Renamed intermediate variables: 
[ (eq(28,1),aux(1))>>s(25), (eq(28,1),aux(6))>>s(26), (eq(28,1),it(23))>>s(27)]

#### Simplifying cost structure of CE 28 
 * Joined equivalent variables [aux(20),s(23),s(26)] into aux(20)
 * Joined equivalent variables [aux(21),s(22),s(25)] into aux(21)
 * Joined equivalent variables [s(24),s(27)] into s(24)

#### Found solution for phase  [25,26] in the cache 

#### Cost of phase [25,26]:insertL(A,B,C,D,E,F,G,H) -> [insertL(A',B',C',D',E',F',G',H')] 
11*it(26)+18*s(7)+0
  Such that:aux(9) =< A
it(26) =< C
it(26) =< C-C'
aux(8) =< D
s(8) =< it(26)*aux(9)
s(9) =< it(26)*aux(8)
s(9) =< s(8)
s(7) =< s(9)
s(7) =< s(8)

#### Simplifying cost structure of chain [[25,26],28] 
 * Joined equivalent variables [aux(22),aux(9),aux(20)] into aux(22)
 * Joined equivalent variables [aux(23),aux(8),aux(21)] into aux(23)
 * Renamed intermediate variables: 
[ (ch([[25,26],32]),aux(9))>>s(28), (ch([[25,26],32]),it(26))>>s(29), (ch([[25,26],32]),aux(8))>>s(30), (ch([[25,26],32]),s(8))>>s(31), (ch([[25,26],32]),s(9))>>s(32), (ch([[25,26],32]),s(7))>>s(33)]
 * Renamed intermediate variables: 
[ (ch([29]),aux(16))>>s(34), (ch([29]),aux(17))>>s(35), (ch([29]),s(17))>>s(36), (ch([29]),s(18))>>s(37)]
 * Renamed intermediate variables: 
[ (ch([[25,26],29]),it(26))>>s(38), (ch([[25,26],29]),aux(18))>>s(39), (ch([[25,26],29]),aux(19))>>s(40), (ch([[25,26],29]),s(17))>>s(41), (ch([[25,26],29]),s(18))>>s(42), (ch([[25,26],29]),s(8))>>s(43), (ch([[25,26],29]),s(9))>>s(44), (ch([[25,26],29]),s(7))>>s(45)]
 * Renamed intermediate variables: 
[ (ch([[25,26],31]),aux(9))>>s(46), (ch([[25,26],31]),it(26))>>s(47), (ch([[25,26],31]),aux(8))>>s(48), (ch([[25,26],31]),s(8))>>s(49), (ch([[25,26],31]),s(9))>>s(50), (ch([[25,26],31]),s(7))>>s(51)]
 * Joined equivalent variables [aux(24),s(34),s(39),s(46)] into aux(24)
 * Joined equivalent variables [aux(26),s(35),s(40),s(48)] into aux(26)
 * Joined equivalent variables [s(38),s(47)] into s(38)
 * Joined equivalent variables [s(43),s(49)] into s(43)
 * Joined equivalent variables [s(36),s(41)] into s(36)
 * Joined equivalent variables [s(44),s(50)] into s(44)
 * Joined equivalent variables [s(37),s(42)] into s(37)
 * Joined equivalent variables [s(45),s(51)] into s(45)
 * Renamed intermediate variables: 
[ (ch([28]),aux(20))>>s(52), (ch([28]),aux(21))>>s(53), (ch([28]),s(24))>>s(54)]
 * Renamed intermediate variables: 
[ (ch([[25,26],28]),it(26))>>s(55), (ch([[25,26],28]),aux(22))>>s(56), (ch([[25,26],28]),aux(23))>>s(57), (ch([[25,26],28]),s(24))>>s(58), (ch([[25,26],28]),s(8))>>s(59), (ch([[25,26],28]),s(9))>>s(60), (ch([[25,26],28]),s(7))>>s(61)]
 * Joined equivalent variables [aux(27),s(52),s(56)] into aux(27)
 * Joined equivalent variables [aux(28),s(53),s(57)] into aux(28)
 * Joined equivalent variables [s(54),s(58)] into s(54)
 * Renamed intermediate variables: 
[ (ch([30]),aux(12))>>s(62), (ch([30]),s(12))>>s(63)]
 * Renamed intermediate variables: 
[ (ch([[25,26],30]),it(26))>>s(64), (ch([[25,26],30]),aux(8))>>s(65), (ch([[25,26],30]),aux(13))>>s(66), (ch([[25,26],30]),s(12))>>s(67), (ch([[25,26],30]),s(8))>>s(68), (ch([[25,26],30]),s(9))>>s(69), (ch([[25,26],30]),s(7))>>s(70)]
 * Joined equivalent variables [aux(29),s(62),s(66)] into aux(29)
 * Joined equivalent variables [s(63),s(67)] into s(63)

#### Cost of chains of insertL(A,B,C,D,E,F,G,H):
* Chain [[25,26],32]: 11*it(26)+18*s(7)+15
  Such that:aux(9) =< 1
it(26) =< C
aux(8) =< D
s(8) =< it(26)*aux(9)
s(9) =< it(26)*aux(8)
s(9) =< s(8)
s(7) =< s(9)
s(7) =< s(8)

  with precondition: [A=1,C+1=F,B>=0,C>=3,E>=0,G>=2,H>=B,D>=G] 

* Chain [[25,26],31]: 11*it(26)+18*s(7)+4
  Such that:aux(9) =< A
it(26) =< C
aux(8) =< D
s(8) =< it(26)*aux(9)
s(9) =< it(26)*aux(8)
s(9) =< s(8)
s(7) =< s(9)
s(7) =< s(8)

  with precondition: [G=A,C+1=F,B>=0,C>=2,D>=1,E>=0,G>=1,H>=B] 

* Chain [[25,26],30]: 11*it(26)+18*s(7)+36*s(12)+12
  Such that:it(26) =< C
aux(8) =< D
aux(13) =< A
s(12) =< aux(13)
s(8) =< it(26)*aux(13)
s(9) =< it(26)*aux(8)
s(9) =< s(8)
s(7) =< s(9)
s(7) =< s(8)

  with precondition: [C+1=F,A>=2,B>=0,C>=3,E>=1,H>=1,G>=A,H>=B,D>=G] 

* Chain [[25,26],29]: 11*it(26)+18*s(7)+36*s(18)+12
  Such that:it(26) =< C
aux(18) =< A
aux(19) =< D
s(17) =< aux(19)
s(17) =< aux(18)
s(18) =< s(17)
s(18) =< aux(18)
s(8) =< it(26)*aux(18)
s(9) =< it(26)*aux(19)
s(9) =< s(8)
s(7) =< s(9)
s(7) =< s(8)

  with precondition: [G=A,C+1=F,B>=0,C>=3,D>=2,E>=1,G>=3,H>=1,H>=B] 

* Chain [[25,26],28]: 11*it(26)+18*s(7)+36*s(24)+15
  Such that:it(26) =< C
aux(22) =< A
aux(23) =< D
s(24) =< aux(23)
s(24) =< aux(22)
s(8) =< it(26)*aux(22)
s(9) =< it(26)*aux(23)
s(9) =< s(8)
s(7) =< s(9)
s(7) =< s(8)

  with precondition: [C+1=F,A>=2,B>=0,C>=3,E>=0,G>=A+1,H>=B,D>=G] 

* Chain [32]: 15
  with precondition: [A=1,C+1=F,B>=0,C>=2,E>=0,G>=2,H>=B,D>=G] 

* Chain [31]: 4
  with precondition: [C=1,D=0,F=2,A=G,A>=1,B>=0,E>=0,H>=B] 

* Chain [30]: 36*s(12)+12
  Such that:aux(12) =< A
s(12) =< aux(12)

  with precondition: [C+1=F,A>=2,B>=0,C>=2,E>=1,H>=1,G>=A,H>=B,D>=G] 

* Chain [29]: 36*s(18)+12
  Such that:aux(16) =< A
aux(17) =< D
s(17) =< aux(17)
s(17) =< aux(16)
s(18) =< s(17)
s(18) =< aux(16)

  with precondition: [C+1=F,A=G,A>=3,B>=0,C>=2,D>=2,E>=1,H>=1,H>=B] 

* Chain [28]: 36*s(24)+15
  Such that:aux(20) =< A
aux(21) =< D
s(24) =< aux(21)
s(24) =< aux(20)

  with precondition: [C+1=F,A>=2,B>=0,C>=2,E>=0,G>=A+1,H>=B,D>=G] 


#### Simplifying cost structure of CE 38 

#### Simplifying cost structure of CE 40 

#### Simplifying cost structure of chain [35,36] 

#### Computing cost of phase [33,34] 
 * Renamed intermediate variables: 
[ (eq(41,1),aux(24))>>s(71), (eq(41,1),aux(25))>>s(72), (eq(41,1),aux(26))>>s(73), (eq(41,1),s(38))>>s(74), (eq(41,1),s(36))>>s(75), (eq(41,1),s(37))>>s(76), (eq(41,1),s(43))>>s(77), (eq(41,1),s(44))>>s(78), (eq(41,1),s(45))>>s(79)]

#### Simplifying cost structure of CE 41 
 * Renamed intermediate variables: 
[ (it(33),s(72))>>s(80), (it(33),s(71))>>s(81), (it(33),s(73))>>s(82), (it(33),s(74))>>s(83), (it(33),s(75))>>s(84), (it(33),s(76))>>s(85), (it(33),s(77))>>s(86), (it(33),s(78))>>s(87), (it(33),s(79))>>s(88)]
 * Renamed intermediate variables: 
[ (eq(39,1),s(28))>>s(89), (eq(39,1),s(29))>>s(90), (eq(39,1),s(30))>>s(91), (eq(39,1),s(31))>>s(92), (eq(39,1),s(32))>>s(93), (eq(39,1),s(33))>>s(94)]

#### Simplifying cost structure of CE 39 
 * Renamed intermediate variables: 
[ (eq(42,1),s(55))>>s(95), (eq(42,1),aux(27))>>s(96), (eq(42,1),aux(28))>>s(97), (eq(42,1),s(54))>>s(98), (eq(42,1),s(59))>>s(99), (eq(42,1),s(60))>>s(100), (eq(42,1),s(61))>>s(101)]

#### Simplifying cost structure of CE 42 
 * Joined equivalent variables [aux(30),s(96),s(97)] into aux(30)
 * Renamed intermediate variables: 
[ (eq(43,1),s(64))>>s(102), (eq(43,1),s(65))>>s(103), (eq(43,1),aux(29))>>s(104), (eq(43,1),s(63))>>s(105), (eq(43,1),s(68))>>s(106), (eq(43,1),s(69))>>s(107), (eq(43,1),s(70))>>s(108)]

#### Simplifying cost structure of CE 43 
 * Joined equivalent variables [aux(31),s(103),s(104)] into aux(31)
 * Joined equivalent variables [aux(33),aux(30),aux(31),s(91)] into aux(33)
 * Joined equivalent variables [s(90),s(95),s(102)] into s(90)
 * Joined equivalent variables [s(99),s(106)] into s(99)
 * Joined equivalent variables [s(98),s(105)] into s(98)
 * Joined equivalent variables [s(100),s(107)] into s(100)
 * Joined equivalent variables [s(101),s(108)] into s(101)
 * Renamed intermediate variables: 
[ (it(34),s(89))>>s(109), (it(34),aux(32))>>s(110), (it(34),aux(33))>>s(111), (it(34),s(90))>>s(112), (it(34),s(92))>>s(113), (it(34),s(93))>>s(114), (it(34),s(94))>>s(115), (it(34),s(98))>>s(116), (it(34),s(99))>>s(117), (it(34),s(100))>>s(118), (it(34),s(101))>>s(119)]

#### Cost of loops [33,34] 

 * loop 33:isortlist(A,B,C,D,E,F) -> [isortlist(A',B',C',D',E',F')] 
22*s(83)+72*s(85)+36*s(88)+17
  Such that:s(80) =< A
s(81) =< B
s(82) =< B'
s(83) =< s(80)
s(84) =< s(82)
s(84) =< s(81)
s(85) =< s(84)
s(85) =< s(81)
s(86) =< s(83)*s(81)
s(87) =< s(83)*s(82)
s(87) =< s(86)
s(88) =< s(87)
s(88) =< s(86)

 * loop 34:isortlist(A,B,C,D,E,F) -> [isortlist(A',B',C',D',E',F')] 
33*s(112)+18*s(115)+144*s(116)+36*s(119)+20
  Such that:s(109) =< 1
s(110) =< A
s(111) =< B'
s(112) =< s(110)
s(113) =< s(112)*s(109)
s(114) =< s(112)*s(111)
s(114) =< s(113)
s(115) =< s(114)
s(115) =< s(113)
s(116) =< s(111)
s(117) =< s(112)*s(111)
s(118) =< s(112)*s(111)
s(118) =< s(117)
s(119) =< s(118)
s(119) =< s(117)

##### Pending set isortlist(A,B,C,D,E,F)
* Pmax/min: [s(109)=<1,s(81)=<B,s(82)=<B,s(111)=<B]
* Psum in Loop 33: [it(33)=<1,s(128)=<A,s(125)=<B,s(127)=<B']
* Psum in Loop 34: [it(34)=<1,s(138)=<A,s(135)=<B']

###### Computing max_min for s(109)=<1  
 * Adding constraints:[s(109)=<1] 

##### Pending set isortlist(A,B,C,D,E,F)
* Pmax/min: [s(81)=<B,s(82)=<B,s(111)=<B]
* Psum in Loop 33: [it(33)=<1,s(128)=<A,s(125)=<B,s(127)=<B']
* Psum in Loop 34: [it(34)=<1,s(138)=<A,s(135)=<B']

###### Computing max_min for s(81)=<B  
   - Found a solution using transitive invariants 
 * Adding constraints:[s(81)=<B] 

##### Pending set isortlist(A,B,C,D,E,F)
* Pmax/min: [s(82)=<B,s(111)=<B]
* Psum in Loop 33: [it(33)=<1,s(128)=<A,s(125)=<B,s(127)=<B']
* Psum in Loop 34: [it(34)=<1,s(138)=<A,s(135)=<B']

###### Computing max_min for s(82)=<B  
   - Found a solution using cacheing 
 * Adding constraints:[s(82)=<s(81)] 

##### Pending set isortlist(A,B,C,D,E,F)
* Pmax/min: [s(111)=<B]
* Psum in Loop 33: [it(33)=<1,s(128)=<A,s(125)=<B,s(127)=<B']
* Psum in Loop 34: [it(34)=<1,s(138)=<A,s(135)=<B']

###### Computing max_min for s(111)=<B  
   - Found a solution using cacheing 
 * Adding constraints:[s(111)=<s(81)] 

##### Pending set isortlist(A,B,C,D,E,F)
* Psum in Loop 33: [it(33)=<1,s(128)=<A,s(125)=<B,s(127)=<B']
* Psum in Loop 34: [it(34)=<1,s(138)=<A,s(135)=<B']

###### Computing sum for it(33)=<1  in Loop 33 
   - Applying inductive sum strategy 
     - head Candidate: A-1 
       - Loop 34 is collaborative and bounds [it(34)] 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
       - Loop 34 is collaborative and bounds [it(34)] 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(33)+it(34)=<A-1,it(33)+it(34)=<A-1,it(33)+it(34)=<A-A',it(33)+it(34)=<A-A'] 

##### Pending set isortlist(A,B,C,D,E,F)
* Psum in Loop 33: [s(128)=<A,s(125)=<B,s(127)=<B']
* Psum in Loop 34: [it(34)=<1,s(138)=<A,s(135)=<B']

###### Computing sum for s(128)=<A  in Loop 33 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(34)=<A] 
 * Adding constraints: [s(128)=<it(33)*aux(34)] 

##### Pending set isortlist(A,B,C,D,E,F)
* Pmax/min: [aux(34)=<A]
* Psum in Loop 33: [s(125)=<B,s(127)=<B']
* Psum in Loop 34: [it(34)=<1,s(138)=<A,s(135)=<B']

###### Computing max_min for aux(34)=<A  
   - Found a solution using transitive invariants 
 * Adding constraints:[aux(34)=<A] 

##### Pending set isortlist(A,B,C,D,E,F)
* Psum in Loop 33: [s(125)=<B,s(127)=<B']
* Psum in Loop 34: [it(34)=<1,s(138)=<A,s(135)=<B']

###### Computing sum for s(125)=<B  in Loop 33 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(35)=<B] 
 * Adding constraints: [s(125)=<it(33)*aux(35)] 

##### Pending set isortlist(A,B,C,D,E,F)
* Pmax/min: [aux(35)=<B]
* Psum in Loop 33: [s(127)=<B']
* Psum in Loop 34: [it(34)=<1,s(138)=<A,s(135)=<B']

###### Computing max_min for aux(35)=<B  
   - Found a solution using cacheing 
 * Adding constraints:[aux(35)=<s(81)] 

##### Pending set isortlist(A,B,C,D,E,F)
* Psum in Loop 33: [s(127)=<B']
* Psum in Loop 34: [it(34)=<1,s(138)=<A,s(135)=<B']

###### Computing sum for s(127)=<B'  in Loop 33 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(36)=<B] 
 * Adding constraints: [s(127)=<it(33)*aux(36)] 

##### Pending set isortlist(A,B,C,D,E,F)
* Pmax/min: [aux(36)=<B]
* Psum in Loop 34: [it(34)=<1,s(138)=<A,s(135)=<B']

###### Computing max_min for aux(36)=<B  
   - Found a solution using cacheing 
 * Adding constraints:[aux(36)=<s(81)] 

##### Pending set isortlist(A,B,C,D,E,F)
* Psum in Loop 34: [it(34)=<1,s(138)=<A,s(135)=<B']

###### Computing sum for it(34)=<1  in Loop 34 
   - Applying inductive sum strategy 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(33)+it(34)=<A-1,it(33)+it(34)=<A-1,it(33)+it(34)=<A-A',it(33)+it(34)=<A-A'] 

##### Pending set isortlist(A,B,C,D,E,F)
* Psum in Loop 34: [s(138)=<A,s(135)=<B']

###### Computing sum for s(138)=<A  in Loop 34 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(37)=<A] 
 * Adding constraints: [s(138)=<it(34)*aux(37)] 

##### Pending set isortlist(A,B,C,D,E,F)
* Pmax/min: [aux(37)=<A]
* Psum in Loop 34: [s(135)=<B']

###### Computing max_min for aux(37)=<A  
   - Found a solution using cacheing 
 * Adding constraints:[aux(37)=<aux(34)] 

##### Pending set isortlist(A,B,C,D,E,F)
* Psum in Loop 34: [s(135)=<B']

###### Computing sum for s(135)=<B'  in Loop 34 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(38)=<B] 
 * Adding constraints: [s(135)=<it(34)*aux(38)] 

##### Pending set isortlist(A,B,C,D,E,F)
* Pmax/min: [aux(38)=<B]

###### Computing max_min for aux(38)=<B  
   - Found a solution using cacheing 
 * Adding constraints:[aux(38)=<s(81)] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [33,34] 

#### Simplifying cost structure of phase [33,34] 
 * Joined equivalent variables [aux(39),aux(34)] into aux(39)
 * Joined equivalent variables [aux(35),aux(36),aux(38),s(82),s(111)] into aux(35)
 * Joined equivalent variables [it(33),it(34)] into it(33)
 * Joined equivalent variables [s(125),s(127),s(135)] into s(125)
 * Joined equivalent variables [s(125),s(126)] into s(125)
 * Joined equivalent variables [s(121),s(131)] into s(121)

#### Cost of phase [33,34]:isortlist(A,B,C,D,E,F) -> [isortlist(A',B',C',D',E',F')] 
37*it(33)+22*s(120)+216*s(121)+36*s(122)+33*s(129)+18*s(130)+36*s(132)+0
  Such that:s(109) =< 1
s(81) =< B
aux(39) =< A
aux(40) =< A-A'
it(33) =< aux(39)
it(33) =< aux(40)
aux(35) =< s(81)
aux(37) =< aux(39)
s(128) =< it(33)*aux(39)
s(125) =< it(33)*aux(35)
s(138) =< it(33)*aux(37)
s(129) =< s(138)
s(136) =< s(129)*s(109)
s(137) =< s(129)*aux(35)
s(137) =< s(136)
s(130) =< s(137)
s(130) =< s(136)
s(121) =< s(125)
s(133) =< s(129)*aux(35)
s(134) =< s(129)*aux(35)
s(134) =< s(133)
s(132) =< s(134)
s(132) =< s(133)
s(120) =< s(128)
s(123) =< s(120)*s(81)
s(124) =< s(120)*aux(35)
s(124) =< s(123)
s(122) =< s(124)
s(122) =< s(123)

#### Simplifying cost structure of chain [[33,34],35,36] 
 * Joined equivalent variables [aux(41),aux(39),aux(40)] into aux(41)

#### Cost of chains of isortlist(A,B,C,D,E,F):
* Chain [[33,34],35,36]: 37*it(33)+22*s(120)+216*s(121)+36*s(122)+33*s(129)+18*s(130)+36*s(132)+12
  Such that:s(109) =< 1
s(81) =< B
aux(41) =< A
it(33) =< aux(41)
aux(35) =< s(81)
aux(37) =< aux(41)
s(128) =< it(33)*aux(41)
s(125) =< it(33)*aux(35)
s(138) =< it(33)*aux(37)
s(129) =< s(138)
s(136) =< s(129)*s(109)
s(137) =< s(129)*aux(35)
s(137) =< s(136)
s(130) =< s(137)
s(130) =< s(136)
s(121) =< s(125)
s(133) =< s(129)*aux(35)
s(134) =< s(129)*aux(35)
s(134) =< s(133)
s(132) =< s(134)
s(132) =< s(133)
s(120) =< s(128)
s(123) =< s(120)*s(81)
s(124) =< s(120)*aux(35)
s(124) =< s(123)
s(122) =< s(124)
s(122) =< s(123)

  with precondition: [A=D,A>=3,C>=0,E>=1,F>=0,B>=E] 

* Chain [36]: 3
  with precondition: [A=1,B=0,D=1,E=0,C>=0,F>=0] 

* Chain [35,36]: 12
  with precondition: [A=2,D=2,C>=0,E>=1,F>=0,B>=E] 


Closed-form bounds of leqL(A,B,C,D,E): 
-------------------------------------
* Chain [[23,24],22] with precondition: [1>=E,A>=2,D>=0,E>=0,C>=A,B+E>=1] 
    - Upper bound: 18*A+3 
    - Complexity: n 
* Chain [[23,24],21] with precondition: [E=0,B>=0,C>=2,D>=0,A>=C+1] 
    - Upper bound: 18*A+6 
    - Complexity: n 
* Chain [22] with precondition: [A=1,E=1,B>=0,C>=0,D>=0] 
    - Upper bound: 3 
    - Complexity: constant 
* Chain [21] with precondition: [C=1,E=0,A>=2,B>=0,D>=0] 
    - Upper bound: 6 
    - Complexity: constant 

### Maximum cost of leqL(A,B,C,D,E): 18*A+6 
Asymptotic class: n 

Closed-form bounds of insertL(A,B,C,D,E,F,G,H): 
-------------------------------------
* Chain [[25,26],32] with precondition: [A=1,C+1=F,B>=0,C>=3,E>=0,G>=2,H>=B,D>=G] 
    - Upper bound: 29*C+15 
    - Complexity: n 
* Chain [[25,26],31] with precondition: [G=A,C+1=F,B>=0,C>=2,D>=1,E>=0,G>=1,H>=B] 
    - Upper bound: 11*C+4+18*C*D 
    - Complexity: n^2 
* Chain [[25,26],30] with precondition: [C+1=F,A>=2,B>=0,C>=3,E>=1,H>=1,G>=A,H>=B,D>=G] 
    - Upper bound: 36*A+11*C+12+18*C*D 
    - Complexity: n^2 
* Chain [[25,26],29] with precondition: [G=A,C+1=F,B>=0,C>=3,D>=2,E>=1,G>=3,H>=1,H>=B] 
    - Upper bound: 11*C+12+18*C*D+36*D 
    - Complexity: n^2 
* Chain [[25,26],28] with precondition: [C+1=F,A>=2,B>=0,C>=3,E>=0,G>=A+1,H>=B,D>=G] 
    - Upper bound: 11*C+15+18*C*D+36*D 
    - Complexity: n^2 
* Chain [32] with precondition: [A=1,C+1=F,B>=0,C>=2,E>=0,G>=2,H>=B,D>=G] 
    - Upper bound: 15 
    - Complexity: constant 
* Chain [31] with precondition: [C=1,D=0,F=2,A=G,A>=1,B>=0,E>=0,H>=B] 
    - Upper bound: 4 
    - Complexity: constant 
* Chain [30] with precondition: [C+1=F,A>=2,B>=0,C>=2,E>=1,H>=1,G>=A,H>=B,D>=G] 
    - Upper bound: 36*A+12 
    - Complexity: n 
* Chain [29] with precondition: [C+1=F,A=G,A>=3,B>=0,C>=2,D>=2,E>=1,H>=1,H>=B] 
    - Upper bound: 36*D+12 
    - Complexity: n 
* Chain [28] with precondition: [C+1=F,A>=2,B>=0,C>=2,E>=0,G>=A+1,H>=B,D>=G] 
    - Upper bound: 36*D+15 
    - Complexity: n 

### Maximum cost of insertL(A,B,C,D,E,F,G,H): max([max([36*D+11,36*A+8]),11*C+max([18*C+11,18*C*D+max([36*D+11,36*A+8])])])+4 
Asymptotic class: n^2 

Closed-form bounds of isortlist(A,B,C,D,E,F): 
-------------------------------------
* Chain [[33,34],35,36] with precondition: [A=D,A>=3,C>=0,E>=1,F>=0,B>=E] 
    - Upper bound: 37*A+12+73*A*A+216*B*A+72*B*A*A 
    - Complexity: n^3 
* Chain [36] with precondition: [A=1,B=0,D=1,E=0,C>=0,F>=0] 
    - Upper bound: 3 
    - Complexity: constant 
* Chain [35,36] with precondition: [A=2,D=2,C>=0,E>=1,F>=0,B>=E] 
    - Upper bound: 12 
    - Complexity: constant 

### Maximum cost of isortlist(A,B,C,D,E,F): max([9,37*A+9+73*A*A+216*B*A+72*B*A*A])+3 
Asymptotic class: n^3 
* Total analysis performed in 2066 ms.


Cost relation system solved by CoFloCo in 2068 ms.

Method leqL terminates?: YES

 - l1_1: size of l1 wrt. List<Rat>
 - l1_2: size of l1 wrt. Rat
 - l2_1: size of l2 wrt. List<Rat>
 - l2_2: size of l2 wrt. Rat
UB for leqL(l1_1,l1_2,l2_1,l2_2) = 18*l1_1+6

Method insertL terminates?: YES

 - x_1: size of x wrt. List<Rat>
 - x_2: size of x wrt. Rat
 - l_1: size of l wrt. List<List<Rat>>
 - l_2: size of l wrt. List<Rat>
 - l_3: size of l wrt. Rat
UB for insertL(x_1,x_2,l_1,l_2,l_3) = max([max([36*l_2+11,36*x_1+8]),11*l_1+max([18*l_1+11,18*l_1*l_2+max([36*l_2+11,36*x_1+8])])])+4

Method isortlist terminates?: YES

 - l_1: size of l wrt. List<List<Rat>>
 - l_2: size of l wrt. List<Rat>
 - l_3: size of l wrt. Rat
UB for isortlist(l_1,l_2,l_3) = max([9,37*l_1+9+73*l_1*l_1+216*l_2*l_1+72*l_2*l_1*l_1])+3
