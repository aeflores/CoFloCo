
Abs program loaded in 16 ms.

Rule based representation generated in 6 ms.

Rule based representation stored in /tmp/costabs/rbr.rbr

RBR properties stored in /tmp/costabs/rbr.properties

Class invariants generated and loaded in 0 ms.

Abstract compilation performed in 39 ms.

Cost relation system stored in /tmp/costabs/crs.crs

Generated 48 equations 
entry('firstline'(A,B,C,D):[]).
entry('rightL'(A,B,C):[]).
entry('maxL'(A,B,C):[]).
entry('newline'(A,B,C,D,E,F,G):[]).
entry('lcstable'(A,B,C,D,E,F,G):[]).
entry('lcs'(A,B,C,D,E):[]).
input_output_vars('and_op'(A,B,C),[A,B],[C]).
input_output_vars('case_0'(A,B,C,D),[A,B],[C,D]).
input_output_vars('case_1'(A,B,C),[A,B],[C]).
input_output_vars('case_2'(A,B,C),[A,B],[C]).
input_output_vars('case_3'(A,B,C,D,E,F,G),[A,B,C,D,E],[F,G]).
input_output_vars('case_4'(A,B,C,D,E,F,G,H,I,J),[A,B,C,D,E,F,G,H],[I,J]).
input_output_vars('case_5'(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P),[A,B,C,D,E,F,G,H,I,J,K,L,M,N,O],[P]).
input_output_vars('case_6'(A,B,C,D,E,F,G),[A,B,C,D],[E,F,G]).
input_output_vars('case_7'(A,B,C,D,E,F,G,H,I,J,K,L,M),[A,B,C,D,E,F,G,H,I,J],[K,L,M]).
input_output_vars('case_8'(A,B,C,D,E,F,G,H),[A,B,C,D,E,F,G],[H]).
input_output_vars('case_9'(A,B,C,D,E,F,G,H,I,J),[A,B,C,D,E,F,G,H,I],[J]).
input_output_vars('eq'(A,B,C),[A,B],[C]).
input_output_vars('firstline'(A,B,C,D),[A,B],[C,D]).
input_output_vars('geq'(A,B,C),[A,B],[C]).
input_output_vars('gt'(A,B,C),[A,B],[C]).
input_output_vars('lcs'(A,B,C,D,E),[A,B,C,D],[E]).
input_output_vars('lcstable'(A,B,C,D,E,F,G),[A,B,C,D],[E,F,G]).
input_output_vars('leq'(A,B,C),[A,B],[C]).
input_output_vars('lt'(A,B,C),[A,B],[C]).
input_output_vars('maxL'(A,B,C),[A,B],[C]).
input_output_vars('maxNorm'(A,B,C),[A,B],[C]).
input_output_vars('neg'(A,B),[A],[B]).
input_output_vars('neq'(A,B,C),[A,B],[C]).
input_output_vars('newline'(A,B,C,D,E,F,G),[A,B,C,D,E],[F,G]).
input_output_vars('or'(A,B,C),[A,B],[C]).
input_output_vars('rightL'(A,B,C),[A,B],[C]).
eq('eq',[A,B,C],0,[],[A=B,C=1,A>=0,B>=0,C>=0]).
eq('eq',[A,B,C],0,[],[A>=B+1,C=0,A>=0,B>=0,C>=0]).
eq('eq',[A,B,C],0,[],[B>=A+1,C=0,A>=0,B>=0,C>=0]).
eq('neq',[A,B,C],0,[],[A=B,C=0,A>=0,B>=0,C>=0]).
eq('neq',[A,B,C],0,[],[A>=B+1,C=1,A>=0,B>=0,C>=0]).
eq('neq',[A,B,C],0,[],[B>=A+1,C=1,A>=0,B>=0,C>=0]).
eq('lt',[A,B,C],0,[],[B-A>=1,C=1,A>=0,B>=0,C>=0]).
eq('lt',[A,B,C],0,[],[B=<A,C=0,A>=0,B>=0,C>=0]).
eq('leq',[A,B,C],0,[],[A=<B,C=1,A>=0,B>=0,C>=0]).
eq('leq',[A,B,C],0,[],[A-B>=1,C=0,A>=0,B>=0,C>=0]).
eq('gt',[A,B,C],0,[],[A-B>=1,C=1,A>=0,B>=0,C>=0]).
eq('gt',[A,B,C],0,[],[A=<B,C=0,A>=0,B>=0,C>=0]).
eq('geq',[A,B,C],0,[],[B=<A,C=1,A>=0,B>=0,C>=0]).
eq('geq',[A,B,C],0,[],[B-A>=1,C=0,A>=0,B>=0,C>=0]).
eq('neg',[A,B],0,[],[A=0,B=1,A>=0,B>=0]).
eq('neg',[A,B],0,[],[A=1,B=0,A>=0,B>=0]).
eq('and_op',[A,B,C],0,[],[A=0,C=0,A>=0,B>=0,C>=0]).
eq('and_op',[A,B,C],0,[],[A=1,C=B,A>=0,B>=0,C>=0]).
eq('or',[A,B,C],0,[],[A=1,C=1,A>=0,B>=0,C>=0]).
eq('or',[A,B,C],0,[],[A=0,C=B,A>=0,B>=0,C>=0]).
eq('maxNorm',[A,B,A],0,[],[A>=1+B,A>=0,B>=0,A>=0]).
eq('maxNorm',[A,B,B],0,[],[A=<B,A>=0,B>=0,B>=0]).
eq('case_0',[A,B,C,D],2,[],[A=1,C=1,A>=0,B>=0,C>=0,D>=0]).
eq('case_0',[A,B,C,D],5,['firstline'(E,F,G,H)],[B=I+F,A=E+1,E>=1,J=0,D=J+H,C=G+1,G>=1,A>=0,B>=0,C>=0,D>=0]).
eq('firstline',[A,B,C,D],1,['case_0'(A,B,C,D)],[A>=0,B>=0,C>=0,D>=0]).
eq('case_1',[A,B,C],2,[],[A=1,C=0,A>=0,B>=0,C>=0]).
eq('case_1',[A,B,C],2,[],[B=C+D,A=E+1,E>=1,A>=0,B>=0,C>=0]).
eq('rightL',[A,B,C],1,['case_1'(A,B,C)],[A>=0,B>=0,C>=0]).
eq('case_2',[A,B,A],1,[],[A>=B+1,A>=0,B>=0,A>=0]).
eq('case_2',[A,B,B],1,[],[B>=A,A>=0,B>=0,B>=0]).
eq('maxL',[A,B,C],1,['case_2'(A,B,C)],[A>=0,B>=0,C>=0]).
eq('case_3',[A,B,C,D,E,F,G],2,[],[D=1,F=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0]).
eq('case_4',[A,B,C,D,E,F,G,H,I,J],2,[],[B=1,I=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0]).
eq('case_5',[A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P],3,[],[J=E,Q=1,P=A+Q,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0,M>=0,N>=0,O>=0,P>=0]).
eq('case_5',[A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P],2,['maxL'(M,B,P)],[J>=E+1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0,M>=0,N>=0,O>=0,P>=0]).
eq('case_4',[A,B,C,D,E,F,G,H,I,J],15,['newline'(A,K,L,G,H,M,N),'rightL'(O,P,Q),'rightL'(K,L,R),'case_5'(S,T,O,P,A,B,C,D,E,F,G,H,U,K,L,V)],[C=U+L,B=K+1,K>=1,P=N,O=M,M>=1,T=Q,S=R,W=V,X=W+P,Y=O+1,O>=1,Z=X,A1=Y,Y>=1,B1=Z,C1=A1,A1>=1,D1=B1,E1=C1,C1>=1,J=D1,I=E1,E1>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0]).
eq('case_3',[A,B,C,D,E,F,G],3,['case_4'(A,B,C,D,E,H,I,J,F,G)],[E=H+J,D=I+1,I>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0]).
eq('newline',[A,B,C,D,E,F,G],1,['case_3'(A,B,C,D,E,F,G)],[A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0]).
eq('case_6',[A,B,C,D,E,F,G],4,['firstline'(C,D,H,I)],[A=1,J=0,K=1,G=I+L,F=H+J,E=K+1,K>=1,H>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0]).
eq('case_7',[A,B,C,D,E,F,G,H,I,J,K,L,M],2,[],[B=0,A=1,L=0,K=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0,M>=0]).
eq('case_7',[A,B,C,D,E,F,G,H,I,J,K,L,M],5,['newline'(H,N,O,F,G,P,Q)],[C=O+R,B=N+S,A=T+1,T>=1,N>=1,U=O+R,V=N+S,W=T+1,T>=1,N>=1,M=Q+U,L=P+V,K=W+1,W>=1,P>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0,M>=0]).
eq('case_6',[A,B,C,D,E,F,G],6,['lcstable'(H,I,C,D,J,K,L),'case_7'(M,N,O,A,B,C,D,P,H,I,Q,R,S)],[B=P+I,A=H+1,H>=1,O=L,N=K,M=J,J>=1,G=S,F=R,E=Q,Q>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0]).
eq('lcstable',[A,B,C,D,E,F,G],1,['case_6'(A,B,C,D,E,F,G)],[A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0]).
eq('case_8',[A,B,C,D,E,F,G,H],2,[],[B=0,A=1,H=0,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0]).
eq('case_9',[A,B,C,D,E,F,G,D,E,H],2,[],[D=1,H=0,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,D>=0,E>=0,H>=0]).
eq('case_9',[A,B,C,D,E,F,G,D,E,H],2,[],[E=H+I,D=J+1,J>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,D>=0,E>=0,H>=0]).
eq('case_8',[A,B,C,D,E,F,G,H],3,['case_9'(A,B,C,D,E,F,G,D,E,H)],[C=E+I,B=D+J,J>=1,A=K+1,K>=1,D>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0]).
eq('lcs',[A,B,C,D,E],4,['lcstable'(A,B,C,D,F,G,H),'case_8'(I,J,K,A,B,C,D,L)],[K=H,J=G,I=F,F>=1,E=L,A>=0,B>=0,C>=0,D>=0,E>=0]).

Preprocessing Cost Relations
=====================================

#### Computed strongly connected components 
0. recursive  : [case_0/4,firstline/4]
1. non_recursive  : [case_9/10]
2. non_recursive  : [case_8/8]
3. non_recursive  : [case_2/3]
4. non_recursive  : [maxL/3]
5. non_recursive  : [case_5/16]
6. non_recursive  : [case_1/3]
7. non_recursive  : [rightL/3]
8. recursive [non_tail] : [case_3/7,case_4/10,newline/7]
9. non_recursive  : [case_7/13]
10. recursive [non_tail] : [case_6/7,lcstable/7]
11. non_recursive  : [lcs/5]
Warning: the following predicates are never called:[and_op/3,eq/3,geq/3,gt/3,leq/3,lt/3,maxNorm/3,neg/2,neq/3,or/3]

#### Obtained direct recursion through partial evaluation 
0. SCC is partially evaluated into firstline/4
1. SCC is partially evaluated into case_9/10
2. SCC is partially evaluated into case_8/8
3. SCC is partially evaluated into case_2/3
4. SCC is partially evaluated into maxL/3
5. SCC is partially evaluated into case_5/16
6. SCC is partially evaluated into case_1/3
7. SCC is partially evaluated into rightL/3
8. SCC is partially evaluated into newline/7
9. SCC is partially evaluated into case_7/13
10. SCC is partially evaluated into lcstable/7
11. SCC is partially evaluated into lcs/5

Control-Flow Refinement of Cost Relations
=====================================

### Specialization of cost equations firstline/4 
* CE 2 is refined into CE [23] 
* CE 1 is refined into CE [24] 


#### Refined cost equations firstline/4 
* CE 23: firstline(A,B,C,D) = 3
     [D>=0,B>=0,C=1,A=1] 
* CE 24: firstline(A,B,C,D) = 6+ firstline(E,F,G,D)
     [G>=1,E>=1,D>=0,B>=0,G+1=C,E+1=A] 

### Cost equations --> "Loop" of firstline/4 
* CEs [24] --> Loop 23 
* CEs [23] --> Loop 24 

#### Loops of firstline/4 
* Loop 23: firstline(A,B,C,D)->  firstline(A',B',C',D)
                  [C'>=1,A'>=1,D>=0,B>=0,C'+1=C,A'+1=A] 
* Loop 24: firstline(A,B,C,D) [D>=0,B>=0,C=1,A=1] 

### Ranking functions of CR firstline(A,B,C,D) 
* RF of phase [23]: [A-1]

#### Partial ranking functions of CR firstline(A,B,C,D) 
* Partial RF of phase [23]:
  - RF of loop [23:1]:
    A-1

Discarded unfeasible chain [[23]]...(Non-terminating chain proved terminating)

### Resulting Chains:firstline(A,B,C,D) 
* [[23],24]
* [24]


### Merging Chains  firstline/4 into  External patterns of execution 
* [[24]] --> 1 
* [[24,[23]]] --> 2 


### Specialization of cost equations case_9/10 
* CE 22 is refined into CE [25] 
* CE 21 is refined into CE [26] 


#### Refined cost equations case_9/10 
* CE 25: case_9(A,B,C,D,E,F,G,D,E,H) = 2
     [B>=D+1,H>=0,G>=0,F>=0,E>=0,D>=2,C>=0,A>=2] 
* CE 26: case_9(A,B,C,D,E,F,G,H,E,I) = 2
     [G>=0,F>=0,E>=0,C>=0,B>=2,A>=2,I=0,H=1,D=1] 

### Cost equations --> "Loop" of case_9/10 
* CEs [25] --> Loop 25 
* CEs [26] --> Loop 26 

#### Loops of case_9/10 
* Loop 25: case_9(A,B,C,D,E,F,G,D,E,H) [B>=D+1,H>=0,G>=0,F>=0,E>=0,D>=2,C>=0,A>=2] 
* Loop 26: case_9(A,B,C,D,E,F,G,H,E,I) [G>=0,F>=0,E>=0,C>=0,B>=2,A>=2,I=0,H=1,D=1] 

### Ranking functions of CR case_9(A,B,C,D,E,F,G,H,I,J) 

#### Partial ranking functions of CR case_9(A,B,C,D,E,F,G,H,I,J) 


### Resulting Chains:case_9(A,B,C,D,E,F,G,H,I,J) 
* [26]
* [25]


### Merging Chains  case_9/10 into  External patterns of execution 
* [[26]] --> 1 
* [[25]] --> 2 


### Specialization of cost equations case_8/8 
* CE 20 is refined into CE [27,28] 
* CE 19 is refined into CE [29] 


#### Refined cost equations case_8/8 
* CE 27: case_8(A,B,C,D,E,F,G,H) = 3+ case_9(A,B,C,I,E,F,G,J,E,K):1
     [E>=0,G>=0,F>=0,C>=0,B>=2,A>=2,K=0,J=1,I=1,H=0,D=1] 
* CE 28: case_8(A,B,C,D,E,F,G,H) = 3+ case_9(A,B,C,D,E,F,G,D,E,H):2
     [B>=D+1,H>=0,E>=0,D>=2,G>=0,F>=0,C>=0,A>=2] 
* CE 29: case_8(A,B,C,D,E,F,G,H) = 2
     [G>=0,F>=0,E>=0,D>=0,C>=0,H=0,B=0,A=1] 

### Cost equations --> "Loop" of case_8/8 
* CEs [28] --> Loop 27 
* CEs [27] --> Loop 28 
* CEs [29] --> Loop 29 

#### Loops of case_8/8 
* Loop 27: case_8(A,B,C,D,E,F,G,H) [B>=D+1,H>=0,G>=0,F>=0,E>=0,D>=2,C>=0,A>=2] 
* Loop 28: case_8(A,B,C,D,E,F,G,H) [G>=0,F>=0,E>=0,C>=0,B>=2,A>=2,H=0,D=1] 
* Loop 29: case_8(A,B,C,D,E,F,G,H) [G>=0,F>=0,E>=0,D>=0,C>=0,H=0,B=0,A=1] 

### Ranking functions of CR case_8(A,B,C,D,E,F,G,H) 

#### Partial ranking functions of CR case_8(A,B,C,D,E,F,G,H) 


### Resulting Chains:case_8(A,B,C,D,E,F,G,H) 
* [29]
* [28]
* [27]


### Merging Chains  case_8/8 into  External patterns of execution 
* [[29]] --> 1 
* [[28]] --> 2 
* [[27]] --> 3 


### Specialization of cost equations case_2/3 
* CE 14 is refined into CE [30] 
* CE 13 is refined into CE [31] 


#### Refined cost equations case_2/3 
* CE 30: case_2(A,B,B) = 1
     [B>=A,A>=0] 
* CE 31: case_2(A,B,A) = 1
     [A>=B+1,B>=0] 

### Cost equations --> "Loop" of case_2/3 
* CEs [30] --> Loop 30 
* CEs [31] --> Loop 31 

#### Loops of case_2/3 
* Loop 30: case_2(A,B,B) [B>=A,A>=0] 
* Loop 31: case_2(A,B,A) [A>=B+1,B>=0] 

### Ranking functions of CR case_2(A,B,C) 

#### Partial ranking functions of CR case_2(A,B,C) 


### Resulting Chains:case_2(A,B,C) 
* [31]
* [30]


### Merging Chains  case_2/3 into  External patterns of execution 
* [[31]] --> 1 
* [[30]] --> 2 


### Specialization of cost equations maxL/3 
* CE 4 is refined into CE [32,33] 


#### Refined cost equations maxL/3 
* CE 32: maxL(A,B,A) = 1+ case_2(A,B,A):1
     [A>=B+1,B>=0] 
* CE 33: maxL(A,B,B) = 1+ case_2(A,B,B):2
     [B>=A,A>=0] 

### Cost equations --> "Loop" of maxL/3 
* CEs [33] --> Loop 32 
* CEs [32] --> Loop 33 

#### Loops of maxL/3 
* Loop 32: maxL(A,B,B) [B>=A,A>=0] 
* Loop 33: maxL(A,B,A) [A>=B+1,B>=0] 

### Ranking functions of CR maxL(A,B,C) 

#### Partial ranking functions of CR maxL(A,B,C) 


### Resulting Chains:maxL(A,B,C) 
* [33]
* [32]


### Merging Chains  maxL/3 into  External patterns of execution 
* [[33]] --> 1 
* [[32]] --> 2 


### Specialization of cost equations case_5/16 
* CE 16 is refined into CE [34,35] 
* CE 15 is refined into CE [36] 


#### Refined cost equations case_5/16 
* CE 34: case_5(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,M) = 2+ maxL(M,B,M):1
     [M>=B+1,J>=E+1,B>=0,O>=0,N>=1,L>=0,K>=1,E>=0,D>=0,C>=1,A>=0,J+L=I,M+O=G,K+1=H,N+1=F] 
* CE 35: case_5(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,B) = 2+ maxL(M,B,B):2
     [B>=M,J>=E+1,M>=0,O>=0,N>=1,L>=0,K>=1,E>=0,D>=0,C>=1,A>=0,J+L=I,M+O=G,K+1=H,N+1=F] 
* CE 36: case_5(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P) = 3
     [I>=L,O>=0,N>=1,M>=0,L>=0,K>=1,D>=0,C>=1,B>=0,A>=0,J+L=I,E+L=I,M+O=G,A+1=P,K+1=H,N+1=F] 

### Cost equations --> "Loop" of case_5/16 
* CEs [34] --> Loop 34 
* CEs [35] --> Loop 35 
* CEs [36] --> Loop 36 

#### Loops of case_5/16 
* Loop 34: case_5(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,M) [G>=M,I>=J,J>=E+1,M>=B+1,H>=2,F>=2,E>=0,D>=0,C>=1,B>=0,A>=0,G=M+O,I=J+L,F=N+1,H=K+1] 
* Loop 35: case_5(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,B) [G>=M,B>=M,I>=J,J>=E+1,M>=0,H>=2,F>=2,E>=0,D>=0,C>=1,A>=0,I=J+L,M+O=G,F=N+1,H=K+1] 
* Loop 36: case_5(A,B,C,D,E,F,G,H,I,E,J,K,L,M,N,O) [G>=L,I>=E,L>=0,H>=2,F>=2,E>=0,D>=0,C>=1,B>=0,A>=0,E+K=I,L+N=G,A+1=O,F=M+1,H=J+1] 

### Ranking functions of CR case_5(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P) 

#### Partial ranking functions of CR case_5(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P) 


### Resulting Chains:case_5(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P) 
* [36]
* [35]
* [34]


### Merging Chains  case_5/16 into  External patterns of execution 
* [[36]] --> 1 
* [[35]] --> 2 
* [[34]] --> 3 


### Specialization of cost equations case_1/3 
* CE 12 is refined into CE [37] 
* CE 11 is refined into CE [38] 


#### Refined cost equations case_1/3 
* CE 37: case_1(A,B,C) = 2
     [C>=0,B>=0,A>=2] 
* CE 38: case_1(A,B,C) = 2
     [B>=0,C=0,A=1] 

### Cost equations --> "Loop" of case_1/3 
* CEs [37] --> Loop 37 
* CEs [38] --> Loop 38 

#### Loops of case_1/3 
* Loop 37: case_1(A,B,C) [C>=0,B>=0,A>=2] 
* Loop 38: case_1(A,B,C) [B>=0,C=0,A=1] 

### Ranking functions of CR case_1(A,B,C) 

#### Partial ranking functions of CR case_1(A,B,C) 


### Resulting Chains:case_1(A,B,C) 
* [38]
* [37]


### Merging Chains  case_1/3 into  External patterns of execution 
* [[38]] --> 1 
* [[37]] --> 2 


### Specialization of cost equations rightL/3 
* CE 3 is refined into CE [39,40] 


#### Refined cost equations rightL/3 
* CE 39: rightL(A,B,C) = 1+ case_1(D,B,E):1
     [B>=0,E=0,D=1,C=0,A=1] 
* CE 40: rightL(A,B,C) = 1+ case_1(A,B,C):2
     [C>=0,B>=0,A>=2] 

### Cost equations --> "Loop" of rightL/3 
* CEs [40] --> Loop 39 
* CEs [39] --> Loop 40 

#### Loops of rightL/3 
* Loop 39: rightL(A,B,C) [C>=0,B>=0,A>=2] 
* Loop 40: rightL(A,B,C) [B>=0,C=0,A=1] 

### Ranking functions of CR rightL(A,B,C) 

#### Partial ranking functions of CR rightL(A,B,C) 


### Resulting Chains:rightL(A,B,C) 
* [40]
* [39]


### Merging Chains  rightL/3 into  External patterns of execution 
* [[40]] --> 1 
* [[39]] --> 2 


### Specialization of cost equations newline/7 
* CE 7 is refined into CE [41,42,43,44,45,46,47,48,49,50,51,52] 
* CE 5 is refined into CE [53] 
* CE 6 is refined into CE [54] 


#### Refined cost equations newline/7 
* CE 41: newline(A,B,C,D,E,F,G) = 19+ newline(A,H,I,J,K,L,M)+ rightL(N,M,O):1+ rightL(P,I,Q):1+ case_5(R,S,T,M,A,U,V,W,E,A,J,X,Y,Z,I,A1):1
     [E>=A,I>=0,Y>=0,J>=1,A>=0,M>=0,A+K=E,A+X=E,I+Y=V,I+Y=C,J+1=W,M+1=G,J+1=D,L=1,H=1,A1=1,Z=1,U=2,T=1,S=0,R=0,Q=0,P=1,O=0,N=1,F=2,B=2] 
* CE 42: newline(A,B,C,D,E,F,G) = 19+ newline(A,H,C,I,J,K,G)+ rightL(L,G,M):1+ rightL(N,C,O):1+ case_5(P,Q,R,G,A,S,C,T,U,V,I,J,W,X,C,Y):2
     [V>=A+1,C>=0,J>=0,I>=1,A>=0,G>=0,V+J=U,V+J=E,I+1=T,I+1=D,K=1,H=1,Y=0,X=1,W=0,S=2,R=1,Q=0,P=0,O=0,N=1,M=0,L=1,F=2,B=2] 
* CE 43: newline(A,B,C,D,E,F,G) = 19+ newline(A,H,I,J,K,L,M)+ rightL(N,M,O):1+ rightL(P,I,Q):1+ case_5(R,S,T,M,A,U,V,W,X,Y,J,K,Z,A1,I,Z):3
     [Y>=A+1,Z>=1,I>=0,K>=0,J>=1,A>=0,M>=0,Y+K=X,I+Z=V,M+Z=G,Y+K=E,I+Z=C,J+1=W,J+1=D,L=1,H=1,A1=1,U=2,T=1,S=0,R=0,Q=0,P=1,O=0,N=1,F=2,B=2] 
* CE 44: newline(A,B,C,D,E,F,G) = 19+ newline(A,H,I,J,K,L,M)+ rightL(N,M,O):1+ rightL(H,I,P):2+ case_5(Q,R,S,M,A,T,U,V,E,A,J,W,X,H,I,Y):1
     [E>=A,Y>=1,I>=0,H>=2,X>=0,J>=1,A>=0,M>=0,A+K=E,A+W=E,I+X=U,M+Y=G,I+X=C,J+1=V,H+1=T,Y=Q+1,Y=P+1,J+1=D,H+1=B,L=1,S=1,R=0,O=0,N=1,F=2] 
* CE 45: newline(A,B,C,D,E,F,G) = 19+ newline(A,H,C,I,J,K,G)+ rightL(L,G,M):1+ rightL(H,C,N):2+ case_5(N,O,P,G,A,Q,C,R,S,T,I,J,U,H,C,V):2
     [T>=A+1,C>=0,H>=2,J>=0,I>=1,A>=0,G>=0,N>=0,T+J=S,T+J=E,I+1=R,H+1=Q,I+1=D,H+1=B,K=1,V=0,U=0,P=1,O=0,M=0,L=1,F=2] 
* CE 46: newline(A,B,C,D,E,F,G) = 19+ newline(A,H,I,J,K,L,M)+ rightL(N,M,O):1+ rightL(H,I,P):2+ case_5(P,Q,R,M,A,S,T,U,V,W,J,K,X,H,I,X):3
     [W>=A+1,X>=1,I>=0,H>=2,K>=0,J>=1,A>=0,M>=0,P>=0,W+K=V,I+X=T,M+X=G,W+K=E,I+X=C,J+1=U,H+1=S,J+1=D,H+1=B,L=1,R=1,Q=0,O=0,N=1,F=2] 
* CE 47: newline(A,B,C,D,E,F,G) = 19+ newline(A,H,I,J,K,L,M)+ rightL(L,M,N):2+ rightL(O,I,P):1+ case_5(Q,N,L,M,A,R,S,T,E,A,J,U,V,W,I,X):1
     [E>=A,I>=0,V>=0,J>=1,A>=0,M>=0,L>=2,N>=0,A+K=E,A+U=E,I+V=S,I+V=C,J+1=T,M+1=G,L+1=F,J+1=D,H=1,X=1,W=1,R=2,Q=0,P=0,O=1,B=2] 
* CE 48: newline(A,B,C,D,E,F,G) = 19+ newline(A,H,I,J,K,L,M)+ rightL(L,M,N):2+ rightL(O,I,P):1+ case_5(Q,N,L,M,A,R,S,T,U,V,J,K,W,X,I,N):2
     [N>=W,V>=A+1,I>=0,W>=0,K>=0,J>=1,A>=0,M>=0,L>=2,V+K=U,I+W=S,M+N=G,V+K=E,I+W=C,J+1=T,L+1=F,J+1=D,H=1,X=1,R=2,Q=0,P=0,O=1,B=2] 
* CE 49: newline(A,B,C,D,E,F,G) = 19+ newline(A,H,I,J,K,L,M)+ rightL(L,M,N):2+ rightL(O,I,P):1+ case_5(Q,N,L,M,A,R,S,T,U,V,J,K,W,X,I,W):3
     [V>=A+1,W>=N+1,I>=0,K>=0,J>=1,A>=0,M>=0,L>=2,N>=0,V+K=U,I+W=S,M+W=G,V+K=E,I+W=C,J+1=T,L+1=F,J+1=D,H=1,X=1,R=2,Q=0,P=0,O=1,B=2] 
* CE 50: newline(A,B,C,D,E,F,G) = 19+ newline(A,H,I,J,K,L,M)+ rightL(L,M,N):2+ rightL(H,I,O):2+ case_5(P,N,L,M,A,Q,R,S,E,A,J,T,U,H,I,V):1
     [E>=A,V>=1,I>=0,H>=2,U>=0,J>=1,A>=0,M>=0,L>=2,N>=0,A+K=E,A+T=E,I+U=R,M+V=G,I+U=C,J+1=S,H+1=Q,V=P+1,V=O+1,L+1=F,J+1=D,H+1=B] 
* CE 51: newline(A,B,C,D,E,F,G) = 19+ newline(A,H,I,J,K,L,M)+ rightL(L,M,N):2+ rightL(H,I,O):2+ case_5(O,N,L,M,A,P,Q,R,S,T,J,K,U,H,I,N):2
     [N>=U,T>=A+1,I>=0,H>=2,U>=0,K>=0,J>=1,A>=0,M>=0,L>=2,O>=0,T+K=S,I+U=Q,M+N=G,T+K=E,I+U=C,J+1=R,H+1=P,L+1=F,J+1=D,H+1=B] 
* CE 52: newline(A,B,C,D,E,F,G) = 19+ newline(A,H,I,J,K,L,M)+ rightL(L,M,N):2+ rightL(H,I,O):2+ case_5(O,N,L,M,A,P,Q,R,S,T,J,K,U,H,I,U):3
     [T>=A+1,U>=N+1,I>=0,H>=2,K>=0,J>=1,A>=0,M>=0,L>=2,N>=0,O>=0,T+K=S,I+U=Q,M+U=G,T+K=E,I+U=C,J+1=R,H+1=P,L+1=F,J+1=D,H+1=B] 
* CE 53: newline(A,B,C,D,E,F,G) = 3
     [G>=0,E>=0,C>=0,B>=0,A>=0,F=1,D=1] 
* CE 54: newline(A,B,C,D,E,F,G) = 6
     [G>=0,E>=0,D>=2,C>=0,A>=0,F=1,B=1] 

### Cost equations --> "Loop" of newline/7 
* CEs [53] --> Loop 41 
* CEs [54] --> Loop 42 
* CEs [51,52] --> Loop 43 
* CEs [50] --> Loop 44 
* CEs [46] --> Loop 45 
* CEs [44] --> Loop 46 
* CEs [45] --> Loop 47 
* CEs [48,49] --> Loop 48 
* CEs [47] --> Loop 49 
* CEs [43] --> Loop 50 
* CEs [42] --> Loop 51 
* CEs [41] --> Loop 52 

#### Loops of newline/7 
* Loop 41: newline(A,B,C,D,E,F,G) [G>=0,E>=0,C>=0,B>=0,A>=0,F=1,D=1] 
* Loop 42: newline(A,B,C,D,E,F,G) [G>=0,E>=0,D>=2,C>=0,A>=0,F=1,B=1] 
* Loop 43: newline(A,B,C,D,E,F,G)->  newline(A,A',B',C',D',E',F')
                  [G+B'>=C+F',E>=A+D'+1,C>=B',F'>=0,D'>=0,B'>=0,F>=3,D>=2,B>=3,A>=0,F=E'+1,D=C'+1,B=A'+1] 
* Loop 44: newline(A,B,C,D,E,F,G)->  newline(A,A',B',C',D',E',F')
                  [G>=F'+1,C>=B',E>=A,F'>=0,B'>=0,F>=3,D>=2,B>=3,A>=0,A+D'=E,F=E'+1,D=C'+1,B=A'+1] 
* Loop 45: newline(A,B,C,D,E,F,G)->  newline(A,A',B',C',D',E',F')
                  [G+B'>=C,E>=A+D'+1,C>=B'+1,D'>=0,B'>=0,D>=2,B>=3,A>=0,C+F'=G+B',D=C'+1,B=A'+1,E'=1,F=2] 
* Loop 46: newline(A,B,C,D,E,F,G)->  newline(A,A',B',C',D',E',F')
                  [G>=F'+1,C>=B',E>=A,F'>=0,B'>=0,D>=2,B>=3,A>=0,A+D'=E,D=C'+1,B=A'+1,E'=1,F=2] 
* Loop 47: newline(A,B,C,D,E,F,G)->  newline(A,A',C,B',C',D',G)
                  [E>=A+C'+1,C'>=0,G>=0,D>=2,C>=0,B>=3,A>=0,D=B'+1,B=A'+1,D'=1,F=2] 
* Loop 48: newline(A,B,C,D,E,F,G)->  newline(A,A',B',C',D',E',F')
                  [G+B'>=C+F',E>=A+D'+1,C>=B',F'>=0,D'>=0,B'>=0,F>=3,D>=2,A>=0,F=E'+1,D=C'+1,A'=1,B=2] 
* Loop 49: newline(A,B,C,D,E,F,G)->  newline(A,A',B',C',D',E',F')
                  [C>=B',E>=A,B'>=0,G>=1,F>=3,D>=2,A>=0,A+D'=E,G=F'+1,F=E'+1,D=C'+1,A'=1,B=2] 
* Loop 50: newline(A,B,C,D,E,F,G)->  newline(A,A',B',C',D',E',F')
                  [G+B'>=C,E>=A+D'+1,C>=B'+1,D'>=0,B'>=0,D>=2,A>=0,C+F'=G+B',D=C'+1,E'=1,A'=1,F=2,B=2] 
* Loop 51: newline(A,B,C,D,E,F,G)->  newline(A,A',C,B',C',D',G)
                  [E>=A+C'+1,C'>=0,G>=0,D>=2,C>=0,A>=0,D=B'+1,D'=1,A'=1,F=2,B=2] 
* Loop 52: newline(A,B,C,D,E,F,G)->  newline(A,A',B',C',D',E',F')
                  [C>=B',E>=A,B'>=0,G>=1,D>=2,A>=0,A+D'=E,G=F'+1,D=C'+1,E'=1,A'=1,F=2,B=2] 

### Ranking functions of CR newline(A,B,C,D,E,F,G) 
* RF of phase [43,44]: [B-2,D-1]

#### Partial ranking functions of CR newline(A,B,C,D,E,F,G) 
* Partial RF of phase [43,44]:
  - RF of loop [43:1]:
    -A+E
    E
  - RF of loop [43:1,44:1]:
    B-2
    D-1

Discarded unfeasible chain [[43,44]]...(Non-terminating chain proved terminating)

### Resulting Chains:newline(A,B,C,D,E,F,G) 
* [[43,44],52,42]
* [[43,44],52,41]
* [[43,44],51,42]
* [[43,44],51,41]
* [[43,44],50,42]
* [[43,44],50,41]
* [[43,44],47,41]
* [[43,44],46,41]
* [[43,44],45,41]
* [52,42]
* [52,41]
* [51,42]
* [51,41]
* [50,42]
* [50,41]
* [47,41]
* [46,41]
* [45,41]
* [42]
* [41]


### Merging Chains  newline/7 into  External patterns of execution 
* [[42]] --> 1 
* [[41,50],[41,51]] --> 2 
* [[41,52]] --> 3 
* [[42,50],[42,51]] --> 4 
* [[42,52]] --> 5 
* [[41]] --> 6 
* [[41,45],[41,47]] --> 7 
* [[41,46]] --> 8 
* [[41,50,[43,44]],[41,51,[43,44]]] --> 9 
* [[41,52,[43,44]]] --> 10 
* [[42,50,[43,44]],[42,51,[43,44]]] --> 11 
* [[42,52,[43,44]]] --> 12 
* [[41,45,[43,44]],[41,47,[43,44]]] --> 13 
* [[41,46,[43,44]]] --> 14 


### Specialization of cost equations case_7/13 
* CE 18 is refined into CE [55,56,57,58,59,60,61,62,63,64,65,66,67,68] 
* CE 17 is refined into CE [69] 


#### Refined cost equations case_7/13 
* CE 55: case_7(A,B,C,D,E,F,G,H,I,J,K,L,M) = 5+ newline(H,N,O,F,G,P,Q):1
     [M>=Q,Q>=0,G>=0,F>=2,O>=0,H>=0,L>=1,J>=0,I>=1,A>=2,C+Q=M,H+J=E,A+1=K,I+1=D,L=B+1,P=1,N=1] 
* CE 56: case_7(A,B,C,D,E,F,G,H,I,J,K,L,M) = 5+ newline(H,N,O,P,G,Q,R):2
     [M>=R,G>=H+1,R>=0,O>=0,H>=0,L>=2,J>=0,I>=1,A>=2,C+R=M,H+J=E,A+1=K,I+1=D,L=B+2,Q=2,P=2,N=2,F=2] 
* CE 57: case_7(A,B,C,D,E,F,G,H,I,J,K,L,M) = 5+ newline(H,N,O,P,G,Q,R):3
     [M>=R,G>=H,R>=1,O>=0,H>=0,L>=2,J>=0,I>=1,A>=2,C+R=M,H+J=E,A+1=K,I+1=D,L=B+2,Q=2,P=2,N=2,F=2] 
* CE 58: case_7(A,B,C,D,E,F,G,H,I,J,K,L,M) = 5+ newline(H,N,O,F,G,P,Q):4
     [M>=Q,G>=H+1,Q>=0,F>=3,O>=0,H>=0,L>=2,J>=0,I>=1,A>=2,C+Q=M,H+J=E,A+1=K,I+1=D,L=B+2,P=2,N=2] 
* CE 59: case_7(A,B,C,D,E,F,G,H,I,J,K,L,M) = 5+ newline(H,N,O,F,G,P,Q):5
     [M>=Q,G>=H,Q>=1,F>=3,O>=0,H>=0,L>=2,J>=0,I>=1,A>=2,C+Q=M,H+J=E,A+1=K,I+1=D,L=B+2,P=2,N=2] 
* CE 60: case_7(A,B,C,D,E,F,G,H,I,J,K,L,M) = 5+ newline(H,N,O,P,G,Q,R):6
     [M>=R,R>=0,G>=0,O>=0,N>=1,H>=0,L>=1,J>=0,I>=1,A>=2,C+R=M,H+J=E,A+1=K,I+1=D,L=B+1,Q=1,P=1,F=1] 
* CE 61: case_7(A,B,C,D,E,F,G,H,I,J,K,L,M) = 5+ newline(H,N,O,P,G,Q,R):7
     [M>=R,G>=H+1,R>=0,O>=0,N>=3,H>=0,L>=2,J>=0,I>=1,A>=2,C+R=M,H+J=E,A+1=K,I+1=D,L=B+2,Q=2,P=2,F=2] 
* CE 62: case_7(A,B,C,D,E,F,G,H,I,J,K,L,M) = 5+ newline(H,N,O,P,G,Q,R):8
     [M>=R,G>=H,R>=1,O>=0,N>=3,H>=0,L>=2,J>=0,I>=1,A>=2,C+R=M,H+J=E,A+1=K,I+1=D,L=B+2,Q=2,P=2,F=2] 
* CE 63: case_7(A,B,C,D,E,F,G,H,I,J,K,L,M) = 5+ newline(H,F,N,F,G,F,O):9
     [G+O+1>=2*H+F,M>=O,L>=F,G>=2*H+1,O>=0,F>=3,N>=0,H>=0,J>=0,I>=1,A>=2,C+O=M,B+F=L,H+J=E,A+1=K,I+1=D] 
* CE 64: case_7(A,B,C,D,E,F,G,H,I,J,K,L,M) = 5+ newline(H,F,N,F,G,F,O):10
     [G+O+1>=2*H+F,M>=O,L>=F,G>=2*H,O>=1,F>=3,N>=0,H>=0,J>=0,I>=1,A>=2,C+O=M,B+F=L,H+J=E,A+1=K,I+1=D] 
* CE 65: case_7(A,B,C,D,E,F,G,H,I,J,K,L,M) = 5+ newline(H,N,O,F,G,N,P):11
     [G+P+1>=2*H+N,M>=P,F>=N+1,L>=N,G>=2*H+1,P>=0,N>=3,O>=0,H>=0,J>=0,I>=1,A>=2,C+P=M,B+N=L,H+J=E,A+1=K,I+1=D] 
* CE 66: case_7(A,B,C,D,E,F,G,H,I,J,K,L,M) = 5+ newline(H,N,O,F,G,N,P):12
     [G+P+1>=2*H+N,M>=P,F>=N+1,L>=N,G>=2*H,P>=1,N>=3,O>=0,H>=0,J>=0,I>=1,A>=2,C+P=M,B+N=L,H+J=E,A+1=K,I+1=D] 
* CE 67: case_7(A,B,C,D,E,F,G,H,I,J,K,L,M) = 5+ newline(H,N,O,F,G,F,P):13
     [G+P+1>=2*H+F,M>=P,N>=F+1,L>=F,G>=2*H+1,P>=0,F>=3,O>=0,H>=0,J>=0,I>=1,A>=2,C+P=M,B+F=L,H+J=E,A+1=K,I+1=D] 
* CE 68: case_7(A,B,C,D,E,F,G,H,I,J,K,L,M) = 5+ newline(H,N,O,F,G,F,P):14
     [G+P+1>=2*H+F,M>=P,N>=F+1,L>=F,G>=2*H,P>=1,F>=3,O>=0,H>=0,J>=0,I>=1,A>=2,C+P=M,B+F=L,H+J=E,A+1=K,I+1=D] 
* CE 69: case_7(A,B,C,D,E,F,G,H,I,J,K,L,M) = 2
     [M>=0,J>=0,I>=1,H>=0,G>=0,F>=0,C>=0,H+J=E,I+1=D,L=0,K=1,B=0,A=1] 

### Cost equations --> "Loop" of case_7/13 
* CEs [65] --> Loop 53 
* CEs [66] --> Loop 54 
* CEs [63,67] --> Loop 55 
* CEs [64,68] --> Loop 56 
* CEs [59] --> Loop 57 
* CEs [58] --> Loop 58 
* CEs [55] --> Loop 59 
* CEs [57,62] --> Loop 60 
* CEs [56,61] --> Loop 61 
* CEs [60] --> Loop 62 
* CEs [69] --> Loop 63 

#### Loops of case_7/13 
* Loop 53: case_7(A,B,C,D,E,F,G,H,I,J,K,L,M) [B+G+M+1>=2*H+C+L,B+F>=L+1,E>=H,M>=C,L>=B+3,G>=2*H+1,H>=0,D>=2,C>=0,B>=0,A>=2,H+J=E,A+1=K,D=I+1] 
* Loop 54: case_7(A,B,C,D,E,F,G,H,I,J,K,L,M) [B+G+M+1>=2*H+C+L,B+F>=L+1,E>=H,M>=C+1,L>=B+3,G>=2*H,H>=0,D>=2,C>=0,B>=0,A>=2,H+J=E,A+1=K,D=I+1] 
* Loop 55: case_7(A,B,C,D,E,F,G,H,I,J,K,L,M) [G+M+1>=2*H+C+F,E>=H,M>=C,G>=2*H+1,H>=0,F>=3,D>=2,C>=0,B>=0,A>=2,B+F=L,E=H+J,A+1=K,D=I+1] 
* Loop 56: case_7(A,B,C,D,E,F,G,H,I,J,K,L,M) [G+M+1>=2*H+C+F,E>=H,M>=C+1,G>=2*H,H>=0,F>=3,D>=2,C>=0,B>=0,A>=2,B+F=L,E=H+J,A+1=K,D=I+1] 
* Loop 57: case_7(A,B,C,D,E,F,G,H,I,J,K,L,M) [G>=H,E>=H,M>=C+1,H>=0,F>=3,D>=2,C>=0,B>=0,A>=2,H+J=E,B+2=L,A+1=K,D=I+1] 
* Loop 58: case_7(A,B,C,D,E,F,G,H,I,J,K,L,M) [G>=H+1,E>=H,M>=C,H>=0,F>=3,D>=2,C>=0,B>=0,A>=2,H+J=E,B+2=L,A+1=K,D=I+1] 
* Loop 59: case_7(A,B,C,D,E,F,G,H,I,J,K,L,M) [E>=H,M>=C,H>=0,G>=0,F>=2,D>=2,C>=0,B>=0,A>=2,H+J=E,B+1=L,A+1=K,D=I+1] 
* Loop 60: case_7(A,B,C,D,E,F,G,H,I,J,K,L,M) [G>=H,E>=H,M>=C+1,H>=0,D>=2,C>=0,B>=0,A>=2,H+J=E,B+2=L,A+1=K,D=I+1,F=2] 
* Loop 61: case_7(A,B,C,D,E,F,G,H,I,J,K,L,M) [G>=H+1,E>=H,M>=C,H>=0,D>=2,C>=0,B>=0,A>=2,H+J=E,B+2=L,A+1=K,D=I+1,F=2] 
* Loop 62: case_7(A,B,C,D,E,F,G,H,I,J,K,L,M) [E>=H,M>=C,H>=0,G>=0,D>=2,C>=0,B>=0,A>=2,H+J=E,B+1=L,A+1=K,D=I+1,F=1] 
* Loop 63: case_7(A,B,C,D,E,F,G,H,I,J,K,L,M) [E>=H,M>=0,H>=0,G>=0,F>=0,D>=2,C>=0,H+J=E,D=I+1,L=0,K=1,B=0,A=1] 

### Ranking functions of CR case_7(A,B,C,D,E,F,G,H,I,J,K,L,M) 

#### Partial ranking functions of CR case_7(A,B,C,D,E,F,G,H,I,J,K,L,M) 


### Resulting Chains:case_7(A,B,C,D,E,F,G,H,I,J,K,L,M) 
* [63]
* [62]
* [61]
* [60]
* [59]
* [58]
* [57]
* [56]
* [55]
* [54]
* [53]


### Merging Chains  case_7/13 into  External patterns of execution 
* [[63]] --> 1 
* [[62]] --> 2 
* [[61]] --> 3 
* [[60]] --> 4 
* [[59]] --> 5 
* [[58]] --> 6 
* [[57]] --> 7 
* [[56]] --> 8 
* [[55]] --> 9 
* [[54]] --> 10 
* [[53]] --> 11 


### Specialization of cost equations lcstable/7 
* CE 9 is refined into CE [70,71] 
* CE 8 is refined into CE [72,73,74,75,76,77,78,79,80,81,82] 


#### Refined cost equations lcstable/7 
* CE 70: lcstable(A,B,C,D,E,F,G) = 5+ firstline(H,D,I,J):1
     [J>=0,D>=0,G>=0,B>=0,I=1,H=1,F=1,E=2,C=1,A=1] 
* CE 71: lcstable(A,B,C,D,E,C,F) = 5+ firstline(C,D,C,G):2
     [G>=0,C>=2,D>=0,F>=0,B>=0,E=2,A=1] 
* CE 72: lcstable(A,B,C,D,E,F,G) = 7+ lcstable(H,I,C,D,J,K,L)+ case_7(M,N,L,O,P,C,D,Q,H,I,R,S,G):1
     [G>=0,I>=0,H>=1,Q>=0,D>=0,C>=0,L>=0,Q+I=P,Q+I=B,H+1=O,H+1=A,K=0,J=1,S=0,R=1,N=0,M=1,F=0,E=1] 
* CE 73: lcstable(A,B,C,D,E,F,G) = 7+ lcstable(H,I,J,D,K,L,M)+ case_7(N,O,M,P,Q,R,D,S,H,I,E,F,G):2
     [G>=M,F>=1,E>=3,I>=0,H>=1,S>=0,D>=0,M>=0,S+I=Q,S+I=B,F=L+1,E=K+1,H+1=P,F=O+1,E=N+1,H+1=A,J=1,R=1,C=1] 
* CE 74: lcstable(A,B,C,D,E,F,G) = 7+ lcstable(H,I,J,D,K,L,M)+ case_7(N,O,M,P,Q,R,D,S,H,I,E,F,G):3
     [D>=S+1,G>=M,F>=2,E>=3,I>=0,H>=1,S>=0,M>=0,S+I=Q,S+I=B,F=L+2,E=K+1,H+1=P,F=O+2,E=N+1,H+1=A,J=2,R=2,C=2] 
* CE 75: lcstable(A,B,C,D,E,F,G) = 7+ lcstable(H,I,J,D,K,L,M)+ case_7(N,O,M,P,Q,R,D,S,H,I,E,F,G):4
     [D>=S,G>=M+1,F>=2,E>=3,I>=0,H>=1,S>=0,M>=0,S+I=Q,S+I=B,F=L+2,E=K+1,H+1=P,F=O+2,E=N+1,H+1=A,J=2,R=2,C=2] 
* CE 76: lcstable(A,B,C,D,E,F,G) = 7+ lcstable(H,I,C,D,J,K,L)+ case_7(M,N,L,O,P,C,D,Q,H,I,E,F,G):5
     [G>=L,F>=1,E>=3,I>=0,H>=1,Q>=0,D>=0,C>=2,L>=0,Q+I=P,Q+I=B,F=K+1,E=J+1,H+1=O,F=N+1,E=M+1,H+1=A] 
* CE 77: lcstable(A,B,C,D,E,F,G) = 7+ lcstable(H,I,C,D,J,K,L)+ case_7(M,N,L,O,P,C,D,Q,H,I,E,F,G):6
     [D>=Q+1,G>=L,F>=2,E>=3,I>=0,H>=1,Q>=0,C>=3,L>=0,Q+I=P,Q+I=B,F=K+2,E=J+1,H+1=O,F=N+2,E=M+1,H+1=A] 
* CE 78: lcstable(A,B,C,D,E,F,G) = 7+ lcstable(H,I,C,D,J,K,L)+ case_7(M,N,L,O,P,C,D,Q,H,I,E,F,G):7
     [D>=Q,G>=L+1,F>=2,E>=3,I>=0,H>=1,Q>=0,C>=3,L>=0,Q+I=P,Q+I=B,F=K+2,E=J+1,H+1=O,F=N+2,E=M+1,H+1=A] 
* CE 79: lcstable(A,B,C,D,E,F,G) = 7+ lcstable(H,I,J,D,K,L,M)+ case_7(N,L,M,O,B,P,D,Q,H,R,E,F,G):8
     [D+G+L+1>=2*Q+F+M,B>=Q,G>=M+1,F>=L+3,D>=2*Q,E>=3,H>=1,Q>=0,M>=0,L>=0,B=Q+I,B=Q+R,F=L+J,F=L+P,F=C+L,E=K+1,H+1=O,E=N+1,H+1=A] 
* CE 80: lcstable(A,B,C,D,E,F,G) = 7+ lcstable(H,I,J,D,K,L,M)+ case_7(N,L,M,O,B,P,D,Q,H,R,E,F,G):9
     [D+G+L+1>=2*Q+F+M,B>=Q,G>=M,F>=L+3,D>=2*Q+1,E>=3,H>=1,Q>=0,M>=0,L>=0,B=Q+I,B=Q+R,F=L+J,F=L+P,F=C+L,E=K+1,H+1=O,E=N+1,H+1=A] 
* CE 81: lcstable(A,B,C,D,E,F,G) = 7+ lcstable(H,I,C,D,J,K,L)+ case_7(M,K,L,N,B,C,D,O,H,P,E,F,G):10
     [D+G+K+1>=2*O+F+L,C+K>=F+1,B>=O,G>=L+1,F>=K+3,D>=2*O,E>=3,H>=1,O>=0,L>=0,K>=0,B=O+I,B=O+P,E=J+1,H+1=N,E=M+1,H+1=A] 
* CE 82: lcstable(A,B,C,D,E,F,G) = 7+ lcstable(H,I,C,D,J,K,L)+ case_7(M,K,L,N,B,C,D,O,H,P,E,F,G):11
     [D+G+K+1>=2*O+F+L,C+K>=F+1,B>=O,G>=L,F>=K+3,D>=2*O+1,E>=3,H>=1,O>=0,L>=0,K>=0,B=O+I,B=O+P,E=J+1,H+1=N,E=M+1,H+1=A] 

### Cost equations --> "Loop" of lcstable/7 
* CEs [81] --> Loop 64 
* CEs [82] --> Loop 65 
* CEs [79] --> Loop 66 
* CEs [80] --> Loop 67 
* CEs [78] --> Loop 68 
* CEs [77] --> Loop 69 
* CEs [76] --> Loop 70 
* CEs [72] --> Loop 71 
* CEs [75] --> Loop 72 
* CEs [74] --> Loop 73 
* CEs [73] --> Loop 74 
* CEs [71] --> Loop 75 
* CEs [70] --> Loop 76 

#### Loops of lcstable/7 
* Loop 64: lcstable(A,B,C,D,E,F,G)->  lcstable(A',B',C,D,C',D',E')
                  [D+G+D'+2*B'+1>=2*B+F+E',C+D'>=F+1,D+2*B'>=2*B,G>=E'+1,F>=D'+3,B>=B',E'>=0,D'>=0,B'>=0,E>=3,A>=2,E=C'+1,A=A'+1] 
* Loop 65: lcstable(A,B,C,D,E,F,G)->  lcstable(A',B',C,D,C',D',E')
                  [D+G+D'+2*B'+1>=2*B+F+E',C+D'>=F+1,D+2*B'>=2*B+1,G>=E',F>=D'+3,B>=B',E'>=0,D'>=0,B'>=0,E>=3,A>=2,E=C'+1,A=A'+1] 
* Loop 66: lcstable(A,B,C,D,E,F,G)->  lcstable(A',B',C,D,C',D',E')
                  [D+G+2*B'+1>=2*B+C+E',D+2*B'>=2*B,G>=E'+1,B>=B',F>=C,E'>=0,B'>=0,E>=3,C>=3,A>=2,C+D'=F,E=C'+1,A=A'+1] 
* Loop 67: lcstable(A,B,C,D,E,F,G)->  lcstable(A',B',C,D,C',D',E')
                  [D+G+2*B'+1>=2*B+C+E',D+2*B'>=2*B+1,G>=E',B>=B',F>=C,E'>=0,B'>=0,E>=3,C>=3,A>=2,C+D'=F,E=C'+1,A=A'+1] 
* Loop 68: lcstable(A,B,C,D,E,F,G)->  lcstable(A',B',C,D,C',D',E')
                  [D+B'>=B,G>=E'+1,B>=B',E'>=0,B'>=0,F>=2,E>=3,C>=3,A>=2,F=D'+2,E=C'+1,A=A'+1] 
* Loop 69: lcstable(A,B,C,D,E,F,G)->  lcstable(A',B',C,D,C',D',E')
                  [D+B'>=B+1,G>=E',B>=B',E'>=0,B'>=0,F>=2,E>=3,C>=3,A>=2,F=D'+2,E=C'+1,A=A'+1] 
* Loop 70: lcstable(A,B,C,D,E,F,G)->  lcstable(A',B',C,D,C',D',E')
                  [G>=E',B>=B',E'>=0,B'>=0,F>=1,E>=3,D>=0,C>=2,A>=2,F=D'+1,E=C'+1,A=A'+1] 
* Loop 71: lcstable(A,B,C,D,E,F,G)->  lcstable(A',B',C,D,C',D',E')
                  [B>=B',E'>=0,B'>=0,G>=0,D>=0,C>=0,A>=2,A=A'+1,D'=0,C'=1,F=0,E=1] 
* Loop 72: lcstable(A,B,C,D,E,F,G)->  lcstable(A',B',C',D,D',E',F')
                  [D+B'>=B,G>=F'+1,B>=B',F'>=0,B'>=0,F>=2,E>=3,A>=2,F=E'+2,E=D'+1,A=A'+1,C'=2,C=2] 
* Loop 73: lcstable(A,B,C,D,E,F,G)->  lcstable(A',B',C',D,D',E',F')
                  [D+B'>=B+1,G>=F',B>=B',F'>=0,B'>=0,F>=2,E>=3,A>=2,F=E'+2,E=D'+1,A=A'+1,C'=2,C=2] 
* Loop 74: lcstable(A,B,C,D,E,F,G)->  lcstable(A',B',C',D,D',E',F')
                  [G>=F',B>=B',F'>=0,B'>=0,F>=1,E>=3,D>=0,A>=2,F=E'+1,E=D'+1,A=A'+1,C'=1,C=1] 
* Loop 75: lcstable(A,B,C,D,E,C,F) [F>=0,D>=0,C>=2,B>=0,E=2,A=1] 
* Loop 76: lcstable(A,B,C,D,E,F,G) [G>=0,D>=0,B>=0,F=1,E=2,C=1,A=1] 

### Ranking functions of CR lcstable(A,B,C,D,E,F,G) 
* RF of phase [64,65,66,67,68,69,70,72,73]: [A-1]
* RF of phase [71]: [A-1]
* RF of phase [74]: [A-1]

#### Partial ranking functions of CR lcstable(A,B,C,D,E,F,G) 
* Partial RF of phase [64,65,66,67,68,69,70,72,73]:
  - RF of loop [64:1,65:1,66:1,67:1,68:1,69:1,70:1,72:1,73:1]:
    A-1
* Partial RF of phase [71]:
  - RF of loop [71:1]:
    A-1
* Partial RF of phase [74]:
  - RF of loop [74:1]:
    A-1

Discarded unfeasible chain [[74]]...(Non-terminating chain proved terminating)
Discarded unfeasible chain [[71]](Non-terminating chain proved terminating)
Discarded unfeasible chain [[64,65,66,67,68,69,70,72,73]](Non-terminating chain proved terminating)

### Resulting Chains:lcstable(A,B,C,D,E,F,G) 
* [[74],76]
* [[64,65,66,67,68,69,70,72,73],75]
* [76]
* [75]


### Merging Chains  lcstable/7 into  External patterns of execution 
* [[76]] --> 1 
* [[75]] --> 2 
* [[76,[74]]] --> 3 
* [[75,[64,65,66,67,68,69,70,72,73]]] --> 4 


### Specialization of cost equations lcs/5 
* CE 10 is refined into CE [83,84] 


#### Refined cost equations lcs/5 
* CE 83: lcs(A,B,C,D,E) = 4+ lcstable(F,B,C,D,G,C,H):2+ case_8(I,C,H,J,B,C,D,K):2
     [D>=0,B>=0,H>=0,C>=2,K=0,J=1,I=2,G=2,F=1,E=0,A=1] 
* CE 84: lcs(A,B,C,D,E) = 4+ lcstable(F,B,C,D,G,H,I):4+ case_8(G,H,I,J,B,C,D,E):3
     [H+2>=C+G,E>=0,D>=0,C>=2,B>=0,I>=0,G>=3,G=J+1,G=F+1,G=A+1] 

### Cost equations --> "Loop" of lcs/5 
* CEs [84] --> Loop 77 
* CEs [83] --> Loop 78 

#### Loops of lcs/5 
* Loop 77: lcs(A,B,C,D,E) [E>=0,D>=0,C>=2,B>=0,A>=2] 
* Loop 78: lcs(A,B,C,D,E) [D>=0,C>=2,B>=0,E=0,A=1] 

### Ranking functions of CR lcs(A,B,C,D,E) 

#### Partial ranking functions of CR lcs(A,B,C,D,E) 


### Resulting Chains:lcs(A,B,C,D,E) 
* [78]
* [77]


### Merging Chains  lcs/5 into  External patterns of execution 
* [[78]] --> 1 
* [[77]] --> 2 


Computing Bounds
=====================================

#### Simplifying cost structure of CE 23 

#### Computing cost of phase [23] 

#### Simplifying cost structure of CE 24 

#### Cost of loops [23] 

 * loop 23:firstline(A,B,C,D) -> [firstline(A',B',C',D')] 
6
##### Pending set firstline(A,B,C,D)
* Psum in Loop 23: [it(23)=<1]

###### Computing sum for it(23)=<1  in Loop 23 
   - Applying inductive sum strategy 
     - head Candidate: A-1 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(23)=<A-1,it(23)=<A-1,it(23)=<A-A',it(23)=<A-A'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [23] 

#### Simplifying cost structure of phase [23] 

#### Cost of phase [23]:firstline(A,B,C,D) -> [firstline(A',B',C',D')] 
6*it(23)+0
  Such that:it(23) =< A
it(23) =< A-A'

#### Simplifying cost structure of chain [[23],24] 

#### Cost of chains of firstline(A,B,C,D):
* Chain [[23],24]: 6*it(23)+3
  Such that:it(23) =< C

  with precondition: [A=C,A>=2,B>=0,D>=0] 

* Chain [24]: 3
  with precondition: [A=1,C=1,B>=0,D>=0] 


#### Simplifying cost structure of CE 26 

#### Simplifying cost structure of CE 25 

#### Cost of chains of case_9(A,B,C,D,E,F,G,H,I,J):
* Chain [26]: 2
  with precondition: [D=1,H=1,J=0,I=E,A>=2,B>=2,C>=0,F>=0,G>=0,I>=0] 

* Chain [25]: 2
  with precondition: [H=D,I=E,A>=2,C>=0,F>=0,G>=0,H>=2,I>=0,J>=0,B>=H+1] 


#### Simplifying cost structure of CE 29 

#### Simplifying cost structure of CE 27 

#### Simplifying cost structure of CE 28 

#### Cost of chains of case_8(A,B,C,D,E,F,G,H):
* Chain [29]: 2
  with precondition: [A=1,B=0,H=0,C>=0,D>=0,E>=0,F>=0,G>=0] 

* Chain [28]: 5
  with precondition: [D=1,H=0,A>=2,B>=2,C>=0,E>=0,F>=0,G>=0] 

* Chain [27]: 5
  with precondition: [A>=2,C>=0,D>=2,E>=0,F>=0,G>=0,H>=0,B>=D+1] 


#### Simplifying cost structure of CE 31 

#### Simplifying cost structure of CE 30 

#### Cost of chains of case_2(A,B,C):
* Chain [31]: 1
  with precondition: [A=C,B>=0,A>=B+1] 

* Chain [30]: 1
  with precondition: [B=C,A>=0,B>=A] 


#### Simplifying cost structure of CE 32 

#### Simplifying cost structure of CE 33 

#### Cost of chains of maxL(A,B,C):
* Chain [33]: 2
  with precondition: [A=C,B>=0,A>=B+1] 

* Chain [32]: 2
  with precondition: [B=C,A>=0,B>=A] 


#### Simplifying cost structure of CE 36 

#### Simplifying cost structure of CE 35 

#### Simplifying cost structure of CE 34 

#### Cost of chains of case_5(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P):
* Chain [36]: 3
  with precondition: [P=A+1,J=E,N+1=F,K+1=H,J+L=I,G=M+O,B>=0,C>=1,D>=0,J>=0,K>=1,M>=0,N>=1,P>=1,I>=J,G>=M] 

* Chain [35]: 4
  with precondition: [P=B,N+1=F,K+1=H,J+L=I,G=M+O,A>=0,C>=1,D>=0,E>=0,K>=1,L>=0,M>=0,N>=1,J>=E+1,G>=M,P>=M] 

* Chain [34]: 4
  with precondition: [N+1=F,K+1=H,M=P,M+O=G,J+L=I,A>=0,B>=0,C>=1,D>=0,E>=0,K>=1,L>=0,N>=1,O>=0,M>=B+1,J>=E+1] 


#### Simplifying cost structure of CE 38 

#### Simplifying cost structure of CE 37 

#### Cost of chains of case_1(A,B,C):
* Chain [38]: 2
  with precondition: [A=1,C=0,B>=0] 

* Chain [37]: 2
  with precondition: [A>=2,B>=0,C>=0] 


#### Simplifying cost structure of CE 39 

#### Simplifying cost structure of CE 40 

#### Cost of chains of rightL(A,B,C):
* Chain [40]: 3
  with precondition: [A=1,C=0,B>=0] 

* Chain [39]: 3
  with precondition: [A>=2,B>=0,C>=0] 


#### Simplifying cost structure of CE 54 

#### Simplifying cost structure of CE 41 

#### Simplifying cost structure of chain [52,42] 

#### Computing cost of phase [43,44] 

#### Simplifying cost structure of CE 51 

#### Simplifying cost structure of CE 52 

#### Simplifying cost structure of CE 50 

#### Cost of loops [43,44] 

 * loop 43:newline(A,B,C,D,E,F,G) -> [newline(A',B',C',D',E',F',G')] 
29
 * loop 44:newline(A,B,C,D,E,F,G) -> [newline(A',B',C',D',E',F',G')] 
28
##### Pending set newline(A,B,C,D,E,F,G)
* Psum in Loop 43: [it(43)=<1]
* Psum in Loop 44: [it(44)=<1]

###### Computing sum for it(43)=<1  in Loop 43 
   - Applying inductive sum strategy 
     - head Candidate: B-2 
       - Loop 44 is collaborative and bounds [it(44)] 
     - head Candidate: D-1 
       - Loop 44 is collaborative and bounds [it(44)] 
     - head Candidate: B-2 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: D-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: E 
       - Loop 44 is collaborative
     - head Candidate: -A+E 
       - Loop 44 is collaborative
     - tail Candidate: B-2 
       - Loop 44 is collaborative and bounds [it(44)] 
     - tail Candidate: D-1 
       - Loop 44 is collaborative and bounds [it(44)] 
     - tail Candidate: B-2 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: D-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: E 
       - Loop 44 is collaborative
     - tail Candidate: -A+E 
       - Loop 44 is collaborative
 * Adding constraints: [it(43)+it(44)=<B-2,it(43)+it(44)=<D-1,it(43)+it(44)=<B-2,it(43)+it(44)=<D-1,it(43)=<E,it(43)=< -A+E,it(43)+it(44)=<B-B',it(43)+it(44)=<D-D',it(43)+it(44)=<B-B',it(43)+it(44)=<D-D',it(43)=<E-E',it(43)=< -A+E+A'-E'] 

##### Pending set A
* Psum in Loop 44: [it(44)=<1]

###### Computing sum for it(44)=<1  in Loop 44 
   - Applying inductive sum strategy 
     - head Candidate: B-2 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: D-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: B-2 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: D-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B-2 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: D-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B-2 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: D-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(43)+it(44)=<B-2,it(43)+it(44)=<D-1,it(43)+it(44)=<B-2,it(43)+it(44)=<D-1,it(43)+it(44)=<B-B',it(43)+it(44)=<D-D',it(43)+it(44)=<B-B',it(43)+it(44)=<D-D'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [43,44] 

#### Simplifying cost structure of phase [43,44] 

#### Cost of phase [43,44]:newline(A,B,C,D,E,F,G) -> [newline(A',B',C',D',E',F',G')] 
29*it(43)+28*it(44)+0
  Such that:it(43) =< -A+E
it(43) =< -A+E+A'-E'
it(43) =< E
it(43) =< E-E'
aux(1) =< B
aux(2) =< B-B'
aux(3) =< D
aux(4) =< D-D'
it(43) =< aux(1)
it(44) =< aux(1)
it(43) =< aux(2)
it(44) =< aux(2)
it(43) =< aux(3)
it(44) =< aux(3)
it(43) =< aux(4)
it(44) =< aux(4)

#### Simplifying cost structure of chain [[43,44],52,42] 
 * Joined equivalent variables [aux(5),aux(1),aux(2),aux(4)] into aux(5)

#### Simplifying cost structure of CE 53 

#### Simplifying cost structure of chain [52,41] 

#### Found solution for phase  [43,44] in the cache 

#### Cost of phase [43,44]:newline(A,B,C,D,E,F,G) -> [newline(A',B',C',D',E',F',G')] 
29*it(43)+28*it(44)+0
  Such that:it(43) =< -A+E
it(43) =< -A+E+A'-E'
it(43) =< E
it(43) =< E-E'
aux(1) =< B
aux(2) =< B-B'
aux(3) =< D
aux(4) =< D-D'
it(43) =< aux(1)
it(44) =< aux(1)
it(43) =< aux(2)
it(44) =< aux(2)
it(43) =< aux(3)
it(44) =< aux(3)
it(43) =< aux(4)
it(44) =< aux(4)

#### Simplifying cost structure of chain [[43,44],52,41] 
 * Joined equivalent variables [aux(6),aux(1),aux(2),aux(3),aux(4)] into aux(6)

#### Simplifying cost structure of CE 42 

#### Simplifying cost structure of chain [51,42] 

#### Found solution for phase  [43,44] in the cache 

#### Cost of phase [43,44]:newline(A,B,C,D,E,F,G) -> [newline(A',B',C',D',E',F',G')] 
29*it(43)+28*it(44)+0
  Such that:it(43) =< -A+E
it(43) =< -A+E+A'-E'
it(43) =< E
it(43) =< E-E'
aux(1) =< B
aux(2) =< B-B'
aux(3) =< D
aux(4) =< D-D'
it(43) =< aux(1)
it(44) =< aux(1)
it(43) =< aux(2)
it(44) =< aux(2)
it(43) =< aux(3)
it(44) =< aux(3)
it(43) =< aux(4)
it(44) =< aux(4)

#### Simplifying cost structure of chain [[43,44],51,42] 
 * Joined equivalent variables [aux(7),aux(1),aux(2),aux(4)] into aux(7)

#### Simplifying cost structure of chain [51,41] 

#### Found solution for phase  [43,44] in the cache 

#### Cost of phase [43,44]:newline(A,B,C,D,E,F,G) -> [newline(A',B',C',D',E',F',G')] 
29*it(43)+28*it(44)+0
  Such that:it(43) =< -A+E
it(43) =< -A+E+A'-E'
it(43) =< E
it(43) =< E-E'
aux(1) =< B
aux(2) =< B-B'
aux(3) =< D
aux(4) =< D-D'
it(43) =< aux(1)
it(44) =< aux(1)
it(43) =< aux(2)
it(44) =< aux(2)
it(43) =< aux(3)
it(44) =< aux(3)
it(43) =< aux(4)
it(44) =< aux(4)

#### Simplifying cost structure of chain [[43,44],51,41] 
 * Joined equivalent variables [aux(8),aux(1),aux(2),aux(3),aux(4)] into aux(8)

#### Simplifying cost structure of CE 43 

#### Simplifying cost structure of chain [50,42] 

#### Found solution for phase  [43,44] in the cache 

#### Cost of phase [43,44]:newline(A,B,C,D,E,F,G) -> [newline(A',B',C',D',E',F',G')] 
29*it(43)+28*it(44)+0
  Such that:it(43) =< -A+E
it(43) =< -A+E+A'-E'
it(43) =< E
it(43) =< E-E'
aux(1) =< B
aux(2) =< B-B'
aux(3) =< D
aux(4) =< D-D'
it(43) =< aux(1)
it(44) =< aux(1)
it(43) =< aux(2)
it(44) =< aux(2)
it(43) =< aux(3)
it(44) =< aux(3)
it(43) =< aux(4)
it(44) =< aux(4)

#### Simplifying cost structure of chain [[43,44],50,42] 
 * Joined equivalent variables [aux(9),aux(1),aux(2),aux(4)] into aux(9)

#### Simplifying cost structure of chain [50,41] 

#### Found solution for phase  [43,44] in the cache 

#### Cost of phase [43,44]:newline(A,B,C,D,E,F,G) -> [newline(A',B',C',D',E',F',G')] 
29*it(43)+28*it(44)+0
  Such that:it(43) =< -A+E
it(43) =< -A+E+A'-E'
it(43) =< E
it(43) =< E-E'
aux(1) =< B
aux(2) =< B-B'
aux(3) =< D
aux(4) =< D-D'
it(43) =< aux(1)
it(44) =< aux(1)
it(43) =< aux(2)
it(44) =< aux(2)
it(43) =< aux(3)
it(44) =< aux(3)
it(43) =< aux(4)
it(44) =< aux(4)

#### Simplifying cost structure of chain [[43,44],50,41] 
 * Joined equivalent variables [aux(10),aux(1),aux(2),aux(3),aux(4)] into aux(10)

#### Simplifying cost structure of CE 45 

#### Simplifying cost structure of chain [47,41] 

#### Found solution for phase  [43,44] in the cache 

#### Cost of phase [43,44]:newline(A,B,C,D,E,F,G) -> [newline(A',B',C',D',E',F',G')] 
29*it(43)+28*it(44)+0
  Such that:it(43) =< -A+E
it(43) =< -A+E+A'-E'
it(43) =< E
it(43) =< E-E'
aux(1) =< B
aux(2) =< B-B'
aux(3) =< D
aux(4) =< D-D'
it(43) =< aux(1)
it(44) =< aux(1)
it(43) =< aux(2)
it(44) =< aux(2)
it(43) =< aux(3)
it(44) =< aux(3)
it(43) =< aux(4)
it(44) =< aux(4)

#### Simplifying cost structure of chain [[43,44],47,41] 
 * Joined equivalent variables [aux(11),aux(2),aux(3),aux(4)] into aux(11)

#### Simplifying cost structure of CE 44 

#### Simplifying cost structure of chain [46,41] 

#### Found solution for phase  [43,44] in the cache 

#### Cost of phase [43,44]:newline(A,B,C,D,E,F,G) -> [newline(A',B',C',D',E',F',G')] 
29*it(43)+28*it(44)+0
  Such that:it(43) =< -A+E
it(43) =< -A+E+A'-E'
it(43) =< E
it(43) =< E-E'
aux(1) =< B
aux(2) =< B-B'
aux(3) =< D
aux(4) =< D-D'
it(43) =< aux(1)
it(44) =< aux(1)
it(43) =< aux(2)
it(44) =< aux(2)
it(43) =< aux(3)
it(44) =< aux(3)
it(43) =< aux(4)
it(44) =< aux(4)

#### Simplifying cost structure of chain [[43,44],46,41] 
 * Joined equivalent variables [aux(12),aux(2),aux(3),aux(4)] into aux(12)

#### Simplifying cost structure of CE 46 

#### Simplifying cost structure of chain [45,41] 

#### Found solution for phase  [43,44] in the cache 

#### Cost of phase [43,44]:newline(A,B,C,D,E,F,G) -> [newline(A',B',C',D',E',F',G')] 
29*it(43)+28*it(44)+0
  Such that:it(43) =< -A+E
it(43) =< -A+E+A'-E'
it(43) =< E
it(43) =< E-E'
aux(1) =< B
aux(2) =< B-B'
aux(3) =< D
aux(4) =< D-D'
it(43) =< aux(1)
it(44) =< aux(1)
it(43) =< aux(2)
it(44) =< aux(2)
it(43) =< aux(3)
it(44) =< aux(3)
it(43) =< aux(4)
it(44) =< aux(4)

#### Simplifying cost structure of chain [[43,44],45,41] 
 * Joined equivalent variables [aux(13),aux(2),aux(3),aux(4)] into aux(13)
 * Renamed intermediate variables: 
[ (ch([[43,44],50,41]),it(43))>>s(1), (ch([[43,44],50,41]),aux(10))>>s(2), (ch([[43,44],50,41]),it(44))>>s(3)]
 * Renamed intermediate variables: 
[ (ch([[43,44],51,41]),it(43))>>s(4), (ch([[43,44],51,41]),aux(8))>>s(5), (ch([[43,44],51,41]),it(44))>>s(6)]
 * Joined equivalent variables [aux(15),s(2),s(5)] into aux(15)
 * Joined equivalent variables [s(1),s(4)] into s(1)
 * Joined equivalent variables [s(3),s(6)] into s(3)
 * Renamed intermediate variables: 
[ (ch([[43,44],50,42]),it(43))>>s(7), (ch([[43,44],50,42]),aux(3))>>s(8), (ch([[43,44],50,42]),aux(9))>>s(9), (ch([[43,44],50,42]),it(44))>>s(10)]
 * Renamed intermediate variables: 
[ (ch([[43,44],51,42]),it(43))>>s(11), (ch([[43,44],51,42]),aux(3))>>s(12), (ch([[43,44],51,42]),aux(7))>>s(13), (ch([[43,44],51,42]),it(44))>>s(14)]
 * Joined equivalent variables [aux(17),s(9),s(13)] into aux(17)
 * Joined equivalent variables [aux(18),s(8),s(12)] into aux(18)
 * Joined equivalent variables [s(7),s(11)] into s(7)
 * Joined equivalent variables [s(10),s(14)] into s(10)
 * Renamed intermediate variables: 
[ (ch([[43,44],45,41]),it(43))>>s(15), (ch([[43,44],45,41]),aux(1))>>s(16), (ch([[43,44],45,41]),aux(13))>>s(17), (ch([[43,44],45,41]),it(44))>>s(18)]
 * Renamed intermediate variables: 
[ (ch([[43,44],47,41]),it(43))>>s(19), (ch([[43,44],47,41]),aux(1))>>s(20), (ch([[43,44],47,41]),aux(11))>>s(21), (ch([[43,44],47,41]),it(44))>>s(22)]
 * Joined equivalent variables [aux(20),s(16),s(20)] into aux(20)
 * Joined equivalent variables [aux(21),s(17),s(21)] into aux(21)
 * Joined equivalent variables [s(15),s(19)] into s(15)
 * Joined equivalent variables [s(18),s(22)] into s(18)

#### Cost of chains of newline(A,B,C,D,E,F,G):
* Chain [[43,44],52,42]: 29*it(43)+28*it(44)+34
  Such that:it(43) =< -A+E
aux(3) =< D
aux(5) =< B
it(43) =< aux(5)
it(44) =< aux(5)
it(43) =< aux(3)
it(44) =< aux(3)

  with precondition: [B=F,A>=0,B>=3,C>=0,G>=1,E>=2*A,D>=B+1,E+G+1>=2*A+B] 

* Chain [[43,44],52,41]: 29*it(43)+28*it(44)+31
  Such that:it(43) =< -A+E
aux(6) =< B
it(43) =< aux(6)
it(44) =< aux(6)

  with precondition: [B=D,B=F,A>=0,B>=3,C>=0,G>=1,E>=2*A,E+G+1>=2*A+B] 

* Chain [[43,44],51,42]: 29*it(43)+28*it(44)+35
  Such that:it(43) =< -A+E
aux(3) =< D
aux(7) =< B
it(43) =< aux(7)
it(44) =< aux(7)
it(43) =< aux(3)
it(44) =< aux(3)

  with precondition: [B=F,A>=0,B>=3,C>=0,G>=0,E>=2*A+1,D>=B+1,E+G+1>=2*A+B] 

* Chain [[43,44],51,41]: 29*it(43)+28*it(44)+32
  Such that:it(43) =< -A+E
aux(8) =< B
it(43) =< aux(8)
it(44) =< aux(8)

  with precondition: [B=D,B=F,A>=0,B>=3,C>=0,G>=0,E>=2*A+1,E+G+1>=2*A+B] 

* Chain [[43,44],50,42]: 29*it(43)+28*it(44)+35
  Such that:it(43) =< -A+E
aux(3) =< D
aux(9) =< B
it(43) =< aux(9)
it(44) =< aux(9)
it(43) =< aux(3)
it(44) =< aux(3)

  with precondition: [B=F,A>=0,B>=3,C>=1,G>=1,E>=2*A+1,D>=B+1,E+G>=2*A+B] 

* Chain [[43,44],50,41]: 29*it(43)+28*it(44)+32
  Such that:it(43) =< -A+E
aux(10) =< B
it(43) =< aux(10)
it(44) =< aux(10)

  with precondition: [B=D,B=F,A>=0,B>=3,C>=1,G>=1,E>=2*A+1,E+G>=2*A+B] 

* Chain [[43,44],47,41]: 29*it(43)+28*it(44)+32
  Such that:it(43) =< -A+E
aux(1) =< B
aux(11) =< D
it(43) =< aux(1)
it(44) =< aux(1)
it(43) =< aux(11)
it(44) =< aux(11)

  with precondition: [D=F,A>=0,C>=0,D>=3,G>=0,E>=2*A+1,B>=D+1,E+G+1>=2*A+D] 

* Chain [[43,44],46,41]: 29*it(43)+28*it(44)+31
  Such that:it(43) =< -A+E
aux(1) =< B
aux(12) =< D
it(43) =< aux(1)
it(44) =< aux(1)
it(43) =< aux(12)
it(44) =< aux(12)

  with precondition: [D=F,A>=0,C>=0,D>=3,G>=1,E>=2*A,B>=D+1,E+G+1>=2*A+D] 

* Chain [[43,44],45,41]: 29*it(43)+28*it(44)+32
  Such that:it(43) =< -A+E
aux(1) =< B
aux(13) =< D
it(43) =< aux(1)
it(44) =< aux(1)
it(43) =< aux(13)
it(44) =< aux(13)

  with precondition: [D=F,A>=0,C>=1,D>=3,G>=1,E>=2*A+1,B>=D+1,E+G>=2*A+D] 

* Chain [52,42]: 34
  with precondition: [B=2,F=2,A>=0,C>=0,D>=3,G>=1,E>=A] 

* Chain [52,41]: 31
  with precondition: [B=2,D=2,F=2,A>=0,C>=0,G>=1,E>=A] 

* Chain [51,42]: 35
  with precondition: [B=2,F=2,A>=0,C>=0,D>=3,G>=0,E>=A+1] 

* Chain [51,41]: 32
  with precondition: [B=2,D=2,F=2,A>=0,C>=0,G>=0,E>=A+1] 

* Chain [50,42]: 35
  with precondition: [B=2,F=2,A>=0,C>=1,D>=3,G>=1,E>=A+1] 

* Chain [50,41]: 32
  with precondition: [B=2,D=2,F=2,A>=0,C>=1,G>=1,E>=A+1] 

* Chain [47,41]: 32
  with precondition: [D=2,F=2,A>=0,B>=3,C>=0,G>=0,E>=A+1] 

* Chain [46,41]: 31
  with precondition: [D=2,F=2,A>=0,B>=3,C>=0,G>=1,E>=A] 

* Chain [45,41]: 32
  with precondition: [D=2,F=2,A>=0,B>=3,C>=1,G>=1,E>=A+1] 

* Chain [42]: 6
  with precondition: [B=1,F=1,A>=0,C>=0,D>=2,E>=0,G>=0] 

* Chain [41]: 3
  with precondition: [D=1,F=1,A>=0,B>=0,C>=0,E>=0,G>=0] 


#### Simplifying cost structure of CE 69 

#### Simplifying cost structure of CE 60 

#### Simplifying cost structure of CE 56 

#### Simplifying cost structure of CE 61 

#### Simplifying cost structure of CE 57 

#### Simplifying cost structure of CE 62 

#### Simplifying cost structure of CE 55 

#### Simplifying cost structure of CE 58 

#### Simplifying cost structure of CE 59 
 * Renamed intermediate variables: 
[ (eq(64,1),it(43))>>s(23), (eq(64,1),aux(6))>>s(24), (eq(64,1),it(44))>>s(25)]

#### Simplifying cost structure of CE 64 
 * Renamed intermediate variables: 
[ (eq(68,1),it(43))>>s(26), (eq(68,1),aux(1))>>s(27), (eq(68,1),aux(12))>>s(28), (eq(68,1),it(44))>>s(29)]

#### Simplifying cost structure of CE 68 
 * Joined equivalent variables [aux(23),s(24),s(28)] into aux(23)
 * Joined equivalent variables [s(23),s(26)] into s(23)
 * Joined equivalent variables [s(25),s(29)] into s(25)
 * Renamed intermediate variables: 
[ (eq(63,1),aux(14))>>s(30), (eq(63,1),aux(15))>>s(31), (eq(63,1),s(1))>>s(32), (eq(63,1),s(3))>>s(33)]

#### Simplifying cost structure of CE 63 
 * Renamed intermediate variables: 
[ (eq(67,1),aux(19))>>s(34), (eq(67,1),aux(20))>>s(35), (eq(67,1),aux(21))>>s(36), (eq(67,1),s(15))>>s(37), (eq(67,1),s(18))>>s(38)]

#### Simplifying cost structure of CE 67 
 * Joined equivalent variables [aux(24),s(31),s(36)] into aux(24)
 * Joined equivalent variables [s(33),s(38)] into s(33)
 * Renamed intermediate variables: 
[ (eq(66,1),it(43))>>s(39), (eq(66,1),aux(3))>>s(40), (eq(66,1),aux(5))>>s(41), (eq(66,1),it(44))>>s(42)]

#### Simplifying cost structure of CE 66 
 * Joined equivalent variables [aux(25),s(40),s(41)] into aux(25)
 * Renamed intermediate variables: 
[ (eq(65,1),aux(16))>>s(43), (eq(65,1),aux(17))>>s(44), (eq(65,1),aux(18))>>s(45), (eq(65,1),s(7))>>s(46), (eq(65,1),s(10))>>s(47)]

#### Simplifying cost structure of CE 65 
 * Joined equivalent variables [aux(26),s(44),s(45)] into aux(26)

#### Cost of chains of case_7(A,B,C,D,E,F,G,H,I,J,K,L,M):
* Chain [63]: 2
  with precondition: [A=1,B=0,K=1,L=0,I+1=D,E=H+J,C>=0,F>=0,G>=0,H>=0,I>=1,M>=0,E>=H] 

* Chain [62]: 8
  with precondition: [F=1,L=B+1,I+1=D,A+1=K,E=H+J,A>=2,C>=0,G>=0,H>=0,I>=1,L>=1,M>=C,E>=H] 

* Chain [61]: 37
  with precondition: [F=2,L=B+2,I+1=D,A+1=K,E=H+J,A>=2,C>=0,H>=0,I>=1,L>=2,M>=C,E>=H,G>=H+1] 

* Chain [60]: 36
  with precondition: [F=2,L=B+2,I+1=D,A+1=K,E=H+J,A>=2,C>=0,H>=0,I>=1,L>=2,M>=C+1,E>=H,G>=H] 

* Chain [59]: 11
  with precondition: [L=B+1,I+1=D,A+1=K,E=H+J,A>=2,C>=0,F>=2,G>=0,H>=0,I>=1,L>=1,M>=C,E>=H] 

* Chain [58]: 40
  with precondition: [L=B+2,I+1=D,A+1=K,E=H+J,A>=2,C>=0,F>=3,H>=0,I>=1,L>=2,M>=C,E>=H,G>=H+1] 

* Chain [57]: 39
  with precondition: [L=B+2,I+1=D,A+1=K,E=H+J,A>=2,C>=0,F>=3,H>=0,I>=1,L>=2,M>=C+1,E>=H,G>=H] 

* Chain [56]: 58*s(23)+56*s(25)+36
  Such that:aux(22) =< -E+G+J
aux(23) =< F
s(23) =< aux(22)
s(23) =< aux(23)
s(25) =< aux(23)

  with precondition: [I+1=D,A+1=K,H+J=E,B+F=L,A>=2,C>=0,F>=3,H>=0,I>=1,J>=0,G>=2*H,M>=C+1,L>=F,G+M+1>=2*H+C+F] 

* Chain [55]: 58*s(32)+112*s(33)+58*s(37)+37
  Such that:s(34) =< -E+G+J
s(30) =< G-H
aux(24) =< F
s(37) =< s(34)
s(37) =< aux(24)
s(33) =< aux(24)
s(32) =< s(30)
s(32) =< aux(24)

  with precondition: [I+1=D,A+1=K,H+J=E,B+F=L,A>=2,C>=0,F>=3,H>=0,I>=1,J>=0,G>=2*H+1,M>=C,L>=F,G+M+1>=2*H+C+F] 

* Chain [54]: 29*s(39)+28*s(42)+39
  Such that:s(39) =< -E+G+J
aux(25) =< F
s(39) =< aux(25)
s(42) =< aux(25)

  with precondition: [I+1=D,A+1=K,E=H+J,A>=2,B>=0,C>=0,H>=0,I>=1,G>=2*H,L>=B+3,M>=C+1,E>=H,B+F>=L+1,B+G+M+1>=2*H+C+L] 

* Chain [53]: 58*s(46)+56*s(47)+40
  Such that:s(43) =< -E+G+J
aux(26) =< F
s(46) =< s(43)
s(46) =< aux(26)
s(47) =< aux(26)

  with precondition: [I+1=D,A+1=K,E=H+J,A>=2,B>=0,C>=0,H>=0,I>=1,G>=2*H+1,L>=B+3,M>=C,E>=H,B+F>=L+1,B+G+M+1>=2*H+C+L] 


#### Simplifying cost structure of CE 70 

#### Computing cost of phase [74] 

#### Simplifying cost structure of CE 73 

#### Cost of loops [74] 

 * loop 74:lcstable(A,B,C,D,E,F,G) -> [lcstable(A',B',C',D',E',F',G')] 
15
##### Pending set lcstable(A,B,C,D,E,F,G)
* Psum in Loop 74: [it(74)=<1]

###### Computing sum for it(74)=<1  in Loop 74 
   - Applying inductive sum strategy 
     - head Candidate: A-1 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(74)=<A-1,it(74)=<A-1,it(74)=<A-A',it(74)=<A-A'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [74] 

#### Simplifying cost structure of phase [74] 

#### Cost of phase [74]:lcstable(A,B,C,D,E,F,G) -> [lcstable(A',B',C',D',E',F',G')] 
15*it(74)+0
  Such that:it(74) =< A
it(74) =< A-A'

#### Simplifying cost structure of chain [[74],76] 
 * Renamed intermediate variables: 
[ (eq(71,1),it(23))>>s(48)]

#### Simplifying cost structure of CE 71 

#### Computing cost of phase [64,65,66,67,68,69,70,72,73] 
 * Renamed intermediate variables: 
[ (eq(81,1),s(39))>>s(49), (eq(81,1),aux(25))>>s(50), (eq(81,1),s(42))>>s(51)]

#### Simplifying cost structure of CE 81 
 * Renamed intermediate variables: 
[ (it(64),s(49))>>s(52), (it(64),s(50))>>s(53), (it(64),s(51))>>s(54)]
 * Renamed intermediate variables: 
[ (eq(82,1),s(43))>>s(55), (eq(82,1),aux(26))>>s(56), (eq(82,1),s(46))>>s(57), (eq(82,1),s(47))>>s(58)]

#### Simplifying cost structure of CE 82 
 * Renamed intermediate variables: 
[ (it(65),s(55))>>s(59), (it(65),s(56))>>s(60), (it(65),s(57))>>s(61), (it(65),s(58))>>s(62)]
 * Renamed intermediate variables: 
[ (eq(79,1),aux(22))>>s(63), (eq(79,1),aux(23))>>s(64), (eq(79,1),s(23))>>s(65), (eq(79,1),s(25))>>s(66)]

#### Simplifying cost structure of CE 79 
 * Renamed intermediate variables: 
[ (it(66),s(63))>>s(67), (it(66),s(64))>>s(68), (it(66),s(65))>>s(69), (it(66),s(66))>>s(70)]
 * Renamed intermediate variables: 
[ (eq(80,1),s(34))>>s(71), (eq(80,1),s(30))>>s(72), (eq(80,1),aux(24))>>s(73), (eq(80,1),s(37))>>s(74), (eq(80,1),s(33))>>s(75), (eq(80,1),s(32))>>s(76)]

#### Simplifying cost structure of CE 80 
 * Joined equivalent variables [aux(27),s(71),s(72)] into aux(27)
 * Joined equivalent variables [s(74),s(76)] into s(74)
 * Renamed intermediate variables: 
[ (it(67),s(73))>>s(77), (it(67),aux(27))>>s(78), (it(67),s(74))>>s(79), (it(67),s(75))>>s(80)]

#### Simplifying cost structure of CE 78 

#### Simplifying cost structure of CE 77 

#### Simplifying cost structure of CE 76 

#### Simplifying cost structure of CE 75 

#### Simplifying cost structure of CE 74 

#### Cost of loops [64,65,66,67,68,69,70,72,73] 

 * loop 64:lcstable(A,B,C,D,E,F,G) -> [lcstable(A',B',C',D',E',F',G')] 
29*s(52)+28*s(54)+46
  Such that:s(52) =< -B+B'+D'
s(53) =< C'
s(52) =< s(53)
s(54) =< s(53)

 * loop 65:lcstable(A,B,C,D,E,F,G) -> [lcstable(A',B',C',D',E',F',G')] 
58*s(61)+56*s(62)+47
  Such that:s(59) =< -B+B'+D'
s(60) =< C'
s(61) =< s(59)
s(61) =< s(60)
s(62) =< s(60)

 * loop 66:lcstable(A,B,C,D,E,F,G) -> [lcstable(A',B',C',D',E',F',G')] 
58*s(69)+56*s(70)+43
  Such that:s(67) =< -B+B'+D'
s(68) =< C'
s(69) =< s(67)
s(69) =< s(68)
s(70) =< s(68)

 * loop 67:lcstable(A,B,C,D,E,F,G) -> [lcstable(A',B',C',D',E',F',G')] 
116*s(79)+112*s(80)+44
  Such that:s(77) =< C'
s(78) =< -B+B'+D'
s(79) =< s(78)
s(79) =< s(77)
s(80) =< s(77)

 * loop 68:lcstable(A,B,C,D,E,F,G) -> [lcstable(A',B',C',D',E',F',G')] 
46
 * loop 69:lcstable(A,B,C,D,E,F,G) -> [lcstable(A',B',C',D',E',F',G')] 
47
 * loop 70:lcstable(A,B,C,D,E,F,G) -> [lcstable(A',B',C',D',E',F',G')] 
18
 * loop 72:lcstable(A,B,C,D,E,F,G) -> [lcstable(A',B',C',D',E',F',G')] 
43
 * loop 73:lcstable(A,B,C,D,E,F,G) -> [lcstable(A',B',C',D',E',F',G')] 
44
##### Pending set lcstable(A,B,C,D,E,F,G)
* Psum in Loop 64: [it(64)=<1,s(81)=< -B+B'+D',s(83)=<C']
* Psum in Loop 65: [it(65)=<1,s(87)=< -B+B'+D',s(86)=<C']
* Psum in Loop 66: [it(66)=<1,s(91)=< -B+B'+D',s(90)=<C']
* Psum in Loop 67: [it(67)=<1,s(95)=< -B+B'+D',s(94)=<C']
* Psum in Loop 68: [it(68)=<1]
* Psum in Loop 69: [it(69)=<1]
* Psum in Loop 70: [it(70)=<1]
* Psum in Loop 72: [it(72)=<1]
* Psum in Loop 73: [it(73)=<1]

###### Computing sum for it(64)=<1  in Loop 64 
   - Applying inductive sum strategy 
     - head Candidate: A-1 
       - Loop 65 is collaborative and bounds [it(65)] 
       - Loop 66 is collaborative and bounds [it(66)] 
       - Loop 67 is collaborative and bounds [it(67)] 
       - Loop 68 is collaborative and bounds [it(68)] 
       - Loop 69 is collaborative and bounds [it(69)] 
       - Loop 70 is collaborative and bounds [it(70)] 
       - Loop 72 is collaborative and bounds [it(72)] 
       - Loop 73 is collaborative and bounds [it(73)] 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
       - Loop 65 is collaborative and bounds [it(65)] 
       - Loop 66 is collaborative and bounds [it(66)] 
       - Loop 67 is collaborative and bounds [it(67)] 
       - Loop 68 is collaborative and bounds [it(68)] 
       - Loop 69 is collaborative and bounds [it(69)] 
       - Loop 70 is collaborative and bounds [it(70)] 
       - Loop 72 is collaborative and bounds [it(72)] 
       - Loop 73 is collaborative and bounds [it(73)] 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(64)+it(65)+it(66)+it(67)+it(68)+it(69)+it(70)+it(72)+it(73)=<A-1,it(64)+it(65)+it(66)+it(67)+it(68)+it(69)+it(70)+it(72)+it(73)=<A-1,it(64)+it(65)+it(66)+it(67)+it(68)+it(69)+it(70)+it(72)+it(73)=<A-A',it(64)+it(65)+it(66)+it(67)+it(68)+it(69)+it(70)+it(72)+it(73)=<A-A'] 

##### Pending set A
* Psum in Loop 64: [s(81)=< -B+B'+D',s(83)=<C']
* Psum in Loop 65: [it(65)=<1,s(87)=< -B+B'+D',s(86)=<C']
* Psum in Loop 66: [it(66)=<1,s(91)=< -B+B'+D',s(90)=<C']
* Psum in Loop 67: [it(67)=<1,s(95)=< -B+B'+D',s(94)=<C']
* Psum in Loop 68: [it(68)=<1]
* Psum in Loop 69: [it(69)=<1]
* Psum in Loop 70: [it(70)=<1]
* Psum in Loop 72: [it(72)=<1]
* Psum in Loop 73: [it(73)=<1]

###### Computing sum for s(81)=< -B+B'+D'  in Loop 64 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(28)=<D] 
 * Adding constraints: [s(81)=<it(64)*aux(28)] 

##### Pending set lcstable(A,B,C,D,E,F,G)
* Pmax/min: [aux(28)=<D]
* Psum in Loop 64: [s(83)=<C']
* Psum in Loop 65: [it(65)=<1,s(87)=< -B+B'+D',s(86)=<C']
* Psum in Loop 66: [it(66)=<1,s(91)=< -B+B'+D',s(90)=<C']
* Psum in Loop 67: [it(67)=<1,s(95)=< -B+B'+D',s(94)=<C']
* Psum in Loop 68: [it(68)=<1]
* Psum in Loop 69: [it(69)=<1]
* Psum in Loop 70: [it(70)=<1]
* Psum in Loop 72: [it(72)=<1]
* Psum in Loop 73: [it(73)=<1]

###### Computing max_min for aux(28)=<D  
   - Found a solution using transitive invariants 
 * Adding constraints:[aux(28)=<D] 

##### Pending set lcstable(A,B,C,D,E,F,G)
* Psum in Loop 64: [s(83)=<C']
* Psum in Loop 65: [it(65)=<1,s(87)=< -B+B'+D',s(86)=<C']
* Psum in Loop 66: [it(66)=<1,s(91)=< -B+B'+D',s(90)=<C']
* Psum in Loop 67: [it(67)=<1,s(95)=< -B+B'+D',s(94)=<C']
* Psum in Loop 68: [it(68)=<1]
* Psum in Loop 69: [it(69)=<1]
* Psum in Loop 70: [it(70)=<1]
* Psum in Loop 72: [it(72)=<1]
* Psum in Loop 73: [it(73)=<1]

###### Computing sum for s(83)=<C'  in Loop 64 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(29)=<C] 
 * Adding constraints: [s(83)=<it(64)*aux(29)] 

##### Pending set lcstable(A,B,C,D,E,F,G)
* Pmax/min: [aux(29)=<C]
* Psum in Loop 65: [it(65)=<1,s(87)=< -B+B'+D',s(86)=<C']
* Psum in Loop 66: [it(66)=<1,s(91)=< -B+B'+D',s(90)=<C']
* Psum in Loop 67: [it(67)=<1,s(95)=< -B+B'+D',s(94)=<C']
* Psum in Loop 68: [it(68)=<1]
* Psum in Loop 69: [it(69)=<1]
* Psum in Loop 70: [it(70)=<1]
* Psum in Loop 72: [it(72)=<1]
* Psum in Loop 73: [it(73)=<1]

###### Computing max_min for aux(29)=<C  
   - Found a solution using transitive invariants 
 * Adding constraints:[aux(29)=<C] 

##### Pending set lcstable(A,B,C,D,E,F,G)
* Psum in Loop 65: [it(65)=<1,s(87)=< -B+B'+D',s(86)=<C']
* Psum in Loop 66: [it(66)=<1,s(91)=< -B+B'+D',s(90)=<C']
* Psum in Loop 67: [it(67)=<1,s(95)=< -B+B'+D',s(94)=<C']
* Psum in Loop 68: [it(68)=<1]
* Psum in Loop 69: [it(69)=<1]
* Psum in Loop 70: [it(70)=<1]
* Psum in Loop 72: [it(72)=<1]
* Psum in Loop 73: [it(73)=<1]

###### Computing sum for it(65)=<1  in Loop 65 
   - Applying inductive sum strategy 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(64)+it(65)+it(66)+it(67)+it(68)+it(69)+it(70)+it(72)+it(73)=<A-1,it(64)+it(65)+it(66)+it(67)+it(68)+it(69)+it(70)+it(72)+it(73)=<A-1,it(64)+it(65)+it(66)+it(67)+it(68)+it(69)+it(70)+it(72)+it(73)=<A-A',it(64)+it(65)+it(66)+it(67)+it(68)+it(69)+it(70)+it(72)+it(73)=<A-A'] 

##### Pending set lcstable(A,B,C,D,E,F,G)
* Psum in Loop 65: [s(87)=< -B+B'+D',s(86)=<C']
* Psum in Loop 66: [it(66)=<1,s(91)=< -B+B'+D',s(90)=<C']
* Psum in Loop 67: [it(67)=<1,s(95)=< -B+B'+D',s(94)=<C']
* Psum in Loop 68: [it(68)=<1]
* Psum in Loop 69: [it(69)=<1]
* Psum in Loop 70: [it(70)=<1]
* Psum in Loop 72: [it(72)=<1]
* Psum in Loop 73: [it(73)=<1]

###### Computing sum for s(87)=< -B+B'+D'  in Loop 65 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(30)=<D] 
 * Adding constraints: [s(87)=<it(65)*aux(30)] 

##### Pending set lcstable(A,B,C,D,E,F,G)
* Pmax/min: [aux(30)=<D]
* Psum in Loop 65: [s(86)=<C']
* Psum in Loop 66: [it(66)=<1,s(91)=< -B+B'+D',s(90)=<C']
* Psum in Loop 67: [it(67)=<1,s(95)=< -B+B'+D',s(94)=<C']
* Psum in Loop 68: [it(68)=<1]
* Psum in Loop 69: [it(69)=<1]
* Psum in Loop 70: [it(70)=<1]
* Psum in Loop 72: [it(72)=<1]
* Psum in Loop 73: [it(73)=<1]

###### Computing max_min for aux(30)=<D  
   - Found a solution using cacheing 
 * Adding constraints:[aux(30)=<aux(28)] 

##### Pending set lcstable(A,B,C,D,E,F,G)
* Psum in Loop 65: [s(86)=<C']
* Psum in Loop 66: [it(66)=<1,s(91)=< -B+B'+D',s(90)=<C']
* Psum in Loop 67: [it(67)=<1,s(95)=< -B+B'+D',s(94)=<C']
* Psum in Loop 68: [it(68)=<1]
* Psum in Loop 69: [it(69)=<1]
* Psum in Loop 70: [it(70)=<1]
* Psum in Loop 72: [it(72)=<1]
* Psum in Loop 73: [it(73)=<1]

###### Computing sum for s(86)=<C'  in Loop 65 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(31)=<C] 
 * Adding constraints: [s(86)=<it(65)*aux(31)] 

##### Pending set lcstable(A,B,C,D,E,F,G)
* Pmax/min: [aux(31)=<C]
* Psum in Loop 66: [it(66)=<1,s(91)=< -B+B'+D',s(90)=<C']
* Psum in Loop 67: [it(67)=<1,s(95)=< -B+B'+D',s(94)=<C']
* Psum in Loop 68: [it(68)=<1]
* Psum in Loop 69: [it(69)=<1]
* Psum in Loop 70: [it(70)=<1]
* Psum in Loop 72: [it(72)=<1]
* Psum in Loop 73: [it(73)=<1]

###### Computing max_min for aux(31)=<C  
   - Found a solution using cacheing 
 * Adding constraints:[aux(31)=<aux(29)] 

##### Pending set lcstable(A,B,C,D,E,F,G)
* Psum in Loop 66: [it(66)=<1,s(91)=< -B+B'+D',s(90)=<C']
* Psum in Loop 67: [it(67)=<1,s(95)=< -B+B'+D',s(94)=<C']
* Psum in Loop 68: [it(68)=<1]
* Psum in Loop 69: [it(69)=<1]
* Psum in Loop 70: [it(70)=<1]
* Psum in Loop 72: [it(72)=<1]
* Psum in Loop 73: [it(73)=<1]

###### Computing sum for it(66)=<1  in Loop 66 
   - Applying inductive sum strategy 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(64)+it(65)+it(66)+it(67)+it(68)+it(69)+it(70)+it(72)+it(73)=<A-1,it(64)+it(65)+it(66)+it(67)+it(68)+it(69)+it(70)+it(72)+it(73)=<A-1,it(64)+it(65)+it(66)+it(67)+it(68)+it(69)+it(70)+it(72)+it(73)=<A-A',it(64)+it(65)+it(66)+it(67)+it(68)+it(69)+it(70)+it(72)+it(73)=<A-A'] 

##### Pending set lcstable(A,B,C,D,E,F,G)
* Psum in Loop 66: [s(91)=< -B+B'+D',s(90)=<C']
* Psum in Loop 67: [it(67)=<1,s(95)=< -B+B'+D',s(94)=<C']
* Psum in Loop 68: [it(68)=<1]
* Psum in Loop 69: [it(69)=<1]
* Psum in Loop 70: [it(70)=<1]
* Psum in Loop 72: [it(72)=<1]
* Psum in Loop 73: [it(73)=<1]

###### Computing sum for s(91)=< -B+B'+D'  in Loop 66 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(32)=<D] 
 * Adding constraints: [s(91)=<it(66)*aux(32)] 

##### Pending set lcstable(A,B,C,D,E,F,G)
* Pmax/min: [aux(32)=<D]
* Psum in Loop 66: [s(90)=<C']
* Psum in Loop 67: [it(67)=<1,s(95)=< -B+B'+D',s(94)=<C']
* Psum in Loop 68: [it(68)=<1]
* Psum in Loop 69: [it(69)=<1]
* Psum in Loop 70: [it(70)=<1]
* Psum in Loop 72: [it(72)=<1]
* Psum in Loop 73: [it(73)=<1]

###### Computing max_min for aux(32)=<D  
   - Found a solution using cacheing 
 * Adding constraints:[aux(32)=<aux(28)] 

##### Pending set lcstable(A,B,C,D,E,F,G)
* Psum in Loop 66: [s(90)=<C']
* Psum in Loop 67: [it(67)=<1,s(95)=< -B+B'+D',s(94)=<C']
* Psum in Loop 68: [it(68)=<1]
* Psum in Loop 69: [it(69)=<1]
* Psum in Loop 70: [it(70)=<1]
* Psum in Loop 72: [it(72)=<1]
* Psum in Loop 73: [it(73)=<1]

###### Computing sum for s(90)=<C'  in Loop 66 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(33)=<C] 
 * Adding constraints: [s(90)=<it(66)*aux(33)] 

##### Pending set lcstable(A,B,C,D,E,F,G)
* Pmax/min: [aux(33)=<C]
* Psum in Loop 67: [it(67)=<1,s(95)=< -B+B'+D',s(94)=<C']
* Psum in Loop 68: [it(68)=<1]
* Psum in Loop 69: [it(69)=<1]
* Psum in Loop 70: [it(70)=<1]
* Psum in Loop 72: [it(72)=<1]
* Psum in Loop 73: [it(73)=<1]

###### Computing max_min for aux(33)=<C  
   - Found a solution using cacheing 
 * Adding constraints:[aux(33)=<aux(29)] 

##### Pending set lcstable(A,B,C,D,E,F,G)
* Psum in Loop 67: [it(67)=<1,s(95)=< -B+B'+D',s(94)=<C']
* Psum in Loop 68: [it(68)=<1]
* Psum in Loop 69: [it(69)=<1]
* Psum in Loop 70: [it(70)=<1]
* Psum in Loop 72: [it(72)=<1]
* Psum in Loop 73: [it(73)=<1]

###### Computing sum for it(67)=<1  in Loop 67 
   - Applying inductive sum strategy 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(64)+it(65)+it(66)+it(67)+it(68)+it(69)+it(70)+it(72)+it(73)=<A-1,it(64)+it(65)+it(66)+it(67)+it(68)+it(69)+it(70)+it(72)+it(73)=<A-1,it(64)+it(65)+it(66)+it(67)+it(68)+it(69)+it(70)+it(72)+it(73)=<A-A',it(64)+it(65)+it(66)+it(67)+it(68)+it(69)+it(70)+it(72)+it(73)=<A-A'] 

##### Pending set lcstable(A,B,C,D,E,F,G)
* Psum in Loop 67: [s(95)=< -B+B'+D',s(94)=<C']
* Psum in Loop 68: [it(68)=<1]
* Psum in Loop 69: [it(69)=<1]
* Psum in Loop 70: [it(70)=<1]
* Psum in Loop 72: [it(72)=<1]
* Psum in Loop 73: [it(73)=<1]

###### Computing sum for s(95)=< -B+B'+D'  in Loop 67 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(34)=<D] 
 * Adding constraints: [s(95)=<it(67)*aux(34)] 

##### Pending set lcstable(A,B,C,D,E,F,G)
* Pmax/min: [aux(34)=<D]
* Psum in Loop 67: [s(94)=<C']
* Psum in Loop 68: [it(68)=<1]
* Psum in Loop 69: [it(69)=<1]
* Psum in Loop 70: [it(70)=<1]
* Psum in Loop 72: [it(72)=<1]
* Psum in Loop 73: [it(73)=<1]

###### Computing max_min for aux(34)=<D  
   - Found a solution using cacheing 
 * Adding constraints:[aux(34)=<aux(28)] 

##### Pending set lcstable(A,B,C,D,E,F,G)
* Psum in Loop 67: [s(94)=<C']
* Psum in Loop 68: [it(68)=<1]
* Psum in Loop 69: [it(69)=<1]
* Psum in Loop 70: [it(70)=<1]
* Psum in Loop 72: [it(72)=<1]
* Psum in Loop 73: [it(73)=<1]

###### Computing sum for s(94)=<C'  in Loop 67 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(35)=<C] 
 * Adding constraints: [s(94)=<it(67)*aux(35)] 

##### Pending set lcstable(A,B,C,D,E,F,G)
* Pmax/min: [aux(35)=<C]
* Psum in Loop 68: [it(68)=<1]
* Psum in Loop 69: [it(69)=<1]
* Psum in Loop 70: [it(70)=<1]
* Psum in Loop 72: [it(72)=<1]
* Psum in Loop 73: [it(73)=<1]

###### Computing max_min for aux(35)=<C  
   - Found a solution using cacheing 
 * Adding constraints:[aux(35)=<aux(29)] 

##### Pending set lcstable(A,B,C,D,E,F,G)
* Psum in Loop 68: [it(68)=<1]
* Psum in Loop 69: [it(69)=<1]
* Psum in Loop 70: [it(70)=<1]
* Psum in Loop 72: [it(72)=<1]
* Psum in Loop 73: [it(73)=<1]

###### Computing sum for it(68)=<1  in Loop 68 
   - Applying inductive sum strategy 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(64)+it(65)+it(66)+it(67)+it(68)+it(69)+it(70)+it(72)+it(73)=<A-1,it(64)+it(65)+it(66)+it(67)+it(68)+it(69)+it(70)+it(72)+it(73)=<A-1,it(64)+it(65)+it(66)+it(67)+it(68)+it(69)+it(70)+it(72)+it(73)=<A-A',it(64)+it(65)+it(66)+it(67)+it(68)+it(69)+it(70)+it(72)+it(73)=<A-A'] 

##### Pending set lcstable(A,B,C,D,E,F,G)
* Psum in Loop 69: [it(69)=<1]
* Psum in Loop 70: [it(70)=<1]
* Psum in Loop 72: [it(72)=<1]
* Psum in Loop 73: [it(73)=<1]

###### Computing sum for it(69)=<1  in Loop 69 
   - Applying inductive sum strategy 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(64)+it(65)+it(66)+it(67)+it(68)+it(69)+it(70)+it(72)+it(73)=<A-1,it(64)+it(65)+it(66)+it(67)+it(68)+it(69)+it(70)+it(72)+it(73)=<A-1,it(64)+it(65)+it(66)+it(67)+it(68)+it(69)+it(70)+it(72)+it(73)=<A-A',it(64)+it(65)+it(66)+it(67)+it(68)+it(69)+it(70)+it(72)+it(73)=<A-A'] 

##### Pending set lcstable(A,B,C,D,E,F,G)
* Psum in Loop 70: [it(70)=<1]
* Psum in Loop 72: [it(72)=<1]
* Psum in Loop 73: [it(73)=<1]

###### Computing sum for it(70)=<1  in Loop 70 
   - Applying inductive sum strategy 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(64)+it(65)+it(66)+it(67)+it(68)+it(69)+it(70)+it(72)+it(73)=<A-1,it(64)+it(65)+it(66)+it(67)+it(68)+it(69)+it(70)+it(72)+it(73)=<A-1,it(64)+it(65)+it(66)+it(67)+it(68)+it(69)+it(70)+it(72)+it(73)=<A-A',it(64)+it(65)+it(66)+it(67)+it(68)+it(69)+it(70)+it(72)+it(73)=<A-A'] 

##### Pending set lcstable(A,B,C,D,E,F,G)
* Psum in Loop 72: [it(72)=<1]
* Psum in Loop 73: [it(73)=<1]

###### Computing sum for it(72)=<1  in Loop 72 
   - Applying inductive sum strategy 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(64)+it(65)+it(66)+it(67)+it(68)+it(69)+it(70)+it(72)+it(73)=<A-1,it(64)+it(65)+it(66)+it(67)+it(68)+it(69)+it(70)+it(72)+it(73)=<A-1,it(64)+it(65)+it(66)+it(67)+it(68)+it(69)+it(70)+it(72)+it(73)=<A-A',it(64)+it(65)+it(66)+it(67)+it(68)+it(69)+it(70)+it(72)+it(73)=<A-A'] 

##### Pending set lcstable(A,B,C,D,E,F,G)
* Psum in Loop 73: [it(73)=<1]

###### Computing sum for it(73)=<1  in Loop 73 
   - Applying inductive sum strategy 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(64)+it(65)+it(66)+it(67)+it(68)+it(69)+it(70)+it(72)+it(73)=<A-1,it(64)+it(65)+it(66)+it(67)+it(68)+it(69)+it(70)+it(72)+it(73)=<A-1,it(64)+it(65)+it(66)+it(67)+it(68)+it(69)+it(70)+it(72)+it(73)=<A-A',it(64)+it(65)+it(66)+it(67)+it(68)+it(69)+it(70)+it(72)+it(73)=<A-A'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [64,65,66,67,68,69,70,72,73] 

#### Simplifying cost structure of phase [64,65,66,67,68,69,70,72,73] 
 * Joined equivalent variables [aux(31),aux(33),aux(35)] into aux(31)
 * Joined equivalent variables [aux(30),aux(32),aux(34)] into aux(30)
 * Joined equivalent variables [it(64),it(65),it(66),it(67),it(68),it(69),it(70),it(72),it(73)] into it(64)
 * Joined equivalent variables [s(86),s(90),s(94)] into s(86)
 * Joined equivalent variables [s(87),s(91),s(95)] into s(87)
 * Joined equivalent variables [s(85),s(89),s(93)] into s(85)
 * Joined equivalent variables [s(84),s(88),s(92)] into s(84)

#### Cost of phase [64,65,66,67,68,69,70,72,73]:lcstable(A,B,C,D,E,F,G) -> [lcstable(A',B',C',D',E',F',G')] 
378*it(64)+29*s(81)+28*s(82)+232*s(84)+224*s(85)+0
  Such that:aux(29) =< C
aux(28) =< D
aux(36) =< A
aux(37) =< A-A'
it(64) =< aux(36)
it(64) =< aux(37)
aux(31) =< aux(29)
aux(30) =< aux(28)
s(83) =< it(64)*aux(29)
s(81) =< it(64)*aux(28)
s(86) =< it(64)*aux(31)
s(87) =< it(64)*aux(30)
s(84) =< s(87)
s(84) =< s(86)
s(85) =< s(86)
s(81) =< s(83)
s(82) =< s(83)

#### Simplifying cost structure of chain [[64,65,66,67,68,69,70,72,73],75] 
 * Joined equivalent variables [aux(38),aux(36),aux(37)] into aux(38)
 * Joined equivalent variables [aux(39),aux(29)] into aux(39)

#### Cost of chains of lcstable(A,B,C,D,E,F,G):
* Chain [[74],76]: 15*it(74)+8
  Such that:it(74) =< F

  with precondition: [C=1,A+1=E,A=F,A>=2,B>=0,D>=0,G>=0] 

* Chain [[64,65,66,67,68,69,70,72,73],75]: 378*it(64)+6*s(48)+29*s(81)+28*s(82)+232*s(84)+224*s(85)+8
  Such that:aux(28) =< D
aux(38) =< A
aux(39) =< C
s(48) =< aux(39)
it(64) =< aux(38)
aux(31) =< aux(39)
aux(30) =< aux(28)
s(83) =< it(64)*aux(39)
s(81) =< it(64)*aux(28)
s(86) =< it(64)*aux(31)
s(87) =< it(64)*aux(30)
s(84) =< s(87)
s(84) =< s(86)
s(85) =< s(86)
s(81) =< s(83)
s(82) =< s(83)

  with precondition: [A+1=E,A>=2,B>=0,C>=2,D>=0,G>=0,F+1>=A+C] 

* Chain [76]: 8
  with precondition: [A=1,C=1,E=2,F=1,B>=0,D>=0,G>=0] 

* Chain [75]: 6*s(48)+8
  Such that:s(48) =< C

  with precondition: [A=1,E=2,C=F,B>=0,C>=2,D>=0,G>=0] 

 * Renamed intermediate variables: 
[ (eq(83,1),s(48))>>s(96)]

#### Simplifying cost structure of CE 83 
 * Renamed intermediate variables: 
[ (eq(84,1),aux(28))>>s(97), (eq(84,1),aux(38))>>s(98), (eq(84,1),aux(39))>>s(99), (eq(84,1),s(48))>>s(100), (eq(84,1),it(64))>>s(101), (eq(84,1),aux(31))>>s(102), (eq(84,1),aux(30))>>s(103), (eq(84,1),s(83))>>s(104), (eq(84,1),s(81))>>s(105), (eq(84,1),s(86))>>s(106), (eq(84,1),s(87))>>s(107), (eq(84,1),s(84))>>s(108), (eq(84,1),s(85))>>s(109), (eq(84,1),s(82))>>s(110)]

#### Simplifying cost structure of CE 84 

#### Cost of chains of lcs(A,B,C,D,E):
* Chain [78]: 6*s(96)+17
  Such that:s(96) =< C

  with precondition: [A=1,E=0,B>=0,C>=2,D>=0] 

* Chain [77]: 6*s(100)+378*s(101)+29*s(105)+232*s(108)+224*s(109)+28*s(110)+17
  Such that:s(98) =< A
s(99) =< C
s(97) =< D
s(100) =< s(99)
s(101) =< s(98)
s(102) =< s(99)
s(103) =< s(97)
s(104) =< s(101)*s(99)
s(105) =< s(101)*s(97)
s(106) =< s(101)*s(102)
s(107) =< s(101)*s(103)
s(108) =< s(107)
s(108) =< s(106)
s(109) =< s(106)
s(105) =< s(104)
s(110) =< s(104)

  with precondition: [A>=2,B>=0,C>=2,D>=0,E>=0] 


Closed-form bounds of firstline(A,B,C,D): 
-------------------------------------
* Chain [[23],24] with precondition: [A=C,A>=2,B>=0,D>=0] 
    - Upper bound: 6*A+3 
    - Complexity: n 
* Chain [24] with precondition: [A=1,C=1,B>=0,D>=0] 
    - Upper bound: 3 
    - Complexity: constant 

### Maximum cost of firstline(A,B,C,D): 6*A+3 
Asymptotic class: n 

Closed-form bounds of rightL(A,B,C): 
-------------------------------------
* Chain [40] with precondition: [A=1,C=0,B>=0] 
    - Upper bound: 3 
    - Complexity: constant 
* Chain [39] with precondition: [A>=2,B>=0,C>=0] 
    - Upper bound: 3 
    - Complexity: constant 

### Maximum cost of rightL(A,B,C): 3 
Asymptotic class: constant 

Closed-form bounds of maxL(A,B,C): 
-------------------------------------
* Chain [33] with precondition: [A=C,B>=0,A>=B+1] 
    - Upper bound: 2 
    - Complexity: constant 
* Chain [32] with precondition: [B=C,A>=0,B>=A] 
    - Upper bound: 2 
    - Complexity: constant 

### Maximum cost of maxL(A,B,C): 2 
Asymptotic class: constant 

Closed-form bounds of newline(A,B,C,D,E,F,G): 
-------------------------------------
* Chain [[43,44],52,42] with precondition: [B=F,A>=0,B>=3,C>=0,G>=1,E>=2*A,D>=B+1,E+G+1>=2*A+B] 
    - Upper bound: -29*A+28*B+29*E+34 
    - Complexity: n 
* Chain [[43,44],52,41] with precondition: [B=D,B=F,A>=0,B>=3,C>=0,G>=1,E>=2*A,E+G+1>=2*A+B] 
    - Upper bound: -29*A+28*B+29*E+31 
    - Complexity: n 
* Chain [[43,44],51,42] with precondition: [B=F,A>=0,B>=3,C>=0,G>=0,E>=2*A+1,D>=B+1,E+G+1>=2*A+B] 
    - Upper bound: -29*A+28*B+29*E+35 
    - Complexity: n 
* Chain [[43,44],51,41] with precondition: [B=D,B=F,A>=0,B>=3,C>=0,G>=0,E>=2*A+1,E+G+1>=2*A+B] 
    - Upper bound: -29*A+28*B+29*E+32 
    - Complexity: n 
* Chain [[43,44],50,42] with precondition: [B=F,A>=0,B>=3,C>=1,G>=1,E>=2*A+1,D>=B+1,E+G>=2*A+B] 
    - Upper bound: -29*A+28*B+29*E+35 
    - Complexity: n 
* Chain [[43,44],50,41] with precondition: [B=D,B=F,A>=0,B>=3,C>=1,G>=1,E>=2*A+1,E+G>=2*A+B] 
    - Upper bound: -29*A+28*B+29*E+32 
    - Complexity: n 
* Chain [[43,44],47,41] with precondition: [D=F,A>=0,C>=0,D>=3,G>=0,E>=2*A+1,B>=D+1,E+G+1>=2*A+D] 
    - Upper bound: -29*A+28*B+29*E+32 
    - Complexity: n 
* Chain [[43,44],46,41] with precondition: [D=F,A>=0,C>=0,D>=3,G>=1,E>=2*A,B>=D+1,E+G+1>=2*A+D] 
    - Upper bound: -29*A+28*B+29*E+31 
    - Complexity: n 
* Chain [[43,44],45,41] with precondition: [D=F,A>=0,C>=1,D>=3,G>=1,E>=2*A+1,B>=D+1,E+G>=2*A+D] 
    - Upper bound: -29*A+28*B+29*E+32 
    - Complexity: n 
* Chain [52,42] with precondition: [B=2,F=2,A>=0,C>=0,D>=3,G>=1,E>=A] 
    - Upper bound: 34 
    - Complexity: constant 
* Chain [52,41] with precondition: [B=2,D=2,F=2,A>=0,C>=0,G>=1,E>=A] 
    - Upper bound: 31 
    - Complexity: constant 
* Chain [51,42] with precondition: [B=2,F=2,A>=0,C>=0,D>=3,G>=0,E>=A+1] 
    - Upper bound: 35 
    - Complexity: constant 
* Chain [51,41] with precondition: [B=2,D=2,F=2,A>=0,C>=0,G>=0,E>=A+1] 
    - Upper bound: 32 
    - Complexity: constant 
* Chain [50,42] with precondition: [B=2,F=2,A>=0,C>=1,D>=3,G>=1,E>=A+1] 
    - Upper bound: 35 
    - Complexity: constant 
* Chain [50,41] with precondition: [B=2,D=2,F=2,A>=0,C>=1,G>=1,E>=A+1] 
    - Upper bound: 32 
    - Complexity: constant 
* Chain [47,41] with precondition: [D=2,F=2,A>=0,B>=3,C>=0,G>=0,E>=A+1] 
    - Upper bound: 32 
    - Complexity: constant 
* Chain [46,41] with precondition: [D=2,F=2,A>=0,B>=3,C>=0,G>=1,E>=A] 
    - Upper bound: 31 
    - Complexity: constant 
* Chain [45,41] with precondition: [D=2,F=2,A>=0,B>=3,C>=1,G>=1,E>=A+1] 
    - Upper bound: 32 
    - Complexity: constant 
* Chain [42] with precondition: [B=1,F=1,A>=0,C>=0,D>=2,E>=0,G>=0] 
    - Upper bound: 6 
    - Complexity: constant 
* Chain [41] with precondition: [D=1,F=1,A>=0,B>=0,C>=0,E>=0,G>=0] 
    - Upper bound: 3 
    - Complexity: constant 

### Maximum cost of newline(A,B,C,D,E,F,G): max([32,28*B+28+nat(-A+E)*29+4])+3 
Asymptotic class: n 

Closed-form bounds of lcstable(A,B,C,D,E,F,G): 
-------------------------------------
* Chain [[74],76] with precondition: [C=1,A+1=E,A=F,A>=2,B>=0,D>=0,G>=0] 
    - Upper bound: 15*A+8 
    - Complexity: n 
* Chain [[64,65,66,67,68,69,70,72,73],75] with precondition: [A+1=E,A>=2,B>=0,C>=2,D>=0,G>=0,F+1>=A+C] 
    - Upper bound: 378*A+6*C+8+252*C*A+261*D*A 
    - Complexity: n^2 
* Chain [76] with precondition: [A=1,C=1,E=2,F=1,B>=0,D>=0,G>=0] 
    - Upper bound: 8 
    - Complexity: constant 
* Chain [75] with precondition: [A=1,E=2,C=F,B>=0,C>=2,D>=0,G>=0] 
    - Upper bound: 6*C+8 
    - Complexity: n 

### Maximum cost of lcstable(A,B,C,D,E,F,G): max([6*C,363*A+6*C+252*C*A+261*D*A+15*A])+8 
Asymptotic class: n^2 

Closed-form bounds of lcs(A,B,C,D,E): 
-------------------------------------
* Chain [78] with precondition: [A=1,E=0,B>=0,C>=2,D>=0] 
    - Upper bound: 6*C+17 
    - Complexity: n 
* Chain [77] with precondition: [A>=2,B>=0,C>=2,D>=0,E>=0] 
    - Upper bound: 378*A+6*C+17+252*C*A+261*D*A 
    - Complexity: n^2 

### Maximum cost of lcs(A,B,C,D,E): 252*C*A+378*A+261*D*A+ (6*C+17) 
Asymptotic class: n^2 
* Total analysis performed in 7013 ms.


Cost relation system solved by CoFloCo in 7024 ms.

Method firstline terminates?: YES

 - l_1: size of l wrt. List<Rat>
 - l_2: size of l wrt. Rat
UB for firstline(l_1,l_2) = 6*l_1+3

Method rightL terminates?: YES

 - l_1: size of l wrt. List<Rat>
 - l_2: size of l wrt. Rat
UB for rightL(l_1,l_2) = 3

Method maxL terminates?: YES

 - a_1: size of a wrt. Rat
 - b_1: size of b wrt. Rat
UB for maxL(a_1,b_1) = 2

Method newline terminates?: YES

 - y_1: size of y wrt. Rat
 - lastline_1: size of lastline wrt. List<Rat>
 - lastline_2: size of lastline wrt. Rat
 - l_1: size of l wrt. List<Rat>
 - l_2: size of l wrt. Rat
UB for newline(y_1,lastline_1,lastline_2,l_1,l_2) = max([32,28*lastline_1+28+nat(-y_1+l_2)*29+4])+3

Method lcstable terminates?: YES

 - l1_1: size of l1 wrt. List<Rat>
 - l1_2: size of l1 wrt. Rat
 - l2_1: size of l2 wrt. List<Rat>
 - l2_2: size of l2 wrt. Rat
UB for lcstable(l1_1,l1_2,l2_1,l2_2) = max([6*l2_1,363*l1_1+6*l2_1+252*l2_1*l1_1+261*l2_2*l1_1+15*l1_1])+8

Method lcs terminates?: YES

 - l1_1: size of l1 wrt. List<Rat>
 - l1_2: size of l1 wrt. Rat
 - l2_1: size of l2 wrt. List<Rat>
 - l2_2: size of l2 wrt. Rat
UB for lcs(l1_1,l1_2,l2_1,l2_2) = 252*l2_1*l1_1+378*l1_1+261*l2_2*l1_1+ (6*l2_1+17)
