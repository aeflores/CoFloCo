
Abs program loaded in 18 ms.

Rule based representation generated in 6 ms.

Rule based representation stored in /tmp/costabs/rbr.rbr

RBR properties stored in /tmp/costabs/rbr.properties

Class invariants generated and loaded in 0 ms.

Abstract compilation performed in 62 ms.

Cost relation system stored in /tmp/costabs/crs.crs

Generated 49 equations 
entry('insertL'(A,B,C,D,E,F,G,H,I,J):[]).
entry('split'(A,B,C,D,E,F,G):[]).
entry('splitqs'(A,B,C,D,E,F):[]).
entry('append'(A,B,C,D,E,F,G,H,I,J,K,L):[]).
entry('quicksort'(A,B,C,D):[]).
entry('sortAll'(A,B,C,D,E,F,G,H):[]).
entry('splitAndSort'(A,B,C,D,E,F,G):[]).
input_output_vars('and_op'(A,B,C),[A,B],[C]).
input_output_vars('append'(A,B,C,D,E,F,G,H,I,J,K,L),[A,B,C,D,E,F,G,H],[I,J,K,L]).
input_output_vars('case_0'(A,B,C,D,E,F,G,H,I,J),[A,B,C,D,E,F],[G,H,I,J]).
input_output_vars('case_1'(A,B,C,D,E,F,G,H,I,J,K,L),[A,B,C,D,E,F,G,H],[I,J,K,L]).
input_output_vars('case_10'(A,B,C,D,E,F,G,H,I,J),[A,B,C,D,E,F,G,H],[I,J]).
input_output_vars('case_11'(A,B,C,D,E,F,G,H),[A,B,C,D],[E,F,G,H]).
input_output_vars('case_2'(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S),[A,B,C,D,E,F,G,H,I,J,K,L,M,N,O],[P,Q,R,S]).
input_output_vars('case_3'(A,B,C,D,E,F,G),[A,B,C],[D,E,F,G]).
input_output_vars('case_4'(A,B,C,D,E,F),[A,B,C],[D,E,F]).
input_output_vars('case_5'(A,B,C,D,E,F,G,H,I),[A,B,C,D,E,F],[G,H,I]).
input_output_vars('case_6'(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O),[A,B,C,D,E,F,G,H,I,J,K,L],[M,N,O]).
input_output_vars('case_7'(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S),[A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P],[Q,R,S]).
input_output_vars('case_8'(A,B,C,D,E,F,G,H,I,J,K,L),[A,B,C,D,E,F,G,H],[I,J,K,L]).
input_output_vars('case_9'(A,B,C,D),[A,B],[C,D]).
input_output_vars('eq'(A,B,C),[A,B],[C]).
input_output_vars('geq'(A,B,C),[A,B],[C]).
input_output_vars('gt'(A,B,C),[A,B],[C]).
input_output_vars('insertL'(A,B,C,D,E,F,G,H,I,J),[A,B,C,D,E,F],[G,H,I,J]).
input_output_vars('leq'(A,B,C),[A,B],[C]).
input_output_vars('lt'(A,B,C),[A,B],[C]).
input_output_vars('maxNorm'(A,B,C),[A,B],[C]).
input_output_vars('neg'(A,B),[A],[B]).
input_output_vars('neq'(A,B,C),[A,B],[C]).
input_output_vars('or'(A,B,C),[A,B],[C]).
input_output_vars('quicksort'(A,B,C,D),[A,B],[C,D]).
input_output_vars('sortAll'(A,B,C,D,E,F,G,H),[A,B,C,D],[E,F,G,H]).
input_output_vars('split'(A,B,C,D,E,F,G),[A,B,C],[D,E,F,G]).
input_output_vars('splitAndSort'(A,B,C,D,E,F,G),[A,B,C],[D,E,F,G]).
input_output_vars('splitqs'(A,B,C,D,E,F),[A,B,C],[D,E,F]).
eq('eq',[A,B,C],0,[],[A=B,C=1,A>=0,B>=0,C>=0]).
eq('eq',[A,B,C],0,[],[A>=B+1,C=0,A>=0,B>=0,C>=0]).
eq('eq',[A,B,C],0,[],[B>=A+1,C=0,A>=0,B>=0,C>=0]).
eq('neq',[A,B,C],0,[],[A=B,C=0,A>=0,B>=0,C>=0]).
eq('neq',[A,B,C],0,[],[A>=B+1,C=1,A>=0,B>=0,C>=0]).
eq('neq',[A,B,C],0,[],[B>=A+1,C=1,A>=0,B>=0,C>=0]).
eq('lt',[A,B,C],0,[],[B-A>=1,C=1,A>=0,B>=0,C>=0]).
eq('lt',[A,B,C],0,[],[B=<A,C=0,A>=0,B>=0,C>=0]).
eq('leq',[A,B,C],0,[],[A=<B,C=1,A>=0,B>=0,C>=0]).
eq('leq',[A,B,C],0,[],[A-B>=1,C=0,A>=0,B>=0,C>=0]).
eq('gt',[A,B,C],0,[],[A-B>=1,C=1,A>=0,B>=0,C>=0]).
eq('gt',[A,B,C],0,[],[A=<B,C=0,A>=0,B>=0,C>=0]).
eq('geq',[A,B,C],0,[],[B=<A,C=1,A>=0,B>=0,C>=0]).
eq('geq',[A,B,C],0,[],[B-A>=1,C=0,A>=0,B>=0,C>=0]).
eq('neg',[A,B],0,[],[A=0,B=1,A>=0,B>=0]).
eq('neg',[A,B],0,[],[A=1,B=0,A>=0,B>=0]).
eq('and_op',[A,B,C],0,[],[A=0,C=0,A>=0,B>=0,C>=0]).
eq('and_op',[A,B,C],0,[],[A=1,C=B,A>=0,B>=0,C>=0]).
eq('or',[A,B,C],0,[],[A=1,C=1,A>=0,B>=0,C>=0]).
eq('or',[A,B,C],0,[],[A=0,C=B,A>=0,B>=0,C>=0]).
eq('maxNorm',[A,B,A],0,[],[A>=1+B,A>=0,B>=0,A>=0]).
eq('maxNorm',[A,B,B],0,[],[A=<B,A>=0,B>=0,B>=0]).
eq('case_1',[A,B,C,D,E,F,G,H,I,J,K,L],6,[],[E=0,D=1,C=0,M=1,N=G+O,P=M+1,M>=1,Q=N+H,R=P,S=1,P>=1,T=0,U=1,V=0,L=Q+W,K=R+T,J=U+1,I=S+V,U>=1,S>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0]).
eq('case_2',[A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S],4,[],[K=H,T=G+J,U=I+1,I>=1,V=T+K,W=U,X=1,U>=1,S=V+O,R=W+N,Q=M+1,P=X+L,M>=1,X>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0,M>=0,N>=0,O>=0,P>=0,Q>=0,R>=0,S>=0]).
eq('case_2',[A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S],4,['insertL'(A,B,L,M,N,O,T,U,V,W)],[K>=H+1,X=J+K,Y=I,Z=1,I>=1,S=X+W,R=Y+V,Q=U+1,P=Z+T,U>=1,Z>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0,M>=0,N>=0,O>=0,P>=0,Q>=0,R>=0,S>=0]).
eq('case_1',[A,B,C,D,E,F,G,H,I,J,K,L],3,['case_2'(A,B,C,D,E,F,G,H,M,N,O,P,Q,R,S,I,J,K,L)],[F=S+N+O,E=R+M,D=Q+1,C=1+P,Q>=1,M>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0]).
eq('case_0',[A,B,C,D,E,F,G,H,I,J],2,['case_1'(A,B,C,D,E,F,K,L,G,H,I,J)],[B=K+L,A=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0]).
eq('insertL',[A,B,C,D,E,F,G,H,I,J],1,['case_0'(A,B,C,D,E,F,G,H,I,J)],[A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0]).
eq('case_3',[A,B,C,D,E,F,G],2,[],[B=1,A=0,F=0,E=1,D=0,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0]).
eq('case_3',[A,B,C,D,E,F,G],4,['split'(H,I,J,K,L,M,N),'insertL'(O,P,K,L,M,N,D,E,F,G)],[C=P+J,B=I+1,A=O+H,I>=1,O>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0]).
eq('split',[A,B,C,D,E,F,G],1,['case_3'(A,B,C,D,E,F,G)],[A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0]).
eq('case_5',[A,B,C,D,E,F,G,H,I],4,[],[E=1,J=1,K=1,I=L+M,H=J+K,G=1,K>=1,J>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0]).
eq('case_7',[A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S],3,[],[J>=G+1,T=J+P,U=O+1,O>=1,S=N+T,R=M+U,Q=1,U>=1,M>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0,M>=0,N>=0,O>=0,P>=0,Q>=0,R>=0,S>=0]).
eq('case_7',[A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S],3,[],[G>=J,T=J+N,U=M+1,M>=1,S=T+P,R=U+O,Q=1,O>=1,U>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0,M>=0,N>=0,O>=0,P>=0,Q>=0,R>=0,S>=0]).
eq('case_6',[A,B,C,D,E,F,G,H,I,J,K,L,M,N,O],2,['case_7'(A,B,C,D,E,F,G,H,I,J,K,L,P,Q,R,S,M,N,O)],[C=Q+S,B=P+R,A=1,R>=1,P>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0,M>=0,N>=0,O>=0]).
eq('case_5',[A,B,C,D,E,F,G,H,I],7,['splitqs'(J,K,L,M,N,O),'case_6'(P,Q,R,A,B,C,D,E,F,S,T,U,V,W,X)],[F=S+U,E=T+1,T>=1,L=D+U,K=T,J=1,T>=1,R=O,Q=N,P=M,M>=1,I=X,H=W,G=V,V>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0]).
eq('case_4',[A,B,C,D,E,F],2,['case_5'(A,B,C,G,H,I,D,E,F)],[C=G+I,B=H,A=1,H>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0]).
eq('splitqs',[A,B,C,D,E,F],1,['case_4'(A,B,C,D,E,F)],[A>=0,B>=0,C>=0,D>=0,E>=0,F>=0]).
eq('case_8',[A,B,C,D,E,F,G,H,E,F,G,H],1,[],[D=0,C=1,A=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,E>=0,F>=0,G>=0,H>=0]).
eq('case_8',[A,B,C,D,E,F,G,H,I,J,K,L],4,['append'(M,N,O,P,E,F,G,H,Q,R,S,T)],[D=U+P,C=O+1,B=V+N,A=M+1,O>=1,M>=1,U>=1,L=U+T,K=S+1,J=V+R,I=Q+1,S>=1,Q>=1,U>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0]).
eq('append',[A,B,C,D,E,F,G,H,I,J,K,L],1,['case_8'(A,B,C,D,E,F,G,H,I,J,K,L)],[A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0]).
eq('case_9',[A,B,C,D],2,[],[A=1,C=1,A>=0,B>=0,C>=0,D>=0]).
eq('case_10',[A,B,C,D,E,F,G,H,I,J],5,['quicksort'(K,L,M,N),'quicksort'(O,P,Q,R),'append'(M,N,S,T,U,V,W,X,I,J,Y,Z)],[C=L+P,B=K+O,A=1,O>=1,K>=1,V=F+R,U=Q+1,Q>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0]).
eq('case_9',[A,B,C,D],7,['splitqs'(E,F,G,H,I,J),'case_10'(K,L,M,A,B,N,O,P,Q,R)],[B=N+P,A=O+1,O>=1,G=N+P,F=O,E=1,O>=1,M=J,L=I,K=H,H>=1,D=R,C=Q,Q>=1,A>=0,B>=0,C>=0,D>=0]).
eq('quicksort',[A,B,C,D],1,['case_9'(A,B,C,D)],[A>=0,B>=0,C>=0,D>=0]).
eq('case_11',[A,B,C,D,E,F,G,H],2,[],[C=0,B=1,A=0,G=0,F=1,E=0,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0]).
eq('case_11',[A,B,C,D,E,F,G,H],6,['quicksort'(I,J,K,L),'sortAll'(M,N,O,P,Q,R,S,T)],[D=P+J+U,C=O+I,B=N+1,A=1+M,N>=1,I>=1,V=L+U,W=K,X=1,K>=1,H=V+T,G=W+S,F=R+1,E=X+Q,R>=1,X>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0]).
eq('sortAll',[A,B,C,D,E,F,G,H],1,['case_11'(A,B,C,D,E,F,G,H)],[A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0]).
eq('splitAndSort',[A,B,C,D,E,F,G],2,['split'(A,B,C,H,I,J,K),'sortAll'(H,I,J,K,D,E,F,G)],[A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0]).

Preprocessing Cost Relations
=====================================

#### Computed strongly connected components 
0. recursive  : [append/12,case_8/12]
1. recursive  : [case_0/10,case_1/12,case_2/19,insertL/10]
2. non_recursive  : [case_7/19]
3. non_recursive  : [case_6/15]
4. recursive [non_tail] : [case_4/6,case_5/9,splitqs/6]
5. recursive [non_tail,multiple] : [case_10/10,case_9/4,quicksort/4]
6. recursive  : [case_11/8,sortAll/8]
7. recursive [non_tail] : [case_3/7,split/7]
8. non_recursive  : [splitAndSort/7]
Warning: the following predicates are never called:[and_op/3,eq/3,geq/3,gt/3,leq/3,lt/3,maxNorm/3,neg/2,neq/3,or/3]

#### Obtained direct recursion through partial evaluation 
0. SCC is partially evaluated into append/12
1. SCC is partially evaluated into insertL/10
2. SCC is partially evaluated into case_7/19
3. SCC is completely evaluated into other SCCs
4. SCC is partially evaluated into splitqs/6
5. SCC is partially evaluated into quicksort/4
6. SCC is partially evaluated into sortAll/8
7. SCC is partially evaluated into split/7
8. SCC is partially evaluated into splitAndSort/7

Control-Flow Refinement of Cost Relations
=====================================

### Specialization of cost equations append/12 
* CE 9 is refined into CE [17] 
* CE 8 is refined into CE [18] 


#### Refined cost equations append/12 
* CE 17: append(A,B,C,D,E,F,G,H,E,F,G,H) = 2
     [H>=0,G>=0,F>=0,E>=0,B>=0,D=0,C=1,A=1] 
* CE 18: append(A,B,C,D,E,F,G,H,I,J,K,L) = 5+ append(M,N,O,P,E,F,G,H,Q,R,S,T)
     [L+P>=T,J+N>=R,L>=T+1,S>=1,Q>=1,O>=1,M>=1,L>=0,J>=0,H>=0,G>=0,F>=0,E>=0,D+T=L+P,B+R=J+N,S+1=K,Q+1=I,O+1=C,M+1=A] 

### Cost equations --> "Loop" of append/12 
* CEs [18] --> Loop 17 
* CEs [17] --> Loop 18 

#### Loops of append/12 
* Loop 17: append(A,B,C,D,E,F,G,H,I,J,K,L)->  append(A',B',C',D',E,F,G,H,E',F',G',H')
                  [L+D'>=H',J+B'>=F',L>=H'+1,G'>=1,E'>=1,C'>=1,A'>=1,L>=0,J>=0,H>=0,G>=0,F>=0,E>=0,L+D'=D+H',J+B'=B+F',G'+1=K,E'+1=I,C'+1=C,A'+1=A] 
* Loop 18: append(A,B,C,D,E,F,G,H,E,F,G,H) [H>=0,G>=0,F>=0,E>=0,B>=0,D=0,C=1,A=1] 

### Ranking functions of CR append(A,B,C,D,E,F,G,H,I,J,K,L) 
* RF of phase [17]: [A-1,C-1,D+1]

#### Partial ranking functions of CR append(A,B,C,D,E,F,G,H,I,J,K,L) 
* Partial RF of phase [17]:
  - RF of loop [17:1]:
    A-1
    C-1
    D+1

Discarded unfeasible chain [[17]]...(Non-terminating chain proved terminating)

### Resulting Chains:append(A,B,C,D,E,F,G,H,I,J,K,L) 
* [[17],18]
* [18]


### Merging Chains  append/12 into  External patterns of execution 
* [[18]] --> 1 
* [[18,[17]]] --> 2 


### Specialization of cost equations insertL/10 
* CE 3 is refined into CE [19] 
* CE 2 is refined into CE [20] 
* CE 1 is refined into CE [21] 


#### Refined cost equations insertL/10 
* CE 19: insertL(A,B,C,D,E,F,G,H,I,J) = 10+ insertL(K,B,L,M,N,O,P,Q,R,S)
     [F+S>=J,E+R>=I,J>=S+1,I>=R+1,Q>=1,P+1>=0,M>=1,L>=0,J>=0,I>=0,B>=0,J+O=F+S,I+N=E+R,Q+1=H,P+1=G,M+1=D,L+1=C,K=1,A=1] 
* CE 20: insertL(A,B,C,D,E,F,C,D,G,H) = 10
     [B+F>=H,H>=F,H>=B,G>=2,D>=2,C>=1,G=E+1,A=1] 
* CE 21: insertL(A,B,C,D,E,F,G,H,I,J) = 9
     [J>=0,F>=0,B>=0,I=2,H=2,G=1,E=0,D=1,C=0,A=1] 

### Cost equations --> "Loop" of insertL/10 
* CEs [20] --> Loop 19 
* CEs [21] --> Loop 20 
* CEs [19] --> Loop 21 

#### Loops of insertL/10 
* Loop 19: insertL(A,B,C,D,E,F,C,D,G,H) [B+F>=H,H>=F,H>=B,E>=1,D>=2,C>=1,E+1=G,A=1] 
* Loop 20: insertL(A,B,C,D,E,F,G,H,I,J) [J>=0,F>=0,B>=0,I=2,H=2,G=1,E=0,D=1,C=0,A=1] 
* Loop 21: insertL(A,B,C,D,E,F,G,H,I,J)->  insertL(A',B,B',C',D',E',F',G',H',I')
                  [F+I'>=J,E+H'>=I,J>=I'+1,I>=H'+1,G'>=1,F'+1>=0,C'>=1,B'>=0,J>=0,I>=0,B>=0,F+I'=J+E',E+H'=I+D',G'+1=H,F'+1=G,C'+1=D,B'+1=C,A'=1,A=1] 

### Ranking functions of CR insertL(A,B,C,D,E,F,G,H,I,J) 
* RF of phase [21]: [C,D-1,E,F]

#### Partial ranking functions of CR insertL(A,B,C,D,E,F,G,H,I,J) 
* Partial RF of phase [21]:
  - RF of loop [21:1]:
    C
    D-1
    E
    F

Discarded unfeasible chain [[21]]...(Non-terminating chain proved terminating)

### Resulting Chains:insertL(A,B,C,D,E,F,G,H,I,J) 
* [[21],20]
* [[21],19]
* [20]
* [19]


### Merging Chains  insertL/10 into  External patterns of execution 
* [[20]] --> 1 
* [[20,[21]]] --> 2 
* [[19],[19,[21]]] --> 3 


### Specialization of cost equations case_7/19 
* CE 16 is refined into CE [22] 
* CE 15 is refined into CE [23] 


#### Refined cost equations case_7/19 
* CE 22: case_7(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S) = 3
     [G+N+P>=S,S>=N+P,P>=0,O>=1,N>=0,M>=1,L>=0,K>=1,G+L+S=F+N+P,L+S=I+N+P,S=J+N+P,M+O+1=R,N+P=C,M+O=B,K+1=H,K+1=E,Q=1,D=1,A=1] 
* CE 23: case_7(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S) = 3
     [J>=G+1,P>=0,O>=1,N>=0,M>=1,L>=0,K>=1,G>=0,J+N+P=S,G+J+L=F,M+O+1=R,J+L=I,N+P=C,M+O=B,K+1=H,K+1=E,Q=1,D=1,A=1] 

### Cost equations --> "Loop" of case_7/19 
* CEs [22] --> Loop 22 
* CEs [23] --> Loop 23 

#### Loops of case_7/19 
* Loop 22: case_7(A,B,C,D,E,F,G,E,H,I,J,K,L,M,N,O,P,Q,R) [F>=G+I,C>=M,B>=L+1,G>=I,M>=0,L>=1,I>=0,E>=2,G+I+K=F,C+I=R,G+H=F,M+O=C,L+N=B,B+1=Q,E=J+1,P=1,D=1,A=1] 
* Loop 23: case_7(A,B,C,D,E,F,G,E,H,I,J,K,L,M,N,O,P,Q,R) [F>=G+I,C>=M,B>=L+1,I>=G+1,M>=0,L>=1,G>=0,E>=2,G+I+K=F,C+I=R,G+H=F,M+O=C,L+N=B,B+1=Q,E=J+1,P=1,D=1,A=1] 

### Ranking functions of CR case_7(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S) 

#### Partial ranking functions of CR case_7(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S) 


### Resulting Chains:case_7(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S) 
* [23]
* [22]


### Merging Chains  case_7/19 into  External patterns of execution 
* [[23]] --> 1 
* [[22]] --> 2 


### Specialization of cost equations splitqs/6 
* CE 7 is refined into CE [24] 
* CE 6 is refined into CE [25,26] 


#### Refined cost equations splitqs/6 
* CE 24: splitqs(A,B,C,D,E,F) = 7
     [F>=0,C>=0,E=2,D=1,B=1,A=1] 
* CE 25: splitqs(A,B,C,D,E,F) = 12+ splitqs(G,H,I,J,K,L)+ case_7(M,N,O,P,B,Q,R,B,S,T,U,V,W,X,Y,Z,A1,E,F):1
     [S+X+Z>=F,F>=R+X+Z+1,E>=W+2,Z>=0,X>=0,W>=1,B>=2,R>=0,R+S+X+Z=F+I,S+X+Z=F+V,T+X+Z=F,X+Z=L,E=W+Y+1,R+S=Q,X+Z=O,R+S=C,E=K+1,B=H+1,B=U+1,E=N+1,J=1,G=1,A1=1,P=1,M=1,D=1,A=1] 
* CE 26: splitqs(A,B,C,D,E,F) = 12+ splitqs(G,H,I,J,K,L)+ case_7(M,N,O,P,B,Q,R,B,S,T,U,V,W,X,Y,Z,A1,E,F):2
     [S+X+Z>=F,R+X+Z>=F,F>=X+Z,E>=W+2,Z>=0,X>=0,W>=1,B>=2,R+S+X+Z=F+I,S+X+Z=F+V,T+X+Z=F,X+Z=L,E=W+Y+1,R+S=Q,X+Z=O,R+S=C,E=K+1,B=H+1,B=U+1,E=N+1,J=1,G=1,A1=1,P=1,M=1,D=1,A=1] 

### Cost equations --> "Loop" of splitqs/6 
* CEs [26] --> Loop 24 
* CEs [25] --> Loop 25 
* CEs [24] --> Loop 26 

#### Loops of splitqs/6 
* Loop 24: splitqs(A,B,C,D,E,F)->  splitqs(A',B',C',D',E',F')
                  [F+C'>=C,C>=C',2*C'>=C,E>=3,B>=2,C+F'=F+C',E=E'+1,B=B'+1,D'=1,A'=1,D=1,A=1] 
* Loop 25: splitqs(A,B,C,D,E,F)->  splitqs(A',B',C',D',E',F')
                  [F+C'>=C,C>=C'+1,C'>=0,E>=3,B>=2,C+F'=F+C',E=E'+1,B=B'+1,D'=1,A'=1,D=1,A=1] 
* Loop 26: splitqs(A,B,C,D,E,F) [F>=0,C>=0,E=2,D=1,B=1,A=1] 

### Ranking functions of CR splitqs(A,B,C,D,E,F) 
* RF of phase [24,25]: [B-1]

#### Partial ranking functions of CR splitqs(A,B,C,D,E,F) 
* Partial RF of phase [24,25]:
  - RF of loop [24:1,25:1]:
    B-1
  - RF of loop [25:1]:
    C

Discarded unfeasible chain [[24,25]]...(Non-terminating chain proved terminating)

### Resulting Chains:splitqs(A,B,C,D,E,F) 
* [[24,25],26]
* [26]


### Merging Chains  splitqs/6 into  External patterns of execution 
* [[26]] --> 1 
* [[26,[24,25]]] --> 2 


### Specialization of cost equations quicksort/4 
* CE 11 is refined into CE [27,28,29,30] 
* CE 10 is refined into CE [31] 


#### Refined cost equations quicksort/4 
* CE 27: quicksort(A,B,C,D) = 13+ splitqs(E,F,B,G,H,I):1+ quicksort(J,K,L,M)+ quicksort(N,O,P,Q)+ append(R,M,S,T,C,D,U,V,C,D,U,V):1
     [B+Q>=D,D>=Q,V>=0,U>=0,D>=0,C>=2,M>=0,I>=0,I=K+O,C=P+1,N=1,L=1,J=1,T=0,S=1,R=1,H=2,G=1,F=1,E=1,A=2] 
* CE 28: quicksort(A,B,C,D) = 13+ splitqs(E,F,B,G,H,I):1+ quicksort(J,K,L,M)+ quicksort(N,O,P,Q)+ append(L,M,L,R,S,T,U,V,C,D,W,X):2
     [M+T>=D,B+Q>=T,T>=Q,X>=R,W>=L,C>=L+1,R+1>=L,D>=0,T>=0,L>=2,M>=0,I>=0,I=K+O,L+U=W+1,L+P=C,L+S=C+1,X=R+V,N=1,J=1,H=2,G=1,F=1,E=1,A=2] 
* CE 29: quicksort(A,B,C,D) = 13+ splitqs(E,F,B,G,A,H):2+ quicksort(I,J,K,L)+ quicksort(M,N,O,P)+ append(Q,L,R,S,C,D,T,U,C,D,T,U):1
     [B+P>=D,D>=P,A>=M+1,M>=1,U>=0,T>=0,D>=0,C>=2,L>=0,H>=0,A>=3,H=J+N,A=I+M,C=O+1,A=F+1,K=1,S=0,R=1,Q=1,G=1,E=1] 
* CE 30: quicksort(A,B,C,D) = 13+ splitqs(E,F,B,G,A,H):2+ quicksort(I,J,K,L)+ quicksort(M,N,O,P)+ append(K,L,K,Q,R,S,T,U,C,D,V,W):2
     [L+S>=D,B+P>=S,S>=P,A>=M+1,W>=Q,V>=K,C>=K+1,Q+1>=K,M>=1,D>=0,S>=0,K>=2,L>=0,H>=0,A>=3,H=J+N,A=I+M,K+T=V+1,K+O=C,K+R=C+1,W=Q+U,A=F+1,G=1,E=1] 
* CE 31: quicksort(A,B,C,D) = 3
     [D>=0,B>=0,C=1,A=1] 

### Cost equations --> "Loop" of quicksort/4 
* CEs [31] --> Loop 27 
* CEs [30] --> Loop 28 
* CEs [29] --> Loop 29 
* CEs [28] --> Loop 30 
* CEs [27] --> Loop 31 

#### Loops of quicksort/4 
* Loop 27: quicksort(A,B,C,D) [D>=0,B>=0,C=1,A=1] 
* Loop 28: quicksort(A,B,C,D)->  quicksort(A',B',C',D')  quicksort(A'2,B'2,C'2,D'2)
                  [B+D'+D'2>=D,B'+B'2>=0,B+D'2>=0,C>=C'+1,A>=A'+1,D'>=0,C'>=2,A'>=1,D>=0,B>=0,A>=3,A=A'+A'2,C'+C'2=C] 
* Loop 29: quicksort(A,B,C,D)->  quicksort(A',B',C',D')  quicksort(A'2,B'2,C'2,D'2)
                  [B+D'2>=D,B'+B'2>=0,D>=D'2,A>=A'+1,D'>=0,A'>=1,D>=0,C>=2,A>=3,A=A'+A'2,C=C'2+1,C'=1] 
* Loop 30: quicksort(A,B,C,D)->  quicksort(A',B',C',D')  quicksort(A'2,B'2,C'2,D'2)
                  [B+D'+D'2>=D,B'+B'2>=0,B+D'2>=0,C>=C'+1,D'>=0,C'>=2,D>=0,B>=0,C'+C'2=C,A'2=1,A'=1,A=2] 
* Loop 31: quicksort(A,B,C,D)->  quicksort(A',B',C',D')  quicksort(A'2,B'2,C'2,D'2)
                  [B+D'2>=D,B'+B'2>=0,D>=D'2,D'>=0,D>=0,C>=2,C=C'2+1,A'2=1,C'=1,A'=1,A=2] 

### Ranking functions of CR quicksort(A,B,C,D) 
* RF of phase [28,29]: [A-2]

#### Partial ranking functions of CR quicksort(A,B,C,D) 
* Partial RF of phase [28,29]:
  - RF of loop [28:1,28:2,29:1,29:2]:
    A-2

Discarded unfeasible chain [multiple([28,29],[[],[multiple(31,[[27]])],[multiple(30,[[27]])],[27]])]...(Non-terminating chain proved terminating)
Remaining chain: [multiple([28,29],[[multiple(31,[[27]])],[multiple(30,[[27]])],[27]])]

### Resulting Chains:quicksort(A,B,C,D) 
* [multiple(31,[[27]])]
* [27]
* [multiple([28,29],[[multiple(31,[[27]])],[multiple(30,[[27]])],[27]])]


### Merging Chains  quicksort/4 into  External patterns of execution 
* [[27]] --> 1 
* [[multiple(31,[[27]])]] --> 2 
* [[multiple([28,29],[[multiple(31,[[27]])],[multiple(30,[[27]])],[27]])]] --> 3 


### Specialization of cost equations sortAll/8 
* CE 13 is refined into CE [32] 
* CE 12 is refined into CE [33,34,35] 


#### Refined cost equations sortAll/8 
* CE 32: sortAll(A,B,C,D,E,F,G,H) = 3
     [H>=0,D>=0,G=0,F=1,E=0,C=0,B=1,A=0] 
* CE 33: sortAll(A,B,C,D,E,F,G,H) = 7+ quicksort(I,J,K,L):1+ sortAll(M,N,O,P,Q,R,S,T)
     [H+J+P>=L+T,S+1>=0,R>=1,Q+1>=0,O+1>=0,N>=1,M+1>=0,L>=0,J>=0,H>=0,H+J+P=D+L+T,S+1=G,R+1=F,Q+1=E,O+1=C,N+1=B,M+1=A,K=1,I=1] 
* CE 34: sortAll(A,B,C,D,E,F,G,H) = 7+ quicksort(I,J,K,L):2+ sortAll(M,N,O,P,Q,R,S,T)
     [H+J+P>=L+T,S+2>=0,R>=1,Q+1>=0,O+2>=0,N>=1,M+1>=0,L>=0,J>=0,H>=0,H+J+P=D+L+T,S+2=G,R+1=F,Q+1=E,O+2=C,N+1=B,M+1=A,K=2,I=2] 
* CE 35: sortAll(A,B,C,D,E,F,G,H) = 7+ quicksort(I,J,I,K):3+ sortAll(L,M,N,O,P,Q,R,S)
     [H+J+O>=K+S,I+R>=0,I+N>=0,Q>=1,P+1>=0,M>=1,L+1>=0,K>=0,I>=3,J>=0,H>=0,H+J+O=D+K+S,I+R=G,I+N=C,Q+1=F,P+1=E,M+1=B,L+1=A] 

### Cost equations --> "Loop" of sortAll/8 
* CEs [35] --> Loop 32 
* CEs [33] --> Loop 33 
* CEs [34] --> Loop 34 
* CEs [32] --> Loop 35 

#### Loops of sortAll/8 
* Loop 32: sortAll(A,B,C,D,E,F,G,H)->  sortAll(A',B',C',D',E',F',G',H')
                  [C>=C'+3,H>=0,G>=0,F>=2,E>=0,D>=0,C>=0,B>=2,A>=0,C+G'=G+C',F=F'+1,E=E'+1,B=B'+1,A=A'+1] 
* Loop 33: sortAll(A,B,C,D,E,F,G,H)->  sortAll(A',B',C',D',E',F',G',H')
                  [H>=0,G>=0,F>=2,E>=0,D>=0,C>=0,B>=2,A>=0,G=G'+1,F=F'+1,E=E'+1,C=C'+1,B=B'+1,A=A'+1] 
* Loop 34: sortAll(A,B,C,D,E,F,G,H)->  sortAll(A',B',C',D',E',F',G',H')
                  [H>=0,G>=0,F>=2,E>=0,D>=0,C>=0,B>=2,A>=0,G=G'+2,F=F'+1,E=E'+1,C=C'+2,B=B'+1,A=A'+1] 
* Loop 35: sortAll(A,B,C,D,E,F,G,H) [H>=0,D>=0,G=0,F=1,E=0,C=0,B=1,A=0] 

### Ranking functions of CR sortAll(A,B,C,D,E,F,G,H) 
* RF of phase [32,33,34]: [A+1,B-1,C+1]

#### Partial ranking functions of CR sortAll(A,B,C,D,E,F,G,H) 
* Partial RF of phase [32,33,34]:
  - RF of loop [32:1]:
    C/3+1/3
  - RF of loop [32:1,33:1,34:1]:
    A+1
    B-1
  - RF of loop [33:1]:
    C+1
  - RF of loop [34:1]:
    C/2+1/2

Discarded unfeasible chain [[32,33,34]]...(Non-terminating chain proved terminating)

### Resulting Chains:sortAll(A,B,C,D,E,F,G,H) 
* [[32,33,34],35]
* [35]


### Merging Chains  sortAll/8 into  External patterns of execution 
* [[35]] --> 1 
* [[35,[32,33,34]]] --> 2 


### Specialization of cost equations split/7 
* CE 5 is refined into CE [36] 
* CE 4 is refined into CE [37,38,39] 


#### Refined cost equations split/7 
* CE 36: split(A,B,C,D,E,F,G) = 3
     [G>=0,C>=0,F=0,E=1,D=0,B=1,A=0] 
* CE 37: split(A,B,C,D,E,F,G) = 5+ split(H,I,J,K,L,M,N)+ insertL(O,P,Q,R,S,N,T,U,V,G):1
     [P+J>=0,I>=1,H+1>=0,G>=0,N>=0,P>=0,P+J=C,I+1=B,H+1=A,M=0,L=1,K=0,V=2,U=2,T=1,S=0,R=1,Q=0,O=1,F=2,E=2,D=1] 
* CE 38: split(A,B,C,D,E,F,G) = 5+ split(H,I,J,K,D,L,M)+ insertL(N,O,P,D,Q,M,D,R,F,G):2
     [O+J>=0,G+1>=D,F>=D+1,M+1>=D,I>=1,H+1>=0,D>=2,O>=0,O+J=C,F=L+2,D=K+1,D+1=R,F=Q+2,D=P+1,D+1=E,I+1=B,H+1=A,N=1] 
* CE 39: split(A,B,C,D,E,F,G) = 5+ split(H,I,J,D,E,K,L)+ insertL(M,N,D,E,O,L,D,E,F,G):3
     [N+L>=G,N+J>=0,G>=L,G>=N,I>=1,H+1>=0,F>=2,E>=2,D>=1,N+J=C,F=K+1,F=O+1,I+1=B,H+1=A,M=1] 

### Cost equations --> "Loop" of split/7 
* CEs [39] --> Loop 36 
* CEs [38] --> Loop 37 
* CEs [37] --> Loop 38 
* CEs [36] --> Loop 39 

#### Loops of split/7 
* Loop 36: split(A,B,C,D,E,F,G)->  split(A',B',C',D,E,D',E')
                  [C+E'>=G+C',G+C'>=C,G>=E',F>=2,E>=2,D>=1,C>=0,B>=2,A>=0,F=D'+1,B=B'+1,A=A'+1] 
* Loop 37: split(A,B,C,D,E,F,G)->  split(A',B',C',D',D,E',F')
                  [C>=C',F'+1>=D,G+1>=D,F>=D+1,D>=2,C>=0,B>=2,A>=0,F=E'+2,D=D'+1,B=B'+1,A=A'+1,D+1=E] 
* Loop 38: split(A,B,C,D,E,F,G)->  split(A',B',C',D',E',F',G')
                  [C>=C',G'>=0,G>=0,C>=0,B>=2,A>=0,B=B'+1,A=A'+1,F'=0,E'=1,D'=0,F=2,E=2,D=1] 
* Loop 39: split(A,B,C,D,E,F,G) [G>=0,C>=0,F=0,E=1,D=0,B=1,A=0] 

### Ranking functions of CR split(A,B,C,D,E,F,G) 
* RF of phase [36,37]: [A+1,B-1]

#### Partial ranking functions of CR split(A,B,C,D,E,F,G) 
* Partial RF of phase [36,37]:
  - RF of loop [36:1,37:1]:
    A+1
    B-1

Discarded unfeasible chain [[36,37]]...(Non-terminating chain proved terminating)

### Resulting Chains:split(A,B,C,D,E,F,G) 
* [[36,37],38,39]
* [39]
* [38,39]


### Merging Chains  split/7 into  External patterns of execution 
* [[39]] --> 1 
* [[39,38]] --> 2 
* [[39,38,[36,37]]] --> 3 


### Specialization of cost equations splitAndSort/7 
* CE 14 is refined into CE [40,41,42] 


#### Refined cost equations splitAndSort/7 
* CE 40: splitAndSort(A,B,C,D,E,F,G) = 2+ split(H,I,C,J,K,L,M):1+ sortAll(N,O,P,M,Q,R,S,G):1
     [G>=0,M>=0,C>=0,S=0,R=1,Q=0,P=0,O=1,N=0,L=0,K=1,J=0,I=1,H=0,F=0,E=1,D=0,B=1,A=0] 
* CE 41: splitAndSort(A,B,C,D,E,F,G) = 2+ split(H,I,C,J,K,L,M):2+ sortAll(N,O,P,M,Q,R,S,G):2
     [G>=0,M>=0,C>=0,S=2,R=2,Q=1,P=2,O=2,N=1,L=2,K=2,J=1,I=2,H=1,F=2,E=2,D=1,B=2,A=1] 
* CE 42: splitAndSort(A,B,C,D,E,F,G) = 2+ split(H,I,C,J,E,F,K):3+ sortAll(L,E,F,K,M,E,F,G):2
     [F>=E+1,K+2>=E,F+2>=2*E,G>=0,E>=2,C>=0,E+I=F+2,E+H=F+1,B+E=F+2,A+E=F+1,E=M+1,E=L+1,E=J+1,E=D+1] 

### Cost equations --> "Loop" of splitAndSort/7 
* CEs [42] --> Loop 40 
* CEs [41] --> Loop 41 
* CEs [40] --> Loop 42 

#### Loops of splitAndSort/7 
* Loop 40: splitAndSort(A,B,C,D,E,F,G) [A>=D,G>=0,D>=1,C>=0,A>=2,A+D=F,D+1=E,A+1=B] 
* Loop 41: splitAndSort(A,B,C,D,E,F,G) [G>=0,C>=0,F=2,E=2,D=1,B=2,A=1] 
* Loop 42: splitAndSort(A,B,C,D,E,F,G) [G>=0,C>=0,F=0,E=1,D=0,B=1,A=0] 

### Ranking functions of CR splitAndSort(A,B,C,D,E,F,G) 

#### Partial ranking functions of CR splitAndSort(A,B,C,D,E,F,G) 


### Resulting Chains:splitAndSort(A,B,C,D,E,F,G) 
* [42]
* [41]
* [40]


### Merging Chains  splitAndSort/7 into  External patterns of execution 
* [[42]] --> 1 
* [[41]] --> 2 
* [[40]] --> 3 


Computing Bounds
=====================================

#### Simplifying cost structure of CE 17 

#### Computing cost of phase [17] 

#### Simplifying cost structure of CE 18 

#### Cost of loops [17] 

 * loop 17:append(A,B,C,D,E,F,G,H,I,J,K,L) -> [append(A',B',C',D',E',F',G',H',I',J',K',L')] 
5
##### Pending set append(A,B,C,D,E,F,G,H,I,J,K,L)
* Psum in Loop 17: [it(17)=<1]

###### Computing sum for it(17)=<1  in Loop 17 
   - Applying inductive sum strategy 
     - head Candidate: C-1 
     - head Candidate: D+1 
     - head Candidate: A-1 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: D+1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
     - tail Candidate: D+1 
     - tail Candidate: A-1 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: D+1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(17)=<C-1,it(17)=<D+1,it(17)=<A-1,it(17)=<A-1,it(17)=<C-1,it(17)=<D+1,it(17)=<C-C',it(17)=<D-D',it(17)=<A-A',it(17)=<A-A',it(17)=<C-C',it(17)=<D-D'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [17] 

#### Simplifying cost structure of phase [17] 

#### Cost of phase [17]:append(A,B,C,D,E,F,G,H,I,J,K,L) -> [append(A',B',C',D',E',F',G',H',I',J',K',L')] 
5*it(17)+0
  Such that:it(17) =< A
it(17) =< A-A'
it(17) =< C
it(17) =< C-C'
it(17) =< D+1
it(17) =< D-D'

#### Simplifying cost structure of chain [[17],18] 

#### Cost of chains of append(A,B,C,D,E,F,G,H,I,J,K,L):
* Chain [[17],18]: 5*it(17)+2
  Such that:it(17) =< -E+I

  with precondition: [A=C,L=D+H,A+E=I+1,A+G=K+1,A>=2,B>=0,E>=1,F>=0,G>=1,J>=0,D+1>=A,L>=D,B+F>=J] 

* Chain [18]: 2
  with precondition: [A=1,C=1,D=0,E=I,F=J,G=K,H=L,B>=0,E>=0,F>=0,G>=0,H>=0] 


#### Simplifying cost structure of CE 21 

#### Computing cost of phase [21] 

#### Simplifying cost structure of CE 19 

#### Cost of loops [21] 

 * loop 21:insertL(A,B,C,D,E,F,G,H,I,J) -> [insertL(A',B',C',D',E',F',G',H',I',J')] 
10
##### Pending set insertL(A,B,C,D,E,F,G,H,I,J)
* Psum in Loop 21: [it(21)=<1]

###### Computing sum for it(21)=<1  in Loop 21 
   - Applying inductive sum strategy 
     - head Candidate: E 
     - head Candidate: F 
     - head Candidate: C 
     - head Candidate: D-1 
     - head Candidate: C 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: D-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: E 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: F 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: E 
     - tail Candidate: F 
     - tail Candidate: C 
     - tail Candidate: D-1 
     - tail Candidate: C 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: D-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: E 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: F 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(21)=<E,it(21)=<F,it(21)=<C,it(21)=<D-1,it(21)=<C,it(21)=<D-1,it(21)=<E,it(21)=<F,it(21)=<E-E',it(21)=<F-F',it(21)=<C-C',it(21)=<D-D',it(21)=<C-C',it(21)=<D-D',it(21)=<E-E',it(21)=<F-F'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [21] 

#### Simplifying cost structure of phase [21] 

#### Cost of phase [21]:insertL(A,B,C,D,E,F,G,H,I,J) -> [insertL(A',B',C',D',E',F',G',H',I',J')] 
10*it(21)+0
  Such that:it(21) =< C
it(21) =< C-C'
it(21) =< D
it(21) =< D-D'
it(21) =< E
it(21) =< E-E'
it(21) =< F
it(21) =< F-F'

#### Simplifying cost structure of chain [[21],20] 

#### Simplifying cost structure of CE 20 

#### Found solution for phase  [21] in the cache 

#### Cost of phase [21]:insertL(A,B,C,D,E,F,G,H,I,J) -> [insertL(A',B',C',D',E',F',G',H',I',J')] 
10*it(21)+0
  Such that:it(21) =< C
it(21) =< C-C'
it(21) =< D
it(21) =< D-D'
it(21) =< E
it(21) =< E-E'
it(21) =< F
it(21) =< F-F'

#### Simplifying cost structure of chain [[21],19] 
 * Renamed intermediate variables: 
[ (ch([[21],19]),it(21))>>s(1)]

#### Cost of chains of insertL(A,B,C,D,E,F,G,H,I,J):
* Chain [[21],20]: 10*it(21)+9
  Such that:it(21) =< G

  with precondition: [A=1,C+1=D,I=E+2,C+1=G,C+2=H,B>=0,C>=1,F>=C,I>=C+2,J>=C] 

* Chain [[21],19]: 10*it(21)+10
  Such that:it(21) =< -B+J
it(21) =< G

  with precondition: [A=1,I=E+1,C=G,D=H,C>=2,D>=3,I>=3,J>=B+1,J>=F,B+F>=J] 

* Chain [20]: 9
  with precondition: [A=1,C=0,D=1,E=0,G=1,H=2,I=2,B>=0,F>=0,J>=0] 

* Chain [19]: 10
  with precondition: [A=1,C=G,D=H,E+1=I,C>=1,D>=2,E>=1,J>=B,J>=F,B+F>=J] 


#### Simplifying cost structure of CE 23 

#### Simplifying cost structure of CE 22 

#### Cost of chains of case_7(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S):
* Chain [23]: 3
  with precondition: [A=1,D=1,Q=1,H=E,H=K+1,B+1=R,F=G+I,B=M+O,C=N+P,C+J=S,F=G+J+L,G>=0,H>=2,M>=1,N>=0,J>=G+1,B>=M+1,C>=N,F>=G+J] 

* Chain [22]: 3
  with precondition: [A=1,D=1,Q=1,H=E,H=K+1,B+1=R,F=G+I,B=M+O,C=N+P,C+J=S,F=G+J+L,H>=2,J>=0,M>=1,N>=0,G>=J,B>=M+1,C>=N,F>=G+J] 


#### Simplifying cost structure of CE 24 

#### Computing cost of phase [24,25] 

#### Simplifying cost structure of CE 26 

#### Simplifying cost structure of CE 25 

#### Cost of loops [24,25] 

 * loop 24:splitqs(A,B,C,D,E,F) -> [splitqs(A',B',C',D',E',F')] 
15
 * loop 25:splitqs(A,B,C,D,E,F) -> [splitqs(A',B',C',D',E',F')] 
15
##### Pending set splitqs(A,B,C,D,E,F)
* Psum in Loop 24: [it(24)=<1]
* Psum in Loop 25: [it(25)=<1]

###### Computing sum for it(24)=<1  in Loop 24 
   - Applying inductive sum strategy 
     - head Candidate: B-1 
       - Loop 25 is collaborative and bounds [it(25)] 
     - head Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B-1 
       - Loop 25 is collaborative and bounds [it(25)] 
     - tail Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(24)+it(25)=<B-1,it(24)+it(25)=<B-1,it(24)+it(25)=<B-B',it(24)+it(25)=<B-B'] 

##### Pending set A
* Psum in Loop 25: [it(25)=<1]

###### Computing sum for it(25)=<1  in Loop 25 
   - Applying inductive sum strategy 
     - head Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: C 
       - Loop 24 is collaborative
     - tail Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C 
       - Loop 24 is collaborative
 * Adding constraints: [it(24)+it(25)=<B-1,it(24)+it(25)=<B-1,it(25)=<C,it(24)+it(25)=<B-B',it(24)+it(25)=<B-B',it(25)=<C-C'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [24,25] 

#### Simplifying cost structure of phase [24,25] 

#### Cost of phase [24,25]:splitqs(A,B,C,D,E,F) -> [splitqs(A',B',C',D',E',F')] 
15*it(24)+15*it(25)+0
  Such that:it(25) =< C
it(25) =< C-C'
aux(1) =< B
aux(2) =< B-B'
it(24) =< aux(1)
it(25) =< aux(1)
it(24) =< aux(2)
it(25) =< aux(2)

#### Simplifying cost structure of chain [[24,25],26] 
 * Joined equivalent variables [aux(3),aux(1),aux(2)] into aux(3)

#### Cost of chains of splitqs(A,B,C,D,E,F):
* Chain [[24,25],26]: 15*it(24)+15*it(25)+7
  Such that:it(25) =< C
it(25) =< F
aux(3) =< B
it(24) =< aux(3)
it(25) =< aux(3)

  with precondition: [A=1,D=1,B+1=E,B>=2,C>=0,F>=0] 

* Chain [26]: 7
  with precondition: [A=1,B=1,D=1,E=2,C>=0,F>=0] 


#### Simplifying cost structure of CE 31 

#### Simplifying cost structure of CE 27 

#### Simplifying cost structure of chain [multiple(31,[[27]])] 
 * Renamed intermediate variables: 
[ (eq(28,2),it(17))>>s(2)]

#### Simplifying cost structure of CE 28 

#### Simplifying cost structure of chain [multiple(30,[[27]])] 

#### Computing cost of chain [multiple([28,29],[[multiple(31,[[27]])],[multiple(30,[[27]])],[27]])] with multiple recursion
 * Renamed intermediate variables: 
[ (eq(30,1),it(25))>>s(3), (eq(30,1),aux(3))>>s(4), (eq(30,1),it(24))>>s(5)]
 * Renamed intermediate variables: 
[ (eq(30,2),it(17))>>s(6)]

#### Simplifying cost structure of CE 30 
 * Renamed intermediate variables: 
[ (it(28),s(3))>>s(7), (it(28),s(6))>>s(8), (it(28),s(4))>>s(9), (it(28),s(5))>>s(10)]
 * Renamed intermediate variables: 
[ (eq(29,1),it(25))>>s(11), (eq(29,1),aux(3))>>s(12), (eq(29,1),it(24))>>s(13)]

#### Simplifying cost structure of CE 29 
 * Renamed intermediate variables: 
[ (it(29),s(11))>>s(14), (it(29),s(12))>>s(15), (it(29),s(13))>>s(16)]

#### Cost of loops [28,29] 

 * loop 28:quicksort(A,B,C,D) -> [quicksort(A',B',C',D'),quicksort(A'2,B'2,C'2,D'2)] 
15*s(7)+15*s(10)+5*s(8)+22
  Such that:s(7) =< B
s(8) =< A'
s(9) =< A'+A'2
s(7) =< B'+B'2
s(10) =< s(9)
s(7) =< s(9)

 * loop 29:quicksort(A,B,C,D) -> [quicksort(A',B',C',D'),quicksort(A'2,B'2,C'2,D'2)] 
15*s(14)+15*s(16)+22
  Such that:s(14) =< B
s(14) =< B'+B'2
s(15) =< A'2
s(16) =< s(15)
s(14) =< s(15)
 * The following chains are unfeasible as continuations of this chain: [[multiple(30,[[27]])]] 

##### Pending set quicksort(A,B,C,D)
* Psum in Loop 28: [it(28)=<1,s(17)=<B,s(19)=<A',s(20)=<A'+A'2,s(17)=<B'+B'2]
* Psum in Loop 29: [it(29)=<1,s(21)=<B,s(21)=<B'+B'2,s(23)=<A'2]
* Psum in Chain-Tail [27]: [it([27])=<1]
* Psum in Chain-Tail [multiple(31,[[27]])]: [it([multiple(31,[[27]])])=<1]

###### Computing sum for it(28)=<1  in Loop 28 
   - Applying inductive sum strategy 
     - head Candidate: 2/3*A-1 
       - Loop 29 is collaborative and bounds [it(29)] 
       - Chain-Tail [multiple(31,[[27]])] is collaborative
       - Chain [27] is ignored
     - tail Candidate: 2/3*A-1 
       - Loop 29 is collaborative and bounds [it(29)] 
       - Chain-Tail [multiple(31,[[27]])] is collaborative
       - Chain-Tail [27] adds a constant 1/3 
 * Adding constraints: [it(28)+it(29)=<it([27])* (1/3)+aux(4),it(28)+it(29)=<2/3*A-1,aux(4)=<2/3*A-1] 

##### Pending set A
* Psum in Loop 28: [s(17)=<B,s(19)=<A',s(20)=<A'+A'2,s(17)=<B'+B'2]
* Psum in Loop 29: [it(29)=<1,s(21)=<B,s(21)=<B'+B'2,s(23)=<A'2]
* Psum in Chain-Tail [27]: [it([27])=<1]
* Psum in Chain-Tail [multiple(31,[[27]])]: [it([multiple(31,[[27]])])=<1]

###### Computing sum for s(17)=<B  in Loop 28 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(5)=<B] 
 * Adding constraints: [s(17)=<it(28)*aux(5)] 

##### Pending set quicksort(A,B,C,D)
* Pmax/min: [aux(5)=<B]
* Psum in Loop 28: [s(19)=<A',s(20)=<A'+A'2,s(17)=<B'+B'2]
* Psum in Loop 29: [it(29)=<1,s(21)=<B,s(21)=<B'+B'2,s(23)=<A'2]
* Psum in Chain-Tail [27]: [it([27])=<1]
* Psum in Chain-Tail [multiple(31,[[27]])]: [it([multiple(31,[[27]])])=<1]

###### Computing max_min for aux(5)=<B  
   - Applying max/min strategy 
   - No strategy succeeded 
 * Adding constraints:[] 

##### Pending set quicksort(A,B,C,D)
* Psum in Loop 28: [s(19)=<A',s(20)=<A'+A'2,s(17)=<B'+B'2]
* Psum in Loop 29: [it(29)=<1,s(21)=<B,s(21)=<B'+B'2,s(23)=<A'2]
* Psum in Chain-Tail [27]: [it([27])=<1]
* Psum in Chain-Tail [multiple(31,[[27]])]: [it([multiple(31,[[27]])])=<1]

###### Computing sum for s(19)=<A'  in Loop 28 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(7)=<A-1] 
 * Adding constraints: [s(19)=<it(28)*aux(7)] 

##### Pending set quicksort(A,B,C,D)
* Pmax/min: [aux(7)=<A-1]
* Psum in Loop 28: [s(20)=<A'+A'2,s(17)=<B'+B'2]
* Psum in Loop 29: [it(29)=<1,s(21)=<B,s(21)=<B'+B'2,s(23)=<A'2]
* Psum in Chain-Tail [27]: [it([27])=<1]
* Psum in Chain-Tail [multiple(31,[[27]])]: [it([multiple(31,[[27]])])=<1]

###### Computing max_min for aux(7)=<A-1  
   - Found a solution using transitive invariants 
 * Adding constraints:[aux(7)=<A-1] 

##### Pending set quicksort(A,B,C,D)
* Psum in Loop 28: [s(20)=<A'+A'2,s(17)=<B'+B'2]
* Psum in Loop 29: [it(29)=<1,s(21)=<B,s(21)=<B'+B'2,s(23)=<A'2]
* Psum in Chain-Tail [27]: [it([27])=<1]
* Psum in Chain-Tail [multiple(31,[[27]])]: [it([multiple(31,[[27]])])=<1]

###### Computing sum for s(20)=<A'+A'2  in Loop 28 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(8)=<A] 
 * Adding constraints: [s(20)=<it(28)*aux(8)] 

##### Pending set quicksort(A,B,C,D)
* Pmax/min: [aux(8)=<A]
* Psum in Loop 28: [s(17)=<B'+B'2]
* Psum in Loop 29: [it(29)=<1,s(21)=<B,s(21)=<B'+B'2,s(23)=<A'2]
* Psum in Chain-Tail [27]: [it([27])=<1]
* Psum in Chain-Tail [multiple(31,[[27]])]: [it([multiple(31,[[27]])])=<1]

###### Computing max_min for aux(8)=<A  
   - Found a solution using cacheing 
 * Adding constraints:[aux(8)=<aux(7)+1] 

##### Pending set quicksort(A,B,C,D)
* Psum in Loop 28: [s(17)=<B'+B'2]
* Psum in Loop 29: [it(29)=<1,s(21)=<B,s(21)=<B'+B'2,s(23)=<A'2]
* Psum in Chain-Tail [27]: [it([27])=<1]
* Psum in Chain-Tail [multiple(31,[[27]])]: [it([multiple(31,[[27]])])=<1]

###### Computing sum for s(17)=<B'+B'2  in Loop 28 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [] 
 * Adding constraints: [s(17)=<it(28)*aux(9)] 

##### Pending set quicksort(A,B,C,D)
* Psum in Loop 29: [it(29)=<1,s(21)=<B,s(21)=<B'+B'2,s(23)=<A'2]
* Psum in Chain-Tail [27]: [it([27])=<1]
* Psum in Chain-Tail [multiple(31,[[27]])]: [it([multiple(31,[[27]])])=<1]

###### Computing sum for it(29)=<1  in Loop 29 
   - Applying inductive sum strategy 
     - head Candidate: 2/3*A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: 2/3*A-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(28)+it(29)=<it([27])* (1/3)+aux(10),it(28)+it(29)=<2/3*A-1,aux(10)=<2/3*A-1] 

##### Pending set quicksort(A,B,C,D)
* Psum in Loop 29: [s(21)=<B,s(21)=<B'+B'2,s(23)=<A'2]
* Psum in Chain-Tail [27]: [it([27])=<1]
* Psum in Chain-Tail [multiple(31,[[27]])]: [it([multiple(31,[[27]])])=<1]

###### Computing sum for s(21)=<B  in Loop 29 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(11)=<B] 
 * Adding constraints: [s(21)=<it(29)*aux(11)] 

##### Pending set quicksort(A,B,C,D)
* Pmax/min: [aux(11)=<B]
* Psum in Loop 29: [s(21)=<B'+B'2,s(23)=<A'2]
* Psum in Chain-Tail [27]: [it([27])=<1]
* Psum in Chain-Tail [multiple(31,[[27]])]: [it([multiple(31,[[27]])])=<1]

###### Computing max_min for aux(11)=<B  
   - Found a solution using cacheing 
 * Adding constraints:[aux(11)=<aux(5)] 

##### Pending set quicksort(A,B,C,D)
* Psum in Loop 29: [s(21)=<B'+B'2,s(23)=<A'2]
* Psum in Chain-Tail [27]: [it([27])=<1]
* Psum in Chain-Tail [multiple(31,[[27]])]: [it([multiple(31,[[27]])])=<1]

###### Computing sum for s(21)=<B'+B'2  in Loop 29 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [] 
 * Adding constraints: [s(21)=<it(29)*aux(12)] 

##### Pending set quicksort(A,B,C,D)
* Psum in Loop 29: [s(23)=<A'2]
* Psum in Chain-Tail [27]: [it([27])=<1]
* Psum in Chain-Tail [multiple(31,[[27]])]: [it([multiple(31,[[27]])])=<1]

###### Computing sum for s(23)=<A'2  in Loop 29 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(13)=<A-1] 
 * Adding constraints: [s(23)=<it(29)*aux(13)] 

##### Pending set quicksort(A,B,C,D)
* Pmax/min: [aux(13)=<A-1]
* Psum in Chain-Tail [27]: [it([27])=<1]
* Psum in Chain-Tail [multiple(31,[[27]])]: [it([multiple(31,[[27]])])=<1]

###### Computing max_min for aux(13)=<A-1  
   - Found a solution using cacheing 
 * Adding constraints:[aux(13)=<aux(7)] 

##### Pending set quicksort(A,B,C,D)
* Psum in Chain-Tail [27]: [it([27])=<1]
* Psum in Chain-Tail [multiple(31,[[27]])]: [it([multiple(31,[[27]])])=<1]

###### Computing sum for it([27])=<1  in Chain-Tail [27] 
   - Applying inductive sum strategy 
     - head Candidate: A 
       - Loop 28 is collaborative
       - Loop 29 is collaborative
       - Chain-Tail [multiple(31,[[27]])] is collaborative and bounds [it([multiple(31,[[27]])])] 
     - tail Candidate: A 
       - Loop 28 is collaborative
       - Loop 29 is collaborative
       - Chain-Tail [multiple(31,[[27]])] is collaborative and bounds [it([multiple(31,[[27]])])] 
 * Adding constraints: [it([27])+it([multiple(31,[[27]])])=<A,it([27])+it([multiple(31,[[27]])])=<A] 

##### Pending set quicksort(A,B,C,D)
* Psum in Chain-Tail [multiple(31,[[27]])]: [it([multiple(31,[[27]])])=<1]

###### Computing sum for it([multiple(31,[[27]])])=<1  in Chain-Tail [multiple(31,[[27]])] 
   - Applying inductive sum strategy 
     - head Candidate: A/2 
       - Loop 28 is collaborative
       - Loop 29 is collaborative
       - Chain-Tail [27] is collaborative
     - tail Candidate: A/2 
       - Loop 28 is collaborative
       - Loop 29 is collaborative
       - Chain-Tail [27] is collaborative
 * Adding constraints: [it([multiple(31,[[27]])])=<A/2,it([multiple(31,[[27]])])=<A/2] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [28,29,[multiple(31,[[27]])],[27]] 

#### Simplifying cost structure of phase [28,29,[multiple(31,[[27]])],[27]] 
 * Joined equivalent variables [aux(14),aux(7)] into aux(14)
 * Joined equivalent variables [aux(15),aux(4),aux(10)] into aux(15)
 * Joined equivalent variables [it(28),it(29)] into it(28)

#### Cost of phase [28,29]:quicksort(A,B,C,D) -> [] 
44*it(28)+3*it([27])+28*it([multiple(31,[[27]])])+15*s(17)+15*s(18)+5*s(19)+15*s(21)+15*s(22)+0
  Such that:it([multiple(31,[[27]])]) =< A/2
aux(14) =< A
aux(15) =< 2/3*A
it([27]) =< aux(14)
it([multiple(31,[[27]])]) =< aux(14)
it(28) =< aux(15)
aux(13) =< aux(14)
aux(8) =< aux(14)+1
it(28) =< it([27])* (1/3)+aux(15)
s(23) =< it(28)*aux(13)
s(20) =< it(28)*aux(8)
s(19) =< it(28)*aux(14)
s(22) =< s(23)
s(21) =< s(23)
s(18) =< s(20)
s(17) =< s(20)

#### Cost of chains of quicksort(A,B,C,D):
* Chain [multiple(31,[[27]])]: 28
  with precondition: [A=2,C=2,B>=0,D>=0] 

* Chain [27]: 3
  with precondition: [A=1,C=1,B>=0,D>=0] 

* Chain [multiple([28,29],[[multiple(31,[[27]])],[multiple(30,[[27]])],[27]])]: 44*it(28)+3*it([27])+28*it([multiple(31,[[27]])])+15*s(17)+15*s(18)+5*s(19)+15*s(21)+15*s(22)+0
  Such that:it([multiple(31,[[27]])]) =< A/2
aux(14) =< A
aux(15) =< 2/3*A
it([27]) =< aux(14)
it([multiple(31,[[27]])]) =< aux(14)
it(28) =< aux(15)
aux(13) =< aux(14)
aux(8) =< aux(14)+1
it(28) =< it([27])* (1/3)+aux(15)
s(23) =< it(28)*aux(13)
s(20) =< it(28)*aux(8)
s(19) =< it(28)*aux(14)
s(22) =< s(23)
s(21) =< s(23)
s(18) =< s(20)
s(17) =< s(20)

  with precondition: [A=C,A>=3,B>=0,D>=0] 


#### Simplifying cost structure of CE 32 

#### Computing cost of phase [32,33,34] 
 * Renamed intermediate variables: 
[ (eq(35,1),it([multiple(31,[[27]])]))>>s(24), (eq(35,1),aux(14))>>s(25), (eq(35,1),aux(15))>>s(26), (eq(35,1),it([27]))>>s(27), (eq(35,1),it(28))>>s(28), (eq(35,1),aux(13))>>s(29), (eq(35,1),aux(8))>>s(30), (eq(35,1),s(23))>>s(31), (eq(35,1),s(20))>>s(32), (eq(35,1),s(19))>>s(33), (eq(35,1),s(22))>>s(34), (eq(35,1),s(21))>>s(35), (eq(35,1),s(18))>>s(36), (eq(35,1),s(17))>>s(37)]

#### Simplifying cost structure of CE 35 
 * Joined equivalent variables [s(34),s(35)] into s(34)
 * Joined equivalent variables [s(36),s(37)] into s(36)
 * Renamed intermediate variables: 
[ (it(32),s(25))>>s(38), (it(32),s(24))>>s(39), (it(32),s(26))>>s(40), (it(32),s(27))>>s(41), (it(32),s(28))>>s(42), (it(32),s(29))>>s(43), (it(32),s(30))>>s(44), (it(32),s(31))>>s(45), (it(32),s(32))>>s(46), (it(32),s(33))>>s(47), (it(32),s(34))>>s(48), (it(32),s(36))>>s(49)]

#### Simplifying cost structure of CE 33 

#### Simplifying cost structure of CE 34 

#### Cost of loops [32,33,34] 

 * loop 32:sortAll(A,B,C,D,E,F,G,H) -> [sortAll(A',B',C',D',E',F',G',H')] 
28*s(39)+3*s(41)+44*s(42)+5*s(47)+30*s(48)+30*s(49)+7
  Such that:s(38) =< C-C'
s(39) =< C/2-C'/2
s(40) =< 2/3*C-2/3*C'
s(41) =< s(38)
s(39) =< s(38)
s(42) =< s(40)
s(43) =< s(38)
s(44) =< s(38)+1
s(42) =< s(41)* (1/3)+s(40)
s(45) =< s(42)*s(43)
s(46) =< s(42)*s(44)
s(47) =< s(42)*s(38)
s(48) =< s(45)
s(49) =< s(46)

 * loop 33:sortAll(A,B,C,D,E,F,G,H) -> [sortAll(A',B',C',D',E',F',G',H')] 
10
 * loop 34:sortAll(A,B,C,D,E,F,G,H) -> [sortAll(A',B',C',D',E',F',G',H')] 
35
##### Pending set sortAll(A,B,C,D,E,F,G,H)
* Pmax/min: [s(38)=< -A+C+1]
* Psum in Loop 32: [it(32)=<1,s(59)=<C-C',s(50)=<C/2-C'/2,s(58)=<2/3*C-2/3*C']
* Psum in Loop 33: [it(33)=<1]
* Psum in Loop 34: [it(34)=<1]

###### Computing max_min for s(38)=< -A+C+1  
   - Found a solution using transitive invariants 
 * Adding constraints:[s(38)=<C+1,s(38)=< -A+C+1] 

##### Pending set sortAll(A,B,C,D,E,F,G,H)
* Psum in Loop 32: [it(32)=<1,s(59)=<C-C',s(50)=<C/2-C'/2,s(58)=<2/3*C-2/3*C']
* Psum in Loop 33: [it(33)=<1]
* Psum in Loop 34: [it(34)=<1]

###### Computing sum for it(32)=<1  in Loop 32 
   - Applying inductive sum strategy 
     - head Candidate: B-1 
       - Loop 33 is collaborative and bounds [it(33)] 
       - Loop 34 is collaborative and bounds [it(34)] 
     - head Candidate: A+1 
       - Loop 33 is collaborative and bounds [it(33)] 
       - Loop 34 is collaborative and bounds [it(34)] 
     - head Candidate: C+1 
       - Loop 33 is collaborative and bounds [it(33)] 
       - Loop 34 is collaborative and bounds [it(34)] 
     - head Candidate: A+1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: C/3+1/3 
       - Loop 33 is collaborative
       - Loop 34 is collaborative
     - tail Candidate: B-1 
       - Loop 33 is collaborative and bounds [it(33)] 
       - Loop 34 is collaborative and bounds [it(34)] 
     - tail Candidate: A+1 
       - Loop 33 is collaborative and bounds [it(33)] 
       - Loop 34 is collaborative and bounds [it(34)] 
     - tail Candidate: C+1 
       - Loop 33 is collaborative and bounds [it(33)] 
       - Loop 34 is collaborative and bounds [it(34)] 
     - tail Candidate: A+1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C/3+1/3 
       - Loop 33 is collaborative
       - Loop 34 is collaborative
 * Adding constraints: [it(32)+it(33)+it(34)=<B-1,it(32)+it(33)+it(34)=<A+1,it(32)+it(33)+it(34)=<C+1,it(32)+it(33)+it(34)=<A+1,it(32)+it(33)+it(34)=<B-1,it(32)=<C/3+1/3,it(32)+it(33)+it(34)=<B-B',it(32)+it(33)+it(34)=<A-A',it(32)+it(33)+it(34)=<C-C',it(32)+it(33)+it(34)=<A-A',it(32)+it(33)+it(34)=<B-B',it(32)=<C/3-C'/3] 

##### Pending set sortAll(A,B,C,D,E,F,G,H)
* Psum in Loop 32: [s(59)=<C-C',s(50)=<C/2-C'/2,s(58)=<2/3*C-2/3*C']
* Psum in Loop 33: [it(33)=<1]
* Psum in Loop 34: [it(34)=<1]

###### Computing sum for s(59)=<C-C'  in Loop 32 
   - Applying inductive sum strategy 
     - head Candidate: -3/2*A+3/2*C 
       - Loop 33 is collaborative
       - Loop 34 is collaborative and bounds [it(34)] 
     - head Candidate: -3/2*B+3/2*C+3/2 
       - Loop 33 is collaborative
       - Loop 34 is collaborative and bounds [it(34)] 
     - tail Candidate: -3/2*A+3/2*C 
       - Loop 33 is collaborative
       - Loop 34 is collaborative and bounds [it(34)] 
     - tail Candidate: -3/2*B+3/2*C+3/2 
       - Loop 33 is collaborative
       - Loop 34 is collaborative and bounds [it(34)] 
 * Adding constraints: [it(34)+s(59)=< -3/2*A+3/2*C,it(34)+s(59)=< -3/2*B+3/2*C+3/2,it(34)+s(59)=< -3/2*A+3/2*C+3/2*A'-3/2*C',it(34)+s(59)=< -3/2*B+3/2*C+3/2*B'-3/2*C'] 

##### Pending set sortAll(A,B,C,D,E,F,G,H)
* Psum in Loop 32: [s(50)=<C/2-C'/2,s(58)=<2/3*C-2/3*C']
* Psum in Loop 33: [it(33)=<1]
* Psum in Loop 34: [it(34)=<1]

###### Computing sum for s(50)=<C/2-C'/2  in Loop 32 
   - Found a solution using cacheing 
 * Adding constraints: [s(50)=<aux(16)* (1/2),aux(16)+it(34)=< -3/2*A+3/2*C,aux(16)+it(34)=< -3/2*B+3/2*C+3/2,aux(16)+it(34)=< -3/2*A+3/2*C+3/2*A'-3/2*C',aux(16)+it(34)=< -3/2*B+3/2*C+3/2*B'-3/2*C'] 

##### Pending set sortAll(A,B,C,D,E,F,G,H)
* Psum in Loop 32: [s(58)=<2/3*C-2/3*C']
* Psum in Loop 33: [it(33)=<1]
* Psum in Loop 34: [it(34)=<1]

###### Computing sum for s(58)=<2/3*C-2/3*C'  in Loop 32 
   - Found a solution using cacheing 
 * Adding constraints: [s(58)=<aux(17)* (2/3),aux(17)+it(34)=< -3/2*A+3/2*C,aux(17)+it(34)=< -3/2*B+3/2*C+3/2,aux(17)+it(34)=< -3/2*A+3/2*C+3/2*A'-3/2*C',aux(17)+it(34)=< -3/2*B+3/2*C+3/2*B'-3/2*C'] 

##### Pending set sortAll(A,B,C,D,E,F,G,H)
* Psum in Loop 33: [it(33)=<1]
* Psum in Loop 34: [it(34)=<1]

###### Computing sum for it(33)=<1  in Loop 33 
   - Applying inductive sum strategy 
     - head Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A+1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: C+1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A+1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: C+1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A+1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C+1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A+1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C+1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(32)+it(33)+it(34)=<B-1,it(32)+it(33)+it(34)=<A+1,it(32)+it(33)+it(34)=<C+1,it(32)+it(33)+it(34)=<A+1,it(32)+it(33)+it(34)=<B-1,it(32)+it(33)+it(34)=<C+1,it(32)+it(33)+it(34)=<B-B',it(32)+it(33)+it(34)=<A-A',it(32)+it(33)+it(34)=<C-C',it(32)+it(33)+it(34)=<A-A',it(32)+it(33)+it(34)=<B-B',it(32)+it(33)+it(34)=<C-C'] 

##### Pending set sortAll(A,B,C,D,E,F,G,H)
* Psum in Loop 34: [it(34)=<1]

###### Computing sum for it(34)=<1  in Loop 34 
   - Applying inductive sum strategy 
     - head Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A+1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: C+1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A+1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: C/2+1/2 
       - Loop 32 is collaborative
       - Loop 33 is collaborative
     - tail Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A+1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C+1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A+1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C/2+1/2 
       - Loop 32 is collaborative
       - Loop 33 is collaborative
 * Adding constraints: [it(32)+it(33)+it(34)=<B-1,it(32)+it(33)+it(34)=<A+1,it(32)+it(33)+it(34)=<C+1,it(32)+it(33)+it(34)=<A+1,it(32)+it(33)+it(34)=<B-1,it(34)=<C/2+1/2,it(32)+it(33)+it(34)=<B-B',it(32)+it(33)+it(34)=<A-A',it(32)+it(33)+it(34)=<C-C',it(32)+it(33)+it(34)=<A-A',it(32)+it(33)+it(34)=<B-B',it(34)=<C/2-C'/2] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [32,33,34] 

#### Simplifying cost structure of phase [32,33,34] 
 * Joined equivalent variables [aux(16),aux(17),s(59)] into aux(16)

#### Cost of phase [32,33,34]:sortAll(A,B,C,D,E,F,G,H) -> [sortAll(A',B',C',D',E',F',G',H')] 
7*it(32)+10*it(33)+35*it(34)+28*s(50)+3*s(51)+44*s(52)+5*s(53)+30*s(54)+30*s(55)+0
  Such that:s(38) =< -A+C+1
it(34) =< C/2+1/2
it(34) =< C/2-C'/2
it(32) =< C/3+1/3
it(32) =< C/3-C'/3
aux(18) =< A+1
aux(19) =< A-A'
aux(20) =< -3/2*A+3/2*C
aux(21) =< -3/2*A+3/2*C+3/2*A'-3/2*C'
aux(22) =< B
aux(23) =< B-B'
aux(24) =< -3/2*B+3/2*C+3/2
aux(25) =< -3/2*B+3/2*C+3/2*B'-3/2*C'
aux(26) =< C+1
aux(27) =< C-C'
it(32) =< aux(18)
it(33) =< aux(18)
it(34) =< aux(18)
it(32) =< aux(19)
it(33) =< aux(19)
it(34) =< aux(19)
aux(16) =< aux(20)
it(34) =< aux(20)
aux(16) =< aux(21)
it(34) =< aux(21)
it(32) =< aux(22)
it(33) =< aux(22)
it(34) =< aux(22)
it(32) =< aux(23)
it(33) =< aux(23)
it(34) =< aux(23)
aux(16) =< aux(24)
it(34) =< aux(24)
aux(16) =< aux(25)
it(34) =< aux(25)
it(32) =< aux(26)
it(33) =< aux(26)
it(34) =< aux(26)
s(38) =< aux(26)
it(32) =< aux(27)
it(33) =< aux(27)
it(34) =< aux(27)
s(58) =< aux(16)* (2/3)
s(50) =< aux(16)* (1/2)
s(51) =< aux(16)
s(50) =< aux(16)
s(52) =< s(58)
s(43) =< s(38)
s(44) =< s(38)+1
s(52) =< s(51)* (1/3)+s(58)
s(57) =< s(52)*s(43)
s(56) =< s(52)*s(44)
s(53) =< s(52)*s(38)
s(54) =< s(57)
s(55) =< s(56)

#### Simplifying cost structure of chain [[32,33,34],35] 
 * Joined equivalent variables [aux(28),aux(19),aux(23)] into aux(28)
 * Joined equivalent variables [aux(29),aux(18),aux(22)] into aux(29)
 * Joined equivalent variables [aux(30),aux(20),aux(21),aux(24),aux(25)] into aux(30)
 * Joined equivalent variables [aux(30),aux(16)] into aux(30)

#### Cost of chains of sortAll(A,B,C,D,E,F,G,H):
* Chain [[32,33,34],35]: 7*it(32)+10*it(33)+35*it(34)+28*s(50)+3*s(51)+44*s(52)+5*s(53)+30*s(54)+30*s(55)+3
  Such that:s(38) =< -A+G+1
aux(27) =< G
aux(26) =< G+1
it(34) =< G/2
it(32) =< G/3
aux(28) =< A
aux(29) =< A+1
aux(30) =< -3/2*A+3/2*G
it(32) =< aux(29)
it(33) =< aux(29)
it(34) =< aux(29)
it(32) =< aux(28)
it(33) =< aux(28)
it(34) =< aux(28)
it(34) =< aux(30)
it(32) =< aux(26)
it(33) =< aux(26)
it(34) =< aux(26)
s(38) =< aux(26)
it(32) =< aux(27)
it(33) =< aux(27)
it(34) =< aux(27)
s(58) =< aux(30)* (2/3)
s(50) =< aux(30)* (1/2)
s(51) =< aux(30)
s(50) =< aux(30)
s(52) =< s(58)
s(43) =< s(38)
s(44) =< s(38)+1
s(52) =< s(51)* (1/3)+s(58)
s(57) =< s(52)*s(43)
s(56) =< s(52)*s(44)
s(53) =< s(52)*s(38)
s(54) =< s(57)
s(55) =< s(56)

  with precondition: [A+1=B,G=C,A=E,A+1=F,A>=1,D>=0,H>=0,G>=A] 

* Chain [35]: 3
  with precondition: [A=0,B=1,C=0,E=0,F=1,G=0,D>=0,H>=0] 


#### Simplifying cost structure of CE 36 

#### Simplifying cost structure of CE 37 

#### Simplifying cost structure of chain [38,39] 

#### Computing cost of phase [36,37] 
 * Renamed intermediate variables: 
[ (eq(39,1),s(1))>>s(60)]

#### Simplifying cost structure of CE 39 
 * Renamed intermediate variables: 
[ (it(36),s(60))>>s(61)]
 * Renamed intermediate variables: 
[ (eq(38,1),it(21))>>s(62)]

#### Simplifying cost structure of CE 38 
 * Renamed intermediate variables: 
[ (it(37),s(62))>>s(63)]

#### Cost of loops [36,37] 

 * loop 36:split(A,B,C,D,E,F,G) -> [split(A',B',C',D',E',F',G')] 
10*s(61)+15
  Such that:s(61) =< A'

 * loop 37:split(A,B,C,D,E,F,G) -> [split(A',B',C',D',E',F',G')] 
10*s(63)+14
  Such that:s(63) =< A'+1

##### Pending set split(A,B,C,D,E,F,G)
* Psum in Loop 36: [it(36)=<1,s(64)=<A']
* Psum in Loop 37: [it(37)=<1,s(65)=<A'+1]

###### Computing sum for it(36)=<1  in Loop 36 
   - Applying inductive sum strategy 
     - head Candidate: B-1 
       - Loop 37 is collaborative and bounds [it(37)] 
     - head Candidate: A+1 
       - Loop 37 is collaborative and bounds [it(37)] 
     - head Candidate: A+1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B-1 
       - Loop 37 is collaborative and bounds [it(37)] 
     - tail Candidate: A+1 
       - Loop 37 is collaborative and bounds [it(37)] 
     - tail Candidate: A+1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(36)+it(37)=<B-1,it(36)+it(37)=<A+1,it(36)+it(37)=<A+1,it(36)+it(37)=<B-1,it(36)+it(37)=<B-B',it(36)+it(37)=<A-A',it(36)+it(37)=<A-A',it(36)+it(37)=<B-B'] 

##### Pending set A
* Psum in Loop 36: [s(64)=<A']
* Psum in Loop 37: [it(37)=<1,s(65)=<A'+1]

###### Computing sum for s(64)=<A'  in Loop 36 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(31)=<A-1,aux(31)=<B-2] 
 * Adding constraints: [s(64)=<it(36)*aux(31)] 

##### Pending set split(A,B,C,D,E,F,G)
* Pmax/min: [aux(31)=<A-1,aux(31)=<B-2]
* Psum in Loop 37: [it(37)=<1,s(65)=<A'+1]

###### Computing max_min for aux(31)=<A-1  
   - Found a solution using transitive invariants 
 * Adding constraints:[aux(31)=<A-1] 

##### Pending set split(A,B,C,D,E,F,G)
* Pmax/min: [aux(31)=<B-2]
* Psum in Loop 37: [it(37)=<1,s(65)=<A'+1]

###### Computing max_min for aux(31)=<B-2  
   - Found a solution using transitive invariants 
 * Adding constraints:[aux(31)=<B-2] 

##### Pending set split(A,B,C,D,E,F,G)
* Psum in Loop 37: [it(37)=<1,s(65)=<A'+1]

###### Computing sum for it(37)=<1  in Loop 37 
   - Applying inductive sum strategy 
     - head Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A+1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A+1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A+1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A+1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(36)+it(37)=<B-1,it(36)+it(37)=<A+1,it(36)+it(37)=<A+1,it(36)+it(37)=<B-1,it(36)+it(37)=<B-B',it(36)+it(37)=<A-A',it(36)+it(37)=<A-A',it(36)+it(37)=<B-B'] 

##### Pending set split(A,B,C,D,E,F,G)
* Psum in Loop 37: [s(65)=<A'+1]

###### Computing sum for s(65)=<A'+1  in Loop 37 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(32)=<A,aux(32)=<B-1] 
 * Adding constraints: [s(65)=<it(37)*aux(32)] 

##### Pending set split(A,B,C,D,E,F,G)
* Pmax/min: [aux(32)=<A,aux(32)=<B-1]

###### Computing max_min for aux(32)=<A  
   - Found a solution using cacheing 
 * Adding constraints:[aux(32)=<aux(31)+1] 

##### Pending set split(A,B,C,D,E,F,G)
* Pmax/min: [aux(32)=<B-1]

###### Computing max_min for aux(32)=<B-1  
   - Found a solution using cacheing 
 * Adding constraints:[aux(32)=<aux(31)+1] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [36,37] 

#### Simplifying cost structure of phase [36,37] 
 * Joined equivalent variables [it(36),it(37)] into it(36)

#### Cost of phase [36,37]:split(A,B,C,D,E,F,G) -> [split(A',B',C',D',E',F',G')] 
29*it(36)+10*s(64)+10*s(65)+0
  Such that:aux(31) =< A
aux(33) =< A+1
aux(34) =< A-A'
aux(35) =< B
aux(36) =< B-B'
it(36) =< aux(33)
it(36) =< aux(34)
aux(31) =< aux(35)
it(36) =< aux(35)
it(36) =< aux(36)
aux(32) =< aux(31)+1
s(64) =< it(36)*aux(31)
s(65) =< it(36)*aux(32)

#### Simplifying cost structure of chain [[36,37],38,39] 
 * Joined equivalent variables [aux(37),aux(33),aux(34),aux(35),aux(36)] into aux(37)
 * Joined equivalent variables [aux(37),aux(31)] into aux(37)

#### Cost of chains of split(A,B,C,D,E,F,G):
* Chain [[36,37],38,39]: 29*it(36)+10*s(64)+10*s(65)+17
  Such that:aux(37) =< B
it(36) =< aux(37)
aux(32) =< aux(37)+1
s(64) =< it(36)*aux(37)
s(65) =< it(36)*aux(32)

  with precondition: [A+1=B,A+D=F,A+E=F+1,A>=2,C>=0,F>=A+1,2*A>=F,A+G+1>=F] 

* Chain [39]: 3
  with precondition: [A=0,B=1,D=0,E=1,F=0,C>=0,G>=0] 

* Chain [38,39]: 17
  with precondition: [A=1,B=2,D=1,E=2,F=2,C>=0,G>=0] 


#### Simplifying cost structure of CE 40 
 * Renamed intermediate variables: 
[ (eq(41,2),s(38))>>s(66), (eq(41,2),aux(27))>>s(67), (eq(41,2),aux(26))>>s(68), (eq(41,2),it(34))>>s(69), (eq(41,2),it(32))>>s(70), (eq(41,2),aux(28))>>s(71), (eq(41,2),aux(29))>>s(72), (eq(41,2),aux(30))>>s(73), (eq(41,2),it(33))>>s(74), (eq(41,2),s(58))>>s(75), (eq(41,2),s(50))>>s(76), (eq(41,2),s(51))>>s(77), (eq(41,2),s(52))>>s(78), (eq(41,2),s(43))>>s(79), (eq(41,2),s(44))>>s(80), (eq(41,2),s(57))>>s(81), (eq(41,2),s(56))>>s(82), (eq(41,2),s(53))>>s(83), (eq(41,2),s(54))>>s(84), (eq(41,2),s(55))>>s(85)]

#### Simplifying cost structure of CE 41 
 * Joined equivalent variables [aux(38),s(71)] into aux(38)
 * Joined equivalent variables [aux(39),s(67),s(72)] into aux(39)
 * Renamed intermediate variables: 
[ (eq(42,1),aux(37))>>s(86), (eq(42,1),it(36))>>s(87), (eq(42,1),aux(32))>>s(88), (eq(42,1),s(64))>>s(89), (eq(42,1),s(65))>>s(90)]
 * Renamed intermediate variables: 
[ (eq(42,2),s(38))>>s(91), (eq(42,2),aux(27))>>s(92), (eq(42,2),aux(26))>>s(93), (eq(42,2),it(34))>>s(94), (eq(42,2),it(32))>>s(95), (eq(42,2),aux(28))>>s(96), (eq(42,2),aux(29))>>s(97), (eq(42,2),aux(30))>>s(98), (eq(42,2),it(33))>>s(99), (eq(42,2),s(58))>>s(100), (eq(42,2),s(50))>>s(101), (eq(42,2),s(51))>>s(102), (eq(42,2),s(52))>>s(103), (eq(42,2),s(43))>>s(104), (eq(42,2),s(44))>>s(105), (eq(42,2),s(57))>>s(106), (eq(42,2),s(56))>>s(107), (eq(42,2),s(53))>>s(108), (eq(42,2),s(54))>>s(109), (eq(42,2),s(55))>>s(110)]

#### Simplifying cost structure of CE 42 
 * Joined equivalent variables [aux(40),s(96)] into aux(40)
 * Joined equivalent variables [aux(41),s(86),s(97)] into aux(41)

#### Cost of chains of splitAndSort(A,B,C,D,E,F,G):
* Chain [42]: 8
  with precondition: [A=0,B=1,D=0,E=1,F=0,C>=0,G>=0] 

* Chain [41]: 35*s(69)+7*s(70)+10*s(74)+28*s(76)+3*s(77)+44*s(78)+5*s(83)+30*s(84)+30*s(85)+22
  Such that:s(68) =< 3
s(70) =< 2/3
s(73) =< 3/2
aux(38) =< 1
aux(39) =< 2
s(69) =< aux(38)
s(66) =< aux(39)
s(70) =< aux(39)
s(74) =< aux(39)
s(69) =< aux(39)
s(70) =< aux(38)
s(74) =< aux(38)
s(69) =< s(73)
s(70) =< s(68)
s(74) =< s(68)
s(69) =< s(68)
s(66) =< s(68)
s(75) =< s(73)* (2/3)
s(76) =< s(73)* (1/2)
s(77) =< s(73)
s(76) =< s(73)
s(78) =< s(75)
s(79) =< s(66)
s(80) =< s(66)+1
s(78) =< s(77)* (1/3)+s(75)
s(81) =< s(78)*s(79)
s(82) =< s(78)*s(80)
s(83) =< s(78)*s(66)
s(84) =< s(81)
s(85) =< s(82)

  with precondition: [A=1,B=2,D=1,E=2,F=2,C>=0,G>=0] 

* Chain [40]: 29*s(87)+10*s(89)+10*s(90)+35*s(94)+7*s(95)+10*s(99)+28*s(101)+3*s(102)+44*s(103)+5*s(108)+30*s(109)+30*s(110)+22
  Such that:s(92) =< 2*A
s(93) =< 2*A+1
s(95) =< 2/3*A
s(98) =< 3/2*A
aux(40) =< A
aux(41) =< A+1
s(94) =< aux(40)
s(91) =< aux(41)
s(95) =< aux(41)
s(99) =< aux(41)
s(94) =< aux(41)
s(95) =< aux(40)
s(99) =< aux(40)
s(94) =< s(98)
s(95) =< s(93)
s(99) =< s(93)
s(94) =< s(93)
s(91) =< s(93)
s(95) =< s(92)
s(99) =< s(92)
s(94) =< s(92)
s(100) =< s(98)* (2/3)
s(101) =< s(98)* (1/2)
s(102) =< s(98)
s(101) =< s(98)
s(103) =< s(100)
s(104) =< s(91)
s(105) =< s(91)+1
s(103) =< s(102)* (1/3)+s(100)
s(106) =< s(103)*s(104)
s(107) =< s(103)*s(105)
s(108) =< s(103)*s(91)
s(109) =< s(106)
s(110) =< s(107)
s(87) =< aux(41)
s(88) =< aux(41)+1
s(89) =< s(87)*aux(41)
s(90) =< s(87)*s(88)

  with precondition: [A+1=B,D+1=E,A+D=F,A>=2,C>=0,D>=1,G>=0,A>=D] 


Closed-form bounds of insertL(A,B,C,D,E,F,G,H,I,J): 
-------------------------------------
* Chain [[21],20] with precondition: [A=1,C+1=D,I=E+2,C+1=G,C+2=H,B>=0,C>=1,F>=C,I>=C+2,J>=C] 
    - Upper bound: 10*D+9 
    - Complexity: n 
* Chain [[21],19] with precondition: [A=1,I=E+1,C=G,D=H,C>=2,D>=3,I>=3,J>=B+1,J>=F,B+F>=J] 
    - Upper bound: 10*C+10 
    - Complexity: n 
* Chain [20] with precondition: [A=1,C=0,D=1,E=0,G=1,H=2,I=2,B>=0,F>=0,J>=0] 
    - Upper bound: 9 
    - Complexity: constant 
* Chain [19] with precondition: [A=1,C=G,D=H,E+1=I,C>=1,D>=2,E>=1,J>=B,J>=F,B+F>=J] 
    - Upper bound: 10 
    - Complexity: constant 

### Maximum cost of insertL(A,B,C,D,E,F,G,H,I,J): max([10*C+1,10*D])+9 
Asymptotic class: n 

Closed-form bounds of split(A,B,C,D,E,F,G): 
-------------------------------------
* Chain [[36,37],38,39] with precondition: [A+1=B,A+D=F,A+E=F+1,A>=2,C>=0,F>=A+1,2*A>=F,A+G+1>=F] 
    - Upper bound: 39*B+17+20*B*B 
    - Complexity: n^2 
* Chain [39] with precondition: [A=0,B=1,D=0,E=1,F=0,C>=0,G>=0] 
    - Upper bound: 3 
    - Complexity: constant 
* Chain [38,39] with precondition: [A=1,B=2,D=1,E=2,F=2,C>=0,G>=0] 
    - Upper bound: 17 
    - Complexity: constant 

### Maximum cost of split(A,B,C,D,E,F,G): max([14,39*B+14+20*B*B])+3 
Asymptotic class: n^2 

Closed-form bounds of splitqs(A,B,C,D,E,F): 
-------------------------------------
* Chain [[24,25],26] with precondition: [A=1,D=1,B+1=E,B>=2,C>=0,F>=0] 
    - Upper bound: 15*B+15*C+7 
    - Complexity: n 
* Chain [26] with precondition: [A=1,B=1,D=1,E=2,C>=0,F>=0] 
    - Upper bound: 7 
    - Complexity: constant 

### Maximum cost of splitqs(A,B,C,D,E,F): 15*B+15*C+7 
Asymptotic class: n 

Closed-form bounds of append(A,B,C,D,E,F,G,H,I,J,K,L): 
-------------------------------------
* Chain [[17],18] with precondition: [A=C,L=D+H,A+E=I+1,A+G=K+1,A>=2,B>=0,E>=1,F>=0,G>=1,J>=0,D+1>=A,L>=D,B+F>=J] 
    - Upper bound: 5*A+2 
    - Complexity: n 
* Chain [18] with precondition: [A=1,C=1,D=0,E=I,F=J,G=K,H=L,B>=0,E>=0,F>=0,G>=0,H>=0] 
    - Upper bound: 2 
    - Complexity: constant 

### Maximum cost of append(A,B,C,D,E,F,G,H,I,J,K,L): 5*A+2 
Asymptotic class: n 
 * Joined equivalent variables [s(17),s(18)] into s(17)
 * Joined equivalent variables [s(21),s(22)] into s(21)

Closed-form bounds of quicksort(A,B,C,D): 
-------------------------------------
* Chain [multiple(31,[[27]])] with precondition: [A=2,C=2,B>=0,D>=0] 
    - Upper bound: 28 
    - Complexity: constant 
* Chain [27] with precondition: [A=1,C=1,B>=0,D>=0] 
    - Upper bound: 3 
    - Complexity: constant 
* Chain [multiple([28,29],[[multiple(31,[[27]])],[multiple(30,[[27]])],[27]])] with precondition: [A=C,A>=3,B>=0,D>=0] 
    - Upper bound: 2/3*A* (65*A)+3*A+148/3*A+14*A 
    - Complexity: n^2 

### Maximum cost of quicksort(A,B,C,D): max([28,2/3*A* (65*A)+3*A+148/3*A+14*A]) 
Asymptotic class: n^2 

Closed-form bounds of sortAll(A,B,C,D,E,F,G,H): 
-------------------------------------
* Chain [[32,33,34],35] with precondition: [A+1=B,G=C,A=E,A+1=F,A>=1,D>=0,H>=0,G>=A] 
    - Upper bound: -179/2*A+199/2*C+13+ (-130/3*A+130/3*C+130/3)* (-3/2*A+3/2*C)+35/2*C+7/3*C 
    - Complexity: n^2 
* Chain [35] with precondition: [A=0,B=1,C=0,E=0,F=1,G=0,D>=0,H>=0] 
    - Upper bound: 3 
    - Complexity: constant 

### Maximum cost of sortAll(A,B,C,D,E,F,G,H): -179/2*A+199/2*C+10+ (-130/3*A+130/3*C+130/3)* (-3/2*A+3/2*C)+35/2*C+7/3*C+3 
Asymptotic class: n^2 

Closed-form bounds of splitAndSort(A,B,C,D,E,F,G): 
-------------------------------------
* Chain [42] with precondition: [A=0,B=1,D=0,E=1,F=0,C>=0,G>=0] 
    - Upper bound: 8 
    - Complexity: constant 
* Chain [41] with precondition: [A=1,B=2,D=1,E=2,F=2,C>=0,G>=0] 
    - Upper bound: 1867/6 
    - Complexity: constant 
* Chain [40] with precondition: [A+1=B,D+1=E,A+D=F,A>=2,C>=0,D>=1,G>=0,A>=D] 
    - Upper bound: 835/6*A+22+ (A+1)* (5*A)+ (49*A+49)+ (40*A+40)* (3/2*A)+ (20*A+20)* (A+1) 
    - Complexity: n^2 

### Maximum cost of splitAndSort(A,B,C,D,E,F,G): max([1819/6,835/6*A+14+ (A+1)* (5*A)+ (49*A+49)+ (40*A+40)* (3/2*A)+ (20*A+20)* (A+1)])+8 
Asymptotic class: n^2 
* Total analysis performed in 4721 ms.


Cost relation system solved by CoFloCo in 4729 ms.

Method insertL terminates?: YES

 - x_1: size of x wrt. Pair<Rat, Rat>
 - x_2: size of x wrt. Rat
 - l_1: size of l wrt. Pair<List<Rat>, Rat>
 - l_2: size of l wrt. List<Pair<List<Rat>, Rat>>
 - l_3: size of l wrt. List<Rat>
 - l_4: size of l wrt. Rat
UB for insertL(x_1,x_2,l_1,l_2,l_3,l_4) = max([10*l_1+1,10*l_2])+9

Method split terminates?: YES

 - l_1: size of l wrt. Pair<Rat, Rat>
 - l_2: size of l wrt. List<Pair<Rat, Rat>>
 - l_3: size of l wrt. Rat
UB for split(l_1,l_2,l_3) = max([14,39*l_2+14+20*l_2*l_2])+3

Method splitqs terminates?: YES

 - q_1: size of q wrt. Pair<Rat, List<Rat>>
 - q_2: size of q wrt. List<Rat>
 - q_3: size of q wrt. Rat
UB for splitqs(q_1,q_2,q_3) = 15*q_2+15*q_3+7

Method append terminates?: YES

 - l_1: size of l wrt. List<Rat>
 - l_2: size of l wrt. Rat
 - l_3: size of l wrt. List<A>
 - l_4: size of l wrt. A
 - ys_1: size of ys wrt. List<Rat>
 - ys_2: size of ys wrt. Rat
 - ys_3: size of ys wrt. List<A>
 - ys_4: size of ys wrt. A
UB for append(l_1,l_2,l_3,l_4,ys_1,ys_2,ys_3,ys_4) = 5*l_1+2

Method quicksort terminates?: YES

 - l_1: size of l wrt. List<Rat>
 - l_2: size of l wrt. Rat
UB for quicksort(l_1,l_2) = max([28,2/3*l_1* (65*l_1)+3*l_1+148/3*l_1+14*l_1])

Method sortAll terminates?: YES

 - l_1: size of l wrt. Pair<List<Rat>, Rat>
 - l_2: size of l wrt. List<Pair<List<Rat>, Rat>>
 - l_3: size of l wrt. List<Rat>
 - l_4: size of l wrt. Rat
UB for sortAll(l_1,l_2,l_3,l_4) = -179/2*l_1+199/2*l_3+10+ (-130/3*l_1+130/3*l_3+130/3)* (-3/2*l_1+3/2*l_3)+35/2*l_3+7/3*l_3+3

Method splitAndSort terminates?: YES

 - l_1: size of l wrt. Pair<Rat, Rat>
 - l_2: size of l wrt. List<Pair<Rat, Rat>>
 - l_3: size of l wrt. Rat
UB for splitAndSort(l_1,l_2,l_3) = max([1819/6,835/6*l_1+14+ (l_1+1)* (5*l_1)+ (49*l_1+49)+ (40*l_1+40)* (3/2*l_1)+ (20*l_1+20)* (l_1+1)])+8
