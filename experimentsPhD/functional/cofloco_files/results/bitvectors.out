
Abs program loaded in 6 ms.

Rule based representation generated in 4 ms.

Rule based representation stored in /tmp/costabs/rbr.rbr

RBR properties stored in /tmp/costabs/rbr.properties

Class invariants generated and loaded in 0 ms.

Abstract compilation performed in 25 ms.

Cost relation system stored in /tmp/costabs/crs.crs

Generated 72 equations 
entry('bitToIntp'(A,B,C,D):[]).
entry('bitToInt'(A,B,C):[]).
entry('sum'(A,B,C,D,E):[]).
entry('addp'(A,B,C,D,E,F,G):[]).
entry('add'(A,B,C,D,E,F):[]).
entry('mult'(A,B,C,D,E,F):[]).
entry('diff'(A,B,C,D,E):[]).
entry('subp'(A,B,C,D,E,F,G,H):[]).
entry('sub'(A,B,C,D,E,F):[]).
entry('compare'(A,B,C,D,E):[]).
entry('leq'(A,B,C,D,E):[]).
input_output_vars('add'(A,B,C,D,E,F),[A,B,C,D],[E,F]).
input_output_vars('addp'(A,B,C,D,E,F,G),[A,B,C,D,E],[F,G]).
input_output_vars('and_op'(A,B,C),[A,B],[C]).
input_output_vars('bitToInt'(A,B,C),[A,B],[C]).
input_output_vars('bitToIntp'(A,B,C,D),[A,B,C],[D]).
input_output_vars('case_0'(A,B,C,D),[A,B,C],[D]).
input_output_vars('case_1'(A,B,C,D,E,F,G),[A,B,C,D,E],[F,G]).
input_output_vars('case_10'(A,B,C,D,E,F,G,H),[A,B,C,D,E],[F,G,H]).
input_output_vars('case_11'(A,B,C,D,E,F,G,H,I,J,K),[A,B,C,D,E,F,G,H],[I,J,K]).
input_output_vars('case_12'(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P),[A,B,C,D,E,F,G,H,I,J,K,L,M],[N,O,P]).
input_output_vars('case_13'(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U),[A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R],[S,T,U]).
input_output_vars('case_14'(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y),[A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V],[W,X,Y]).
input_output_vars('case_15'(A,B,C,D,E),[A,B,C,D],[E]).
input_output_vars('case_16'(A,B,C,D,E,F,G,H),[A,B,C,D,E,F,G],[H]).
input_output_vars('case_17'(A,B,C,D,E,F,G,H,I,J,K,L,M),[A,B,C,D,E,F,G,H,I,J,K,L],[M]).
input_output_vars('case_18'(A,B,C,D,E,F,G,H,I,J,K,L,M),[A,B,C,D,E,F,G,H,I,J,K,L],[M]).
input_output_vars('case_19'(A,B,C,D,E,F,G,H,I,J,K,L,M),[A,B,C,D,E,F,G,H,I,J,K,L],[M]).
input_output_vars('case_2'(A,B,C,D,E,F,G,H),[A,B,C,D,E,F],[G,H]).
input_output_vars('case_20'(A,B,C,D,E),[A,B,C],[D,E]).
input_output_vars('case_3'(A,B,C,D,E,F,G,H,I),[A,B,C,D,E,F,G],[H,I]).
input_output_vars('case_4'(A,B,C,D,E,F,G),[A,B,C,D,E],[F,G]).
input_output_vars('case_5'(A,B,C,D,E,F,G,H,I,J),[A,B,C,D,E,F,G,H],[I,J]).
input_output_vars('case_6'(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O),[A,B,C,D,E,F,G,H,I,J,K,L,M],[N,O]).
input_output_vars('case_7'(A,B,C,D,E,F),[A,B,C,D],[E,F]).
input_output_vars('case_8'(A,B,C,D,E,F,G,H,I,J,K,L),[A,B,C,D,E,F,G,H,I,J],[K,L]).
input_output_vars('case_9'(A,B,C,D,E,F),[A,B,C,D,E],[F]).
input_output_vars('compare'(A,B,C,D,E),[A,B,C,D],[E]).
input_output_vars('diff'(A,B,C,D,E),[A,B,C],[D,E]).
input_output_vars('eq'(A,B,C),[A,B],[C]).
input_output_vars('fst'(A,B,C,D,E),[A,B,C],[D,E]).
input_output_vars('geq'(A,B,C),[A,B],[C]).
input_output_vars('gt'(A,B,C),[A,B],[C]).
input_output_vars('leq'(A,B,C),[A,B],[C]).
input_output_vars('lt'(A,B,C),[A,B],[C]).
input_output_vars('maxNorm'(A,B,C),[A,B],[C]).
input_output_vars('mult'(A,B,C,D,E,F),[A,B,C,D],[E,F]).
input_output_vars('neg'(A,B),[A],[B]).
input_output_vars('neq'(A,B,C),[A,B],[C]).
input_output_vars('or'(A,B,C),[A,B],[C]).
input_output_vars('sub'(A,B,C,D,E,F),[A,B,C,D],[E,F]).
input_output_vars('subp'(A,B,C,D,E,F,G,H),[A,B,C,D,E],[F,G,H]).
input_output_vars('sum'(A,B,C,D,E),[A,B,C],[D,E]).
eq('eq',[A,B,C],0,[],[A=B,C=1,A>=0,B>=0,C>=0]).
eq('eq',[A,B,C],0,[],[A>=B+1,C=0,A>=0,B>=0,C>=0]).
eq('eq',[A,B,C],0,[],[B>=A+1,C=0,A>=0,B>=0,C>=0]).
eq('neq',[A,B,C],0,[],[A=B,C=0,A>=0,B>=0,C>=0]).
eq('neq',[A,B,C],0,[],[A>=B+1,C=1,A>=0,B>=0,C>=0]).
eq('neq',[A,B,C],0,[],[B>=A+1,C=1,A>=0,B>=0,C>=0]).
eq('lt',[A,B,C],0,[],[B-A>=1,C=1,A>=0,B>=0,C>=0]).
eq('lt',[A,B,C],0,[],[B=<A,C=0,A>=0,B>=0,C>=0]).
eq('leq',[A,B,C],0,[],[A=<B,C=1,A>=0,B>=0,C>=0]).
eq('leq',[A,B,C],0,[],[A-B>=1,C=0,A>=0,B>=0,C>=0]).
eq('gt',[A,B,C],0,[],[A-B>=1,C=1,A>=0,B>=0,C>=0]).
eq('gt',[A,B,C],0,[],[A=<B,C=0,A>=0,B>=0,C>=0]).
eq('geq',[A,B,C],0,[],[B=<A,C=1,A>=0,B>=0,C>=0]).
eq('geq',[A,B,C],0,[],[B-A>=1,C=0,A>=0,B>=0,C>=0]).
eq('neg',[A,B],0,[],[A=0,B=1,A>=0,B>=0]).
eq('neg',[A,B],0,[],[A=1,B=0,A>=0,B>=0]).
eq('and_op',[A,B,C],0,[],[A=0,C=0,A>=0,B>=0,C>=0]).
eq('and_op',[A,B,C],0,[],[A=1,C=B,A>=0,B>=0,C>=0]).
eq('or',[A,B,C],0,[],[A=1,C=1,A>=0,B>=0,C>=0]).
eq('or',[A,B,C],0,[],[A=0,C=B,A>=0,B>=0,C>=0]).
eq('maxNorm',[A,B,A],0,[],[A>=1+B,A>=0,B>=0,A>=0]).
eq('maxNorm',[A,B,B],0,[],[A=<B,A>=0,B>=0,B>=0]).
eq('case_0',[A,B,C,D],2,[],[A=1,D=0,A>=0,B>=0,C>=0,D>=0]).
eq('case_0',[A,B,C,D],6,['bitToIntp'(E,F,G,H)],[B=I+F,A=E+1,E>=1,J=K,G=L,D=J+H,A>=0,B>=0,C>=0,D>=0]).
eq('bitToIntp',[A,B,C,D],1,['case_0'(A,B,C,D)],[A>=0,B>=0,C>=0,D>=0]).
eq('bitToInt',[A,B,C],2,['bitToIntp'(A,B,D,C)],[D=1,A>=0,B>=0,C>=0]).
eq('case_1',[A,B,C,D,E,F,G],4,[],[B=A,H=0,I=0,G=H+I,F=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0]).
eq('case_2',[A,B,C,D,E,F,G,H],4,[],[C=A,I=1,J=0,H=I+J,G=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0]).
eq('case_3',[A,B,C,D,E,F,G,H,I],4,[],[D=A,J=0,K=1,I=J+K,H=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0]).
eq('case_3',[A,B,C,D,E,F,G,H,I],4,[],[D>=A+1,J=1,K=1,I=J+K,H=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0]).
eq('case_2',[A,B,C,D,E,F,G,H],3,['case_3'(I,A,B,C,D,E,F,G,H)],[C>=A+1,I=2,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0]).
eq('case_1',[A,B,C,D,E,F,G],3,['case_2'(H,A,B,C,D,E,F,G)],[B>=A+1,H=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0]).
eq('sum',[A,B,C,D,E],6,['case_1'(F,G,A,B,C,H,I)],[J=A+B,K=J+C,G=K,F=0,E=I,D=H,H>=1,A>=0,B>=0,C>=0,D>=0,E>=0]).
eq('case_4',[A,B,C,D,E,F,G],2,[],[A=1,F=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0]).
eq('case_5',[A,B,C,D,E,F,G,H,I,J],2,[],[C=1,I=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0]).
eq('case_6',[A,B,C,D,E,F,G,H,I,J,K,L,M,N,O],3,['addp'(I,J,L,M,P,Q,R)],[B=S+P,A=1,O=S+R,N=Q+1,Q>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0,M>=0,N>=0,O>=0]).
eq('case_5',[A,B,C,D,E,F,G,H,I,J],6,['sum'(F,K,E,L,M),'case_6'(N,O,A,B,C,D,E,F,G,H,K,P,Q,R,S)],[D=K+Q,C=P+1,P>=1,O=M,N=L,L>=1,J=S,I=R,R>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0]).
eq('case_4',[A,B,C,D,E,F,G],3,['case_5'(A,B,C,D,E,H,I,J,F,G)],[B=H+J,A=I+1,I>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0]).
eq('addp',[A,B,C,D,E,F,G],1,['case_4'(A,B,C,D,E,F,G)],[A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0]).
eq('add',[A,B,C,D,E,F],2,['addp'(A,B,C,D,G,E,F)],[G=0,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0]).
eq('case_7',[A,B,C,D,E,F],2,[],[A=1,E=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0]).
eq('case_8',[A,B,C,D,E,F,G,H,I,J,K,L],2,['add'(F,G,B,C,K,L)],[H=A,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0]).
eq('case_8',[A,B,C,D,E,F,G,H,I,J,B,C],1,[],[H>=A+1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,B>=0,C>=0]).
eq('case_7',[A,B,C,D,E,F],9,['mult'(G,H,C,D,I,J),'case_8'(K,L,M,A,B,C,D,N,G,H,O,P)],[B=N+H,A=G+1,G>=1,Q=0,R=Q+J,S=I+1,I>=1,M=R,L=S,S>=1,K=1,F=P,E=O,O>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0]).
eq('mult',[A,B,C,D,E,F],1,['case_7'(A,B,C,D,E,F)],[A>=0,B>=0,C>=0,D>=0,E>=0,F>=0]).
eq('case_9',[A,B,C,D,E,F],2,[],[B>=A+1,F=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0]).
eq('case_9',[A,B,C,D,E,F],2,[],[A>=B,F=0,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0]).
eq('diff',[A,B,C,D,E],9,['case_9'(F,G,A,B,C,H)],[I=A+B,J=2,K=L,M=I+K,N=A-B,F=N-C,G=0,E=M+H,D=1,A>=0,B>=0,C>=0,D>=0,E>=0]).
eq('case_10',[A,B,C,D,E,F,G,H],3,[],[A=1,I=1,H=J+E,G=I,F=1,I>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0]).
eq('case_11',[A,B,C,D,E,F,G,H,I,J,K],3,[],[C=1,L=1,K=M+E,J=L,I=1,L>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0]).
eq('case_14',[A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y],4,[],[V=A,Z=0,A1=Z+U,B1=T+1,T>=1,Y=A1+V,X=B1,W=1,B1>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0,M>=0,N>=0,O>=0,P>=0,Q>=0,R>=0,S>=0,T>=0,U>=0,V>=0,W>=0,X>=0,Y>=0]).
eq('case_14',[A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y],3,[],[V>=A+1,Z=R+U,A1=T+1,T>=1,Y=Z+V,X=A1,W=1,A1>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0,M>=0,N>=0,O>=0,P>=0,Q>=0,R>=0,S>=0,T>=0,U>=0,V>=0,W>=0,X>=0,Y>=0]).
eq('case_13',[A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U],3,['case_14'(V,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,W,X,Y,S,T,U)],[C=X+Y,B=W,A=1,W>=1,V=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0,M>=0,N>=0,O>=0,P>=0,Q>=0,R>=0,S>=0,T>=0,U>=0]).
eq('case_12',[A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P],5,['subp'(I,J,L,M,Q,R,S,T),'case_13'(U,V,W,A,B,C,D,E,F,G,H,I,J,K,L,M,X,Q,Y,Z,A1)],[B=X+Q,A=1,W=T,V=S,U=R,R>=1,P=A1,O=Z,N=Y,Y>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0,M>=0,N>=0,O>=0,P>=0]).
eq('case_11',[A,B,C,D,E,F,G,H,I,J,K],6,['diff'(F,L,E,M,N),'case_12'(O,P,A,B,C,D,E,F,G,H,L,Q,R,S,T,U)],[D=L+R,C=Q+1,Q>=1,P=N,O=M,M>=1,K=U,J=T,I=S,S>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0]).
eq('case_10',[A,B,C,D,E,F,G,H],3,['case_11'(A,B,C,D,E,I,J,K,F,G,H)],[B=I+K,A=J+1,J>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0]).
eq('subp',[A,B,C,D,E,F,G,H],1,['case_10'(A,B,C,D,E,F,G,H)],[A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0]).
eq('sub',[A,B,C,D,E,F],3,['subp'(A,B,C,D,G,H,I,J),'fst'(H,I,J,E,F)],[G=0,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0]).
eq('case_15',[A,B,C,D,E],2,[],[A=1,E=0,A>=0,B>=0,C>=0,D>=0,E>=0]).
eq('case_16',[A,B,C,D,E,F,G,H],2,[],[C=1,H=0,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0]).
eq('case_18',[A,B,C,D,E,F,G,H,I,J,K,L,M],2,[],[J>=G+1,M= -1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0,M>=0]).
eq('case_19',[A,B,C,D,E,F,G,H,I,J,K,L,M],2,[],[G>=J+1,M=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0,M>=0]).
eq('case_19',[A,B,C,D,E,F,G,H,I,J,K,L,M],2,[],[J>=G,M=0,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0,M>=0]).
eq('case_18',[A,B,C,D,E,F,G,H,I,J,K,L,M],2,['case_19'(A,B,C,D,E,F,G,H,I,J,K,L,M)],[G>=J,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0,M>=0]).
eq('case_17',[A,B,C,D,E,F,G,H,I,J,K,L,M],2,['case_18'(A,B,C,D,E,F,G,H,I,J,K,L,M)],[B=A,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0,M>=0]).
eq('case_17',[A,B,C,D,E,F,G,H,I,J,K,L,B],1,[],[B>=A+1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0,B>=0]).
eq('case_16',[A,B,C,D,E,F,G,H],7,['compare'(F,G,I,J,K),'case_17'(L,M,A,B,C,D,E,F,G,N,I,J,O)],[D=N+J,C=I+1,I>=1,M=K,L=0,H=O,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0]).
eq('case_15',[A,B,C,D,E],3,['case_16'(A,B,C,D,F,G,H,E)],[B=F+H,A=G+1,G>=1,A>=0,B>=0,C>=0,D>=0,E>=0]).
eq('compare',[A,B,C,D,E],1,['case_15'(A,B,C,D,E)],[A>=0,B>=0,C>=0,D>=0,E>=0]).
eq('leq',[A,B,C,D,E],3,['compare'(A,B,C,D,F),'lt'(F,G,E)],[G=1,A>=0,B>=0,C>=0,D>=0,E>=0]).
eq('case_20',[A,B,C,D,E],1,[],[C=E+F,B=D,A=1,D>=1,A>=0,B>=0,C>=0,D>=0,E>=0]).
eq('fst',[A,B,C,D,E],1,['case_20'(A,B,C,D,E)],[A>=0,B>=0,C>=0,D>=0,E>=0]).

Preprocessing Cost Relations
=====================================

#### Computed strongly connected components 
0. non_recursive  : [case_3/9]
1. non_recursive  : [case_2/8]
2. non_recursive  : [case_1/7]
3. non_recursive  : [sum/5]
4. recursive  : [addp/7,case_4/7,case_5/10,case_6/15]
5. non_recursive  : [add/6]
6. recursive  : [bitToIntp/4,case_0/4]
7. non_recursive  : [bitToInt/3]
8. non_recursive  : [case_19/13]
9. non_recursive  : [case_18/13]
10. non_recursive  : [case_17/13]
11. recursive [non_tail] : [case_15/5,case_16/8,compare/5]
12. non_recursive  : [case_9/6]
13. non_recursive  : [diff/5]
14. non_recursive  : [lt/3]
15. non_recursive  : [leq/5]
16. non_recursive  : [case_8/12]
17. recursive [non_tail] : [case_7/6,mult/6]
18. non_recursive  : [case_20/5]
19. non_recursive  : [fst/5]
20. non_recursive  : [case_14/25]
21. non_recursive  : [case_13/21]
22. recursive [non_tail] : [case_10/8,case_11/11,case_12/16,subp/8]
23. non_recursive  : [sub/6]
Warning: the following predicates are never called:[and_op/3,eq/3,geq/3,gt/3,leq/3,maxNorm/3,neg/2,neq/3,or/3]

#### Obtained direct recursion through partial evaluation 
0. SCC is partially evaluated into case_3/9
1. SCC is partially evaluated into case_2/8
2. SCC is partially evaluated into case_1/7
3. SCC is partially evaluated into sum/5
4. SCC is partially evaluated into addp/7
5. SCC is partially evaluated into add/6
6. SCC is partially evaluated into bitToIntp/4
7. SCC is partially evaluated into bitToInt/3
8. SCC is partially evaluated into case_19/13
9. SCC is partially evaluated into case_18/13
10. SCC is partially evaluated into case_17/13
11. SCC is partially evaluated into compare/5
12. SCC is partially evaluated into case_9/6
13. SCC is partially evaluated into diff/5
14. SCC is partially evaluated into lt/3
15. SCC is partially evaluated into leq/5
16. SCC is partially evaluated into case_8/12
17. SCC is partially evaluated into mult/6
18. SCC is completely evaluated into other SCCs
19. SCC is completely evaluated into other SCCs
20. SCC is partially evaluated into case_14/25
21. SCC is completely evaluated into other SCCs
22. SCC is partially evaluated into subp/8
23. SCC is partially evaluated into sub/6

Control-Flow Refinement of Cost Relations
=====================================

### Specialization of cost equations case_3/9 
* CE 36 is refined into CE [39] 
* CE 35 is refined into CE [40] 


#### Refined cost equations case_3/9 
* CE 39: case_3(A,B,C,D,E,F,G,H,I) = 4
     [D>=F+G,G>=0,F>=0,D>=3,D=E+F+G,I=2,H=1,C=0,B=1,A=2] 
* CE 40: case_3(A,B,C,D,E,F,G,H,I) = 4
     [2>=F+G,G>=0,F>=0,E+F+G=2,I=1,H=1,D=2,C=0,B=1,A=2] 

### Cost equations --> "Loop" of case_3/9 
* CEs [39] --> Loop 39 
* CEs [40] --> Loop 40 

#### Loops of case_3/9 
* Loop 39: case_3(A,B,C,D,E,F,G,H,I) [D>=E+F,F>=0,E>=0,D>=3,D=E+F+G,I=2,H=1,C=0,B=1,A=2] 
* Loop 40: case_3(A,B,C,D,E,F,G,H,I) [2>=E+F,F>=0,E>=0,E+F+G=2,I=1,H=1,D=2,C=0,B=1,A=2] 

### Ranking functions of CR case_3(A,B,C,D,E,F,G,H,I) 

#### Partial ranking functions of CR case_3(A,B,C,D,E,F,G,H,I) 


### Resulting Chains:case_3(A,B,C,D,E,F,G,H,I) 
* [40]
* [39]


### Merging Chains  case_3/9 into  External patterns of execution 
* [[40]] --> 1 
* [[39]] --> 2 


### Specialization of cost equations case_2/8 
* CE 33 is refined into CE [41,42] 
* CE 32 is refined into CE [43] 


#### Refined cost equations case_2/8 
* CE 41: case_2(A,B,C,D,E,F,G,H) = 3+ case_3(I,J,K,L,D,E,M,N,O):1
     [2>=D+E,E>=0,D>=0,D+E+M=2,D+E+F=2,O=1,N=1,L=2,K=0,J=1,I=2,H=1,G=1,C=2,B=0,A=1] 
* CE 42: case_2(A,B,C,D,E,F,G,H) = 3+ case_3(I,J,K,L,D,E,F,M,N):2
     [D+E+F>=3,F>=0,E>=0,D>=0,D+E+F=L,D+E+F=C,N=2,M=1,K=0,J=1,I=2,H=2,G=1,B=0,A=1] 
* CE 43: case_2(A,B,C,D,E,F,G,H) = 4
     [1>=E+F,F>=0,E>=0,D+E+F=1,H=1,G=1,C=1,B=0,A=1] 

### Cost equations --> "Loop" of case_2/8 
* CEs [42] --> Loop 41 
* CEs [41] --> Loop 42 
* CEs [43] --> Loop 43 

#### Loops of case_2/8 
* Loop 41: case_2(A,B,C,D,E,F,G,H) [C>=D+E,E>=0,D>=0,C>=3,C=D+E+F,H=2,G=1,B=0,A=1] 
* Loop 42: case_2(A,B,C,D,E,F,G,H) [2>=D+E,E>=0,D>=0,D+E+F=2,H=1,G=1,C=2,B=0,A=1] 
* Loop 43: case_2(A,B,C,D,E,F,G,H) [1>=D+E,E>=0,D>=0,D+E+F=1,H=1,G=1,C=1,B=0,A=1] 

### Ranking functions of CR case_2(A,B,C,D,E,F,G,H) 

#### Partial ranking functions of CR case_2(A,B,C,D,E,F,G,H) 


### Resulting Chains:case_2(A,B,C,D,E,F,G,H) 
* [43]
* [42]
* [41]


### Merging Chains  case_2/8 into  External patterns of execution 
* [[43]] --> 1 
* [[42]] --> 2 
* [[41]] --> 3 


### Specialization of cost equations case_1/7 
* CE 21 is refined into CE [44,45,46] 
* CE 20 is refined into CE [47] 


#### Refined cost equations case_1/7 
* CE 44: case_1(A,B,C,D,E,F,G) = 3+ case_2(H,I,J,C,D,K,L,M):1
     [1>=C+D,D>=0,C>=0,C+D+K=1,C+D+E=1,M=1,L=1,J=1,I=0,H=1,G=1,F=1,B=1,A=0] 
* CE 45: case_1(A,B,C,D,E,F,G) = 3+ case_2(H,I,J,C,D,K,L,M):2
     [2>=C+D,D>=0,C>=0,C+D+K=2,C+D+E=2,M=1,L=1,J=2,I=0,H=1,G=1,F=1,B=2,A=0] 
* CE 46: case_1(A,B,C,D,E,F,G) = 3+ case_2(H,I,J,C,D,E,K,L):3
     [C+D+E>=3,E>=0,D>=0,C>=0,C+D+E=J,C+D+E=B,L=2,K=1,I=0,H=1,G=2,F=1,A=0] 
* CE 47: case_1(A,B,C,D,E,F,G) = 4
     [G=0,F=1,E=0,D=0,C=0,B=0,A=0] 

### Cost equations --> "Loop" of case_1/7 
* CEs [46] --> Loop 44 
* CEs [45] --> Loop 45 
* CEs [44] --> Loop 46 
* CEs [47] --> Loop 47 

#### Loops of case_1/7 
* Loop 44: case_1(A,B,C,D,E,F,G) [B>=C+D,D>=0,C>=0,B>=3,B=C+D+E,G=2,F=1,A=0] 
* Loop 45: case_1(A,B,C,D,E,F,G) [2>=C+D,D>=0,C>=0,C+D+E=2,G=1,F=1,B=2,A=0] 
* Loop 46: case_1(A,B,C,D,E,F,G) [1>=C+D,D>=0,C>=0,C+D+E=1,G=1,F=1,B=1,A=0] 
* Loop 47: case_1(A,B,C,D,E,F,G) [G=0,F=1,E=0,D=0,C=0,B=0,A=0] 

### Ranking functions of CR case_1(A,B,C,D,E,F,G) 

#### Partial ranking functions of CR case_1(A,B,C,D,E,F,G) 


### Resulting Chains:case_1(A,B,C,D,E,F,G) 
* [47]
* [46]
* [45]
* [44]


### Merging Chains  case_1/7 into  External patterns of execution 
* [[47]] --> 1 
* [[46]] --> 2 
* [[45]] --> 3 
* [[44]] --> 4 


### Specialization of cost equations sum/5 
* CE 4 is refined into CE [48,49,50,51] 


#### Refined cost equations sum/5 
* CE 48: sum(A,B,C,D,E) = 6+ case_1(F,G,H,I,J,K,L):1
     [L=0,K=1,J=0,I=0,H=0,G=0,F=0,E=0,D=1,C=0,B=0,A=0] 
* CE 49: sum(A,B,C,D,E) = 6+ case_1(F,G,A,B,H,I,J):2
     [1>=A+B,B>=0,A>=0,A+B+H=1,A+B+C=1,J=1,I=1,G=1,F=0,E=1,D=1] 
* CE 50: sum(A,B,C,D,E) = 6+ case_1(F,G,A,B,H,I,J):3
     [2>=A+B,B>=0,A>=0,A+B+H=2,A+B+C=2,J=1,I=1,G=2,F=0,E=1,D=1] 
* CE 51: sum(A,B,C,D,E) = 6+ case_1(F,G,A,B,C,H,I):4
     [A+B+C>=3,C>=0,B>=0,A>=0,A+B+C=G,I=2,H=1,F=0,E=2,D=1] 

### Cost equations --> "Loop" of sum/5 
* CEs [51] --> Loop 48 
* CEs [50] --> Loop 49 
* CEs [49] --> Loop 50 
* CEs [48] --> Loop 51 

#### Loops of sum/5 
* Loop 48: sum(A,B,C,D,E) [A+B+C>=3,C>=0,B>=0,A>=0,E=2,D=1] 
* Loop 49: sum(A,B,C,D,E) [2>=A+B,B>=0,A>=0,A+B+C=2,E=1,D=1] 
* Loop 50: sum(A,B,C,D,E) [1>=A+B,B>=0,A>=0,A+B+C=1,E=1,D=1] 
* Loop 51: sum(A,B,C,D,E) [E=0,D=1,C=0,B=0,A=0] 

### Ranking functions of CR sum(A,B,C,D,E) 

#### Partial ranking functions of CR sum(A,B,C,D,E) 


### Resulting Chains:sum(A,B,C,D,E) 
* [51]
* [50]
* [49]
* [48]


### Merging Chains  sum/5 into  External patterns of execution 
* [[51]] --> 1 
* [[50]] --> 2 
* [[49]] --> 3 
* [[48]] --> 4 


### Specialization of cost equations addp/7 
* CE 7 is refined into CE [52] 
* CE 5 is refined into CE [53] 
* CE 6 is refined into CE [54,55,56,57] 


#### Refined cost equations addp/7 
* CE 52: addp(A,B,C,D,E,F,G) = 6
     [G>=0,E>=0,D>=0,B>=0,A>=2,F=1,C=1] 
* CE 53: addp(A,B,C,D,E,F,G) = 3
     [G>=0,E>=0,D>=0,C>=0,B>=0,F=1,A=1] 
* CE 54: addp(A,B,C,D,E,F,G) = 13+ sum(H,I,J,K,L):1+ addp(M,B,N,D,O,P,Q)
     [Q>=O,P>=1,D>=0,N>=1,B>=0,M>=1,G+O=Q,P+1=F,N+1=C,M+1=A,L=0,K=1,J=0,I=0,H=0,E=0] 
* CE 55: addp(A,B,C,D,E,F,G) = 13+ sum(H,I,J,K,L):2+ addp(M,N,O,P,Q,R,S)
     [S+1>=Q,1>=H+I,R>=1,P>=0,O>=1,N>=0,M>=1,I>=0,H>=0,H+I+J=1,E+H+I=1,G+Q=S+1,I+P=D,H+N=B,R+1=F,O+1=C,M+1=A,L=1,K=1] 
* CE 56: addp(A,B,C,D,E,F,G) = 13+ sum(H,I,J,K,L):3+ addp(M,N,O,P,Q,R,S)
     [S+1>=Q,2>=H+I,R>=1,P>=0,O>=1,N>=0,M>=1,I>=0,H>=0,H+I+J=2,E+H+I=2,G+Q=S+1,I+P=D,H+N=B,R+1=F,O+1=C,M+1=A,L=1,K=1] 
* CE 57: addp(A,B,C,D,E,F,G) = 13+ sum(H,I,E,J,K):4+ addp(L,M,N,O,P,Q,R)
     [E+H+I>=3,R+2>=P,Q>=1,O>=0,N>=1,M>=0,L>=1,E>=0,I>=0,H>=0,G+P=R+2,I+O=D,H+M=B,Q+1=F,N+1=C,L+1=A,K=2,J=1] 

### Cost equations --> "Loop" of addp/7 
* CEs [57] --> Loop 52 
* CEs [56] --> Loop 53 
* CEs [55] --> Loop 54 
* CEs [54] --> Loop 55 
* CEs [52] --> Loop 56 
* CEs [53] --> Loop 57 

#### Loops of addp/7 
* Loop 52: addp(A,B,C,D,E,F,G)->  addp(A',B',C',D',E',F',G')
                  [B+D+E>=B'+D'+3,D>=D',B>=B',D'>=0,B'>=0,G>=0,F>=2,E>=0,C>=2,A>=2,G+E'=G'+2,F=F'+1,C=C'+1,A=A'+1] 
* Loop 53: addp(A,B,C,D,E,F,G)->  addp(A',B',C',D',E',F',G')
                  [B+D+E>=B'+2,B'+2>=B+E,B>=B',B'>=0,G>=0,F>=2,E>=0,C>=2,A>=2,B+D+E=B'+D'+2,G+E'=G'+1,F=F'+1,C=C'+1,A=A'+1] 
* Loop 54: addp(A,B,C,D,E,F,G)->  addp(A',B',C',D',E',F',G')
                  [B+D+E>=B'+1,B'+1>=B+E,B>=B',B'>=0,G>=0,F>=2,E>=0,C>=2,A>=2,B+D+E=B'+D'+1,G+E'=G'+1,F=F'+1,C=C'+1,A=A'+1] 
* Loop 55: addp(A,B,C,D,E,F,G)->  addp(A',B,B',D,C',D',E')
                  [G>=0,F>=2,D>=0,C>=2,B>=0,A>=2,G+C'=E',F=D'+1,C=B'+1,A=A'+1,E=0] 
* Loop 56: addp(A,B,C,D,E,F,G) [G>=0,E>=0,D>=0,B>=0,A>=2,F=1,C=1] 
* Loop 57: addp(A,B,C,D,E,F,G) [G>=0,E>=0,D>=0,C>=0,B>=0,F=1,A=1] 

### Ranking functions of CR addp(A,B,C,D,E,F,G) 
* RF of phase [52,53,54,55]: [A-1,C-1]

#### Partial ranking functions of CR addp(A,B,C,D,E,F,G) 
* Partial RF of phase [52,53,54,55]:
  - RF of loop [52:1,53:1,54:1,55:1]:
    A-1
    C-1

Discarded unfeasible chain [[52,53,54,55]]...(Non-terminating chain proved terminating)

### Resulting Chains:addp(A,B,C,D,E,F,G) 
* [[52,53,54,55],57]
* [[52,53,54,55],56]
* [57]
* [56]


### Merging Chains  addp/7 into  External patterns of execution 
* [[57]] --> 1 
* [[56]] --> 2 
* [[57,[52,53,54,55]]] --> 3 
* [[56,[52,53,54,55]]] --> 4 


### Specialization of cost equations add/6 
* CE 8 is refined into CE [58,59,60,61] 


#### Refined cost equations add/6 
* CE 58: add(A,B,C,D,E,F) = 2+ addp(G,B,C,D,H,I,F):1
     [F>=0,D>=0,C>=0,B>=0,I=1,H=0,G=1,E=1,A=1] 
* CE 59: add(A,B,C,D,E,F) = 2+ addp(A,B,G,D,H,I,F):2
     [F>=0,D>=0,B>=0,A>=2,I=1,H=0,G=1,E=1,C=1] 
* CE 60: add(A,B,C,D,A,E) = 2+ addp(A,B,C,D,F,A,E):3
     [C>=A,E>=0,A>=2,D>=0,B>=0,F=0] 
* CE 61: add(A,B,C,D,C,E) = 2+ addp(A,B,C,D,F,C,E):4
     [A>=C+1,E>=0,C>=2,D>=0,B>=0,F=0] 

### Cost equations --> "Loop" of add/6 
* CEs [61] --> Loop 58 
* CEs [60] --> Loop 59 
* CEs [59] --> Loop 60 
* CEs [58] --> Loop 61 

#### Loops of add/6 
* Loop 58: add(A,B,C,D,C,E) [A>=C+1,E>=0,D>=0,C>=2,B>=0] 
* Loop 59: add(A,B,C,D,A,E) [C>=A,E>=0,D>=0,B>=0,A>=2] 
* Loop 60: add(A,B,C,D,E,F) [F>=0,D>=0,B>=0,A>=2,E=1,C=1] 
* Loop 61: add(A,B,C,D,E,F) [F>=0,D>=0,C>=0,B>=0,E=1,A=1] 

### Ranking functions of CR add(A,B,C,D,E,F) 

#### Partial ranking functions of CR add(A,B,C,D,E,F) 


### Resulting Chains:add(A,B,C,D,E,F) 
* [61]
* [60]
* [59]
* [58]


### Merging Chains  add/6 into  External patterns of execution 
* [[61]] --> 1 
* [[60]] --> 2 
* [[59]] --> 3 
* [[58]] --> 4 


### Specialization of cost equations bitToIntp/4 
* CE 2 is refined into CE [62] 
* CE 1 is refined into CE [63] 


#### Refined cost equations bitToIntp/4 
* CE 62: bitToIntp(A,B,C,D) = 3
     [C>=0,B>=0,D=0,A=1] 
* CE 63: bitToIntp(A,B,C,D) = 7+ bitToIntp(E,F,G,H)
     [E>=1,D>=0,C>=0,B>=0,E+1=A] 

### Cost equations --> "Loop" of bitToIntp/4 
* CEs [63] --> Loop 62 
* CEs [62] --> Loop 63 

#### Loops of bitToIntp/4 
* Loop 62: bitToIntp(A,B,C,D)->  bitToIntp(A',B',C',D')
                  [A'>=1,D>=0,C>=0,B>=0,A'+1=A] 
* Loop 63: bitToIntp(A,B,C,D) [C>=0,B>=0,D=0,A=1] 

### Ranking functions of CR bitToIntp(A,B,C,D) 
* RF of phase [62]: [A-1]

#### Partial ranking functions of CR bitToIntp(A,B,C,D) 
* Partial RF of phase [62]:
  - RF of loop [62:1]:
    A-1

Discarded unfeasible chain [[62]]...(Non-terminating chain proved terminating)

### Resulting Chains:bitToIntp(A,B,C,D) 
* [[62],63]
* [63]


### Merging Chains  bitToIntp/4 into  External patterns of execution 
* [[63]] --> 1 
* [[63,[62]]] --> 2 


### Specialization of cost equations bitToInt/3 
* CE 3 is refined into CE [64,65] 


#### Refined cost equations bitToInt/3 
* CE 64: bitToInt(A,B,C) = 2+ bitToIntp(D,B,E,F):1
     [B>=0,F=0,E=1,D=1,C=0,A=1] 
* CE 65: bitToInt(A,B,C) = 2+ bitToIntp(A,B,D,C):2
     [C>=0,B>=0,A>=2,D=1] 

### Cost equations --> "Loop" of bitToInt/3 
* CEs [65] --> Loop 64 
* CEs [64] --> Loop 65 

#### Loops of bitToInt/3 
* Loop 64: bitToInt(A,B,C) [C>=0,B>=0,A>=2] 
* Loop 65: bitToInt(A,B,C) [B>=0,C=0,A=1] 

### Ranking functions of CR bitToInt(A,B,C) 

#### Partial ranking functions of CR bitToInt(A,B,C) 


### Resulting Chains:bitToInt(A,B,C) 
* [65]
* [64]


### Merging Chains  bitToInt/3 into  External patterns of execution 
* [[65]] --> 1 
* [[64]] --> 2 


### Specialization of cost equations case_19/13 
* CE 37 is refined into CE [66] 
* CE 38 is refined into CE [67] 


#### Refined cost equations case_19/13 
* CE 66: case_19(A,B,C,D,E,F,G,H,I,J,K,L,M) = 2
     [G>=J+1,L>=0,K>=1,J>=0,I>=0,H>=1,J+L=F,G+I=D,K+1=E,H+1=C,M=1,B=0,A=0] 
* CE 67: case_19(A,B,C,D,E,F,G,H,I,G,J,K,L) = 2
     [K>=0,J>=1,I>=0,H>=1,G>=0,G+K=F,G+I=D,J+1=E,H+1=C,L=0,B=0,A=0] 

### Cost equations --> "Loop" of case_19/13 
* CEs [66] --> Loop 66 
* CEs [67] --> Loop 67 

#### Loops of case_19/13 
* Loop 66: case_19(A,B,C,D,E,F,G,H,I,J,K,L,M) [G>=J+1,F>=J,D>=G,J>=0,E>=2,C>=2,J+L=F,G+I=D,E=K+1,C=H+1,M=1,B=0,A=0] 
* Loop 67: case_19(A,B,C,D,E,F,G,H,I,G,J,K,L) [F>=G,D>=G,G>=0,E>=2,C>=2,G+K=F,G+I=D,E=J+1,C=H+1,L=0,B=0,A=0] 

### Ranking functions of CR case_19(A,B,C,D,E,F,G,H,I,J,K,L,M) 

#### Partial ranking functions of CR case_19(A,B,C,D,E,F,G,H,I,J,K,L,M) 


### Resulting Chains:case_19(A,B,C,D,E,F,G,H,I,J,K,L,M) 
* [67]
* [66]


### Merging Chains  case_19/13 into  External patterns of execution 
* [[67]] --> 1 
* [[66]] --> 2 


### Specialization of cost equations case_18/13 
* CE 34 is refined into CE [68,69] 


#### Refined cost equations case_18/13 
* CE 68: case_18(A,B,C,D,E,F,G,H,I,G,J,K,L) = 2+ case_19(M,N,O,P,Q,F,G,H,I,G,J,R,S):1
     [F>=G,J>=1,G>=0,I>=0,H>=1,G+R=F,G+K=F,G+I=P,G+I=D,J+1=Q,H+1=O,J+1=E,H+1=C,S=0,N=0,M=0,L=0,B=0,A=0] 
* CE 69: case_18(A,B,C,D,E,F,G,H,I,J,K,L,M) = 2+ case_19(N,O,P,Q,R,S,G,H,I,J,K,L,T):2
     [G>=J+1,L>=0,K>=1,J>=0,I>=0,H>=1,J+L=S,G+I=Q,J+L=F,G+I=D,K+1=R,H+1=P,K+1=E,H+1=C,T=1,O=0,N=0,M=1,B=0,A=0] 

### Cost equations --> "Loop" of case_18/13 
* CEs [69] --> Loop 68 
* CEs [68] --> Loop 69 

#### Loops of case_18/13 
* Loop 68: case_18(A,B,C,D,E,F,G,H,I,J,K,L,M) [G>=J+1,F>=J,D>=G,J>=0,E>=2,C>=2,F=J+L,D=G+I,E=K+1,C=H+1,M=1,B=0,A=0] 
* Loop 69: case_18(A,B,C,D,E,F,G,H,I,G,J,K,L) [F>=G,D>=G,G>=0,E>=2,C>=2,G+K=F,G+I=D,E=J+1,C=H+1,L=0,B=0,A=0] 

### Ranking functions of CR case_18(A,B,C,D,E,F,G,H,I,J,K,L,M) 

#### Partial ranking functions of CR case_18(A,B,C,D,E,F,G,H,I,J,K,L,M) 


### Resulting Chains:case_18(A,B,C,D,E,F,G,H,I,J,K,L,M) 
* [69]
* [68]


### Merging Chains  case_18/13 into  External patterns of execution 
* [[69]] --> 1 
* [[68]] --> 2 


### Specialization of cost equations case_17/13 
* CE 29 is refined into CE [70] 
* CE 28 is refined into CE [71,72] 


#### Refined cost equations case_17/13 
* CE 70: case_17(A,B,C,D,E,F,G,H,I,J,K,L,B) = 1
     [L>=0,K>=1,J>=0,I>=0,H>=1,G>=0,B>=1,J+L=F,G+I=D,K+1=E,H+1=C,A=0] 
* CE 71: case_17(A,B,C,D,E,F,G,H,I,G,J,K,L) = 2+ case_18(M,N,O,P,Q,F,G,H,I,G,J,R,S):1
     [F>=G,J>=1,G>=0,I>=0,H>=1,G+R=F,G+K=F,G+I=P,G+I=D,J+1=Q,H+1=O,J+1=E,H+1=C,S=0,N=0,M=0,L=0,B=0,A=0] 
* CE 72: case_17(A,B,C,D,E,F,G,H,I,J,K,L,M) = 2+ case_18(N,O,P,D,Q,F,G,H,R,J,K,S,T):2
     [G>=J+1,F>=J,D>=G,K>=1,J>=0,H>=1,F=J+S,D=G+R,F=J+L,D=G+I,K+1=Q,H+1=P,K+1=E,H+1=C,T=1,O=0,N=0,M=1,B=0,A=0] 

### Cost equations --> "Loop" of case_17/13 
* CEs [70] --> Loop 70 
* CEs [72] --> Loop 71 
* CEs [71] --> Loop 72 

#### Loops of case_17/13 
* Loop 70: case_17(A,B,C,D,E,F,G,H,I,J,K,L,B) [F>=J,D>=G,J>=0,G>=0,E>=2,C>=2,B>=1,J+L=F,G+I=D,E=K+1,C=H+1,A=0] 
* Loop 71: case_17(A,B,C,D,E,F,G,H,I,J,K,L,M) [G>=J+1,F>=J,D>=G,J>=0,E>=2,C>=2,F=J+L,D=G+I,E=K+1,C=H+1,M=1,B=0,A=0] 
* Loop 72: case_17(A,B,C,D,E,F,G,H,I,G,J,K,L) [F>=G,D>=G,G>=0,E>=2,C>=2,G+K=F,G+I=D,E=J+1,C=H+1,L=0,B=0,A=0] 

### Ranking functions of CR case_17(A,B,C,D,E,F,G,H,I,J,K,L,M) 

#### Partial ranking functions of CR case_17(A,B,C,D,E,F,G,H,I,J,K,L,M) 


### Resulting Chains:case_17(A,B,C,D,E,F,G,H,I,J,K,L,M) 
* [72]
* [71]
* [70]


### Merging Chains  case_17/13 into  External patterns of execution 
* [[72]] --> 1 
* [[71]] --> 2 
* [[70]] --> 3 


### Specialization of cost equations compare/5 
* CE 18 is refined into CE [73,74,75] 
* CE 17 is refined into CE [76] 
* CE 16 is refined into CE [77] 


#### Refined cost equations compare/5 
* CE 73: compare(A,B,C,D,E) = 11+ compare(F,G,H,I,J)+ case_17(K,L,M,N,O,D,P,F,G,P,H,Q,R):1
     [D>=P,H>=1,P>=0,G>=0,F>=1,P+I=D,P+Q=D,P+G=N,P+G=B,H+1=O,F+1=M,H+1=C,F+1=A,J=0,R=0,L=0,K=0,E=0] 
* CE 74: compare(A,B,C,D,E) = 11+ compare(F,G,H,I,J)+ case_17(K,L,M,B,N,D,O,F,P,Q,H,R,S):2
     [O>=Q+1,D>=Q,B>=O,H>=1,Q>=0,F>=1,D=Q+I,D=Q+R,B=O+G,B=O+P,H+1=N,F+1=M,H+1=C,F+1=A,J=0,S=1,L=0,K=0,E=1] 
* CE 75: compare(A,B,C,D,E) = 11+ compare(F,G,H,I,E)+ case_17(J,E,K,L,M,N,O,F,G,P,H,I,E):3
     [E>=1,I>=0,H>=1,P>=0,G>=0,F>=1,O>=0,P+I=N,O+G=L,P+I=D,O+G=B,H+1=M,F+1=K,H+1=C,F+1=A,J=0] 
* CE 76: compare(A,B,C,D,E) = 6
     [D>=0,B>=0,A>=2,E=0,C=1] 
* CE 77: compare(A,B,C,D,E) = 3
     [D>=0,C>=0,B>=0,E=0,A=1] 

### Cost equations --> "Loop" of compare/5 
* CEs [76] --> Loop 73 
* CEs [77] --> Loop 74 
* CEs [75] --> Loop 75 
* CEs [74] --> Loop 76 
* CEs [73] --> Loop 77 

#### Loops of compare/5 
* Loop 73: compare(A,B,C,D,E) [D>=0,B>=0,A>=2,E=0,C=1] 
* Loop 74: compare(A,B,C,D,E) [D>=0,C>=0,B>=0,E=0,A=1] 
* Loop 75: compare(A,B,C,D,E)->  compare(A',B',C',D',E)
                  [D>=D',B>=B',D'>=0,B'>=0,E>=1,C>=2,A>=2,C=C'+1,A=A'+1] 
* Loop 76: compare(A,B,C,D,E)->  compare(A',B',C',D',E')
                  [B+D'>=D+B'+1,D>=D',D'>=0,B'>=0,C>=2,A>=2,C=C'+1,A=A'+1,E'=0,E=1] 
* Loop 77: compare(A,B,C,D,E)->  compare(A',B',C',D',E')
                  [D+B'>=B,B>=B',B'>=0,C>=2,A>=2,B+D'=D+B',C=C'+1,A=A'+1,E'=0,E=0] 

### Ranking functions of CR compare(A,B,C,D,E) 
* RF of phase [75]: [A-1,C-1]
* RF of phase [77]: [A-1,C-1]

#### Partial ranking functions of CR compare(A,B,C,D,E) 
* Partial RF of phase [75]:
  - RF of loop [75:1]:
    A-1
    C-1
* Partial RF of phase [77]:
  - RF of loop [77:1]:
    A-1
    C-1

Discarded unfeasible chain [[77]]...(Non-terminating chain proved terminating)
Discarded unfeasible chain [[75]](Non-terminating chain proved terminating)
Discarded unfeasible chain [[75],76,[77]](Non-terminating chain proved terminating)
Discarded unfeasible chain [76,[77]](Non-terminating chain proved terminating)

### Resulting Chains:compare(A,B,C,D,E) 
* [[77],74]
* [[77],73]
* [[75],76,[77],74]
* [[75],76,[77],73]
* [[75],76,74]
* [[75],76,73]
* [76,[77],74]
* [76,[77],73]
* [76,74]
* [76,73]
* [74]
* [73]


### Merging Chains  compare/5 into  External patterns of execution 
* [[74]] --> 1 
* [[74,76]] --> 2 
* [[73]] --> 3 
* [[73,76]] --> 4 
* [[74,[77]]] --> 5 
* [[73,[77]]] --> 6 
* [[74,[77],76],[74,76,[75]],[74,[77],76,[75]]] --> 7 
* [[73,[77],76],[73,76,[75]],[73,[77],76,[75]]] --> 8 


### Specialization of cost equations case_9/6 
* CE 24 is discarded (unfeasible) 
* CE 25 is refined into CE [78] 


#### Refined cost equations case_9/6 
* CE 78: case_9(A,B,C,D,E,F) = 2
     [E>=0,D>=0,A>=0,A+D+E=C,F=0,B=0] 

### Cost equations --> "Loop" of case_9/6 
* CEs [78] --> Loop 78 

#### Loops of case_9/6 
* Loop 78: case_9(A,B,C,D,E,F) [E>=0,D>=0,A>=0,A+D+E=C,F=0,B=0] 

### Ranking functions of CR case_9(A,B,C,D,E,F) 

#### Partial ranking functions of CR case_9(A,B,C,D,E,F) 


### Resulting Chains:case_9(A,B,C,D,E,F) 
* [78]


### Merging Chains  case_9/6 into  External patterns of execution 
* [[78]] --> 1 


### Specialization of cost equations diff/5 
* CE 11 is refined into CE [79] 


#### Refined cost equations diff/5 
* CE 79: diff(A,B,C,D,E) = 9+ case_9(F,G,A,B,H,I):1
     [A>=B+F,B>=0,F>=0,E>=0,A=B+F+H,A=B+C+F,I=0,G=0,D=1] 

### Cost equations --> "Loop" of diff/5 
* CEs [79] --> Loop 79 

#### Loops of diff/5 
* Loop 79: diff(A,B,C,D,E) [A>=B+C,E>=0,C>=0,B>=0,D=1] 

### Ranking functions of CR diff(A,B,C,D,E) 

#### Partial ranking functions of CR diff(A,B,C,D,E) 


### Resulting Chains:diff(A,B,C,D,E) 
* [79]


### Merging Chains  diff/5 into  External patterns of execution 
* [[79]] --> 1 


### Specialization of cost equations lt/3 
* CE 30 is refined into CE [80] 
* CE 31 is refined into CE [81] 


#### Refined cost equations lt/3 
* CE 80: lt(A,B,C) = 0
     [C=1,B=1,A=0] 
* CE 81: lt(A,B,C) = 0
     [A>=1,C=0,B=1] 

### Cost equations --> "Loop" of lt/3 
* CEs [81] --> Loop 80 
* CEs [80] --> Loop 81 

#### Loops of lt/3 
* Loop 80: lt(A,B,C) [A>=1,C=0,B=1] 
* Loop 81: lt(A,B,C) [C=1,B=1,A=0] 

### Ranking functions of CR lt(A,B,C) 

#### Partial ranking functions of CR lt(A,B,C) 


### Resulting Chains:lt(A,B,C) 
* [81]
* [80]


### Merging Chains  lt/3 into  External patterns of execution 
* [[81]] --> 1 
* [[80]] --> 2 


### Specialization of cost equations leq/5 
* CE 19 is refined into CE [82,83,84,85,86,87,88,89] 


#### Refined cost equations leq/5 
* CE 82: leq(A,B,C,D,E) = 3+ compare(F,B,C,D,G):1+ lt(H,I,J):1
     [D>=0,C>=0,B>=0,J=1,I=1,H=0,G=0,F=1,E=1,A=1] 
* CE 83: leq(A,B,C,D,E) = 3+ compare(F,B,C,D,G):2+ lt(H,I,J):2
     [D>=0,C>=2,B>=1,J=0,I=1,H=1,G=1,F=2,E=0,A=2] 
* CE 84: leq(A,B,C,D,E) = 3+ compare(A,B,F,D,G):3+ lt(H,I,J):1
     [D>=0,B>=0,A>=2,J=1,I=1,H=0,G=0,F=1,E=1,C=1] 
* CE 85: leq(A,B,C,D,E) = 3+ compare(A,B,F,D,G):4+ lt(H,I,J):2
     [D>=0,B>=1,A>=3,J=0,I=1,H=1,G=1,F=2,E=0,C=2] 
* CE 86: leq(A,B,C,D,E) = 3+ compare(A,B,C,D,F):5+ lt(G,H,I):1
     [C>=A,D>=0,B>=0,A>=2,I=1,H=1,G=0,F=0,E=1] 
* CE 87: leq(A,B,C,D,E) = 3+ compare(A,B,C,D,F):6+ lt(G,H,I):1
     [A>=C+1,D>=0,C>=2,B>=0,I=1,H=1,G=0,F=0,E=1] 
* CE 88: leq(A,B,C,D,E) = 3+ compare(A,B,C,D,F):7+ lt(G,H,I):2
     [C>=A,D>=0,B>=1,A>=3,I=0,H=1,G=1,F=1,E=0] 
* CE 89: leq(A,B,C,D,E) = 3+ compare(A,B,C,D,F):8+ lt(G,H,I):2
     [A>=C+1,D>=0,C>=3,B>=1,I=0,H=1,G=1,F=1,E=0] 

### Cost equations --> "Loop" of leq/5 
* CEs [87] --> Loop 82 
* CEs [86] --> Loop 83 
* CEs [89] --> Loop 84 
* CEs [88] --> Loop 85 
* CEs [85] --> Loop 86 
* CEs [84] --> Loop 87 
* CEs [83] --> Loop 88 
* CEs [82] --> Loop 89 

#### Loops of leq/5 
* Loop 82: leq(A,B,C,D,E) [A>=C+1,D>=0,C>=2,B>=0,E=1] 
* Loop 83: leq(A,B,C,D,E) [C>=A,D>=0,B>=0,A>=2,E=1] 
* Loop 84: leq(A,B,C,D,E) [A>=C+1,D>=0,C>=3,B>=1,E=0] 
* Loop 85: leq(A,B,C,D,E) [C>=A,D>=0,B>=1,A>=3,E=0] 
* Loop 86: leq(A,B,C,D,E) [D>=0,B>=1,A>=3,E=0,C=2] 
* Loop 87: leq(A,B,C,D,E) [D>=0,B>=0,A>=2,E=1,C=1] 
* Loop 88: leq(A,B,C,D,E) [D>=0,C>=2,B>=1,E=0,A=2] 
* Loop 89: leq(A,B,C,D,E) [D>=0,C>=0,B>=0,E=1,A=1] 

### Ranking functions of CR leq(A,B,C,D,E) 

#### Partial ranking functions of CR leq(A,B,C,D,E) 


### Resulting Chains:leq(A,B,C,D,E) 
* [89]
* [88]
* [87]
* [86]
* [85]
* [84]
* [83]
* [82]


### Merging Chains  leq/5 into  External patterns of execution 
* [[89]] --> 1 
* [[88]] --> 2 
* [[87]] --> 3 
* [[86]] --> 4 
* [[85]] --> 5 
* [[84]] --> 6 
* [[83]] --> 7 
* [[82]] --> 8 


### Specialization of cost equations case_8/12 
* CE 23 is refined into CE [90] 
* CE 22 is refined into CE [91,92,93] 


#### Refined cost equations case_8/12 
* CE 90: case_8(A,B,C,D,E,F,G,H,I,J,B,C) = 1
     [J>=0,I>=1,H>=2,G>=0,F>=0,C>=0,B>=2,H+J=E,I+1=D,A=1] 
* CE 91: case_8(A,B,C,D,E,F,G,H,I,J,K,L) = 2+ add(M,G,B,C,N,L):1
     [L>=0,C>=0,B>=2,G>=0,J>=0,I>=1,J+1=E,I+1=D,N=1,M=1,K=1,H=1,F=1,A=1] 
* CE 92: case_8(A,B,C,D,E,F,G,H,I,J,F,K) = 2+ add(F,G,B,C,F,K):3
     [B>=F,K>=0,F>=2,C>=0,G>=0,J>=0,I>=1,J+1=E,I+1=D,H=1,A=1] 
* CE 93: case_8(A,B,C,D,E,F,G,H,I,J,B,K) = 2+ add(F,G,B,C,B,K):4
     [F>=B+1,K>=0,B>=2,C>=0,G>=0,J>=0,I>=1,J+1=E,I+1=D,H=1,A=1] 

### Cost equations --> "Loop" of case_8/12 
* CEs [90] --> Loop 90 
* CEs [92] --> Loop 91 
* CEs [93] --> Loop 92 
* CEs [91] --> Loop 93 

#### Loops of case_8/12 
* Loop 90: case_8(A,B,C,D,E,F,G,H,I,J,B,C) [E>=H,H>=2,G>=0,F>=0,D>=2,C>=0,B>=2,H+J=E,D=I+1,A=1] 
* Loop 91: case_8(A,B,C,D,E,F,G,H,I,J,F,K) [B>=F,K>=0,G>=0,F>=2,E>=1,D>=2,C>=0,E=J+1,D=I+1,H=1,A=1] 
* Loop 92: case_8(A,B,C,D,E,F,G,H,I,J,B,K) [F>=B+1,K>=0,G>=0,E>=1,D>=2,C>=0,B>=2,E=J+1,D=I+1,H=1,A=1] 
* Loop 93: case_8(A,B,C,D,E,F,G,H,I,J,K,L) [L>=0,G>=0,E>=1,D>=2,C>=0,B>=2,E=J+1,D=I+1,K=1,H=1,F=1,A=1] 

### Ranking functions of CR case_8(A,B,C,D,E,F,G,H,I,J,K,L) 

#### Partial ranking functions of CR case_8(A,B,C,D,E,F,G,H,I,J,K,L) 


### Resulting Chains:case_8(A,B,C,D,E,F,G,H,I,J,K,L) 
* [93]
* [92]
* [91]
* [90]


### Merging Chains  case_8/12 into  External patterns of execution 
* [[93]] --> 1 
* [[92]] --> 2 
* [[91]] --> 3 
* [[90]] --> 4 


### Specialization of cost equations mult/6 
* CE 10 is refined into CE [94] 
* CE 9 is refined into CE [95,96,97,98] 


#### Refined cost equations mult/6 
* CE 94: mult(A,B,C,D,E,F) = 3
     [F>=0,D>=0,C>=0,B>=0,E=1,A=1] 
* CE 95: mult(A,B,C,D,E,F) = 10+ mult(G,H,I,D,J,K)+ case_8(L,M,K,N,O,P,D,Q,G,H,R,F):1
     [F>=0,H>=0,G>=1,D>=0,K>=0,M>=2,M=J+1,H+1=O,G+1=N,H+1=B,G+1=A,I=1,R=1,Q=1,P=1,L=1,E=1,C=1] 
* CE 96: mult(A,B,C,D,E,F) = 10+ mult(G,H,C,D,I,J)+ case_8(K,E,J,L,M,C,D,N,G,H,E,F):2
     [C>=E+1,F>=0,E>=2,H>=0,G>=1,D>=0,J>=0,E=I+1,H+1=M,G+1=L,H+1=B,G+1=A,N=1,K=1] 
* CE 97: mult(A,B,C,D,C,E) = 10+ mult(F,G,C,D,H,I)+ case_8(J,K,I,L,M,C,D,N,F,G,C,E):3
     [K>=C,E>=0,C>=2,G>=0,F>=1,D>=0,I>=0,K=H+1,G+1=M,F+1=L,G+1=B,F+1=A,N=1,J=1] 
* CE 98: mult(A,B,C,D,E,F) = 10+ mult(G,H,C,D,I,F)+ case_8(J,E,F,K,L,C,D,M,G,H,E,F):4
     [F>=0,E>=2,H>=0,G>=1,M>=2,D>=0,C>=0,M+H=L,M+H=B,E=I+1,G+1=K,G+1=A,J=1] 

### Cost equations --> "Loop" of mult/6 
* CEs [98] --> Loop 94 
* CEs [96] --> Loop 95 
* CEs [97] --> Loop 96 
* CEs [95] --> Loop 97 
* CEs [94] --> Loop 98 

#### Loops of mult/6 
* Loop 94: mult(A,B,C,D,E,F)->  mult(A',B',C,D,C',F)
                  [B>=B'+2,B'>=0,F>=0,E>=2,D>=0,C>=0,A>=2,E=C'+1,A=A'+1] 
* Loop 95: mult(A,B,C,D,E,F)->  mult(A',B',C,D,C',D')
                  [C>=E+1,D'>=0,F>=0,E>=2,D>=0,B>=1,A>=2,E=C'+1,B=B'+1,A=A'+1] 
* Loop 96: mult(A,B,C,D,C,E)->  mult(A',B',C,D,C',D')
                  [C'+1>=C,D'>=0,E>=0,D>=0,C>=2,B>=1,A>=2,B=B'+1,A=A'+1] 
* Loop 97: mult(A,B,C,D,E,F)->  mult(A',B',C',D,D',E')
                  [E'>=0,D'>=1,F>=0,D>=0,B>=1,A>=2,B=B'+1,A=A'+1,C'=1,E=1,C=1] 
* Loop 98: mult(A,B,C,D,E,F) [F>=0,D>=0,C>=0,B>=0,E=1,A=1] 

### Ranking functions of CR mult(A,B,C,D,E,F) 
* RF of phase [94,95,96,97]: [A-1,B,B+C-1]

#### Partial ranking functions of CR mult(A,B,C,D,E,F) 
* Partial RF of phase [94,95,96,97]:
  - RF of loop [94:1]:
    B/2-1/2
  - RF of loop [94:1,95:1,96:1,97:1]:
    A-1
  - RF of loop [95:1,96:1,97:1]:
    B

Discarded unfeasible chain [[94,95,96,97]]...(Non-terminating chain proved terminating)

### Resulting Chains:mult(A,B,C,D,E,F) 
* [[94,95,96,97],98]
* [98]


### Merging Chains  mult/6 into  External patterns of execution 
* [[98]] --> 1 
* [[98,[94,95,96,97]]] --> 2 


### Specialization of cost equations case_14/25 
* CE 27 is refined into CE [99] 
* CE 26 is refined into CE [100] 


#### Refined cost equations case_14/25 
* CE 99: case_14(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,C,T,U,V,W,X) = 3
     [X>=T+U,U>=2,T>=0,C>=1,S>=0,Q>=0,P>=1,O>=0,N>=0,M>=1,L>=0,K>=0,S+X=F+T+U,X=R+T+U,O+Q=J,L+N=H,T+U=D,C+1=W,P+1=I,M+1=G,V=1,E=1,B=1,A=1] 
* CE 100: case_14(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,C,T,U,V,W,X) = 4
     [T>=0,C>=1,S>=0,R>=0,Q>=0,P>=1,O>=0,N>=0,M>=1,L>=0,K>=0,O+Q=J,L+N=H,R+S=F,T+1=X,C+1=W,P+1=I,M+1=G,T+1=D,V=1,U=1,E=1,B=1,A=1] 

### Cost equations --> "Loop" of case_14/25 
* CEs [99] --> Loop 99 
* CEs [100] --> Loop 100 

#### Loops of case_14/25 
* Loop 99: case_14(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,C,T,U,V,W,X) [D>=T+2,F>=R,J>=O,H>=L,T>=0,R>=0,O>=0,L>=0,K>=0,I>=2,G>=2,C>=1,D+R=X,F=R+S,O+Q=J,L+N=H,T+U=D,C+1=W,I=P+1,G=M+1,V=1,E=1,B=1,A=1] 
* Loop 100: case_14(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,C,T,U,V,W,D) [F>=R,J>=O,H>=L,R>=0,O>=0,L>=0,K>=0,I>=2,G>=2,D>=1,C>=1,O+Q=J,L+N=H,R+S=F,C+1=W,D=T+1,I=P+1,G=M+1,V=1,U=1,E=1,B=1,A=1] 

### Ranking functions of CR case_14(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y) 

#### Partial ranking functions of CR case_14(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y) 


### Resulting Chains:case_14(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y) 
* [100]
* [99]


### Merging Chains  case_14/25 into  External patterns of execution 
* [[100]] --> 1 
* [[99]] --> 2 


### Specialization of cost equations subp/8 
* CE 14 is refined into CE [101] 
* CE 12 is refined into CE [102] 
* CE 13 is refined into CE [103,104] 


#### Refined cost equations subp/8 
* CE 101: subp(A,B,C,D,E,F,G,H) = 7
     [H>=0,E>=0,D>=0,B>=0,A>=2,G=1,F=1,C=1] 
* CE 102: subp(A,B,C,D,E,F,G,H) = 4
     [H>=0,E>=0,D>=0,C>=0,B>=0,G=1,F=1,A=1] 
* CE 103: subp(A,B,C,D,E,F,G,H) = 18+ diff(I,J,E,K,L):1+ subp(M,N,O,P,Q,R,S,T)+ case_14(U,V,S,W,X,Y,Z,A1,B1,C1,E,I,M,N,J,O,P,D1,Q,S,E1,F1,G1,H1,I1):1
     [I>=E+J,E1>=0,S>=1,Q>=0,D1>=0,P>=0,O>=1,J>=0,N>=0,M>=1,E>=0,J+P=C1,I+N=A1,D1+Q=Y,D1+Q=L,J+P=D,I+N=B,E1+1=T,E1+1=I1,S+1=H1,O+1=B1,M+1=Z,E1+1=W,E1+1=H,S+1=G,O+1=C,M+1=A,R=1,G1=1,F1=1,X=1,V=1,U=1,K=1,F=1] 
* CE 104: subp(A,B,C,D,E,F,G,H) = 18+ diff(I,J,E,K,L):1+ subp(M,N,O,P,Q,R,S,T)+ case_14(U,V,S,W,X,L,Y,Z,A1,B1,E,I,M,N,J,O,P,C1,D1,S,E1,F1,G1,H1,I1):2
     [I>=E+J,L>=C1,F1>=2,E1>=0,S>=1,C1>=0,P>=0,O>=1,J>=0,N>=0,M>=1,E>=0,C1+E1+F1=I1,C1+E1+F1=H,E1+F1=T,L=C1+Q,L=C1+D1,J+P=B1,I+N=Z,E1+F1=W,J+P=D,I+N=B,S+1=H1,O+1=A1,M+1=Y,S+1=G,O+1=C,M+1=A,R=1,G1=1,X=1,V=1,U=1,K=1,F=1] 

### Cost equations --> "Loop" of subp/8 
* CEs [104] --> Loop 101 
* CEs [103] --> Loop 102 
* CEs [101] --> Loop 103 
* CEs [102] --> Loop 104 

#### Loops of subp/8 
* Loop 101: subp(A,B,C,D,E,F,G,H)->  subp(A',B',C',D',E',F',G',H')
                  [B+D'>=D+E+B',H>=H',D>=D',H'>=2,E'>=0,D'>=0,B'>=0,G>=2,E>=0,C>=2,A>=2,G=G'+1,C=C'+1,A=A'+1,F'=1,F=1] 
* Loop 102: subp(A,B,C,D,E,F,G,H)->  subp(A',B',C',D',E',F',G',H)
                  [B+D'>=D+E+B',D>=D',E'>=0,D'>=0,B'>=0,H>=1,G>=2,E>=0,C>=2,A>=2,G=G'+1,C=C'+1,A=A'+1,F'=1,F=1] 
* Loop 103: subp(A,B,C,D,E,F,G,H) [H>=0,E>=0,D>=0,B>=0,A>=2,G=1,F=1,C=1] 
* Loop 104: subp(A,B,C,D,E,F,G,H) [H>=0,E>=0,D>=0,C>=0,B>=0,G=1,F=1,A=1] 

### Ranking functions of CR subp(A,B,C,D,E,F,G,H) 
* RF of phase [101,102]: [A-1,C-1]

#### Partial ranking functions of CR subp(A,B,C,D,E,F,G,H) 
* Partial RF of phase [101,102]:
  - RF of loop [101:1,102:1]:
    A-1
    C-1

Discarded unfeasible chain [[101,102]]...(Non-terminating chain proved terminating)

### Resulting Chains:subp(A,B,C,D,E,F,G,H) 
* [[101,102],104]
* [[101,102],103]
* [104]
* [103]


### Merging Chains  subp/8 into  External patterns of execution 
* [[104]] --> 1 
* [[103]] --> 2 
* [[104,[101,102]]] --> 3 
* [[103,[101,102]]] --> 4 


### Specialization of cost equations sub/6 
* CE 15 is refined into CE [105,106,107,108] 


#### Refined cost equations sub/6 
* CE 105: sub(A,B,C,D,E,F) = 5+ subp(G,B,C,D,H,I,J,K):1
     [K>=0,D>=0,C>=0,B>=0,F>=0,J=1,I=1,H=0,G=1,E=1,A=1] 
* CE 106: sub(A,B,C,D,E,F) = 5+ subp(A,B,G,D,H,I,J,K):2
     [K>=0,D>=0,B>=0,A>=2,F>=0,J=1,I=1,H=0,G=1,E=1,C=1] 
* CE 107: sub(A,B,C,D,A,E) = 5+ subp(A,B,C,D,F,G,A,H):3
     [C>=A,H>=1,A>=2,D>=0,B>=0,E>=0,G=1,F=0] 
* CE 108: sub(A,B,C,D,C,E) = 5+ subp(A,B,C,D,F,G,C,H):4
     [A>=C+1,H>=1,C>=2,D>=0,B>=0,E>=0,G=1,F=0] 

### Cost equations --> "Loop" of sub/6 
* CEs [108] --> Loop 105 
* CEs [107] --> Loop 106 
* CEs [106] --> Loop 107 
* CEs [105] --> Loop 108 

#### Loops of sub/6 
* Loop 105: sub(A,B,C,D,C,E) [A>=C+1,E>=0,D>=0,C>=2,B>=0] 
* Loop 106: sub(A,B,C,D,A,E) [C>=A,E>=0,D>=0,B>=0,A>=2] 
* Loop 107: sub(A,B,C,D,E,F) [F>=0,D>=0,B>=0,A>=2,E=1,C=1] 
* Loop 108: sub(A,B,C,D,E,F) [F>=0,D>=0,C>=0,B>=0,E=1,A=1] 

### Ranking functions of CR sub(A,B,C,D,E,F) 

#### Partial ranking functions of CR sub(A,B,C,D,E,F) 


### Resulting Chains:sub(A,B,C,D,E,F) 
* [108]
* [107]
* [106]
* [105]


### Merging Chains  sub/6 into  External patterns of execution 
* [[108]] --> 1 
* [[107]] --> 2 
* [[106]] --> 3 
* [[105]] --> 4 


Computing Bounds
=====================================

#### Simplifying cost structure of CE 40 

#### Simplifying cost structure of CE 39 

#### Cost of chains of case_3(A,B,C,D,E,F,G,H,I):
* Chain [40]: 4
  with precondition: [A=2,B=1,C=0,D=2,H=1,I=1,E+F+G=2,E>=0,F>=0,2>=E+F] 

* Chain [39]: 4
  with precondition: [A=2,B=1,C=0,H=1,I=2,E+F+G=D,E>=0,F>=0,G>=0,E+F+G>=3] 


#### Simplifying cost structure of CE 43 

#### Simplifying cost structure of CE 41 

#### Simplifying cost structure of CE 42 

#### Cost of chains of case_2(A,B,C,D,E,F,G,H):
* Chain [43]: 4
  with precondition: [A=1,B=0,C=1,G=1,H=1,D+E+F=1,D>=0,E>=0,1>=D+E] 

* Chain [42]: 7
  with precondition: [A=1,B=0,C=2,G=1,H=1,D+E+F=2,D>=0,E>=0,2>=D+E] 

* Chain [41]: 7
  with precondition: [A=1,B=0,G=1,H=2,D+E+F=C,D>=0,E>=0,F>=0,D+E+F>=3] 


#### Simplifying cost structure of CE 47 

#### Simplifying cost structure of CE 44 

#### Simplifying cost structure of CE 45 

#### Simplifying cost structure of CE 46 

#### Cost of chains of case_1(A,B,C,D,E,F,G):
* Chain [47]: 4
  with precondition: [A=0,B=0,C=0,D=0,E=0,F=1,G=0] 

* Chain [46]: 7
  with precondition: [A=0,B=1,F=1,G=1,C+D+E=1,C>=0,D>=0,1>=C+D] 

* Chain [45]: 10
  with precondition: [A=0,B=2,F=1,G=1,C+D+E=2,C>=0,D>=0,2>=C+D] 

* Chain [44]: 10
  with precondition: [A=0,F=1,G=2,C+D+E=B,C>=0,D>=0,E>=0,C+D+E>=3] 


#### Simplifying cost structure of CE 48 

#### Simplifying cost structure of CE 49 

#### Simplifying cost structure of CE 50 

#### Simplifying cost structure of CE 51 

#### Cost of chains of sum(A,B,C,D,E):
* Chain [51]: 10
  with precondition: [A=0,B=0,C=0,D=1,E=0] 

* Chain [50]: 13
  with precondition: [D=1,E=1,A+B+C=1,A>=0,B>=0,1>=A+B] 

* Chain [49]: 16
  with precondition: [D=1,E=1,A+B+C=2,A>=0,B>=0,2>=A+B] 

* Chain [48]: 16
  with precondition: [D=1,E=2,A>=0,B>=0,C>=0,A+B+C>=3] 


#### Simplifying cost structure of CE 53 

#### Computing cost of phase [52,53,54,55] 

#### Simplifying cost structure of CE 57 

#### Simplifying cost structure of CE 56 

#### Simplifying cost structure of CE 55 

#### Simplifying cost structure of CE 54 

#### Cost of loops [52,53,54,55] 

 * loop 52:addp(A,B,C,D,E,F,G) -> [addp(A',B',C',D',E',F',G')] 
29
 * loop 53:addp(A,B,C,D,E,F,G) -> [addp(A',B',C',D',E',F',G')] 
29
 * loop 54:addp(A,B,C,D,E,F,G) -> [addp(A',B',C',D',E',F',G')] 
26
 * loop 55:addp(A,B,C,D,E,F,G) -> [addp(A',B',C',D',E',F',G')] 
23
##### Pending set addp(A,B,C,D,E,F,G)
* Psum in Loop 52: [it(52)=<1]
* Psum in Loop 53: [it(53)=<1]
* Psum in Loop 54: [it(54)=<1]
* Psum in Loop 55: [it(55)=<1]

###### Computing sum for it(52)=<1  in Loop 52 
   - Applying inductive sum strategy 
     - head Candidate: C-1 
       - Loop 53 is collaborative and bounds [it(53)] 
       - Loop 54 is collaborative and bounds [it(54)] 
       - Loop 55 is collaborative and bounds [it(55)] 
     - head Candidate: A-1 
       - Loop 53 is collaborative and bounds [it(53)] 
       - Loop 54 is collaborative and bounds [it(54)] 
       - Loop 55 is collaborative and bounds [it(55)] 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - Loop 53 is collaborative and bounds [it(53)] 
       - Loop 54 is collaborative and bounds [it(54)] 
       - Loop 55 is collaborative and bounds [it(55)] 
     - tail Candidate: A-1 
       - Loop 53 is collaborative and bounds [it(53)] 
       - Loop 54 is collaborative and bounds [it(54)] 
       - Loop 55 is collaborative and bounds [it(55)] 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(52)+it(53)+it(54)+it(55)=<C-1,it(52)+it(53)+it(54)+it(55)=<A-1,it(52)+it(53)+it(54)+it(55)=<A-1,it(52)+it(53)+it(54)+it(55)=<C-1,it(52)+it(53)+it(54)+it(55)=<C-C',it(52)+it(53)+it(54)+it(55)=<A-A',it(52)+it(53)+it(54)+it(55)=<A-A',it(52)+it(53)+it(54)+it(55)=<C-C'] 

##### Pending set A
* Psum in Loop 53: [it(53)=<1]
* Psum in Loop 54: [it(54)=<1]
* Psum in Loop 55: [it(55)=<1]

###### Computing sum for it(53)=<1  in Loop 53 
   - Applying inductive sum strategy 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(52)+it(53)+it(54)+it(55)=<C-1,it(52)+it(53)+it(54)+it(55)=<A-1,it(52)+it(53)+it(54)+it(55)=<A-1,it(52)+it(53)+it(54)+it(55)=<C-1,it(52)+it(53)+it(54)+it(55)=<C-C',it(52)+it(53)+it(54)+it(55)=<A-A',it(52)+it(53)+it(54)+it(55)=<A-A',it(52)+it(53)+it(54)+it(55)=<C-C'] 

##### Pending set A
* Psum in Loop 54: [it(54)=<1]
* Psum in Loop 55: [it(55)=<1]

###### Computing sum for it(54)=<1  in Loop 54 
   - Applying inductive sum strategy 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(52)+it(53)+it(54)+it(55)=<C-1,it(52)+it(53)+it(54)+it(55)=<A-1,it(52)+it(53)+it(54)+it(55)=<A-1,it(52)+it(53)+it(54)+it(55)=<C-1,it(52)+it(53)+it(54)+it(55)=<C-C',it(52)+it(53)+it(54)+it(55)=<A-A',it(52)+it(53)+it(54)+it(55)=<A-A',it(52)+it(53)+it(54)+it(55)=<C-C'] 

##### Pending set A
* Psum in Loop 55: [it(55)=<1]

###### Computing sum for it(55)=<1  in Loop 55 
   - Applying inductive sum strategy 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(52)+it(53)+it(54)+it(55)=<C-1,it(52)+it(53)+it(54)+it(55)=<A-1,it(52)+it(53)+it(54)+it(55)=<A-1,it(52)+it(53)+it(54)+it(55)=<C-1,it(52)+it(53)+it(54)+it(55)=<C-C',it(52)+it(53)+it(54)+it(55)=<A-A',it(52)+it(53)+it(54)+it(55)=<A-A',it(52)+it(53)+it(54)+it(55)=<C-C'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [52,53,54,55] 

#### Simplifying cost structure of phase [52,53,54,55] 
 * Joined equivalent variables [it(52),it(53),it(54),it(55)] into it(52)

#### Cost of phase [52,53,54,55]:addp(A,B,C,D,E,F,G) -> [addp(A',B',C',D',E',F',G')] 
107*it(52)+0
  Such that:aux(1) =< A
aux(2) =< A-A'
aux(3) =< C
aux(4) =< C-C'
it(52) =< aux(1)
it(52) =< aux(2)
it(52) =< aux(3)
it(52) =< aux(4)

#### Simplifying cost structure of chain [[52,53,54,55],57] 
 * Joined equivalent variables [aux(5),aux(1),aux(2),aux(4)] into aux(5)

#### Simplifying cost structure of CE 52 

#### Found solution for phase  [52,53,54,55] in the cache 

#### Cost of phase [52,53,54,55]:addp(A,B,C,D,E,F,G) -> [addp(A',B',C',D',E',F',G')] 
107*it(52)+0
  Such that:aux(1) =< A
aux(2) =< A-A'
aux(3) =< C
aux(4) =< C-C'
it(52) =< aux(1)
it(52) =< aux(2)
it(52) =< aux(3)
it(52) =< aux(4)

#### Simplifying cost structure of chain [[52,53,54,55],56] 
 * Joined equivalent variables [aux(6),aux(2),aux(3),aux(4)] into aux(6)

#### Cost of chains of addp(A,B,C,D,E,F,G):
* Chain [[52,53,54,55],57]: 107*it(52)+3
  Such that:aux(3) =< C
aux(5) =< A
it(52) =< aux(5)
it(52) =< aux(3)

  with precondition: [A=F,A>=2,B>=0,D>=0,E>=0,G>=0,C>=A] 

* Chain [[52,53,54,55],56]: 107*it(52)+6
  Such that:aux(1) =< A
aux(6) =< C
it(52) =< aux(1)
it(52) =< aux(6)

  with precondition: [C=F,B>=0,C>=2,D>=0,E>=0,G>=0,A>=C+1] 

* Chain [57]: 3
  with precondition: [A=1,F=1,B>=0,C>=0,D>=0,E>=0,G>=0] 

* Chain [56]: 6
  with precondition: [C=1,F=1,A>=2,B>=0,D>=0,E>=0,G>=0] 


#### Simplifying cost structure of CE 58 

#### Simplifying cost structure of CE 59 
 * Renamed intermediate variables: 
[ (eq(60,1),aux(3))>>s(1), (eq(60,1),aux(5))>>s(2), (eq(60,1),it(52))>>s(3)]

#### Simplifying cost structure of CE 60 
 * Renamed intermediate variables: 
[ (eq(61,1),aux(1))>>s(4), (eq(61,1),aux(6))>>s(5), (eq(61,1),it(52))>>s(6)]

#### Simplifying cost structure of CE 61 

#### Cost of chains of add(A,B,C,D,E,F):
* Chain [61]: 5
  with precondition: [A=1,E=1,B>=0,C>=0,D>=0,F>=0] 

* Chain [60]: 8
  with precondition: [C=1,E=1,A>=2,B>=0,D>=0,F>=0] 

* Chain [59]: 107*s(3)+5
  Such that:s(2) =< A
s(1) =< C
s(3) =< s(2)
s(3) =< s(1)

  with precondition: [A=E,A>=2,B>=0,D>=0,F>=0,C>=A] 

* Chain [58]: 107*s(6)+8
  Such that:s(4) =< A
s(5) =< C
s(6) =< s(4)
s(6) =< s(5)

  with precondition: [C=E,B>=0,C>=2,D>=0,F>=0,A>=C+1] 


#### Simplifying cost structure of CE 62 

#### Computing cost of phase [62] 

#### Simplifying cost structure of CE 63 

#### Cost of loops [62] 

 * loop 62:bitToIntp(A,B,C,D) -> [bitToIntp(A',B',C',D')] 
7
##### Pending set bitToIntp(A,B,C,D)
* Psum in Loop 62: [it(62)=<1]

###### Computing sum for it(62)=<1  in Loop 62 
   - Applying inductive sum strategy 
     - head Candidate: A-1 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(62)=<A-1,it(62)=<A-1,it(62)=<A-A',it(62)=<A-A'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [62] 

#### Simplifying cost structure of phase [62] 

#### Cost of phase [62]:bitToIntp(A,B,C,D) -> [bitToIntp(A',B',C',D')] 
7*it(62)+0
  Such that:it(62) =< A
it(62) =< A-A'

#### Simplifying cost structure of chain [[62],63] 

#### Cost of chains of bitToIntp(A,B,C,D):
* Chain [[62],63]: 7*it(62)+3
  Such that:it(62) =< A

  with precondition: [A>=2,B>=0,C>=0,D>=0] 

* Chain [63]: 3
  with precondition: [A=1,D=0,B>=0,C>=0] 


#### Simplifying cost structure of CE 64 
 * Renamed intermediate variables: 
[ (eq(65,1),it(62))>>s(7)]

#### Simplifying cost structure of CE 65 

#### Cost of chains of bitToInt(A,B,C):
* Chain [65]: 5
  with precondition: [A=1,C=0,B>=0] 

* Chain [64]: 7*s(7)+5
  Such that:s(7) =< A

  with precondition: [A>=2,B>=0,C>=0] 


#### Simplifying cost structure of CE 67 

#### Simplifying cost structure of CE 66 

#### Cost of chains of case_19(A,B,C,D,E,F,G,H,I,J,K,L,M):
* Chain [67]: 2
  with precondition: [A=0,B=0,M=0,H+1=C,K+1=E,G=J,G+I=D,G+L=F,G>=0,H>=1,K>=1,D>=G,F>=G] 

* Chain [66]: 2
  with precondition: [A=0,B=0,M=1,H+1=C,K+1=E,D=G+I,F=J+L,H>=1,J>=0,K>=1,D>=G,F>=J,G>=J+1] 


#### Simplifying cost structure of CE 68 

#### Simplifying cost structure of CE 69 

#### Cost of chains of case_18(A,B,C,D,E,F,G,H,I,J,K,L,M):
* Chain [69]: 4
  with precondition: [A=0,B=0,M=0,H+1=C,K+1=E,G=J,G+I=D,G+L=F,G>=0,H>=1,K>=1,D>=G,F>=G] 

* Chain [68]: 4
  with precondition: [A=0,B=0,M=1,H+1=C,K+1=E,G+I=D,J+L=F,H>=1,I>=0,J>=0,K>=1,L>=0,G>=J+1] 


#### Simplifying cost structure of CE 71 

#### Simplifying cost structure of CE 72 

#### Simplifying cost structure of CE 70 

#### Cost of chains of case_17(A,B,C,D,E,F,G,H,I,J,K,L,M):
* Chain [72]: 6
  with precondition: [A=0,B=0,M=0,H+1=C,K+1=E,G=J,G+I=D,G+L=F,G>=0,H>=1,K>=1,D>=G,F>=G] 

* Chain [71]: 6
  with precondition: [A=0,B=0,M=1,H+1=C,K+1=E,G+I=D,J+L=F,H>=1,I>=0,J>=0,K>=1,L>=0,G>=J+1] 

* Chain [70]: 1
  with precondition: [A=0,M=B,H+1=C,K+1=E,D=G+I,F=J+L,G>=0,H>=1,J>=0,K>=1,M>=1,D>=G,F>=J] 


#### Simplifying cost structure of CE 77 

#### Computing cost of phase [77] 

#### Simplifying cost structure of CE 73 

#### Cost of loops [77] 

 * loop 77:compare(A,B,C,D,E) -> [compare(A',B',C',D',E')] 
17
##### Pending set compare(A,B,C,D,E)
* Psum in Loop 77: [it(77)=<1]

###### Computing sum for it(77)=<1  in Loop 77 
   - Applying inductive sum strategy 
     - head Candidate: C-1 
     - head Candidate: A-1 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
     - tail Candidate: A-1 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(77)=<C-1,it(77)=<A-1,it(77)=<A-1,it(77)=<C-1,it(77)=<C-C',it(77)=<A-A',it(77)=<A-A',it(77)=<C-C'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [77] 

#### Simplifying cost structure of phase [77] 

#### Cost of phase [77]:compare(A,B,C,D,E) -> [compare(A',B',C',D',E')] 
17*it(77)+0
  Such that:it(77) =< A
it(77) =< A-A'
it(77) =< C
it(77) =< C-C'

#### Simplifying cost structure of chain [[77],74] 

#### Simplifying cost structure of CE 76 

#### Found solution for phase  [77] in the cache 

#### Cost of phase [77]:compare(A,B,C,D,E) -> [compare(A',B',C',D',E')] 
17*it(77)+0
  Such that:it(77) =< A
it(77) =< A-A'
it(77) =< C
it(77) =< C-C'

#### Simplifying cost structure of chain [[77],73] 

#### Simplifying cost structure of CE 74 

#### Simplifying cost structure of chain [76,[77],74] 

#### Computing cost of phase [75] 

#### Simplifying cost structure of CE 75 

#### Cost of loops [75] 

 * loop 75:compare(A,B,C,D,E) -> [compare(A',B',C',D',E')] 
12
##### Pending set compare(A,B,C,D,E)
* Psum in Loop 75: [it(75)=<1]

###### Computing sum for it(75)=<1  in Loop 75 
   - Applying inductive sum strategy 
     - head Candidate: C-1 
     - head Candidate: A-1 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
     - tail Candidate: A-1 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(75)=<C-1,it(75)=<A-1,it(75)=<A-1,it(75)=<C-1,it(75)=<C-C',it(75)=<A-A',it(75)=<A-A',it(75)=<C-C'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [75] 

#### Simplifying cost structure of phase [75] 

#### Cost of phase [75]:compare(A,B,C,D,E) -> [compare(A',B',C',D',E')] 
12*it(75)+0
  Such that:it(75) =< A
it(75) =< A-A'
it(75) =< C
it(75) =< C-C'

#### Simplifying cost structure of chain [[75],76,[77],74] 
 * Joined equivalent variables [it(75),it(77)] into it(75)

#### Simplifying cost structure of chain [76,[77],73] 

#### Found solution for phase  [75] in the cache 

#### Cost of phase [75]:compare(A,B,C,D,E) -> [compare(A',B',C',D',E')] 
12*it(75)+0
  Such that:it(75) =< A
it(75) =< A-A'
it(75) =< C
it(75) =< C-C'

#### Simplifying cost structure of chain [[75],76,[77],73] 
 * Joined equivalent variables [it(75),it(77)] into it(75)

#### Simplifying cost structure of chain [76,74] 

#### Found solution for phase  [75] in the cache 

#### Cost of phase [75]:compare(A,B,C,D,E) -> [compare(A',B',C',D',E')] 
12*it(75)+0
  Such that:it(75) =< A
it(75) =< A-A'
it(75) =< C
it(75) =< C-C'

#### Simplifying cost structure of chain [[75],76,74] 

#### Simplifying cost structure of chain [76,73] 

#### Found solution for phase  [75] in the cache 

#### Cost of phase [75]:compare(A,B,C,D,E) -> [compare(A',B',C',D',E')] 
12*it(75)+0
  Such that:it(75) =< A
it(75) =< A-A'
it(75) =< C
it(75) =< C-C'

#### Simplifying cost structure of chain [[75],76,73] 
 * Renamed intermediate variables: 
[ (ch([76,[77],74]),it(77))>>s(8)]
 * Renamed intermediate variables: 
[ (ch([[75],76,74]),it(75))>>s(9)]
 * Renamed intermediate variables: 
[ (ch([[75],76,[77],74]),aux(7))>>s(10), (ch([[75],76,[77],74]),it(75))>>s(11)]
 * Joined equivalent variables [aux(9),s(10)] into aux(9)
 * Joined equivalent variables [s(8),s(9)] into s(8)
 * Joined equivalent variables [s(8),s(11)] into s(8)
 * Renamed intermediate variables: 
[ (ch([76,[77],73]),it(77))>>s(12)]
 * Renamed intermediate variables: 
[ (ch([[75],76,73]),it(75))>>s(13)]
 * Renamed intermediate variables: 
[ (ch([[75],76,[77],73]),aux(8))>>s(14), (ch([[75],76,[77],73]),it(75))>>s(15)]
 * Joined equivalent variables [aux(10),s(14)] into aux(10)
 * Joined equivalent variables [s(12),s(13)] into s(12)
 * Joined equivalent variables [s(12),s(15)] into s(12)

#### Cost of chains of compare(A,B,C,D,E):
* Chain [[77],74]: 17*it(77)+3
  Such that:it(77) =< A

  with precondition: [E=0,A>=2,B>=0,D>=0,C>=A] 

* Chain [[77],73]: 17*it(77)+6
  Such that:it(77) =< C

  with precondition: [E=0,B>=0,C>=2,D>=0,A>=C+1] 

* Chain [[75],76,[77],74]: 29*it(75)+20
  Such that:aux(7) =< A
it(75) =< aux(7)

  with precondition: [E=1,A>=4,B>=1,D>=0,C>=A] 

* Chain [[75],76,[77],73]: 29*it(75)+23
  Such that:aux(8) =< C
it(75) =< aux(8)

  with precondition: [E=1,B>=1,C>=4,D>=0,A>=C+1] 

* Chain [[75],76,74]: 12*it(75)+20
  Such that:it(75) =< A

  with precondition: [E=1,A>=3,B>=1,D>=0,C>=A] 

* Chain [[75],76,73]: 12*it(75)+23
  Such that:it(75) =< C

  with precondition: [E=1,B>=1,C>=3,D>=0,A>=C+1] 

* Chain [76,[77],74]: 17*it(77)+20
  Such that:it(77) =< A

  with precondition: [E=1,A>=3,B>=1,D>=0,C>=A] 

* Chain [76,[77],73]: 17*it(77)+23
  Such that:it(77) =< C

  with precondition: [E=1,B>=1,C>=3,D>=0,A>=C+1] 

* Chain [76,74]: 20
  with precondition: [A=2,E=1,B>=1,C>=2,D>=0] 

* Chain [76,73]: 23
  with precondition: [C=2,E=1,A>=3,B>=1,D>=0] 

* Chain [74]: 3
  with precondition: [A=1,E=0,B>=0,C>=0,D>=0] 

* Chain [73]: 6
  with precondition: [C=1,E=0,A>=2,B>=0,D>=0] 


#### Simplifying cost structure of CE 78 

#### Cost of chains of case_9(A,B,C,D,E,F):
* Chain [78]: 2
  with precondition: [B=0,F=0,C=A+D+E,A>=0,D>=0,C>=A+D] 


#### Simplifying cost structure of CE 79 

#### Cost of chains of diff(A,B,C,D,E):
* Chain [79]: 11
  with precondition: [D=1,B>=0,C>=0,E>=0,A>=B+C] 


#### Simplifying cost structure of CE 80 

#### Simplifying cost structure of CE 81 

#### Cost of chains of lt(A,B,C):
* Chain [81]: 0
  with precondition: [A=0,B=1,C=1] 

* Chain [80]: 0
  with precondition: [B=1,C=0,A>=1] 


#### Simplifying cost structure of CE 82 

#### Simplifying cost structure of CE 83 

#### Simplifying cost structure of CE 84 

#### Simplifying cost structure of CE 85 
 * Renamed intermediate variables: 
[ (eq(88,1),aux(9))>>s(16), (eq(88,1),s(8))>>s(17)]

#### Simplifying cost structure of CE 88 
 * Renamed intermediate variables: 
[ (eq(89,1),aux(10))>>s(18), (eq(89,1),s(12))>>s(19)]

#### Simplifying cost structure of CE 89 
 * Renamed intermediate variables: 
[ (eq(86,1),it(77))>>s(20)]

#### Simplifying cost structure of CE 86 
 * Renamed intermediate variables: 
[ (eq(87,1),it(77))>>s(21)]

#### Simplifying cost structure of CE 87 

#### Cost of chains of leq(A,B,C,D,E):
* Chain [89]: 6
  with precondition: [A=1,E=1,B>=0,C>=0,D>=0] 

* Chain [88]: 23
  with precondition: [A=2,E=0,B>=1,C>=2,D>=0] 

* Chain [87]: 9
  with precondition: [C=1,E=1,A>=2,B>=0,D>=0] 

* Chain [86]: 26
  with precondition: [C=2,E=0,A>=3,B>=1,D>=0] 

* Chain [85]: 58*s(17)+23
  Such that:s(16) =< A
s(17) =< s(16)

  with precondition: [E=0,A>=3,B>=1,D>=0,C>=A] 

* Chain [84]: 58*s(19)+26
  Such that:s(18) =< C
s(19) =< s(18)

  with precondition: [E=0,B>=1,C>=3,D>=0,A>=C+1] 

* Chain [83]: 17*s(20)+6
  Such that:s(20) =< A

  with precondition: [E=1,A>=2,B>=0,D>=0,C>=A] 

* Chain [82]: 17*s(21)+9
  Such that:s(21) =< C

  with precondition: [E=1,B>=0,C>=2,D>=0,A>=C+1] 


#### Simplifying cost structure of CE 91 
 * Renamed intermediate variables: 
[ (eq(93,1),s(4))>>s(22), (eq(93,1),s(5))>>s(23), (eq(93,1),s(6))>>s(24)]

#### Simplifying cost structure of CE 93 
 * Renamed intermediate variables: 
[ (eq(92,1),s(2))>>s(25), (eq(92,1),s(1))>>s(26), (eq(92,1),s(3))>>s(27)]

#### Simplifying cost structure of CE 92 

#### Simplifying cost structure of CE 90 

#### Cost of chains of case_8(A,B,C,D,E,F,G,H,I,J,K,L):
* Chain [93]: 7
  with precondition: [A=1,F=1,H=1,K=1,I+1=D,J+1=E,B>=2,C>=0,G>=0,I>=1,J>=0,L>=0] 

* Chain [92]: 107*s(24)+10
  Such that:s(23) =< B
s(22) =< F
s(24) =< s(22)
s(24) =< s(23)

  with precondition: [A=1,H=1,I+1=D,J+1=E,B=K,B>=2,C>=0,G>=0,I>=1,J>=0,L>=0,F>=B+1] 

* Chain [91]: 107*s(27)+7
  Such that:s(26) =< B
s(25) =< F
s(27) =< s(25)
s(27) =< s(26)

  with precondition: [A=1,H=1,I+1=D,J+1=E,F=K,C>=0,F>=2,G>=0,I>=1,J>=0,L>=0,B>=F] 

* Chain [90]: 1
  with precondition: [A=1,L=C,I+1=D,B=K,E=H+J,B>=2,F>=0,G>=0,H>=2,I>=1,L>=0,E>=H] 


#### Simplifying cost structure of CE 94 

#### Computing cost of phase [94,95,96,97] 

#### Simplifying cost structure of CE 98 
 * Renamed intermediate variables: 
[ (eq(96,1),s(23))>>s(28), (eq(96,1),s(22))>>s(29), (eq(96,1),s(24))>>s(30)]

#### Simplifying cost structure of CE 96 
 * Joined equivalent variables [aux(11),s(29)] into aux(11)
 * Renamed intermediate variables: 
[ (it(95),s(28))>>s(31), (it(95),aux(11))>>s(32), (it(95),s(30))>>s(33)]
 * Renamed intermediate variables: 
[ (eq(97,1),s(26))>>s(34), (eq(97,1),s(25))>>s(35), (eq(97,1),s(27))>>s(36)]

#### Simplifying cost structure of CE 97 
 * Renamed intermediate variables: 
[ (it(96),s(34))>>s(37), (it(96),s(35))>>s(38), (it(96),s(36))>>s(39)]

#### Simplifying cost structure of CE 95 

#### Cost of loops [94,95,96,97] 

 * loop 94:mult(A,B,C,D,E,F) -> [mult(A',B',C',D',E',F')] 
11
 * loop 95:mult(A,B,C,D,E,F) -> [mult(A',B',C',D',E',F')] 
107*s(33)+20
  Such that:s(31) =< A'+1
s(32) =< C'
s(31) =< s(32)
s(33) =< s(32)
s(33) =< s(31)

 * loop 96:mult(A,B,C,D,E,F) -> [mult(A',B',C',D',E',F')] 
107*s(39)+17
  Such that:s(37) =< -2*A'+2*B'+C'+4
s(37) =< A'+1
s(38) =< C'
s(39) =< s(38)
s(39) =< s(37)

 * loop 97:mult(A,B,C,D,E,F) -> [mult(A',B',C',D',E',F')] 
17
##### Pending set mult(A,B,C,D,E,F)
* Psum in Loop 94: [it(94)=<1]
* Psum in Loop 95: [it(95)=<1,s(41)=<A'+1,s(42)=<C']
* Psum in Loop 96: [it(96)=<1,s(44)=< -2*A'+2*B'+C'+4,s(44)=<A'+1,s(45)=<C']
* Psum in Loop 97: [it(97)=<1]

###### Computing sum for it(94)=<1  in Loop 94 
   - Applying inductive sum strategy 
     - head Candidate: B+C-1 
       - Loop 95 is collaborative and bounds [it(95)] 
       - Loop 96 is collaborative and bounds [it(96)] 
       - Loop 97 is collaborative and bounds [it(97)] 
     - head Candidate: B 
       - Loop 95 is collaborative and bounds [it(95)] 
       - Loop 96 is collaborative and bounds [it(96)] 
       - Loop 97 is collaborative and bounds [it(97)] 
     - head Candidate: A-1 
       - Loop 95 is collaborative and bounds [it(95)] 
       - Loop 96 is collaborative and bounds [it(96)] 
       - Loop 97 is collaborative and bounds [it(97)] 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: B/2-1/2 
       - Loop 95 is collaborative
       - Loop 96 is collaborative
       - Loop 97 is collaborative
     - tail Candidate: B+C-1 
       - Loop 95 is collaborative and bounds [it(95)] 
       - Loop 96 is collaborative and bounds [it(96)] 
       - Loop 97 is collaborative and bounds [it(97)] 
     - tail Candidate: B 
       - Loop 95 is collaborative and bounds [it(95)] 
       - Loop 96 is collaborative and bounds [it(96)] 
       - Loop 97 is collaborative and bounds [it(97)] 
     - tail Candidate: A-1 
       - Loop 95 is collaborative and bounds [it(95)] 
       - Loop 96 is collaborative and bounds [it(96)] 
       - Loop 97 is collaborative and bounds [it(97)] 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B/2-1/2 
       - Loop 95 is collaborative
       - Loop 96 is collaborative
       - Loop 97 is collaborative
 * Adding constraints: [it(94)+it(95)+it(96)+it(97)=<B+C-1,it(94)+it(95)+it(96)+it(97)=<B,it(94)+it(95)+it(96)+it(97)=<A-1,it(94)+it(95)+it(96)+it(97)=<A-1,it(94)=<B/2-1/2,it(94)+it(95)+it(96)+it(97)=<B+C-B'-C',it(94)+it(95)+it(96)+it(97)=<B-B',it(94)+it(95)+it(96)+it(97)=<A-A',it(94)+it(95)+it(96)+it(97)=<A-A',it(94)=<B/2-B'/2] 

##### Pending set A
* Psum in Loop 95: [it(95)=<1,s(41)=<A'+1,s(42)=<C']
* Psum in Loop 96: [it(96)=<1,s(44)=< -2*A'+2*B'+C'+4,s(44)=<A'+1,s(45)=<C']
* Psum in Loop 97: [it(97)=<1]

###### Computing sum for it(95)=<1  in Loop 95 
   - Applying inductive sum strategy 
     - head Candidate: B+C-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: B 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: B 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B+C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(94)+it(95)+it(96)+it(97)=<B+C-1,it(94)+it(95)+it(96)+it(97)=<B,it(94)+it(95)+it(96)+it(97)=<A-1,it(94)+it(95)+it(96)+it(97)=<A-1,it(94)+it(95)+it(96)+it(97)=<B,it(94)+it(95)+it(96)+it(97)=<B+C-B'-C',it(94)+it(95)+it(96)+it(97)=<B-B',it(94)+it(95)+it(96)+it(97)=<A-A',it(94)+it(95)+it(96)+it(97)=<A-A',it(94)+it(95)+it(96)+it(97)=<B-B'] 

##### Pending set A
* Psum in Loop 95: [s(41)=<A'+1,s(42)=<C']
* Psum in Loop 96: [it(96)=<1,s(44)=< -2*A'+2*B'+C'+4,s(44)=<A'+1,s(45)=<C']
* Psum in Loop 97: [it(97)=<1]

###### Computing sum for s(41)=<A'+1  in Loop 95 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(12)=<A,aux(12)=<B+1] 
 * Adding constraints: [s(41)=<it(95)*aux(12)] 

##### Pending set mult(A,B,C,D,E,F)
* Pmax/min: [aux(12)=<A,aux(12)=<B+1]
* Psum in Loop 95: [s(42)=<C']
* Psum in Loop 96: [it(96)=<1,s(44)=< -2*A'+2*B'+C'+4,s(44)=<A'+1,s(45)=<C']
* Psum in Loop 97: [it(97)=<1]

###### Computing max_min for aux(12)=<A  
   - Found a solution using transitive invariants 
 * Adding constraints:[aux(12)=<A] 

##### Pending set mult(A,B,C,D,E,F)
* Pmax/min: [aux(12)=<B+1]
* Psum in Loop 95: [s(42)=<C']
* Psum in Loop 96: [it(96)=<1,s(44)=< -2*A'+2*B'+C'+4,s(44)=<A'+1,s(45)=<C']
* Psum in Loop 97: [it(97)=<1]

###### Computing max_min for aux(12)=<B+1  
   - Found a solution using transitive invariants 
 * Adding constraints:[aux(12)=<B+1] 

##### Pending set mult(A,B,C,D,E,F)
* Psum in Loop 95: [s(42)=<C']
* Psum in Loop 96: [it(96)=<1,s(44)=< -2*A'+2*B'+C'+4,s(44)=<A'+1,s(45)=<C']
* Psum in Loop 97: [it(97)=<1]

###### Computing sum for s(42)=<C'  in Loop 95 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(13)=<C] 
 * Adding constraints: [s(42)=<it(95)*aux(13)] 

##### Pending set mult(A,B,C,D,E,F)
* Pmax/min: [aux(13)=<C]
* Psum in Loop 96: [it(96)=<1,s(44)=< -2*A'+2*B'+C'+4,s(44)=<A'+1,s(45)=<C']
* Psum in Loop 97: [it(97)=<1]

###### Computing max_min for aux(13)=<C  
   - Found a solution using transitive invariants 
 * Adding constraints:[aux(13)=<C] 

##### Pending set mult(A,B,C,D,E,F)
* Psum in Loop 96: [it(96)=<1,s(44)=< -2*A'+2*B'+C'+4,s(44)=<A'+1,s(45)=<C']
* Psum in Loop 97: [it(97)=<1]

###### Computing sum for it(96)=<1  in Loop 96 
   - Applying inductive sum strategy 
     - head Candidate: B+C-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: B 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: B 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B+C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(94)+it(95)+it(96)+it(97)=<B+C-1,it(94)+it(95)+it(96)+it(97)=<B,it(94)+it(95)+it(96)+it(97)=<A-1,it(94)+it(95)+it(96)+it(97)=<A-1,it(94)+it(95)+it(96)+it(97)=<B,it(94)+it(95)+it(96)+it(97)=<B+C-B'-C',it(94)+it(95)+it(96)+it(97)=<B-B',it(94)+it(95)+it(96)+it(97)=<A-A',it(94)+it(95)+it(96)+it(97)=<A-A',it(94)+it(95)+it(96)+it(97)=<B-B'] 

##### Pending set mult(A,B,C,D,E,F)
* Psum in Loop 96: [s(44)=< -2*A'+2*B'+C'+4,s(44)=<A'+1,s(45)=<C']
* Psum in Loop 97: [it(97)=<1]

###### Computing sum for s(44)=< -2*A'+2*B'+C'+4  in Loop 96 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(14)=<2*B-C+4,aux(14)=< -2*A+2*B+C+4] 
 * Adding constraints: [s(44)=<it(96)*aux(14)] 

##### Pending set mult(A,B,C,D,E,F)
* Pmax/min: [aux(14)=< -2*A+2*B+C+4,aux(14)=<2*B-C+4]
* Psum in Loop 96: [s(44)=<A'+1,s(45)=<C']
* Psum in Loop 97: [it(97)=<1]

###### Computing max_min for aux(14)=< -2*A+2*B+C+4  
   - Found a solution using transitive invariants 
 * Adding constraints:[aux(14)=<2*B+C,aux(14)=< -2*A+2*B+C+4] 

##### Pending set mult(A,B,C,D,E,F)
* Pmax/min: [aux(14)=<2*B-C+4]
* Psum in Loop 96: [s(44)=<A'+1,s(45)=<C']
* Psum in Loop 97: [it(97)=<1]

###### Computing max_min for aux(14)=<2*B-C+4  
   - Found a solution using transitive invariants 
 * Adding constraints:[aux(14)=<2*B-C+4] 

##### Pending set mult(A,B,C,D,E,F)
* Psum in Loop 96: [s(44)=<A'+1,s(45)=<C']
* Psum in Loop 97: [it(97)=<1]

###### Computing sum for s(44)=<A'+1  in Loop 96 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(15)=<A,aux(15)=<B+1] 
 * Adding constraints: [s(44)=<it(96)*aux(15)] 

##### Pending set mult(A,B,C,D,E,F)
* Pmax/min: [aux(15)=<A,aux(15)=<B+1]
* Psum in Loop 96: [s(45)=<C']
* Psum in Loop 97: [it(97)=<1]

###### Computing max_min for aux(15)=<A  
   - Found a solution using cacheing 
 * Adding constraints:[aux(15)=<aux(12)] 

##### Pending set mult(A,B,C,D,E,F)
* Pmax/min: [aux(15)=<B+1]
* Psum in Loop 96: [s(45)=<C']
* Psum in Loop 97: [it(97)=<1]

###### Computing max_min for aux(15)=<B+1  
   - Found a solution using cacheing 
 * Adding constraints:[aux(15)=<aux(12)] 

##### Pending set mult(A,B,C,D,E,F)
* Psum in Loop 96: [s(45)=<C']
* Psum in Loop 97: [it(97)=<1]

###### Computing sum for s(45)=<C'  in Loop 96 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(16)=<A,aux(16)=<C] 
 * Adding constraints: [s(45)=<it(96)*aux(16)] 

##### Pending set mult(A,B,C,D,E,F)
* Pmax/min: [aux(16)=<A,aux(16)=<C]
* Psum in Loop 97: [it(97)=<1]

###### Computing max_min for aux(16)=<A  
   - Found a solution using cacheing 
 * Adding constraints:[aux(16)=<aux(12)] 

##### Pending set mult(A,B,C,D,E,F)
* Pmax/min: [aux(16)=<C]
* Psum in Loop 97: [it(97)=<1]

###### Computing max_min for aux(16)=<C  
   - Found a solution using cacheing 
 * Adding constraints:[aux(16)=<aux(13)] 

##### Pending set mult(A,B,C,D,E,F)
* Psum in Loop 97: [it(97)=<1]

###### Computing sum for it(97)=<1  in Loop 97 
   - Applying inductive sum strategy 
     - head Candidate: B+C-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: B 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: B 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B+C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(94)+it(95)+it(96)+it(97)=<B+C-1,it(94)+it(95)+it(96)+it(97)=<B,it(94)+it(95)+it(96)+it(97)=<A-1,it(94)+it(95)+it(96)+it(97)=<A-1,it(94)+it(95)+it(96)+it(97)=<B,it(94)+it(95)+it(96)+it(97)=<B+C-B'-C',it(94)+it(95)+it(96)+it(97)=<B-B',it(94)+it(95)+it(96)+it(97)=<A-A',it(94)+it(95)+it(96)+it(97)=<A-A',it(94)+it(95)+it(96)+it(97)=<B-B'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [94,95,96,97] 

#### Simplifying cost structure of phase [94,95,96,97] 
 * Joined equivalent variables [it(95),it(96),it(97)] into it(95)

#### Cost of phase [94,95,96,97]:mult(A,B,C,D,E,F) -> [mult(A',B',C',D',E',F')] 
11*it(94)+54*it(95)+107*s(40)+107*s(43)+0
  Such that:aux(14) =< -2*A+2*B+C+4
aux(12) =< B+1
aux(14) =< 2*B-C+4
aux(14) =< 2*B+C
it(94) =< B/2
it(94) =< B/2-B'/2
aux(13) =< C
aux(17) =< A
aux(18) =< A-A'
aux(19) =< B
aux(20) =< B+C
aux(21) =< B+C-B'-C'
aux(22) =< B-B'
aux(12) =< aux(17)
it(94) =< aux(17)
it(95) =< aux(17)
it(94) =< aux(18)
it(95) =< aux(18)
it(94) =< aux(19)
it(95) =< aux(19)
it(94) =< aux(20)
it(95) =< aux(20)
it(94) =< aux(21)
it(95) =< aux(21)
it(94) =< aux(22)
it(95) =< aux(22)
aux(16) =< aux(13)
aux(16) =< aux(12)
aux(15) =< aux(12)
s(44) =< it(95)*aux(14)
s(42) =< it(95)*aux(13)
s(41) =< it(95)*aux(12)
s(45) =< it(95)*aux(16)
s(44) =< it(95)*aux(15)
s(43) =< s(45)
s(43) =< s(44)
s(41) =< s(42)
s(40) =< s(42)
s(40) =< s(41)

#### Simplifying cost structure of chain [[94,95,96,97],98] 
 * Joined equivalent variables [aux(23),aux(17),aux(18)] into aux(23)
 * Joined equivalent variables [aux(24),aux(19),aux(21),aux(22)] into aux(24)

#### Cost of chains of mult(A,B,C,D,E,F):
* Chain [[94,95,96,97],98]: 11*it(94)+54*it(95)+107*s(40)+107*s(43)+3
  Such that:aux(14) =< -2*A+2*B+C+4
aux(12) =< B+1
aux(20) =< B+C
aux(14) =< 2*B-C+4
it(94) =< B/2
aux(13) =< C
aux(23) =< A
aux(24) =< B
aux(12) =< aux(23)
it(94) =< aux(23)
it(95) =< aux(23)
it(94) =< aux(24)
it(95) =< aux(24)
it(94) =< aux(20)
it(95) =< aux(20)
aux(16) =< aux(13)
aux(16) =< aux(12)
aux(15) =< aux(12)
s(44) =< it(95)*aux(14)
s(42) =< it(95)*aux(13)
s(41) =< it(95)*aux(12)
s(45) =< it(95)*aux(16)
s(44) =< it(95)*aux(15)
s(43) =< s(45)
s(43) =< s(44)
s(41) =< s(42)
s(40) =< s(42)
s(40) =< s(41)

  with precondition: [A>=2,C>=0,D>=0,E>=1,F>=0,B+1>=A,A>=E,C+E>=2,C+2*B+2>=2*A+E] 

* Chain [98]: 3
  with precondition: [A=1,E=1,B>=0,C>=0,D>=0,F>=0] 


#### Simplifying cost structure of CE 100 

#### Simplifying cost structure of CE 99 

#### Cost of chains of case_14(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y):
* Chain [100]: 4
  with precondition: [A=1,B=1,E=1,V=1,W=1,T=C,U+1=D,M+1=G,P+1=I,T+1=X,U+1=Y,H=L+N,J=O+Q,F=R+S,K>=0,L>=0,M>=1,O>=0,P>=1,R>=0,T>=1,U>=0,H>=L,J>=O,F>=R] 

* Chain [99]: 3
  with precondition: [A=1,B=1,E=1,W=1,T=C,M+1=G,P+1=I,T+1=X,R+S=F,H=L+N,J=O+Q,D=U+V,D+R=Y,K>=0,L>=0,M>=1,O>=0,P>=1,R>=0,S>=0,T>=1,U>=0,H>=L,J>=O,D>=U+2] 


#### Simplifying cost structure of CE 102 

#### Computing cost of phase [101,102] 

#### Simplifying cost structure of CE 104 

#### Simplifying cost structure of CE 103 

#### Cost of loops [101,102] 

 * loop 101:subp(A,B,C,D,E,F,G,H) -> [subp(A',B',C',D',E',F',G',H')] 
32
 * loop 102:subp(A,B,C,D,E,F,G,H) -> [subp(A',B',C',D',E',F',G',H')] 
33
##### Pending set subp(A,B,C,D,E,F,G,H)
* Psum in Loop 101: [it(101)=<1]
* Psum in Loop 102: [it(102)=<1]

###### Computing sum for it(101)=<1  in Loop 101 
   - Applying inductive sum strategy 
     - head Candidate: C-1 
       - Loop 102 is collaborative and bounds [it(102)] 
     - head Candidate: A-1 
       - Loop 102 is collaborative and bounds [it(102)] 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - Loop 102 is collaborative and bounds [it(102)] 
     - tail Candidate: A-1 
       - Loop 102 is collaborative and bounds [it(102)] 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(101)+it(102)=<C-1,it(101)+it(102)=<A-1,it(101)+it(102)=<A-1,it(101)+it(102)=<C-1,it(101)+it(102)=<C-C',it(101)+it(102)=<A-A',it(101)+it(102)=<A-A',it(101)+it(102)=<C-C'] 

##### Pending set A
* Psum in Loop 102: [it(102)=<1]

###### Computing sum for it(102)=<1  in Loop 102 
   - Applying inductive sum strategy 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(101)+it(102)=<C-1,it(101)+it(102)=<A-1,it(101)+it(102)=<A-1,it(101)+it(102)=<C-1,it(101)+it(102)=<C-C',it(101)+it(102)=<A-A',it(101)+it(102)=<A-A',it(101)+it(102)=<C-C'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [101,102] 

#### Simplifying cost structure of phase [101,102] 
 * Joined equivalent variables [it(101),it(102)] into it(101)

#### Cost of phase [101,102]:subp(A,B,C,D,E,F,G,H) -> [subp(A',B',C',D',E',F',G',H')] 
65*it(101)+0
  Such that:aux(25) =< A
aux(26) =< A-A'
aux(27) =< C
aux(28) =< C-C'
it(101) =< aux(25)
it(101) =< aux(26)
it(101) =< aux(27)
it(101) =< aux(28)

#### Simplifying cost structure of chain [[101,102],104] 
 * Joined equivalent variables [aux(29),aux(25),aux(26),aux(28)] into aux(29)

#### Simplifying cost structure of CE 101 

#### Found solution for phase  [101,102] in the cache 

#### Cost of phase [101,102]:subp(A,B,C,D,E,F,G,H) -> [subp(A',B',C',D',E',F',G',H')] 
65*it(101)+0
  Such that:aux(25) =< A
aux(26) =< A-A'
aux(27) =< C
aux(28) =< C-C'
it(101) =< aux(25)
it(101) =< aux(26)
it(101) =< aux(27)
it(101) =< aux(28)

#### Simplifying cost structure of chain [[101,102],103] 
 * Joined equivalent variables [aux(30),aux(26),aux(27),aux(28)] into aux(30)

#### Cost of chains of subp(A,B,C,D,E,F,G,H):
* Chain [[101,102],104]: 65*it(101)+4
  Such that:aux(27) =< C
aux(29) =< A
it(101) =< aux(29)
it(101) =< aux(27)

  with precondition: [F=1,A=G,A>=2,D>=0,E>=0,H>=1,C>=A,B>=E] 

* Chain [[101,102],103]: 65*it(101)+7
  Such that:aux(25) =< A
aux(30) =< C
it(101) =< aux(25)
it(101) =< aux(30)

  with precondition: [F=1,C=G,C>=2,D>=0,E>=0,H>=1,A>=C+1,B>=E] 

* Chain [104]: 4
  with precondition: [A=1,F=1,G=1,B>=0,C>=0,D>=0,E>=0,H>=0] 

* Chain [103]: 7
  with precondition: [C=1,F=1,G=1,A>=2,B>=0,D>=0,E>=0,H>=0] 


#### Simplifying cost structure of CE 105 

#### Simplifying cost structure of CE 106 
 * Renamed intermediate variables: 
[ (eq(107,1),aux(27))>>s(46), (eq(107,1),aux(29))>>s(47), (eq(107,1),it(101))>>s(48)]

#### Simplifying cost structure of CE 107 
 * Renamed intermediate variables: 
[ (eq(108,1),aux(25))>>s(49), (eq(108,1),aux(30))>>s(50), (eq(108,1),it(101))>>s(51)]

#### Simplifying cost structure of CE 108 

#### Cost of chains of sub(A,B,C,D,E,F):
* Chain [108]: 9
  with precondition: [A=1,E=1,B>=0,C>=0,D>=0,F>=0] 

* Chain [107]: 12
  with precondition: [C=1,E=1,A>=2,B>=0,D>=0,F>=0] 

* Chain [106]: 65*s(48)+9
  Such that:s(47) =< A
s(46) =< C
s(48) =< s(47)
s(48) =< s(46)

  with precondition: [A=E,A>=2,B>=0,D>=0,F>=0,C>=A] 

* Chain [105]: 65*s(51)+12
  Such that:s(49) =< A
s(50) =< C
s(51) =< s(49)
s(51) =< s(50)

  with precondition: [C=E,B>=0,C>=2,D>=0,F>=0,A>=C+1] 


Closed-form bounds of bitToIntp(A,B,C,D): 
-------------------------------------
* Chain [[62],63] with precondition: [A>=2,B>=0,C>=0,D>=0] 
    - Upper bound: 7*A+3 
    - Complexity: n 
* Chain [63] with precondition: [A=1,D=0,B>=0,C>=0] 
    - Upper bound: 3 
    - Complexity: constant 

### Maximum cost of bitToIntp(A,B,C,D): 7*A+3 
Asymptotic class: n 

Closed-form bounds of bitToInt(A,B,C): 
-------------------------------------
* Chain [65] with precondition: [A=1,C=0,B>=0] 
    - Upper bound: 5 
    - Complexity: constant 
* Chain [64] with precondition: [A>=2,B>=0,C>=0] 
    - Upper bound: 7*A+5 
    - Complexity: n 

### Maximum cost of bitToInt(A,B,C): 7*A+5 
Asymptotic class: n 

Closed-form bounds of sum(A,B,C,D,E): 
-------------------------------------
* Chain [51] with precondition: [A=0,B=0,C=0,D=1,E=0] 
    - Upper bound: 10 
    - Complexity: constant 
* Chain [50] with precondition: [D=1,E=1,A+B+C=1,A>=0,B>=0,1>=A+B] 
    - Upper bound: 13 
    - Complexity: constant 
* Chain [49] with precondition: [D=1,E=1,A+B+C=2,A>=0,B>=0,2>=A+B] 
    - Upper bound: 16 
    - Complexity: constant 
* Chain [48] with precondition: [D=1,E=2,A>=0,B>=0,C>=0,A+B+C>=3] 
    - Upper bound: 16 
    - Complexity: constant 

### Maximum cost of sum(A,B,C,D,E): 16 
Asymptotic class: constant 

Closed-form bounds of addp(A,B,C,D,E,F,G): 
-------------------------------------
* Chain [[52,53,54,55],57] with precondition: [A=F,A>=2,B>=0,D>=0,E>=0,G>=0,C>=A] 
    - Upper bound: 107*A+3 
    - Complexity: n 
* Chain [[52,53,54,55],56] with precondition: [C=F,B>=0,C>=2,D>=0,E>=0,G>=0,A>=C+1] 
    - Upper bound: 107*A+6 
    - Complexity: n 
* Chain [57] with precondition: [A=1,F=1,B>=0,C>=0,D>=0,E>=0,G>=0] 
    - Upper bound: 3 
    - Complexity: constant 
* Chain [56] with precondition: [C=1,F=1,A>=2,B>=0,D>=0,E>=0,G>=0] 
    - Upper bound: 6 
    - Complexity: constant 

### Maximum cost of addp(A,B,C,D,E,F,G): 107*A+6 
Asymptotic class: n 

Closed-form bounds of add(A,B,C,D,E,F): 
-------------------------------------
* Chain [61] with precondition: [A=1,E=1,B>=0,C>=0,D>=0,F>=0] 
    - Upper bound: 5 
    - Complexity: constant 
* Chain [60] with precondition: [C=1,E=1,A>=2,B>=0,D>=0,F>=0] 
    - Upper bound: 8 
    - Complexity: constant 
* Chain [59] with precondition: [A=E,A>=2,B>=0,D>=0,F>=0,C>=A] 
    - Upper bound: 107*A+5 
    - Complexity: n 
* Chain [58] with precondition: [C=E,B>=0,C>=2,D>=0,F>=0,A>=C+1] 
    - Upper bound: 107*A+8 
    - Complexity: n 

### Maximum cost of add(A,B,C,D,E,F): 107*A+8 
Asymptotic class: n 

Closed-form bounds of mult(A,B,C,D,E,F): 
-------------------------------------
* Chain [[94,95,96,97],98] with precondition: [A>=2,C>=0,D>=0,E>=1,F>=0,B+1>=A,A>=E,C+E>=2,C+2*B+2>=2*A+E] 
    - Upper bound: 54*A+3+214*C*A+11/2*B 
    - Complexity: n^2 
* Chain [98] with precondition: [A=1,E=1,B>=0,C>=0,D>=0,F>=0] 
    - Upper bound: 3 
    - Complexity: constant 

### Maximum cost of mult(A,B,C,D,E,F): 214*C*A+54*A+11/2*B+3 
Asymptotic class: n^2 

Closed-form bounds of diff(A,B,C,D,E): 
-------------------------------------
* Chain [79] with precondition: [D=1,B>=0,C>=0,E>=0,A>=B+C] 
    - Upper bound: 11 
    - Complexity: constant 

### Maximum cost of diff(A,B,C,D,E): 11 
Asymptotic class: constant 

Closed-form bounds of subp(A,B,C,D,E,F,G,H): 
-------------------------------------
* Chain [[101,102],104] with precondition: [F=1,A=G,A>=2,D>=0,E>=0,H>=1,C>=A,B>=E] 
    - Upper bound: 65*A+4 
    - Complexity: n 
* Chain [[101,102],103] with precondition: [F=1,C=G,C>=2,D>=0,E>=0,H>=1,A>=C+1,B>=E] 
    - Upper bound: 65*A+7 
    - Complexity: n 
* Chain [104] with precondition: [A=1,F=1,G=1,B>=0,C>=0,D>=0,E>=0,H>=0] 
    - Upper bound: 4 
    - Complexity: constant 
* Chain [103] with precondition: [C=1,F=1,G=1,A>=2,B>=0,D>=0,E>=0,H>=0] 
    - Upper bound: 7 
    - Complexity: constant 

### Maximum cost of subp(A,B,C,D,E,F,G,H): 65*A+7 
Asymptotic class: n 

Closed-form bounds of sub(A,B,C,D,E,F): 
-------------------------------------
* Chain [108] with precondition: [A=1,E=1,B>=0,C>=0,D>=0,F>=0] 
    - Upper bound: 9 
    - Complexity: constant 
* Chain [107] with precondition: [C=1,E=1,A>=2,B>=0,D>=0,F>=0] 
    - Upper bound: 12 
    - Complexity: constant 
* Chain [106] with precondition: [A=E,A>=2,B>=0,D>=0,F>=0,C>=A] 
    - Upper bound: 65*A+9 
    - Complexity: n 
* Chain [105] with precondition: [C=E,B>=0,C>=2,D>=0,F>=0,A>=C+1] 
    - Upper bound: 65*A+12 
    - Complexity: n 

### Maximum cost of sub(A,B,C,D,E,F): 65*A+12 
Asymptotic class: n 

Closed-form bounds of compare(A,B,C,D,E): 
-------------------------------------
* Chain [[77],74] with precondition: [E=0,A>=2,B>=0,D>=0,C>=A] 
    - Upper bound: 17*A+3 
    - Complexity: n 
* Chain [[77],73] with precondition: [E=0,B>=0,C>=2,D>=0,A>=C+1] 
    - Upper bound: 17*C+6 
    - Complexity: n 
* Chain [[75],76,[77],74] with precondition: [E=1,A>=4,B>=1,D>=0,C>=A] 
    - Upper bound: 29*A+20 
    - Complexity: n 
* Chain [[75],76,[77],73] with precondition: [E=1,B>=1,C>=4,D>=0,A>=C+1] 
    - Upper bound: 29*C+23 
    - Complexity: n 
* Chain [[75],76,74] with precondition: [E=1,A>=3,B>=1,D>=0,C>=A] 
    - Upper bound: 12*A+20 
    - Complexity: n 
* Chain [[75],76,73] with precondition: [E=1,B>=1,C>=3,D>=0,A>=C+1] 
    - Upper bound: 12*C+23 
    - Complexity: n 
* Chain [76,[77],74] with precondition: [E=1,A>=3,B>=1,D>=0,C>=A] 
    - Upper bound: 17*A+20 
    - Complexity: n 
* Chain [76,[77],73] with precondition: [E=1,B>=1,C>=3,D>=0,A>=C+1] 
    - Upper bound: 17*C+23 
    - Complexity: n 
* Chain [76,74] with precondition: [A=2,E=1,B>=1,C>=2,D>=0] 
    - Upper bound: 20 
    - Complexity: constant 
* Chain [76,73] with precondition: [C=2,E=1,A>=3,B>=1,D>=0] 
    - Upper bound: 23 
    - Complexity: constant 
* Chain [74] with precondition: [A=1,E=0,B>=0,C>=0,D>=0] 
    - Upper bound: 3 
    - Complexity: constant 
* Chain [73] with precondition: [C=1,E=0,A>=2,B>=0,D>=0] 
    - Upper bound: 6 
    - Complexity: constant 

### Maximum cost of compare(A,B,C,D,E): max([29*C+20,29*A+17])+3 
Asymptotic class: n 

Closed-form bounds of leq(A,B,C,D,E): 
-------------------------------------
* Chain [89] with precondition: [A=1,E=1,B>=0,C>=0,D>=0] 
    - Upper bound: 6 
    - Complexity: constant 
* Chain [88] with precondition: [A=2,E=0,B>=1,C>=2,D>=0] 
    - Upper bound: 23 
    - Complexity: constant 
* Chain [87] with precondition: [C=1,E=1,A>=2,B>=0,D>=0] 
    - Upper bound: 9 
    - Complexity: constant 
* Chain [86] with precondition: [C=2,E=0,A>=3,B>=1,D>=0] 
    - Upper bound: 26 
    - Complexity: constant 
* Chain [85] with precondition: [E=0,A>=3,B>=1,D>=0,C>=A] 
    - Upper bound: 58*A+23 
    - Complexity: n 
* Chain [84] with precondition: [E=0,B>=1,C>=3,D>=0,A>=C+1] 
    - Upper bound: 58*C+26 
    - Complexity: n 
* Chain [83] with precondition: [E=1,A>=2,B>=0,D>=0,C>=A] 
    - Upper bound: 17*A+6 
    - Complexity: n 
* Chain [82] with precondition: [E=1,B>=0,C>=2,D>=0,A>=C+1] 
    - Upper bound: 17*C+9 
    - Complexity: n 

### Maximum cost of leq(A,B,C,D,E): max([58*C+20,58*A+17])+6 
Asymptotic class: n 
* Total analysis performed in 1704 ms.


Cost relation system solved by CoFloCo in 1707 ms.

Method bitToIntp terminates?: YES

 - b_1: size of b wrt. List<Rat>
 - b_2: size of b wrt. Rat
 - n_1: size of n wrt. Rat
UB for bitToIntp(b_1,b_2,n_1) = 7*b_1+3

Method bitToInt terminates?: YES

 - b_1: size of b wrt. List<Rat>
 - b_2: size of b wrt. Rat
UB for bitToInt(b_1,b_2) = 7*b_1+5

Method sum terminates?: YES

 - x_1: size of x wrt. Rat
 - y_1: size of y wrt. Rat
 - r_1: size of r wrt. Rat
UB for sum(x_1,y_1,r_1) = 16

Method addp terminates?: YES

 - b1_1: size of b1 wrt. List<Rat>
 - b1_2: size of b1 wrt. Rat
 - b2_1: size of b2 wrt. List<Rat>
 - b2_2: size of b2 wrt. Rat
 - r_1: size of r wrt. Rat
UB for addp(b1_1,b1_2,b2_1,b2_2,r_1) = 107*b1_1+6

Method add terminates?: YES

 - b1_1: size of b1 wrt. List<Rat>
 - b1_2: size of b1 wrt. Rat
 - b2_1: size of b2 wrt. List<Rat>
 - b2_2: size of b2 wrt. Rat
UB for add(b1_1,b1_2,b2_1,b2_2) = 107*b1_1+8

Method mult terminates?: YES

 - b1_1: size of b1 wrt. List<Rat>
 - b1_2: size of b1 wrt. Rat
 - b2_1: size of b2 wrt. List<Rat>
 - b2_2: size of b2 wrt. Rat
UB for mult(b1_1,b1_2,b2_1,b2_2) = 214*b2_1*b1_1+54*b1_1+11/2*b1_2+3

Method diff terminates?: YES

 - x_1: size of x wrt. Rat
 - y_1: size of y wrt. Rat
 - r_1: size of r wrt. Rat
UB for diff(x_1,y_1,r_1) = 11

Method subp terminates?: YES

 - b1_1: size of b1 wrt. List<Rat>
 - b1_2: size of b1 wrt. Rat
 - b2_1: size of b2 wrt. List<Rat>
 - b2_2: size of b2 wrt. Rat
 - r_1: size of r wrt. Rat
UB for subp(b1_1,b1_2,b2_1,b2_2,r_1) = 65*b1_1+7

Method sub terminates?: YES

 - b1_1: size of b1 wrt. List<Rat>
 - b1_2: size of b1 wrt. Rat
 - b2_1: size of b2 wrt. List<Rat>
 - b2_2: size of b2 wrt. Rat
UB for sub(b1_1,b1_2,b2_1,b2_2) = 65*b1_1+12

Method compare terminates?: YES

 - b1_1: size of b1 wrt. List<Rat>
 - b1_2: size of b1 wrt. Rat
 - b2_1: size of b2 wrt. List<Rat>
 - b2_2: size of b2 wrt. Rat
UB for compare(b1_1,b1_2,b2_1,b2_2) = max([29*b2_1+20,29*b1_1+17])+3
