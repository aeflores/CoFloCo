
Abs program loaded in 12 ms.

Rule based representation generated in 1 ms.

Rule based representation stored in /tmp/costabs/rbr.rbr

RBR properties stored in /tmp/costabs/rbr.properties

Class invariants generated and loaded in 0 ms.

Abstract compilation performed in 7 ms.

Cost relation system stored in /tmp/costabs/crs.crs

Generated 37 equations 
entry('eqD'(A,B,C,D,E):[]).
entry('removeL'(A,B,C,D,E,F,G,H):[]).
entry('nub'(A,B,C,D,E,F):[]).
input_output_vars('and_op'(A,B,C),[A,B],[C]).
input_output_vars('case_0'(A,B,C,D,E),[A,B,C,D],[E]).
input_output_vars('case_1'(A,B,C,D,E),[A,B,C,D],[E]).
input_output_vars('case_2'(A,B,C,D,E,F,G,H),[A,B,C,D,E,F,G],[H]).
input_output_vars('case_3'(A,B,C,D,E,F,G,H),[A,B,C,D,E],[F,G,H]).
input_output_vars('case_4'(A,B,C,D,E,F,G,H,I,J,K,L,M,N),[A,B,C,D,E,F,G,H,I,J,K],[L,M,N]).
input_output_vars('case_5'(A,B,C,D,E,F),[A,B,C],[D,E,F]).
input_output_vars('eq'(A,B,C),[A,B],[C]).
input_output_vars('eqD'(A,B,C,D,E),[A,B,C,D],[E]).
input_output_vars('geq'(A,B,C),[A,B],[C]).
input_output_vars('gt'(A,B,C),[A,B],[C]).
input_output_vars('leq'(A,B,C),[A,B],[C]).
input_output_vars('lt'(A,B,C),[A,B],[C]).
input_output_vars('maxNorm'(A,B,C),[A,B],[C]).
input_output_vars('neg'(A,B),[A],[B]).
input_output_vars('neq'(A,B,C),[A,B],[C]).
input_output_vars('nub'(A,B,C,D,E,F),[A,B,C],[D,E,F]).
input_output_vars('or'(A,B,C),[A,B],[C]).
input_output_vars('removeL'(A,B,C,D,E,F,G,H),[A,B,C,D,E],[F,G,H]).
eq('eq',[A,B,C],0,[],[A=B,C=1,A>=0,B>=0,C>=0]).
eq('eq',[A,B,C],0,[],[A>=B+1,C=0,A>=0,B>=0,C>=0]).
eq('eq',[A,B,C],0,[],[B>=A+1,C=0,A>=0,B>=0,C>=0]).
eq('neq',[A,B,C],0,[],[A=B,C=0,A>=0,B>=0,C>=0]).
eq('neq',[A,B,C],0,[],[A>=B+1,C=1,A>=0,B>=0,C>=0]).
eq('neq',[A,B,C],0,[],[B>=A+1,C=1,A>=0,B>=0,C>=0]).
eq('lt',[A,B,C],0,[],[B-A>=1,C=1,A>=0,B>=0,C>=0]).
eq('lt',[A,B,C],0,[],[B=<A,C=0,A>=0,B>=0,C>=0]).
eq('leq',[A,B,C],0,[],[A=<B,C=1,A>=0,B>=0,C>=0]).
eq('leq',[A,B,C],0,[],[A-B>=1,C=0,A>=0,B>=0,C>=0]).
eq('gt',[A,B,C],0,[],[A-B>=1,C=1,A>=0,B>=0,C>=0]).
eq('gt',[A,B,C],0,[],[A=<B,C=0,A>=0,B>=0,C>=0]).
eq('geq',[A,B,C],0,[],[B=<A,C=1,A>=0,B>=0,C>=0]).
eq('geq',[A,B,C],0,[],[B-A>=1,C=0,A>=0,B>=0,C>=0]).
eq('neg',[A,B],0,[],[A=0,B=1,A>=0,B>=0]).
eq('neg',[A,B],0,[],[A=1,B=0,A>=0,B>=0]).
eq('and_op',[A,B,C],0,[],[A=0,C=0,A>=0,B>=0,C>=0]).
eq('and_op',[A,B,C],0,[],[A=1,C=B,A>=0,B>=0,C>=0]).
eq('or',[A,B,C],0,[],[A=1,C=1,A>=0,B>=0,C>=0]).
eq('or',[A,B,C],0,[],[A=0,C=B,A>=0,B>=0,C>=0]).
eq('maxNorm',[A,B,A],0,[],[A>=1+B,A>=0,B>=0,A>=0]).
eq('maxNorm',[A,B,B],0,[],[A=<B,A>=0,B>=0,B>=0]).
eq('case_1',[A,B,C,D,E],2,[],[C=1,E=1,A>=0,B>=0,C>=0,D>=0,E>=0]).
eq('case_1',[A,B,C,D,E],3,[],[D=F+G,C=H+1,H>=1,E=0,A>=0,B>=0,C>=0,D>=0,E>=0]).
eq('case_0',[A,B,C,D,E],2,['case_1'(A,B,C,D,E)],[A=1,A>=0,B>=0,C>=0,D>=0,E>=0]).
eq('case_2',[A,B,C,D,E,F,G,H],2,[],[C=1,H=0,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0]).
eq('case_2',[A,B,C,D,E,F,G,H],5,['eq'(E,I,J),'eqD'(F,G,K,L,M),'and_op'(J,M,H)],[D=I+L,C=K+1,K>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0]).
eq('case_0',[A,B,C,D,E],3,['case_2'(A,B,C,D,F,G,H,E)],[B=F+H,A=G+1,G>=1,A>=0,B>=0,C>=0,D>=0,E>=0]).
eq('eqD',[A,B,C,D,E],1,['case_0'(A,B,C,D,E)],[A>=0,B>=0,C>=0,D>=0,E>=0]).
eq('case_3',[A,B,C,D,E,F,G,H],2,[],[D=0,C=1,G=0,F=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0]).
eq('case_4',[A,B,C,D,E,F,G,H,I,J,K,L,M,N],2,['removeL'(B,C,I,J,K,L,M,N)],[A=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0,M>=0,N>=0]).
eq('case_4',[A,B,C,D,E,F,G,H,I,J,K,L,M,N],4,['removeL'(B,C,I,J,K,O,P,Q)],[A=0,N=H+Q,M=G+P,L=O+1,O>=1,G>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0,M>=0,N>=0]).
eq('case_3',[A,B,C,D,E,F,G,H],4,['eqD'(A,B,I,J,K),'case_4'(K,A,B,C,D,E,I,J,L,M,N,F,G,H)],[E=J+N,D=I+M,C=L+1,L>=1,I>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0]).
eq('removeL',[A,B,C,D,E,F,G,H],1,['case_3'(A,B,C,D,E,F,G,H)],[A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0]).
eq('case_5',[A,B,C,D,E,F],2,[],[B=0,A=1,E=0,D=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0]).
eq('case_5',[A,B,C,D,E,F],5,['removeL'(G,H,I,J,K,L,M,N),'nub'(L,M,N,O,P,Q)],[C=H+K,B=G+J,A=I+1,I>=1,G>=1,F=H+Q,E=G+P,D=O+1,O>=1,G>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0]).
eq('nub',[A,B,C,D,E,F],1,['case_5'(A,B,C,D,E,F)],[A>=0,B>=0,C>=0,D>=0,E>=0,F>=0]).

Preprocessing Cost Relations
=====================================

#### Computed strongly connected components 
0. non_recursive  : [case_1/5]
1. non_recursive  : [and_op/3]
2. non_recursive  : [eq/3]
3. recursive [non_tail] : [case_0/5,case_2/8,eqD/5]
4. recursive  : [case_3/8,case_4/14,removeL/8]
5. recursive  : [case_5/6,nub/6]
Warning: the following predicates are never called:[geq/3,gt/3,leq/3,lt/3,maxNorm/3,neg/2,neq/3,or/3]

#### Obtained direct recursion through partial evaluation 
0. SCC is partially evaluated into case_1/5
1. SCC is partially evaluated into and_op/3
2. SCC is partially evaluated into eq/3
3. SCC is partially evaluated into eqD/5
4. SCC is partially evaluated into removeL/8
5. SCC is partially evaluated into nub/6

Control-Flow Refinement of Cost Relations
=====================================

### Specialization of cost equations case_1/5 
* CE 10 is refined into CE [16] 
* CE 9 is refined into CE [17] 


#### Refined cost equations case_1/5 
* CE 16: case_1(A,B,C,D,E) = 3
     [D>=0,C>=2,B>=0,E=0,A=1] 
* CE 17: case_1(A,B,C,D,E) = 2
     [D>=0,B>=0,E=1,C=1,A=1] 

### Cost equations --> "Loop" of case_1/5 
* CEs [16] --> Loop 16 
* CEs [17] --> Loop 17 

#### Loops of case_1/5 
* Loop 16: case_1(A,B,C,D,E) [D>=0,C>=2,B>=0,E=0,A=1] 
* Loop 17: case_1(A,B,C,D,E) [D>=0,B>=0,E=1,C=1,A=1] 

### Ranking functions of CR case_1(A,B,C,D,E) 

#### Partial ranking functions of CR case_1(A,B,C,D,E) 


### Resulting Chains:case_1(A,B,C,D,E) 
* [17]
* [16]


### Merging Chains  case_1/5 into  External patterns of execution 
* [[17]] --> 1 
* [[16]] --> 2 


### Specialization of cost equations and_op/3 
* CE 15 is refined into CE [18] 
* CE 14 is refined into CE [19] 


#### Refined cost equations and_op/3 
* CE 18: and_op(A,B,B) = 0
     [B>=0,A=1] 
* CE 19: and_op(A,B,C) = 0
     [B>=0,C=0,A=0] 

### Cost equations --> "Loop" of and_op/3 
* CEs [18] --> Loop 18 
* CEs [19] --> Loop 19 

#### Loops of and_op/3 
* Loop 18: and_op(A,B,B) [B>=0,A=1] 
* Loop 19: and_op(A,B,C) [B>=0,C=0,A=0] 

### Ranking functions of CR and_op(A,B,C) 

#### Partial ranking functions of CR and_op(A,B,C) 


### Resulting Chains:and_op(A,B,C) 
* [19]
* [18]


### Merging Chains  and_op/3 into  External patterns of execution 
* [[19]] --> 1 
* [[18]] --> 2 


### Specialization of cost equations eq/3 
* CE 11 is refined into CE [20] 
* CE 12 is refined into CE [21] 
* CE 13 is refined into CE [22] 


#### Refined cost equations eq/3 
* CE 20: eq(A,A,B) = 0
     [A>=0,B=1] 
* CE 21: eq(A,B,C) = 0
     [A>=B+1,B>=0,C=0] 
* CE 22: eq(A,B,C) = 0
     [B>=A+1,A>=0,C=0] 

### Cost equations --> "Loop" of eq/3 
* CEs [20] --> Loop 20 
* CEs [21] --> Loop 21 
* CEs [22] --> Loop 22 

#### Loops of eq/3 
* Loop 20: eq(A,A,B) [A>=0,B=1] 
* Loop 21: eq(A,B,C) [A>=B+1,B>=0,C=0] 
* Loop 22: eq(A,B,C) [B>=A+1,A>=0,C=0] 

### Ranking functions of CR eq(A,B,C) 

#### Partial ranking functions of CR eq(A,B,C) 


### Resulting Chains:eq(A,B,C) 
* [22]
* [21]
* [20]


### Merging Chains  eq/3 into  External patterns of execution 
* [[22]] --> 1 
* [[21]] --> 2 
* [[20]] --> 3 


### Specialization of cost equations eqD/5 
* CE 3 is refined into CE [23,24,25] 
* CE 2 is refined into CE [26] 
* CE 1 is refined into CE [27,28] 


#### Refined cost equations eqD/5 
* CE 23: eqD(A,B,C,D,E) = 9+ eq(F,G,H):1+ eqD(I,J,K,L,M)+ and_op(N,M,O):1
     [G+L>=0,G>=F+1,K>=1,J>=0,I>=1,M>=0,F>=0,G+L=D,F+J=B,K+1=C,I+1=A,O=0,N=0,H=0,E=0] 
* CE 24: eqD(A,B,C,D,E) = 9+ eq(F,G,H):2+ eqD(I,J,K,L,M)+ and_op(N,M,O):1
     [G+L>=0,F>=G+1,K>=1,J>=0,I>=1,M>=0,G>=0,G+L=D,F+J=B,K+1=C,I+1=A,O=0,N=0,H=0,E=0] 
* CE 25: eqD(A,B,C,D,E) = 9+ eq(F,F,G):3+ eqD(H,I,J,K,E)+ and_op(L,E,E):2
     [F+K>=0,J>=1,I>=0,H>=1,E>=0,F>=0,F+K=D,F+I=B,J+1=C,H+1=A,L=1,G=1] 
* CE 26: eqD(A,B,C,D,E) = 6
     [D>=0,B>=0,A>=2,E=0,C=1] 
* CE 27: eqD(A,B,C,D,E) = 3+ case_1(F,B,G,D,H):1
     [D>=0,B>=0,H=1,G=1,F=1,E=1,C=1,A=1] 
* CE 28: eqD(A,B,C,D,E) = 3+ case_1(F,B,C,D,G):2
     [D>=0,C>=2,B>=0,G=0,F=1,E=0,A=1] 

### Cost equations --> "Loop" of eqD/5 
* CEs [26] --> Loop 23 
* CEs [28] --> Loop 24 
* CEs [27] --> Loop 25 
* CEs [25] --> Loop 26 
* CEs [24] --> Loop 27 
* CEs [23] --> Loop 28 

#### Loops of eqD/5 
* Loop 23: eqD(A,B,C,D,E) [D>=0,B>=0,A>=2,E=0,C=1] 
* Loop 24: eqD(A,B,C,D,E) [D>=0,C>=2,B>=0,E=0,A=1] 
* Loop 25: eqD(A,B,C,D,E) [D>=0,B>=0,E=1,C=1,A=1] 
* Loop 26: eqD(A,B,C,D,E)->  eqD(A',B',C',D',E)
                  [B>=B',B'>=0,E>=0,D>=0,C>=2,A>=2,D+B'=B+D',C=C'+1,A=A'+1] 
* Loop 27: eqD(A,B,C,D,E)->  eqD(A',B',C',D',E')
                  [B+D'>=D+B'+1,D>=D',E'>=0,B'>=0,D>=0,C>=2,A>=2,C=C'+1,A=A'+1,E=0] 
* Loop 28: eqD(A,B,C,D,E)->  eqD(A',B',C',D',E')
                  [D+B'>=B+D'+1,B>=B',E'>=0,B'>=0,D>=0,C>=2,A>=2,C=C'+1,A=A'+1,E=0] 

### Ranking functions of CR eqD(A,B,C,D,E) 
* RF of phase [26,27,28]: [A-1,C-1]

#### Partial ranking functions of CR eqD(A,B,C,D,E) 
* Partial RF of phase [26,27,28]:
  - RF of loop [26:1,27:1,28:1]:
    A-1
    C-1
  - RF of loop [27:1]:
    B
  - RF of loop [28:1]:
    D+1

Discarded unfeasible chain [[26,27,28]]...(Non-terminating chain proved terminating)

### Resulting Chains:eqD(A,B,C,D,E) 
* [[26,27,28],25]
* [[26,27,28],24]
* [[26,27,28],23]
* [25]
* [24]
* [23]


### Merging Chains  eqD/5 into  External patterns of execution 
* [[25]] --> 1 
* [[24]] --> 2 
* [[23]] --> 3 
* [[24,[26,27,28]]] --> 4 
* [[23,[26,27,28]]] --> 5 
* [[25,[26,27,28]]] --> 6 


### Specialization of cost equations removeL/8 
* CE 5 is refined into CE [29,30] 
* CE 6 is refined into CE [31,32,33,34,35] 
* CE 4 is refined into CE [36] 


#### Refined cost equations removeL/8 
* CE 29: removeL(A,B,C,D,E,F,G,H) = 7+ eqD(I,B,J,K,L):1+ removeL(M,B,N,O,P,F,G,H)
     [P>=0,O>=0,N>=1,K>=0,B>=0,H>=0,G>=0,F>=0,K+P=E,O+1=D,N+1=C,M=1,L=1,J=1,I=1,A=1] 
* CE 30: removeL(A,B,C,D,E,F,G,H) = 7+ eqD(A,B,A,I,J):6+ removeL(A,B,K,L,M,F,G,H)
     [M>=0,L>=0,K>=1,I>=0,A>=2,B>=0,H>=0,G>=0,F>=0,I+M=E,A+L=D,K+1=C,J=1] 
* CE 31: removeL(A,B,C,D,E,F,G,H) = 9+ eqD(I,B,J,K,L):2+ removeL(M,B,N,O,P,Q,R,S)
     [K+S>=0,J+R>=0,Q>=1,P>=0,O>=0,N>=1,K>=0,J>=2,B>=0,K+S=H,J+R=G,K+P=E,J+O=D,Q+1=F,N+1=C,M=1,L=0,I=1,A=1] 
* CE 32: removeL(A,B,C,D,E,F,G,H) = 9+ eqD(A,B,I,J,K):3+ removeL(A,B,L,M,N,O,P,Q)
     [J+Q>=0,P+1>=0,O>=1,N>=0,M>=0,L>=1,J>=0,B>=0,A>=2,J+Q=H,J+N=E,P+1=G,O+1=F,M+1=D,L+1=C,K=0,I=1] 
* CE 33: removeL(A,B,C,D,E,F,G,H) = 9+ eqD(A,B,I,J,K):4+ removeL(A,B,L,M,N,O,P,Q)
     [J+Q>=0,I+P>=0,I>=A+1,O>=1,N>=0,M>=0,L>=1,J>=0,B>=0,A>=2,J+Q=H,I+P=G,J+N=E,I+M=D,O+1=F,L+1=C,K=0] 
* CE 34: removeL(A,B,C,D,E,F,G,H) = 9+ eqD(A,B,I,J,K):5+ removeL(A,B,L,M,N,O,P,Q)
     [J+Q>=0,I+P>=0,A>=I+1,O>=1,N>=0,M>=0,L>=1,J>=0,I>=2,B>=0,J+Q=H,I+P=G,J+N=E,I+M=D,O+1=F,L+1=C,K=0] 
* CE 35: removeL(A,B,C,D,E,F,G,H) = 9+ eqD(A,B,A,I,J):6+ removeL(A,B,K,L,M,N,O,P)
     [I+P>=0,A+O>=0,B+I>=1,N>=1,M>=0,L>=0,K>=1,I>=0,A>=2,B>=0,I+P=H,A+O=G,I+M=E,A+L=D,N+1=F,K+1=C,J=0] 
* CE 36: removeL(A,B,C,D,E,F,G,H) = 3
     [H>=0,E>=0,B>=0,A>=0,G=0,F=1,D=0,C=1] 

### Cost equations --> "Loop" of removeL/8 
* CEs [36] --> Loop 29 
* CEs [30] --> Loop 30 
* CEs [34] --> Loop 31 
* CEs [33] --> Loop 32 
* CEs [35] --> Loop 33 
* CEs [32] --> Loop 34 
* CEs [31] --> Loop 35 
* CEs [29] --> Loop 36 

#### Loops of removeL/8 
* Loop 29: removeL(A,B,C,D,E,F,G,H) [H>=0,E>=0,B>=0,A>=0,G=0,F=1,D=0,C=1] 
* Loop 30: removeL(A,B,C,D,E,F,G,H)->  removeL(A,B,A',B',C',F,G,H)
                  [E>=C',D>=A,C'>=0,H>=0,G>=0,F>=0,C>=2,B>=0,A>=2,A+B'=D,C=A'+1] 
* Loop 31: removeL(A,B,C,D,E,F,G,H)->  removeL(A,B,A',B',C',D',E',F')
                  [A+B'>=D+1,E>=C',D>=B'+2,C'>=0,B'>=0,H>=0,G>=0,F>=2,C>=2,B>=0,D+E'=G+B',H+C'=E+F',F=D'+1,C=A'+1] 
* Loop 32: removeL(A,B,C,D,E,F,G,H)->  removeL(A,B,A',B',C',D',E',F')
                  [D>=A+B'+1,E>=C',C'>=0,B'>=0,H>=0,G>=0,F>=2,C>=2,B>=0,A>=2,H+C'=E+F',G+B'=D+E',F=D'+1,C=A'+1] 
* Loop 33: removeL(A,B,C,D,E,F,G,H)->  removeL(A,B,A',B',C',D',E',F')
                  [B+E>=C'+1,E>=C',D>=A,C'>=0,H>=0,G>=0,F>=2,C>=2,B>=0,A>=2,E+F'=H+C',A+B'=D,G=A+E',F=D'+1,C=A'+1] 
* Loop 34: removeL(A,B,C,D,E,F,G,H)->  removeL(A,B,A',B',C',D',E',F')
                  [E>=C',C'>=0,H>=0,G>=0,F>=2,D>=1,C>=2,B>=0,A>=2,H+C'=E+F',G=E'+1,F=D'+1,D=B'+1,C=A'+1] 
* Loop 35: removeL(A,B,C,D,E,F,G,H)->  removeL(A',B,B',C',D',E',F',G')
                  [E>=D',D>=C'+2,D'>=0,C'>=0,H>=0,G>=0,F>=2,C>=2,B>=0,D+F'=G+C',H+D'=E+G',F=E'+1,C=B'+1,A'=1,A=1] 
* Loop 36: removeL(A,B,C,D,E,F,G,H)->  removeL(A',B,B',C',D',F,G,H)
                  [E>=D',D'>=0,H>=0,G>=0,F>=0,D>=1,C>=2,B>=0,D=C'+1,C=B'+1,A'=1,A=1] 

### Ranking functions of CR removeL(A,B,C,D,E,F,G,H) 
* RF of phase [30,31,32,33,34]: [C-1,D]
* RF of phase [35,36]: [C-1,D]

#### Partial ranking functions of CR removeL(A,B,C,D,E,F,G,H) 
* Partial RF of phase [30,31,32,33,34]:
  - RF of loop [30:1,31:1,32:1,33:1,34:1]:
    C-1
  - RF of loop [30:1,31:1,33:1]:
    D/2-1/2
  - RF of loop [30:1,33:1]:
    -A/2+D/2+1/2
  - RF of loop [32:1]:
    -A/3+D/3
    D/3-2/3
  - RF of loop [34:1]:
    D
* Partial RF of phase [35,36]:
  - RF of loop [35:1]:
    D/2-1/2
  - RF of loop [35:1,36:1]:
    C-1
  - RF of loop [36:1]:
    D

Discarded unfeasible chain [[35,36]]...(Non-terminating chain proved terminating)
Discarded unfeasible chain [[30,31,32,33,34]](Non-terminating chain proved terminating)

### Resulting Chains:removeL(A,B,C,D,E,F,G,H) 
* [[35,36],29]
* [[30,31,32,33,34],29]
* [29]


### Merging Chains  removeL/8 into  External patterns of execution 
* [[29,[35,36]]] --> 1 
* [[29]] --> 2 
* [[29,[30,31,32,33,34]]] --> 3 


### Specialization of cost equations nub/6 
* CE 8 is refined into CE [37] 
* CE 7 is refined into CE [38,39,40] 


#### Refined cost equations nub/6 
* CE 37: nub(A,B,C,D,E,F) = 3
     [F>=0,C>=0,E=0,D=1,B=0,A=1] 
* CE 38: nub(A,B,C,D,E,F) = 6+ removeL(G,H,I,J,K,L,M,N):1+ nub(L,O,N,P,Q,R)
     [J+2>=I+L,H+R>=0,I>=L,Q+1>=0,P>=1,N>=0,L>=1,K>=0,I>=2,H>=0,J+L=I+O,J+L=I+M,H+R=F,H+K=C,Q+1=E,P+1=D,J+1=B,I+1=A,G=1] 
* CE 39: nub(A,B,C,D,E,F) = 6+ removeL(B,G,H,I,J,K,L,M):2+ nub(N,O,M,P,Q,R)
     [G+R>=0,B+Q>=0,P>=1,M>=0,J>=0,G>=0,B>=1,G+R=F,B+Q=E,G+J=C,P+1=D,O=0,N=1,L=0,K=1,I=0,H=1,A=2] 
* CE 40: nub(A,B,C,D,E,F) = 6+ removeL(G,H,I,J,K,L,M,N):3+ nub(L,M,N,O,P,Q)
     [J+2*L>=2*I+M,H+Q>=0,G+P>=0,M+1>=L,I>=L,O>=1,N>=0,L>=1,K>=0,I>=2,H>=0,G>=2,H+Q=F,G+P=E,H+K=C,G+J=B,O+1=D,I+1=A] 

### Cost equations --> "Loop" of nub/6 
* CEs [40] --> Loop 37 
* CEs [38] --> Loop 38 
* CEs [39] --> Loop 39 
* CEs [37] --> Loop 40 

#### Loops of nub/6 
* Loop 37: nub(A,B,C,D,E,F)->  nub(A',B',C',D',E',F')
                  [B+E'+2*A'+2>=2*A+E+B',C+F'>=F,F>=F',E>=E'+2,B'+1>=A',A>=A'+1,C'>=0,A'>=1,F>=0,E>=0,D>=2,A>=3,D=D'+1] 
* Loop 38: nub(A,B,C,D,E,F)->  nub(A',B',C',D',E',F')
                  [C+F'>=F,B+2>=A+A',F>=F',A>=A'+1,C'>=0,A'>=1,F>=0,E>=0,D>=2,A>=3,A+B'=B+A',E=E'+1,D=D'+1] 
* Loop 39: nub(A,B,C,D,E,F)->  nub(A',B',C',D',E',F')
                  [C+F'>=F,F>=F',C'>=0,F>=0,E>=0,D>=2,B>=1,E=B+E',D=D'+1,B'=0,A'=1,A=2] 
* Loop 40: nub(A,B,C,D,E,F) [F>=0,C>=0,E=0,D=1,B=0,A=1] 

### Ranking functions of CR nub(A,B,C,D,E,F) 
* RF of phase [37,38]: [A-2,B-1]

#### Partial ranking functions of CR nub(A,B,C,D,E,F) 
* Partial RF of phase [37,38]:
  - RF of loop [37:1]:
    -A+B+1
  - RF of loop [37:1,38:1]:
    A-2

Discarded unfeasible chain [[37,38]]...(Non-terminating chain proved terminating)

### Resulting Chains:nub(A,B,C,D,E,F) 
* [[37,38],40]
* [[37,38],39,40]
* [40]
* [39,40]


### Merging Chains  nub/6 into  External patterns of execution 
* [[40]] --> 1 
* [[40,39]] --> 2 
* [[40,[37,38]]] --> 3 
* [[40,39,[37,38]]] --> 4 


Computing Bounds
=====================================

#### Simplifying cost structure of CE 17 

#### Simplifying cost structure of CE 16 

#### Cost of chains of case_1(A,B,C,D,E):
* Chain [17]: 2
  with precondition: [A=1,C=1,E=1,B>=0,D>=0] 

* Chain [16]: 3
  with precondition: [A=1,E=0,B>=0,C>=2,D>=0] 


#### Simplifying cost structure of CE 19 

#### Simplifying cost structure of CE 18 

#### Cost of chains of and_op(A,B,C):
* Chain [19]: 0
  with precondition: [A=0,C=0,B>=0] 

* Chain [18]: 0
  with precondition: [A=1,C=B,C>=0] 


#### Simplifying cost structure of CE 22 

#### Simplifying cost structure of CE 21 

#### Simplifying cost structure of CE 20 

#### Cost of chains of eq(A,B,C):
* Chain [22]: 0
  with precondition: [C=0,A>=0,B>=A+1] 

* Chain [21]: 0
  with precondition: [C=0,B>=0,A>=B+1] 

* Chain [20]: 0
  with precondition: [C=1,A=B,A>=0] 


#### Simplifying cost structure of CE 27 

#### Computing cost of phase [26,27,28] 

#### Simplifying cost structure of CE 25 

#### Simplifying cost structure of CE 24 

#### Simplifying cost structure of CE 23 

#### Cost of loops [26,27,28] 

 * loop 26:eqD(A,B,C,D,E) -> [eqD(A',B',C',D',E')] 
9
 * loop 27:eqD(A,B,C,D,E) -> [eqD(A',B',C',D',E')] 
9
 * loop 28:eqD(A,B,C,D,E) -> [eqD(A',B',C',D',E')] 
9
##### Pending set eqD(A,B,C,D,E)
* Psum in Loop 26: [it(26)=<1]
* Psum in Loop 27: [it(27)=<1]
* Psum in Loop 28: [it(28)=<1]

###### Computing sum for it(26)=<1  in Loop 26 
   - Applying inductive sum strategy 
     - head Candidate: C-1 
       - Loop 27 is collaborative and bounds [it(27)] 
       - Loop 28 is collaborative and bounds [it(28)] 
     - head Candidate: A-1 
       - Loop 27 is collaborative and bounds [it(27)] 
       - Loop 28 is collaborative and bounds [it(28)] 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - Loop 27 is collaborative and bounds [it(27)] 
       - Loop 28 is collaborative and bounds [it(28)] 
     - tail Candidate: A-1 
       - Loop 27 is collaborative and bounds [it(27)] 
       - Loop 28 is collaborative and bounds [it(28)] 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(26)+it(27)+it(28)=<C-1,it(26)+it(27)+it(28)=<A-1,it(26)+it(27)+it(28)=<A-1,it(26)+it(27)+it(28)=<C-1,it(26)+it(27)+it(28)=<C-C',it(26)+it(27)+it(28)=<A-A',it(26)+it(27)+it(28)=<A-A',it(26)+it(27)+it(28)=<C-C'] 

##### Pending set A
* Psum in Loop 27: [it(27)=<1]
* Psum in Loop 28: [it(28)=<1]

###### Computing sum for it(27)=<1  in Loop 27 
   - Applying inductive sum strategy 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: B 
       - Loop 26 is collaborative
       - Loop 28 is collaborative
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B 
       - Loop 26 is collaborative
       - Loop 28 is collaborative
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(26)+it(27)+it(28)=<C-1,it(26)+it(27)+it(28)=<A-1,it(26)+it(27)+it(28)=<A-1,it(27)=<B,it(26)+it(27)+it(28)=<C-1,it(26)+it(27)+it(28)=<C-C',it(26)+it(27)+it(28)=<A-A',it(26)+it(27)+it(28)=<A-A',it(27)=<B-B',it(26)+it(27)+it(28)=<C-C'] 

##### Pending set A
* Psum in Loop 28: [it(28)=<1]

###### Computing sum for it(28)=<1  in Loop 28 
   - Applying inductive sum strategy 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: D+1 
       - Loop 26 is collaborative
       - Loop 27 is collaborative
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: D+1 
       - Loop 26 is collaborative
       - Loop 27 is collaborative
 * Adding constraints: [it(26)+it(27)+it(28)=<C-1,it(26)+it(27)+it(28)=<A-1,it(26)+it(27)+it(28)=<A-1,it(26)+it(27)+it(28)=<C-1,it(28)=<D+1,it(26)+it(27)+it(28)=<C-C',it(26)+it(27)+it(28)=<A-A',it(26)+it(27)+it(28)=<A-A',it(26)+it(27)+it(28)=<C-C',it(28)=<D-D'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [26,27,28] 

#### Simplifying cost structure of phase [26,27,28] 

#### Cost of phase [26,27,28]:eqD(A,B,C,D,E) -> [eqD(A',B',C',D',E')] 
9*it(26)+9*it(27)+9*it(28)+0
  Such that:it(27) =< B
it(27) =< B-B'
it(28) =< D+1
it(28) =< D-D'
aux(1) =< A
aux(2) =< A-A'
aux(3) =< C
aux(4) =< C-C'
it(26) =< aux(1)
it(27) =< aux(1)
it(28) =< aux(1)
it(26) =< aux(2)
it(27) =< aux(2)
it(28) =< aux(2)
it(26) =< aux(3)
it(27) =< aux(3)
it(28) =< aux(3)
it(26) =< aux(4)
it(27) =< aux(4)
it(28) =< aux(4)

#### Simplifying cost structure of chain [[26,27,28],25] 
 * Joined equivalent variables [aux(5),aux(1),aux(2),aux(3),aux(4)] into aux(5)

#### Simplifying cost structure of CE 28 

#### Found solution for phase  [26,27,28] in the cache 

#### Cost of phase [26,27,28]:eqD(A,B,C,D,E) -> [eqD(A',B',C',D',E')] 
9*it(26)+9*it(27)+9*it(28)+0
  Such that:it(27) =< B
it(27) =< B-B'
it(28) =< D+1
it(28) =< D-D'
aux(1) =< A
aux(2) =< A-A'
aux(3) =< C
aux(4) =< C-C'
it(26) =< aux(1)
it(27) =< aux(1)
it(28) =< aux(1)
it(26) =< aux(2)
it(27) =< aux(2)
it(28) =< aux(2)
it(26) =< aux(3)
it(27) =< aux(3)
it(28) =< aux(3)
it(26) =< aux(4)
it(27) =< aux(4)
it(28) =< aux(4)

#### Simplifying cost structure of chain [[26,27,28],24] 
 * Joined equivalent variables [aux(6),aux(1),aux(2),aux(4)] into aux(6)

#### Simplifying cost structure of CE 26 

#### Found solution for phase  [26,27,28] in the cache 

#### Cost of phase [26,27,28]:eqD(A,B,C,D,E) -> [eqD(A',B',C',D',E')] 
9*it(26)+9*it(27)+9*it(28)+0
  Such that:it(27) =< B
it(27) =< B-B'
it(28) =< D+1
it(28) =< D-D'
aux(1) =< A
aux(2) =< A-A'
aux(3) =< C
aux(4) =< C-C'
it(26) =< aux(1)
it(27) =< aux(1)
it(28) =< aux(1)
it(26) =< aux(2)
it(27) =< aux(2)
it(28) =< aux(2)
it(26) =< aux(3)
it(27) =< aux(3)
it(28) =< aux(3)
it(26) =< aux(4)
it(27) =< aux(4)
it(28) =< aux(4)

#### Simplifying cost structure of chain [[26,27,28],23] 
 * Joined equivalent variables [aux(7),aux(2),aux(3),aux(4)] into aux(7)

#### Cost of chains of eqD(A,B,C,D,E):
* Chain [[26,27,28],25]: 9*it(26)+9*it(27)+9*it(28)+5
  Such that:it(27) =< B
it(28) =< D
aux(5) =< A
it(26) =< aux(5)
it(27) =< aux(5)
it(28) =< aux(5)

  with precondition: [A=C,1>=E,A>=2,B>=0,D>=0,E>=0,B+D+E>=1] 

* Chain [[26,27,28],24]: 9*it(26)+9*it(27)+9*it(28)+6
  Such that:it(27) =< B
aux(3) =< C
it(28) =< D
aux(6) =< A
it(26) =< aux(6)
it(27) =< aux(6)
it(28) =< aux(6)
it(26) =< aux(3)
it(27) =< aux(3)
it(28) =< aux(3)

  with precondition: [E=0,A>=2,B>=0,D>=0,C>=A+1] 

* Chain [[26,27,28],23]: 9*it(26)+9*it(27)+9*it(28)+6
  Such that:aux(1) =< A
it(27) =< B
it(28) =< D
aux(7) =< C
it(26) =< aux(1)
it(27) =< aux(1)
it(28) =< aux(1)
it(26) =< aux(7)
it(27) =< aux(7)
it(28) =< aux(7)

  with precondition: [E=0,B>=0,C>=2,D>=0,A>=C+1] 

* Chain [25]: 5
  with precondition: [A=1,C=1,E=1,B>=0,D>=0] 

* Chain [24]: 6
  with precondition: [A=1,E=0,B>=0,C>=2,D>=0] 

* Chain [23]: 6
  with precondition: [C=1,E=0,A>=2,B>=0,D>=0] 


#### Simplifying cost structure of CE 36 

#### Computing cost of phase [35,36] 

#### Simplifying cost structure of CE 31 

#### Simplifying cost structure of CE 29 

#### Cost of loops [35,36] 

 * loop 35:removeL(A,B,C,D,E,F,G,H) -> [removeL(A',B',C',D',E',F',G',H')] 
15
 * loop 36:removeL(A,B,C,D,E,F,G,H) -> [removeL(A',B',C',D',E',F',G',H')] 
12
##### Pending set removeL(A,B,C,D,E,F,G,H)
* Psum in Loop 35: [it(35)=<1]
* Psum in Loop 36: [it(36)=<1]

###### Computing sum for it(35)=<1  in Loop 35 
   - Applying inductive sum strategy 
     - head Candidate: D 
       - Loop 36 is collaborative and bounds [it(36)] 
     - head Candidate: C-1 
       - Loop 36 is collaborative and bounds [it(36)] 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: D/2-1/2 
       - Loop 36 is collaborative
     - tail Candidate: D 
       - Loop 36 is collaborative and bounds [it(36)] 
     - tail Candidate: C-1 
       - Loop 36 is collaborative and bounds [it(36)] 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: D/2-1/2 
       - Loop 36 is collaborative
 * Adding constraints: [it(35)+it(36)=<D,it(35)+it(36)=<C-1,it(35)+it(36)=<C-1,it(35)=<D/2-1/2,it(35)+it(36)=<D-D',it(35)+it(36)=<C-C',it(35)+it(36)=<C-C',it(35)=<D/2-D'/2] 

##### Pending set A
* Psum in Loop 36: [it(36)=<1]

###### Computing sum for it(36)=<1  in Loop 36 
   - Applying inductive sum strategy 
     - head Candidate: D 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: D 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: D 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: D 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(35)+it(36)=<D,it(35)+it(36)=<C-1,it(35)+it(36)=<C-1,it(35)+it(36)=<D,it(35)+it(36)=<D-D',it(35)+it(36)=<C-C',it(35)+it(36)=<C-C',it(35)+it(36)=<D-D'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [35,36] 

#### Simplifying cost structure of phase [35,36] 

#### Cost of phase [35,36]:removeL(A,B,C,D,E,F,G,H) -> [removeL(A',B',C',D',E',F',G',H')] 
15*it(35)+12*it(36)+0
  Such that:it(35) =< D/2
it(35) =< D/2-D'/2
aux(8) =< C
aux(9) =< C-C'
aux(10) =< D
aux(11) =< D-D'
it(35) =< aux(8)
it(36) =< aux(8)
it(35) =< aux(9)
it(36) =< aux(9)
it(35) =< aux(10)
it(36) =< aux(10)
it(35) =< aux(11)
it(36) =< aux(11)

#### Simplifying cost structure of chain [[35,36],29] 
 * Joined equivalent variables [aux(12),aux(8),aux(9)] into aux(12)
 * Joined equivalent variables [aux(13),aux(10),aux(11)] into aux(13)

#### Computing cost of phase [30,31,32,33,34] 
 * Renamed intermediate variables: 
[ (eq(30,1),it(27))>>s(1), (eq(30,1),it(28))>>s(2), (eq(30,1),aux(5))>>s(3), (eq(30,1),it(26))>>s(4)]

#### Simplifying cost structure of CE 30 
 * Renamed intermediate variables: 
[ (it(30),s(2))>>s(5), (it(30),s(3))>>s(6), (it(30),s(1))>>s(7), (it(30),s(4))>>s(8)]
 * Renamed intermediate variables: 
[ (eq(34,1),aux(1))>>s(9), (eq(34,1),it(27))>>s(10), (eq(34,1),it(28))>>s(11), (eq(34,1),aux(7))>>s(12), (eq(34,1),it(26))>>s(13)]

#### Simplifying cost structure of CE 34 
 * Renamed intermediate variables: 
[ (it(31),s(12))>>s(14), (it(31),s(11))>>s(15), (it(31),s(9))>>s(16), (it(31),s(10))>>s(17), (it(31),s(13))>>s(18)]
 * Renamed intermediate variables: 
[ (eq(33,1),it(27))>>s(19), (eq(33,1),aux(3))>>s(20), (eq(33,1),it(28))>>s(21), (eq(33,1),aux(6))>>s(22), (eq(33,1),it(26))>>s(23)]

#### Simplifying cost structure of CE 33 
 * Renamed intermediate variables: 
[ (it(32),s(20))>>s(24), (it(32),s(21))>>s(25), (it(32),s(22))>>s(26), (it(32),s(19))>>s(27), (it(32),s(23))>>s(28)]
 * Renamed intermediate variables: 
[ (eq(35,1),it(27))>>s(29), (eq(35,1),it(28))>>s(30), (eq(35,1),aux(5))>>s(31), (eq(35,1),it(26))>>s(32)]

#### Simplifying cost structure of CE 35 
 * Renamed intermediate variables: 
[ (it(33),s(29))>>s(33), (it(33),s(30))>>s(34), (it(33),s(31))>>s(35), (it(33),s(32))>>s(36)]

#### Simplifying cost structure of CE 32 

#### Cost of loops [30,31,32,33,34] 

 * loop 30:removeL(A,B,C,D,E,F,G,H) -> [removeL(A',B',C',D',E',F',G',H')] 
9*s(7)+9*s(5)+9*s(8)+12
  Such that:s(5) =< E-E'
s(6) =< A'
s(7) =< B'
s(8) =< s(6)
s(7) =< s(6)
s(5) =< s(6)

 * loop 31:removeL(A,B,C,D,E,F,G,H) -> [removeL(A',B',C',D',E',F',G',H')] 
9*s(17)+9*s(15)+9*s(18)+15
  Such that:s(14) =< D-D'
s(15) =< E-E'
s(16) =< A'
s(17) =< B'
s(18) =< s(16)
s(17) =< s(16)
s(15) =< s(16)
s(18) =< s(14)
s(17) =< s(14)
s(15) =< s(14)

 * loop 32:removeL(A,B,C,D,E,F,G,H) -> [removeL(A',B',C',D',E',F',G',H')] 
9*s(27)+9*s(25)+9*s(28)+15
  Such that:s(24) =< D-D'
s(25) =< E-E'
s(26) =< A'
s(27) =< B'
s(28) =< s(26)
s(27) =< s(26)
s(25) =< s(26)
s(28) =< s(24)
s(27) =< s(24)
s(25) =< s(24)

 * loop 33:removeL(A,B,C,D,E,F,G,H) -> [removeL(A',B',C',D',E',F',G',H')] 
9*s(33)+9*s(34)+9*s(36)+14
  Such that:s(33) =< B
s(34) =< E-E'
s(35) =< A'
s(36) =< s(35)
s(33) =< s(35)
s(34) =< s(35)

 * loop 34:removeL(A,B,C,D,E,F,G,H) -> [removeL(A',B',C',D',E',F',G',H')] 
15
##### Pending set removeL(A,B,C,D,E,F,G,H)
* Psum in Loop 30: [it(30)=<1,s(38)=<E-E',s(40)=<A',s(37)=<B']
* Psum in Loop 31: [it(31)=<1,s(44)=<D-D',s(42)=<E-E',s(45)=<A',s(41)=<B']
* Psum in Loop 32: [it(32)=<1,s(49)=<D-D',s(47)=<E-E',s(50)=<A',s(46)=<B']
* Psum in Loop 33: [it(33)=<1,s(51)=<B,s(52)=<E-E',s(54)=<A']
* Psum in Loop 34: [it(34)=<1]

###### Computing sum for it(30)=<1  in Loop 30 
   - Applying inductive sum strategy 
     - head Candidate: C-1 
       - Loop 31 is collaborative and bounds [it(31)] 
       - Loop 32 is collaborative and bounds [it(32)] 
       - Loop 33 is collaborative and bounds [it(33)] 
       - Loop 34 is collaborative and bounds [it(34)] 
     - head Candidate: D 
       - Loop 31 is collaborative and bounds [it(31)] 
       - Loop 32 is collaborative and bounds [it(32)] 
       - Loop 33 is collaborative and bounds [it(33)] 
       - Loop 34 is collaborative and bounds [it(34)] 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: D/2-1/2 
       - Loop 31 is collaborative
       - Loop 32 is collaborative and bounds [it(32)] 
       - Loop 33 is collaborative
       - Loop 34 is collaborative
     - head Candidate: -A/2+D/2+1/2 
       - Loop 31 is collaborative
       - Loop 32 is collaborative and bounds [it(32)] 
       - Loop 33 is collaborative
       - Loop 34 is collaborative
     - tail Candidate: C-1 
       - Loop 31 is collaborative and bounds [it(31)] 
       - Loop 32 is collaborative and bounds [it(32)] 
       - Loop 33 is collaborative and bounds [it(33)] 
       - Loop 34 is collaborative and bounds [it(34)] 
     - tail Candidate: D 
       - Loop 31 is collaborative and bounds [it(31)] 
       - Loop 32 is collaborative and bounds [it(32)] 
       - Loop 33 is collaborative and bounds [it(33)] 
       - Loop 34 is collaborative and bounds [it(34)] 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: D/2-1/2 
       - Loop 31 is collaborative and bounds [it(31)] 
       - Loop 32 is collaborative and bounds [it(32)] 
       - Loop 33 is collaborative and bounds [it(33)] 
       - Loop 34 is collaborative
     - tail Candidate: -A/2+D/2+1/2 
       - Loop 31 is collaborative and bounds [it(31)] 
       - Loop 32 is collaborative and bounds [it(32)] 
       - Loop 33 is collaborative and bounds [it(33)] 
       - Loop 34 is collaborative
 * Adding constraints: [it(30)+it(31)+it(32)+it(33)+it(34)=<C-1,it(30)+it(31)+it(32)+it(33)+it(34)=<D,it(30)+it(31)+it(32)+it(33)+it(34)=<C-1,it(30)+it(32)=<D/2-1/2,it(30)+it(32)=< -A/2+D/2+1/2,it(30)+it(31)+it(32)+it(33)+it(34)=<C-C',it(30)+it(31)+it(32)+it(33)+it(34)=<D-D',it(30)+it(31)+it(32)+it(33)+it(34)=<C-C',it(30)+it(31)+it(32)+it(33)=<D/2-D'/2,it(30)+it(31)+it(32)+it(33)=< -A/2+D/2+A'/2-D'/2] 

##### Pending set A
* Psum in Loop 30: [s(38)=<E-E',s(40)=<A',s(37)=<B']
* Psum in Loop 31: [it(31)=<1,s(44)=<D-D',s(42)=<E-E',s(45)=<A',s(41)=<B']
* Psum in Loop 32: [it(32)=<1,s(49)=<D-D',s(47)=<E-E',s(50)=<A',s(46)=<B']
* Psum in Loop 33: [it(33)=<1,s(51)=<B,s(52)=<E-E',s(54)=<A']
* Psum in Loop 34: [it(34)=<1]

###### Computing sum for s(38)=<E-E'  in Loop 30 
   - Applying inductive sum strategy 
     - head Candidate: E 
       - Loop 31 is collaborative and bounds [s(42)] 
       - Loop 32 is collaborative and bounds [s(47)] 
       - Loop 33 is collaborative and bounds [s(52)] 
       - Loop 34 is collaborative
     - tail Candidate: E 
       - Loop 31 is collaborative and bounds [s(42)] 
       - Loop 32 is collaborative and bounds [s(47)] 
       - Loop 33 is collaborative and bounds [s(52)] 
       - Loop 34 is collaborative
 * Adding constraints: [s(38)+s(42)+s(47)+s(52)=<E,s(38)+s(42)+s(47)+s(52)=<E-E'] 

##### Pending set A
* Psum in Loop 30: [s(40)=<A',s(37)=<B']
* Psum in Loop 31: [it(31)=<1,s(44)=<D-D',s(42)=<E-E',s(45)=<A',s(41)=<B']
* Psum in Loop 32: [it(32)=<1,s(49)=<D-D',s(47)=<E-E',s(50)=<A',s(46)=<B']
* Psum in Loop 33: [it(33)=<1,s(51)=<B,s(52)=<E-E',s(54)=<A']
* Psum in Loop 34: [it(34)=<1]

###### Computing sum for s(40)=<A'  in Loop 30 
   - Applying inductive sum strategy 
     - head Candidate: -2*C+2*D+2 
       - Loop 31 is collaborative and bounds [it(31)] 
       - Loop 32 is collaborative and bounds [it(32)] 
       - Loop 33 is collaborative and bounds [it(33)] 
       - Loop 34 is collaborative
     - head Candidate: -A+2*D 
       - Loop 31 is collaborative
       - Loop 32 is collaborative and bounds [it(32)] 
       - Loop 33 is collaborative and bounds [it(33)] 
       - Loop 34 is collaborative
     - tail Candidate: -2*C+2*D+2 
       - Loop 31 is collaborative and bounds [it(31)] 
       - Loop 32 is collaborative and bounds [it(32)] 
       - Loop 33 is collaborative and bounds [it(33)] 
       - Loop 34 is collaborative
     - tail Candidate: -A+2*D 
       - Loop 31 is collaborative and bounds [it(31)] 
       - Loop 32 is collaborative and bounds [it(32)] 
       - Loop 33 is collaborative and bounds [it(33)] 
       - Loop 34 is collaborative and bounds [it(34)] 
 * Adding constraints: [it(31)+it(32)+it(33)+s(40)=< -2*C+2*D+2,it(32)+it(33)+s(40)=< -A+2*D,it(31)+it(32)+it(33)+s(40)=< -2*C+2*D+2*C'-2*D',it(31)+it(32)+it(33)+it(34)+s(40)=< -A+2*D+A'-2*D'] 

##### Pending set A
* Psum in Loop 30: [s(37)=<B']
* Psum in Loop 31: [it(31)=<1,s(44)=<D-D',s(42)=<E-E',s(45)=<A',s(41)=<B']
* Psum in Loop 32: [it(32)=<1,s(49)=<D-D',s(47)=<E-E',s(50)=<A',s(46)=<B']
* Psum in Loop 33: [it(33)=<1,s(51)=<B,s(52)=<E-E',s(54)=<A']
* Psum in Loop 34: [it(34)=<1]

###### Computing sum for s(37)=<B'  in Loop 30 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(14)=<B] 
 * Adding constraints: [s(37)=<it(30)*aux(14)] 

##### Pending set removeL(A,B,C,D,E,F,G,H)
* Pmax/min: [aux(14)=<B]
* Psum in Loop 31: [it(31)=<1,s(44)=<D-D',s(42)=<E-E',s(45)=<A',s(41)=<B']
* Psum in Loop 32: [it(32)=<1,s(49)=<D-D',s(47)=<E-E',s(50)=<A',s(46)=<B']
* Psum in Loop 33: [it(33)=<1,s(51)=<B,s(52)=<E-E',s(54)=<A']
* Psum in Loop 34: [it(34)=<1]

###### Computing max_min for aux(14)=<B  
   - Found a solution using transitive invariants 
 * Adding constraints:[aux(14)=<B] 

##### Pending set removeL(A,B,C,D,E,F,G,H)
* Psum in Loop 31: [it(31)=<1,s(44)=<D-D',s(42)=<E-E',s(45)=<A',s(41)=<B']
* Psum in Loop 32: [it(32)=<1,s(49)=<D-D',s(47)=<E-E',s(50)=<A',s(46)=<B']
* Psum in Loop 33: [it(33)=<1,s(51)=<B,s(52)=<E-E',s(54)=<A']
* Psum in Loop 34: [it(34)=<1]

###### Computing sum for it(31)=<1  in Loop 31 
   - Applying inductive sum strategy 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: D 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: D/2-1/2 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: D 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: D/2-1/2 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(30)+it(31)+it(32)+it(33)+it(34)=<C-1,it(30)+it(31)+it(32)+it(33)+it(34)=<D,it(30)+it(31)+it(32)+it(33)+it(34)=<C-1,it(30)+it(31)+it(32)=<D/2-1/2,it(30)+it(31)+it(32)+it(33)+it(34)=<C-C',it(30)+it(31)+it(32)+it(33)+it(34)=<D-D',it(30)+it(31)+it(32)+it(33)+it(34)=<C-C',it(30)+it(31)+it(32)+it(33)=<D/2-D'/2] 

##### Pending set removeL(A,B,C,D,E,F,G,H)
* Psum in Loop 31: [s(44)=<D-D',s(42)=<E-E',s(45)=<A',s(41)=<B']
* Psum in Loop 32: [it(32)=<1,s(49)=<D-D',s(47)=<E-E',s(50)=<A',s(46)=<B']
* Psum in Loop 33: [it(33)=<1,s(51)=<B,s(52)=<E-E',s(54)=<A']
* Psum in Loop 34: [it(34)=<1]

###### Computing sum for s(44)=<D-D'  in Loop 31 
   - Applying inductive sum strategy 
     - head Candidate: -2*C+2*D+2 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: D 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: -2*C+2*D+2 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: D 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(32)+it(33)+s(40)+s(44)=< -2*C+2*D+2,it(30)+it(32)+it(33)+it(34)+s(44)=<D,it(32)+it(33)+s(40)+s(44)=< -2*C+2*D+2*C'-2*D',it(30)+it(32)+it(33)+it(34)+s(44)=<D-D'] 

##### Pending set removeL(A,B,C,D,E,F,G,H)
* Psum in Loop 31: [s(42)=<E-E',s(45)=<A',s(41)=<B']
* Psum in Loop 32: [it(32)=<1,s(49)=<D-D',s(47)=<E-E',s(50)=<A',s(46)=<B']
* Psum in Loop 33: [it(33)=<1,s(51)=<B,s(52)=<E-E',s(54)=<A']
* Psum in Loop 34: [it(34)=<1]

###### Computing sum for s(42)=<E-E'  in Loop 31 
   - Applying inductive sum strategy 
     - head Candidate: E 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: E 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [s(38)+s(42)+s(47)+s(52)=<E,s(38)+s(42)+s(47)+s(52)=<E-E'] 

##### Pending set removeL(A,B,C,D,E,F,G,H)
* Psum in Loop 31: [s(45)=<A',s(41)=<B']
* Psum in Loop 32: [it(32)=<1,s(49)=<D-D',s(47)=<E-E',s(50)=<A',s(46)=<B']
* Psum in Loop 33: [it(33)=<1,s(51)=<B,s(52)=<E-E',s(54)=<A']
* Psum in Loop 34: [it(34)=<1]

###### Computing sum for s(45)=<A'  in Loop 31 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(15)=<A] 
 * Adding constraints: [s(45)=<it(31)*aux(15)] 

##### Pending set removeL(A,B,C,D,E,F,G,H)
* Pmax/min: [aux(15)=<A]
* Psum in Loop 31: [s(41)=<B']
* Psum in Loop 32: [it(32)=<1,s(49)=<D-D',s(47)=<E-E',s(50)=<A',s(46)=<B']
* Psum in Loop 33: [it(33)=<1,s(51)=<B,s(52)=<E-E',s(54)=<A']
* Psum in Loop 34: [it(34)=<1]

###### Computing max_min for aux(15)=<A  
   - Found a solution using transitive invariants 
 * Adding constraints:[aux(15)=<A] 

##### Pending set removeL(A,B,C,D,E,F,G,H)
* Psum in Loop 31: [s(41)=<B']
* Psum in Loop 32: [it(32)=<1,s(49)=<D-D',s(47)=<E-E',s(50)=<A',s(46)=<B']
* Psum in Loop 33: [it(33)=<1,s(51)=<B,s(52)=<E-E',s(54)=<A']
* Psum in Loop 34: [it(34)=<1]

###### Computing sum for s(41)=<B'  in Loop 31 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(16)=<B] 
 * Adding constraints: [s(41)=<it(31)*aux(16)] 

##### Pending set removeL(A,B,C,D,E,F,G,H)
* Pmax/min: [aux(16)=<B]
* Psum in Loop 32: [it(32)=<1,s(49)=<D-D',s(47)=<E-E',s(50)=<A',s(46)=<B']
* Psum in Loop 33: [it(33)=<1,s(51)=<B,s(52)=<E-E',s(54)=<A']
* Psum in Loop 34: [it(34)=<1]

###### Computing max_min for aux(16)=<B  
   - Found a solution using cacheing 
 * Adding constraints:[aux(16)=<aux(14)] 

##### Pending set removeL(A,B,C,D,E,F,G,H)
* Psum in Loop 32: [it(32)=<1,s(49)=<D-D',s(47)=<E-E',s(50)=<A',s(46)=<B']
* Psum in Loop 33: [it(33)=<1,s(51)=<B,s(52)=<E-E',s(54)=<A']
* Psum in Loop 34: [it(34)=<1]

###### Computing sum for it(32)=<1  in Loop 32 
   - Applying inductive sum strategy 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: D 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: -A/3+D/3 
       - Loop 30 is collaborative
       - Loop 31 is collaborative
       - Loop 33 is collaborative
       - Loop 34 is collaborative
     - head Candidate: D/3-2/3 
       - Loop 30 is collaborative
       - Loop 31 is collaborative
       - Loop 33 is collaborative
       - Loop 34 is collaborative
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: D 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: -A/3+D/3 
       - Loop 30 is collaborative
       - Loop 31 is collaborative
       - Loop 33 is collaborative
       - Loop 34 is collaborative
     - tail Candidate: D/3-2/3 
       - Loop 30 is collaborative
       - Loop 31 is collaborative
       - Loop 33 is collaborative
       - Loop 34 is collaborative
 * Adding constraints: [it(30)+it(31)+it(32)+it(33)+it(34)=<C-1,it(30)+it(31)+it(32)+it(33)+it(34)=<D,it(30)+it(31)+it(32)+it(33)+it(34)=<C-1,it(32)=< -A/3+D/3,it(32)=<D/3-2/3,it(30)+it(31)+it(32)+it(33)+it(34)=<C-C',it(30)+it(31)+it(32)+it(33)+it(34)=<D-D',it(30)+it(31)+it(32)+it(33)+it(34)=<C-C',it(32)=< -A/3+D/3+A'/3-D'/3,it(32)=<D/3-D'/3] 

##### Pending set removeL(A,B,C,D,E,F,G,H)
* Psum in Loop 32: [s(49)=<D-D',s(47)=<E-E',s(50)=<A',s(46)=<B']
* Psum in Loop 33: [it(33)=<1,s(51)=<B,s(52)=<E-E',s(54)=<A']
* Psum in Loop 34: [it(34)=<1]

###### Computing sum for s(49)=<D-D'  in Loop 32 
   - Applying inductive sum strategy 
     - head Candidate: -3/2*C+3/2*D+3/2 
       - Loop 30 is collaborative
       - Loop 31 is collaborative
       - Loop 33 is collaborative and bounds [it(33)] 
       - Loop 34 is collaborative
     - head Candidate: -A/2-3/2*C+3/2*D+5/2 
       - Loop 30 is collaborative
       - Loop 31 is collaborative
       - Loop 33 is collaborative and bounds [it(33)] 
       - Loop 34 is collaborative
     - tail Candidate: -3/2*C+3/2*D+3/2 
       - Loop 30 is collaborative
       - Loop 31 is collaborative
       - Loop 33 is collaborative and bounds [it(33)] 
       - Loop 34 is collaborative
     - tail Candidate: -A/2-3/2*C+3/2*D+5/2 
       - Loop 30 is collaborative
       - Loop 31 is collaborative
       - Loop 33 is collaborative and bounds [it(33)] 
       - Loop 34 is collaborative
 * Adding constraints: [it(33)+s(49)=< -3/2*C+3/2*D+3/2,it(33)+s(49)=< -A/2-3/2*C+3/2*D+5/2,it(33)+s(49)=< -3/2*C+3/2*D+3/2*C'-3/2*D',it(33)+s(49)=< -A/2-3/2*C+3/2*D+A'/2+3/2*C'-3/2*D'] 

##### Pending set removeL(A,B,C,D,E,F,G,H)
* Psum in Loop 32: [s(47)=<E-E',s(50)=<A',s(46)=<B']
* Psum in Loop 33: [it(33)=<1,s(51)=<B,s(52)=<E-E',s(54)=<A']
* Psum in Loop 34: [it(34)=<1]

###### Computing sum for s(47)=<E-E'  in Loop 32 
   - Applying inductive sum strategy 
     - head Candidate: E 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: E 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [s(38)+s(42)+s(47)+s(52)=<E,s(38)+s(42)+s(47)+s(52)=<E-E'] 

##### Pending set removeL(A,B,C,D,E,F,G,H)
* Psum in Loop 32: [s(50)=<A',s(46)=<B']
* Psum in Loop 33: [it(33)=<1,s(51)=<B,s(52)=<E-E',s(54)=<A']
* Psum in Loop 34: [it(34)=<1]

###### Computing sum for s(50)=<A'  in Loop 32 
   - Applying inductive sum strategy 
     - head Candidate: D-1 
       - Loop 30 is collaborative
       - Loop 31 is collaborative
       - Loop 33 is collaborative and bounds [it(33)] 
       - Loop 34 is collaborative
     - head Candidate: -C+D+1 
       - Loop 30 is collaborative
       - Loop 31 is collaborative
       - Loop 33 is collaborative and bounds [it(33)] 
       - Loop 34 is collaborative
     - tail Candidate: D-1 
       - Loop 30 is collaborative
       - Loop 31 is collaborative
       - Loop 33 is collaborative and bounds [it(33)] 
       - Loop 34 is collaborative and bounds [it(34)] 
     - tail Candidate: -C+D+1 
       - Loop 30 is collaborative
       - Loop 31 is collaborative
       - Loop 33 is collaborative and bounds [it(33)] 
       - Loop 34 is collaborative
 * Adding constraints: [it(33)+s(50)=<D-1,it(33)+s(50)=< -C+D+1,it(33)+it(34)+s(50)=<D-D',it(33)+s(50)=< -C+D+C'-D'] 

##### Pending set removeL(A,B,C,D,E,F,G,H)
* Psum in Loop 32: [s(46)=<B']
* Psum in Loop 33: [it(33)=<1,s(51)=<B,s(52)=<E-E',s(54)=<A']
* Psum in Loop 34: [it(34)=<1]

###### Computing sum for s(46)=<B'  in Loop 32 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(17)=<B] 
 * Adding constraints: [s(46)=<it(32)*aux(17)] 

##### Pending set removeL(A,B,C,D,E,F,G,H)
* Pmax/min: [aux(17)=<B]
* Psum in Loop 33: [it(33)=<1,s(51)=<B,s(52)=<E-E',s(54)=<A']
* Psum in Loop 34: [it(34)=<1]

###### Computing max_min for aux(17)=<B  
   - Found a solution using cacheing 
 * Adding constraints:[aux(17)=<aux(14)] 

##### Pending set removeL(A,B,C,D,E,F,G,H)
* Psum in Loop 33: [it(33)=<1,s(51)=<B,s(52)=<E-E',s(54)=<A']
* Psum in Loop 34: [it(34)=<1]

###### Computing sum for it(33)=<1  in Loop 33 
   - Applying inductive sum strategy 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: D 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: D/2-1/2 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: -A/2+D/2+1/2 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: D 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: D/2-1/2 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: -A/2+D/2+1/2 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(30)+it(31)+it(32)+it(33)+it(34)=<C-1,it(30)+it(31)+it(32)+it(33)+it(34)=<D,it(30)+it(31)+it(32)+it(33)+it(34)=<C-1,it(30)+it(32)+it(33)=<D/2-1/2,it(30)+it(32)+it(33)=< -A/2+D/2+1/2,it(30)+it(31)+it(32)+it(33)+it(34)=<C-C',it(30)+it(31)+it(32)+it(33)+it(34)=<D-D',it(30)+it(31)+it(32)+it(33)+it(34)=<C-C',it(30)+it(31)+it(32)+it(33)=<D/2-D'/2,it(30)+it(31)+it(32)+it(33)=< -A/2+D/2+A'/2-D'/2] 

##### Pending set removeL(A,B,C,D,E,F,G,H)
* Psum in Loop 33: [s(51)=<B,s(52)=<E-E',s(54)=<A']
* Psum in Loop 34: [it(34)=<1]

###### Computing sum for s(51)=<B  in Loop 33 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(18)=<B] 
 * Adding constraints: [s(51)=<it(33)*aux(18)] 

##### Pending set removeL(A,B,C,D,E,F,G,H)
* Pmax/min: [aux(18)=<B]
* Psum in Loop 33: [s(52)=<E-E',s(54)=<A']
* Psum in Loop 34: [it(34)=<1]

###### Computing max_min for aux(18)=<B  
   - Found a solution using cacheing 
 * Adding constraints:[aux(18)=<aux(14)] 

##### Pending set removeL(A,B,C,D,E,F,G,H)
* Psum in Loop 33: [s(52)=<E-E',s(54)=<A']
* Psum in Loop 34: [it(34)=<1]

###### Computing sum for s(52)=<E-E'  in Loop 33 
   - Applying inductive sum strategy 
     - head Candidate: E 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: E 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [s(38)+s(42)+s(47)+s(52)=<E,s(38)+s(42)+s(47)+s(52)=<E-E'] 

##### Pending set removeL(A,B,C,D,E,F,G,H)
* Psum in Loop 33: [s(54)=<A']
* Psum in Loop 34: [it(34)=<1]

###### Computing sum for s(54)=<A'  in Loop 33 
   - Applying inductive sum strategy 
     - head Candidate: -2*C+2*D+2 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: -A+2*D 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: -2*C+2*D+2 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: -A+2*D 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(31)+it(32)+s(40)+s(54)=< -2*C+2*D+2,it(32)+s(40)+s(54)=< -A+2*D,it(31)+it(32)+s(40)+s(54)=< -2*C+2*D+2*C'-2*D',it(31)+it(32)+it(34)+s(40)+s(54)=< -A+2*D+A'-2*D'] 

##### Pending set removeL(A,B,C,D,E,F,G,H)
* Psum in Loop 34: [it(34)=<1]

###### Computing sum for it(34)=<1  in Loop 34 
   - Applying inductive sum strategy 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: D 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: D 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: D 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: D 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(30)+it(31)+it(32)+it(33)+it(34)=<C-1,it(30)+it(31)+it(32)+it(33)+it(34)=<D,it(30)+it(31)+it(32)+it(33)+it(34)=<C-1,it(30)+it(31)+it(32)+it(33)+it(34)=<D,it(30)+it(31)+it(32)+it(33)+it(34)=<C-C',it(30)+it(31)+it(32)+it(33)+it(34)=<D-D',it(30)+it(31)+it(32)+it(33)+it(34)=<C-C',it(30)+it(31)+it(32)+it(33)+it(34)=<D-D'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [30,31,32,33,34] 

#### Simplifying cost structure of phase [30,31,32,33,34] 
 * Joined equivalent variables [aux(16),aux(17),aux(18)] into aux(16)
 * Joined equivalent variables [s(40),s(54)] into s(40)
 * Joined equivalent variables [s(38),s(52)] into s(38)
 * Joined equivalent variables [s(39),s(53)] into s(39)

#### Cost of phase [30,31,32,33,34]:removeL(A,B,C,D,E,F,G,H) -> [removeL(A',B',C',D',E',F',G',H')] 
12*it(30)+15*it(31)+15*it(32)+14*it(33)+15*it(34)+9*s(37)+18*s(38)+18*s(39)+9*s(41)+9*s(42)+9*s(43)+9*s(46)+9*s(47)+9*s(48)+9*s(51)+0
  Such that:aux(15) =< A
it(32) =< -A/3+D/3
it(32) =< -A/3+D/3+A'/3-D'/3
aux(14) =< B
it(32) =< D/3
it(32) =< D/3-D'/3
aux(19) =< -A+2*D
aux(20) =< -A+2*D+A'-2*D'
aux(21) =< -A/2-3/2*C+3/2*D+5/2
aux(22) =< -A/2-3/2*C+3/2*D+A'/2+3/2*C'-3/2*D'
aux(23) =< -A/2+D/2+1/2
aux(24) =< -A/2+D/2+A'/2-D'/2
aux(25) =< -2*C+2*D+2
aux(26) =< -2*C+2*D+2*C'-2*D'
aux(27) =< -C+D+1
aux(28) =< -C+D+C'-D'
aux(29) =< C
aux(30) =< C-C'
aux(31) =< -3/2*C+3/2*D+3/2
aux(32) =< -3/2*C+3/2*D+3/2*C'-3/2*D'
aux(33) =< D
aux(34) =< D-D'
aux(35) =< D/2
aux(36) =< D/2-D'/2
aux(37) =< E
aux(38) =< E-E'
it(32) =< aux(19)
it(33) =< aux(19)
s(40) =< aux(19)
it(31) =< aux(20)
it(32) =< aux(20)
it(33) =< aux(20)
it(34) =< aux(20)
s(40) =< aux(20)
it(33) =< aux(21)
s(49) =< aux(21)
it(33) =< aux(22)
s(49) =< aux(22)
it(30) =< aux(23)
it(32) =< aux(23)
it(33) =< aux(23)
it(30) =< aux(24)
it(31) =< aux(24)
it(32) =< aux(24)
it(33) =< aux(24)
it(31) =< aux(25)
it(32) =< aux(25)
it(33) =< aux(25)
s(40) =< aux(25)
s(44) =< aux(25)
it(31) =< aux(26)
it(32) =< aux(26)
it(33) =< aux(26)
s(40) =< aux(26)
s(44) =< aux(26)
it(33) =< aux(27)
s(50) =< aux(27)
it(33) =< aux(28)
s(50) =< aux(28)
it(30) =< aux(29)
it(31) =< aux(29)
it(32) =< aux(29)
it(33) =< aux(29)
it(34) =< aux(29)
it(30) =< aux(30)
it(31) =< aux(30)
it(32) =< aux(30)
it(33) =< aux(30)
it(34) =< aux(30)
it(33) =< aux(31)
s(49) =< aux(31)
it(33) =< aux(32)
s(49) =< aux(32)
it(30) =< aux(33)
it(31) =< aux(33)
it(32) =< aux(33)
it(33) =< aux(33)
it(34) =< aux(33)
s(44) =< aux(33)
s(50) =< aux(33)
it(30) =< aux(34)
it(31) =< aux(34)
it(32) =< aux(34)
it(33) =< aux(34)
it(34) =< aux(34)
s(44) =< aux(34)
s(50) =< aux(34)
it(30) =< aux(35)
it(31) =< aux(35)
it(32) =< aux(35)
it(33) =< aux(35)
it(30) =< aux(36)
it(31) =< aux(36)
it(32) =< aux(36)
it(33) =< aux(36)
s(38) =< aux(37)
s(42) =< aux(37)
s(47) =< aux(37)
s(38) =< aux(38)
s(42) =< aux(38)
s(47) =< aux(38)
aux(16) =< aux(14)
s(45) =< it(31)*aux(15)
s(37) =< it(30)*aux(14)
s(51) =< it(33)*aux(16)
s(46) =< it(32)*aux(16)
s(41) =< it(31)*aux(16)
s(39) =< s(40)
s(51) =< s(40)
s(38) =< s(40)
s(48) =< s(50)
s(46) =< s(50)
s(47) =< s(50)
s(48) =< s(49)
s(46) =< s(49)
s(47) =< s(49)
s(43) =< s(45)
s(41) =< s(45)
s(42) =< s(45)
s(43) =< s(44)
s(41) =< s(44)
s(42) =< s(44)
s(37) =< s(40)

#### Simplifying cost structure of chain [[30,31,32,33,34],29] 
 * Joined equivalent variables [aux(39),aux(25),aux(26)] into aux(39)
 * Joined equivalent variables [aux(40),aux(27),aux(28)] into aux(40)
 * Joined equivalent variables [aux(41),aux(29),aux(30)] into aux(41)
 * Joined equivalent variables [aux(42),aux(22),aux(31),aux(32)] into aux(42)
 * Joined equivalent variables [aux(43),aux(33),aux(34)] into aux(43)
 * Joined equivalent variables [aux(44),aux(24),aux(35),aux(36)] into aux(44)
 * Joined equivalent variables [aux(45),aux(37),aux(38)] into aux(45)

#### Cost of chains of removeL(A,B,C,D,E,F,G,H):
* Chain [[35,36],29]: 15*it(35)+12*it(36)+3
  Such that:it(35) =< C/2-F/2+G/2
aux(12) =< C
aux(13) =< C-F+G
it(35) =< aux(12)
it(36) =< aux(12)
it(35) =< aux(13)
it(36) =< aux(13)

  with precondition: [A=1,C+G=D+F,B>=0,C>=2,E>=0,F>=1,H>=0,C>=F,D+2>=C+F] 

* Chain [[30,31,32,33,34],29]: 12*it(30)+15*it(31)+15*it(32)+14*it(33)+15*it(34)+9*s(37)+18*s(38)+18*s(39)+9*s(41)+9*s(42)+9*s(43)+9*s(46)+9*s(47)+9*s(48)+9*s(51)+3
  Such that:aux(19) =< -A+2*D
aux(15) =< A
aux(21) =< -A/2-3/2*C+3/2*D+5/2
aux(23) =< -A/2+D/2+1/2
it(32) =< -A/3+D/3
aux(14) =< B
aux(20) =< 2*D
it(32) =< D/3
aux(39) =< -2*C+2*D+2
aux(40) =< -C+D+1
aux(41) =< C
aux(42) =< -3/2*C+3/2*D+3/2
aux(43) =< D
aux(44) =< D/2
aux(45) =< E
it(32) =< aux(19)
it(33) =< aux(19)
s(40) =< aux(19)
it(31) =< aux(20)
it(32) =< aux(20)
it(33) =< aux(20)
it(34) =< aux(20)
s(40) =< aux(20)
it(33) =< aux(21)
s(49) =< aux(21)
it(33) =< aux(42)
s(49) =< aux(42)
it(30) =< aux(23)
it(32) =< aux(23)
it(33) =< aux(23)
it(30) =< aux(44)
it(31) =< aux(44)
it(32) =< aux(44)
it(33) =< aux(44)
it(31) =< aux(39)
it(32) =< aux(39)
it(33) =< aux(39)
s(40) =< aux(39)
s(44) =< aux(39)
it(33) =< aux(40)
s(50) =< aux(40)
it(30) =< aux(41)
it(31) =< aux(41)
it(32) =< aux(41)
it(33) =< aux(41)
it(34) =< aux(41)
it(30) =< aux(43)
it(31) =< aux(43)
it(32) =< aux(43)
it(33) =< aux(43)
it(34) =< aux(43)
s(44) =< aux(43)
s(50) =< aux(43)
s(38) =< aux(45)
s(42) =< aux(45)
s(47) =< aux(45)
aux(16) =< aux(14)
s(45) =< it(31)*aux(15)
s(37) =< it(30)*aux(14)
s(51) =< it(33)*aux(16)
s(46) =< it(32)*aux(16)
s(41) =< it(31)*aux(16)
s(39) =< s(40)
s(51) =< s(40)
s(38) =< s(40)
s(48) =< s(50)
s(46) =< s(50)
s(47) =< s(50)
s(48) =< s(49)
s(46) =< s(49)
s(47) =< s(49)
s(43) =< s(45)
s(41) =< s(45)
s(42) =< s(45)
s(43) =< s(44)
s(41) =< s(44)
s(42) =< s(44)
s(37) =< s(40)

  with precondition: [A>=2,B>=0,C>=2,E>=0,F>=1,H>=0,C>=F,G+1>=F,D+2*F>=2*C+G] 

* Chain [29]: 3
  with precondition: [C=1,D=0,F=1,G=0,A>=0,B>=0,E>=0,H>=0] 


#### Simplifying cost structure of CE 37 

#### Computing cost of phase [37,38] 
 * Renamed intermediate variables: 
[ (eq(40,1),aux(19))>>s(55), (eq(40,1),aux(15))>>s(56), (eq(40,1),aux(21))>>s(57), (eq(40,1),aux(23))>>s(58), (eq(40,1),it(32))>>s(59), (eq(40,1),aux(14))>>s(60), (eq(40,1),aux(20))>>s(61), (eq(40,1),aux(39))>>s(62), (eq(40,1),aux(40))>>s(63), (eq(40,1),aux(41))>>s(64), (eq(40,1),aux(42))>>s(65), (eq(40,1),aux(43))>>s(66), (eq(40,1),aux(44))>>s(67), (eq(40,1),aux(45))>>s(68), (eq(40,1),it(33))>>s(69), (eq(40,1),s(40))>>s(70), (eq(40,1),it(31))>>s(71), (eq(40,1),it(34))>>s(72), (eq(40,1),s(49))>>s(73), (eq(40,1),it(30))>>s(74), (eq(40,1),s(44))>>s(75), (eq(40,1),s(50))>>s(76), (eq(40,1),s(38))>>s(77), (eq(40,1),s(42))>>s(78), (eq(40,1),s(47))>>s(79), (eq(40,1),aux(16))>>s(80), (eq(40,1),s(45))>>s(81), (eq(40,1),s(37))>>s(82), (eq(40,1),s(51))>>s(83), (eq(40,1),s(46))>>s(84), (eq(40,1),s(41))>>s(85), (eq(40,1),s(39))>>s(86), (eq(40,1),s(48))>>s(87), (eq(40,1),s(43))>>s(88)]

#### Simplifying cost structure of CE 40 
 * Joined equivalent variables [aux(49),s(66)] into aux(49)
 * Joined equivalent variables [aux(50),s(55),s(61)] into aux(50)
 * Joined equivalent variables [aux(51),s(58)] into aux(51)
 * Joined equivalent variables [aux(52),s(60),s(68)] into aux(52)
 * Renamed intermediate variables: 
[ (it(37),s(62))>>s(89), (it(37),s(63))>>s(90), (it(37),s(64))>>s(91), (it(37),s(59))>>s(92), (it(37),s(57))>>s(93), (it(37),aux(46))>>s(94), (it(37),aux(47))>>s(95), (it(37),aux(48))>>s(96), (it(37),aux(49))>>s(97), (it(37),aux(50))>>s(98), (it(37),aux(51))>>s(99), (it(37),aux(52))>>s(100), (it(37),s(56))>>s(101), (it(37),s(65))>>s(102), (it(37),s(67))>>s(103), (it(37),s(69))>>s(104), (it(37),s(70))>>s(105), (it(37),s(71))>>s(106), (it(37),s(72))>>s(107), (it(37),s(73))>>s(108), (it(37),s(74))>>s(109), (it(37),s(75))>>s(110), (it(37),s(76))>>s(111), (it(37),s(77))>>s(112), (it(37),s(78))>>s(113), (it(37),s(79))>>s(114), (it(37),s(80))>>s(115), (it(37),s(81))>>s(116), (it(37),s(82))>>s(117), (it(37),s(83))>>s(118), (it(37),s(84))>>s(119), (it(37),s(85))>>s(120), (it(37),s(86))>>s(121), (it(37),s(87))>>s(122), (it(37),s(88))>>s(123)]
 * Renamed intermediate variables: 
[ (eq(38,1),it(35))>>s(124), (eq(38,1),aux(12))>>s(125), (eq(38,1),aux(13))>>s(126), (eq(38,1),it(36))>>s(127)]

#### Simplifying cost structure of CE 38 
 * Renamed intermediate variables: 
[ (it(38),s(125))>>s(128), (it(38),s(126))>>s(129), (it(38),s(124))>>s(130), (it(38),s(127))>>s(131)]

#### Cost of loops [37,38] 

 * loop 37:nub(A,B,C,D,E,F) -> [nub(A',B',C',D',E',F')] 
15*s(92)+14*s(104)+15*s(106)+15*s(107)+12*s(109)+18*s(112)+9*s(113)+9*s(114)+9*s(117)+9*s(118)+9*s(119)+9*s(120)+18*s(121)+9*s(122)+9*s(123)+9
  Such that:s(89) =< -2*A+2*B
s(89) =< -2*A+2*B+4
s(90) =< -A+B
s(91) =< A
s(92) =< B/3
s(93) =< 3/2*B
s(94) =< -3*A+3*B+6
s(95) =< -A+B+2
s(96) =< -3/2*A+3/2*B
s(97) =< B
s(98) =< 2*B
s(99) =< B/2
s(100) =< C
s(101) =< s(94)
s(102) =< s(94)
s(101) =< s(95)
s(90) =< s(95)
s(93) =< s(96)
s(102) =< s(96)
s(92) =< s(97)
s(103) =< s(97)
s(103) =< s(99)
s(92) =< s(98)
s(104) =< s(98)
s(105) =< s(98)
s(106) =< s(98)
s(107) =< s(98)
s(104) =< s(93)
s(108) =< s(93)
s(104) =< s(102)
s(108) =< s(102)
s(109) =< s(99)
s(92) =< s(99)
s(104) =< s(99)
s(109) =< s(103)
s(106) =< s(103)
s(92) =< s(103)
s(104) =< s(103)
s(106) =< s(89)
s(92) =< s(89)
s(104) =< s(89)
s(105) =< s(89)
s(110) =< s(89)
s(104) =< s(90)
s(111) =< s(90)
s(109) =< s(91)
s(106) =< s(91)
s(92) =< s(91)
s(104) =< s(91)
s(107) =< s(91)
s(109) =< s(97)
s(106) =< s(97)
s(104) =< s(97)
s(107) =< s(97)
s(110) =< s(97)
s(111) =< s(97)
s(112) =< s(100)
s(113) =< s(100)
s(114) =< s(100)
s(115) =< s(100)
s(116) =< s(106)*s(101)
s(117) =< s(109)*s(100)
s(118) =< s(104)*s(115)
s(119) =< s(92)*s(115)
s(120) =< s(106)*s(115)
s(121) =< s(105)
s(118) =< s(105)
s(112) =< s(105)
s(122) =< s(111)
s(119) =< s(111)
s(114) =< s(111)
s(122) =< s(108)
s(119) =< s(108)
s(114) =< s(108)
s(123) =< s(116)
s(120) =< s(116)
s(113) =< s(116)
s(123) =< s(110)
s(120) =< s(110)
s(113) =< s(110)
s(117) =< s(105)

 * loop 38:nub(A,B,C,D,E,F) -> [nub(A',B',C',D',E',F')] 
15*s(130)+12*s(131)+9
  Such that:s(128) =< A
s(129) =< B
s(130) =< B/2
s(130) =< s(128)
s(131) =< s(128)
s(130) =< s(129)
s(131) =< s(129)

##### Pending set nub(A,B,C,D,E,F)
* Pmax/min: [s(94)=< -3*A+3*B+6,s(95)=< -A+B+2,s(100)=<C]
* Psum in Loop 37: [it(37)=<1,s(164)=< -3*A+3*B+6,s(156)=< -2*A+2*B,s(156)=< -2*A+2*B+4,s(155)=< -A+B,s(163)=< -A+B+2,s(154)=<A,s(162)=< -3/2*A+3/2*B,s(153)=<B,s(161)=<2*B,s(158)=<B/2,s(132)=<B/3,s(160)=<3/2*B,s(152)=<C]
* Psum in Loop 38: [it(38)=<1,s(168)=<A,s(167)=<B,s(165)=<B/2]

###### Computing max_min for s(94)=< -3*A+3*B+6  
   - Found a solution using transitive invariants 
 * Adding constraints:[s(94)=<3*B-3,s(94)=< -3*A+3*B+6] 

##### Pending set nub(A,B,C,D,E,F)
* Pmax/min: [s(95)=< -A+B+2,s(100)=<C]
* Psum in Loop 37: [it(37)=<1,s(164)=< -3*A+3*B+6,s(156)=< -2*A+2*B,s(156)=< -2*A+2*B+4,s(155)=< -A+B,s(163)=< -A+B+2,s(154)=<A,s(162)=< -3/2*A+3/2*B,s(153)=<B,s(161)=<2*B,s(158)=<B/2,s(132)=<B/3,s(160)=<3/2*B,s(152)=<C]
* Psum in Loop 38: [it(38)=<1,s(168)=<A,s(167)=<B,s(165)=<B/2]

###### Computing max_min for s(95)=< -A+B+2  
   - Found a solution using cacheing 
 * Adding constraints:[s(95)=<s(94)* (1/3)] 

##### Pending set nub(A,B,C,D,E,F)
* Pmax/min: [s(100)=<C]
* Psum in Loop 37: [it(37)=<1,s(164)=< -3*A+3*B+6,s(156)=< -2*A+2*B,s(156)=< -2*A+2*B+4,s(155)=< -A+B,s(163)=< -A+B+2,s(154)=<A,s(162)=< -3/2*A+3/2*B,s(153)=<B,s(161)=<2*B,s(158)=<B/2,s(132)=<B/3,s(160)=<3/2*B,s(152)=<C]
* Psum in Loop 38: [it(38)=<1,s(168)=<A,s(167)=<B,s(165)=<B/2]

###### Computing max_min for s(100)=<C  
   - Applying max/min strategy 
     - Loop 37  increases the expression by [C',-F+C'+F'] 
     - Loop 38  increases the expression by [C',-F+C'+F'] 
 * Adding constraints:[s(100)=<aux(53)+aux(54)+aux(55),aux(53)=<C] 

##### Pending set nub(A,B,C,D,E,F)
* Psum in Loop 37: [it(37)=<1,s(164)=< -3*A+3*B+6,s(156)=< -2*A+2*B,s(156)=< -2*A+2*B+4,s(155)=< -A+B,s(163)=< -A+B+2,s(154)=<A,s(162)=< -3/2*A+3/2*B,s(153)=<B,s(161)=<2*B,s(158)=<B/2,s(132)=<B/3,s(160)=<3/2*B,s(152)=<C,aux(54)=< -F+C'+F',aux(54)=<C']
* Psum in Loop 38: [it(38)=<1,s(168)=<A,s(167)=<B,s(165)=<B/2,aux(55)=< -F+C'+F',aux(55)=<C']

###### Computing sum for it(37)=<1  in Loop 37 
   - Applying inductive sum strategy 
     - head Candidate: B-1 
       - Loop 38 is collaborative and bounds [it(38)] 
     - head Candidate: A-2 
       - Loop 38 is collaborative and bounds [it(38)] 
     - head Candidate: A-2 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: -A+B+1 
       - Loop 38 is collaborative
     - tail Candidate: B-1 
       - Loop 38 is collaborative and bounds [it(38)] 
     - tail Candidate: A-2 
       - Loop 38 is collaborative and bounds [it(38)] 
     - tail Candidate: A-2 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: -A+B+1 
       - Loop 38 is collaborative
 * Adding constraints: [it(37)+it(38)=<B-1,it(37)+it(38)=<A-2,it(37)+it(38)=<A-2,it(37)=< -A+B+1,it(37)+it(38)=<B-B',it(37)+it(38)=<A-A',it(37)+it(38)=<A-A',it(37)=< -A+B+A'-B'] 

##### Pending set nub(A,B,C,D,E,F)
* Psum in Loop 37: [s(164)=< -3*A+3*B+6,s(156)=< -2*A+2*B,s(156)=< -2*A+2*B+4,s(155)=< -A+B,s(163)=< -A+B+2,s(154)=<A,s(162)=< -3/2*A+3/2*B,s(153)=<B,s(161)=<2*B,s(158)=<B/2,s(132)=<B/3,s(160)=<3/2*B,s(152)=<C,aux(54)=< -F+C'+F',aux(54)=<C']
* Psum in Loop 38: [it(38)=<1,s(168)=<A,s(167)=<B,s(165)=<B/2,aux(55)=< -F+C'+F',aux(55)=<C']

###### Computing sum for s(164)=< -3*A+3*B+6  in Loop 37 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(56)=< -3*A+3*B+6] 
 * Adding constraints: [s(164)=<it(37)*aux(56)] 

##### Pending set nub(A,B,C,D,E,F)
* Pmax/min: [aux(56)=< -3*A+3*B+6]
* Psum in Loop 37: [s(156)=< -2*A+2*B,s(156)=< -2*A+2*B+4,s(155)=< -A+B,s(163)=< -A+B+2,s(154)=<A,s(162)=< -3/2*A+3/2*B,s(153)=<B,s(161)=<2*B,s(158)=<B/2,s(132)=<B/3,s(160)=<3/2*B,s(152)=<C,aux(54)=< -F+C'+F',aux(54)=<C']
* Psum in Loop 38: [it(38)=<1,s(168)=<A,s(167)=<B,s(165)=<B/2,aux(55)=< -F+C'+F',aux(55)=<C']

###### Computing max_min for aux(56)=< -3*A+3*B+6  
   - Found a solution using cacheing 
 * Adding constraints:[aux(56)=<s(94)] 

##### Pending set nub(A,B,C,D,E,F)
* Psum in Loop 37: [s(156)=< -2*A+2*B,s(156)=< -2*A+2*B+4,s(155)=< -A+B,s(163)=< -A+B+2,s(154)=<A,s(162)=< -3/2*A+3/2*B,s(153)=<B,s(161)=<2*B,s(158)=<B/2,s(132)=<B/3,s(160)=<3/2*B,s(152)=<C,aux(54)=< -F+C'+F',aux(54)=<C']
* Psum in Loop 38: [it(38)=<1,s(168)=<A,s(167)=<B,s(165)=<B/2,aux(55)=< -F+C'+F',aux(55)=<C']

###### Computing sum for s(156)=< -2*A+2*B  in Loop 37 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(57)=< -2*A+2*B] 
 * Adding constraints: [s(156)=<it(37)*aux(57)] 

##### Pending set nub(A,B,C,D,E,F)
* Pmax/min: [aux(57)=< -2*A+2*B]
* Psum in Loop 37: [s(156)=< -2*A+2*B+4,s(155)=< -A+B,s(163)=< -A+B+2,s(154)=<A,s(162)=< -3/2*A+3/2*B,s(153)=<B,s(161)=<2*B,s(158)=<B/2,s(132)=<B/3,s(160)=<3/2*B,s(152)=<C,aux(54)=< -F+C'+F',aux(54)=<C']
* Psum in Loop 38: [it(38)=<1,s(168)=<A,s(167)=<B,s(165)=<B/2,aux(55)=< -F+C'+F',aux(55)=<C']

###### Computing max_min for aux(57)=< -2*A+2*B  
   - Found a solution using cacheing 
 * Adding constraints:[aux(57)=<s(94)* (2/3)-4] 

##### Pending set nub(A,B,C,D,E,F)
* Psum in Loop 37: [s(156)=< -2*A+2*B+4,s(155)=< -A+B,s(163)=< -A+B+2,s(154)=<A,s(162)=< -3/2*A+3/2*B,s(153)=<B,s(161)=<2*B,s(158)=<B/2,s(132)=<B/3,s(160)=<3/2*B,s(152)=<C,aux(54)=< -F+C'+F',aux(54)=<C']
* Psum in Loop 38: [it(38)=<1,s(168)=<A,s(167)=<B,s(165)=<B/2,aux(55)=< -F+C'+F',aux(55)=<C']

###### Computing sum for s(156)=< -2*A+2*B+4  in Loop 37 
   - Found a solution using cacheing 
 * Adding constraints: [s(156)=<aux(58)* (2/3),aux(58)=<it(37)*aux(56)] 

##### Pending set nub(A,B,C,D,E,F)
* Psum in Loop 37: [s(155)=< -A+B,s(163)=< -A+B+2,s(154)=<A,s(162)=< -3/2*A+3/2*B,s(153)=<B,s(161)=<2*B,s(158)=<B/2,s(132)=<B/3,s(160)=<3/2*B,s(152)=<C,aux(54)=< -F+C'+F',aux(54)=<C']
* Psum in Loop 38: [it(38)=<1,s(168)=<A,s(167)=<B,s(165)=<B/2,aux(55)=< -F+C'+F',aux(55)=<C']

###### Computing sum for s(155)=< -A+B  in Loop 37 
   - Found a solution using cacheing 
 * Adding constraints: [s(155)=<aux(59)* (1/2),aux(59)=<it(37)*aux(57)] 

##### Pending set nub(A,B,C,D,E,F)
* Psum in Loop 37: [s(163)=< -A+B+2,s(154)=<A,s(162)=< -3/2*A+3/2*B,s(153)=<B,s(161)=<2*B,s(158)=<B/2,s(132)=<B/3,s(160)=<3/2*B,s(152)=<C,aux(54)=< -F+C'+F',aux(54)=<C']
* Psum in Loop 38: [it(38)=<1,s(168)=<A,s(167)=<B,s(165)=<B/2,aux(55)=< -F+C'+F',aux(55)=<C']

###### Computing sum for s(163)=< -A+B+2  in Loop 37 
   - Found a solution using cacheing 
 * Adding constraints: [s(163)=<aux(60)* (1/3),aux(60)=<it(37)*aux(56)] 

##### Pending set nub(A,B,C,D,E,F)
* Psum in Loop 37: [s(154)=<A,s(162)=< -3/2*A+3/2*B,s(153)=<B,s(161)=<2*B,s(158)=<B/2,s(132)=<B/3,s(160)=<3/2*B,s(152)=<C,aux(54)=< -F+C'+F',aux(54)=<C']
* Psum in Loop 38: [it(38)=<1,s(168)=<A,s(167)=<B,s(165)=<B/2,aux(55)=< -F+C'+F',aux(55)=<C']

###### Computing sum for s(154)=<A  in Loop 37 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(61)=<A] 
 * Adding constraints: [s(154)=<it(37)*aux(61)] 

##### Pending set nub(A,B,C,D,E,F)
* Pmax/min: [aux(61)=<A]
* Psum in Loop 37: [s(162)=< -3/2*A+3/2*B,s(153)=<B,s(161)=<2*B,s(158)=<B/2,s(132)=<B/3,s(160)=<3/2*B,s(152)=<C,aux(54)=< -F+C'+F',aux(54)=<C']
* Psum in Loop 38: [it(38)=<1,s(168)=<A,s(167)=<B,s(165)=<B/2,aux(55)=< -F+C'+F',aux(55)=<C']

###### Computing max_min for aux(61)=<A  
   - Found a solution using transitive invariants 
 * Adding constraints:[aux(61)=<A,aux(61)=<B+1] 

##### Pending set nub(A,B,C,D,E,F)
* Psum in Loop 37: [s(162)=< -3/2*A+3/2*B,s(153)=<B,s(161)=<2*B,s(158)=<B/2,s(132)=<B/3,s(160)=<3/2*B,s(152)=<C,aux(54)=< -F+C'+F',aux(54)=<C']
* Psum in Loop 38: [it(38)=<1,s(168)=<A,s(167)=<B,s(165)=<B/2,aux(55)=< -F+C'+F',aux(55)=<C']

###### Computing sum for s(162)=< -3/2*A+3/2*B  in Loop 37 
   - Found a solution using cacheing 
 * Adding constraints: [s(162)=<aux(62)* (3/4),aux(62)=<it(37)*aux(57)] 

##### Pending set nub(A,B,C,D,E,F)
* Psum in Loop 37: [s(153)=<B,s(161)=<2*B,s(158)=<B/2,s(132)=<B/3,s(160)=<3/2*B,s(152)=<C,aux(54)=< -F+C'+F',aux(54)=<C']
* Psum in Loop 38: [it(38)=<1,s(168)=<A,s(167)=<B,s(165)=<B/2,aux(55)=< -F+C'+F',aux(55)=<C']

###### Computing sum for s(153)=<B  in Loop 37 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(63)=<B] 
 * Adding constraints: [s(153)=<it(37)*aux(63)] 

##### Pending set nub(A,B,C,D,E,F)
* Pmax/min: [aux(63)=<B]
* Psum in Loop 37: [s(161)=<2*B,s(158)=<B/2,s(132)=<B/3,s(160)=<3/2*B,s(152)=<C,aux(54)=< -F+C'+F',aux(54)=<C']
* Psum in Loop 38: [it(38)=<1,s(168)=<A,s(167)=<B,s(165)=<B/2,aux(55)=< -F+C'+F',aux(55)=<C']

###### Computing max_min for aux(63)=<B  
   - Found a solution using transitive invariants 
 * Adding constraints:[aux(63)=<B] 

##### Pending set nub(A,B,C,D,E,F)
* Psum in Loop 37: [s(161)=<2*B,s(158)=<B/2,s(132)=<B/3,s(160)=<3/2*B,s(152)=<C,aux(54)=< -F+C'+F',aux(54)=<C']
* Psum in Loop 38: [it(38)=<1,s(168)=<A,s(167)=<B,s(165)=<B/2,aux(55)=< -F+C'+F',aux(55)=<C']

###### Computing sum for s(161)=<2*B  in Loop 37 
   - Found a solution using cacheing 
 * Adding constraints: [s(161)=<aux(64)*2,aux(64)=<it(37)*aux(63)] 

##### Pending set nub(A,B,C,D,E,F)
* Psum in Loop 37: [s(158)=<B/2,s(132)=<B/3,s(160)=<3/2*B,s(152)=<C,aux(54)=< -F+C'+F',aux(54)=<C']
* Psum in Loop 38: [it(38)=<1,s(168)=<A,s(167)=<B,s(165)=<B/2,aux(55)=< -F+C'+F',aux(55)=<C']

###### Computing sum for s(158)=<B/2  in Loop 37 
   - Found a solution using cacheing 
 * Adding constraints: [s(158)=<aux(65)* (1/2),aux(65)=<it(37)*aux(63)] 

##### Pending set nub(A,B,C,D,E,F)
* Psum in Loop 37: [s(132)=<B/3,s(160)=<3/2*B,s(152)=<C,aux(54)=< -F+C'+F',aux(54)=<C']
* Psum in Loop 38: [it(38)=<1,s(168)=<A,s(167)=<B,s(165)=<B/2,aux(55)=< -F+C'+F',aux(55)=<C']

###### Computing sum for s(132)=<B/3  in Loop 37 
   - Found a solution using cacheing 
 * Adding constraints: [s(132)=<aux(66)* (1/3),aux(66)=<it(37)*aux(63)] 

##### Pending set nub(A,B,C,D,E,F)
* Psum in Loop 37: [s(160)=<3/2*B,s(152)=<C,aux(54)=< -F+C'+F',aux(54)=<C']
* Psum in Loop 38: [it(38)=<1,s(168)=<A,s(167)=<B,s(165)=<B/2,aux(55)=< -F+C'+F',aux(55)=<C']

###### Computing sum for s(160)=<3/2*B  in Loop 37 
   - Found a solution using cacheing 
 * Adding constraints: [s(160)=<aux(67)* (3/2),aux(67)=<it(37)*aux(63)] 

##### Pending set nub(A,B,C,D,E,F)
* Psum in Loop 37: [s(152)=<C,aux(54)=< -F+C'+F',aux(54)=<C']
* Psum in Loop 38: [it(38)=<1,s(168)=<A,s(167)=<B,s(165)=<B/2,aux(55)=< -F+C'+F',aux(55)=<C']

###### Computing sum for s(152)=<C  in Loop 37 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(68)=<C] 
 * Adding constraints: [s(152)=<it(37)*aux(68)] 

##### Pending set nub(A,B,C,D,E,F)
* Pmax/min: [aux(68)=<C]
* Psum in Loop 37: [aux(54)=< -F+C'+F',aux(54)=<C']
* Psum in Loop 38: [it(38)=<1,s(168)=<A,s(167)=<B,s(165)=<B/2,aux(55)=< -F+C'+F',aux(55)=<C']

###### Computing max_min for aux(68)=<C  
   - Found a solution using cacheing 
 * Adding constraints:[aux(68)=<s(100)] 

##### Pending set nub(A,B,C,D,E,F)
* Psum in Loop 37: [aux(54)=< -F+C'+F',aux(54)=<C']
* Psum in Loop 38: [it(38)=<1,s(168)=<A,s(167)=<B,s(165)=<B/2,aux(55)=< -F+C'+F',aux(55)=<C']

###### Computing sum for aux(54)=< -F+C'+F'  in Loop 37 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [] 
 * Adding constraints: [aux(54)=<it(37)*aux(69)] 

##### Pending set nub(A,B,C,D,E,F)
* Psum in Loop 37: [aux(54)=<C']
* Psum in Loop 38: [it(38)=<1,s(168)=<A,s(167)=<B,s(165)=<B/2,aux(55)=< -F+C'+F',aux(55)=<C']

###### Computing sum for aux(54)=<C'  in Loop 37 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [] 
 * Adding constraints: [aux(54)=<it(37)*aux(70)] 

##### Pending set nub(A,B,C,D,E,F)
* Psum in Loop 38: [it(38)=<1,s(168)=<A,s(167)=<B,s(165)=<B/2,aux(55)=< -F+C'+F',aux(55)=<C']

###### Computing sum for it(38)=<1  in Loop 38 
   - Applying inductive sum strategy 
     - head Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A-2 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A-2 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-2 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-2 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(37)+it(38)=<B-1,it(37)+it(38)=<A-2,it(37)+it(38)=<A-2,it(37)+it(38)=<B-B',it(37)+it(38)=<A-A',it(37)+it(38)=<A-A'] 

##### Pending set nub(A,B,C,D,E,F)
* Psum in Loop 38: [s(168)=<A,s(167)=<B,s(165)=<B/2,aux(55)=< -F+C'+F',aux(55)=<C']

###### Computing sum for s(168)=<A  in Loop 38 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(71)=<A] 
 * Adding constraints: [s(168)=<it(38)*aux(71)] 

##### Pending set nub(A,B,C,D,E,F)
* Pmax/min: [aux(71)=<A]
* Psum in Loop 38: [s(167)=<B,s(165)=<B/2,aux(55)=< -F+C'+F',aux(55)=<C']

###### Computing max_min for aux(71)=<A  
   - Found a solution using cacheing 
 * Adding constraints:[aux(71)=<aux(61)] 

##### Pending set nub(A,B,C,D,E,F)
* Psum in Loop 38: [s(167)=<B,s(165)=<B/2,aux(55)=< -F+C'+F',aux(55)=<C']

###### Computing sum for s(167)=<B  in Loop 38 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(72)=<B] 
 * Adding constraints: [s(167)=<it(38)*aux(72)] 

##### Pending set nub(A,B,C,D,E,F)
* Pmax/min: [aux(72)=<B]
* Psum in Loop 38: [s(165)=<B/2,aux(55)=< -F+C'+F',aux(55)=<C']

###### Computing max_min for aux(72)=<B  
   - Found a solution using cacheing 
 * Adding constraints:[aux(72)=<aux(63)] 

##### Pending set nub(A,B,C,D,E,F)
* Psum in Loop 38: [s(165)=<B/2,aux(55)=< -F+C'+F',aux(55)=<C']

###### Computing sum for s(165)=<B/2  in Loop 38 
   - Found a solution using cacheing 
 * Adding constraints: [s(165)=<aux(73)* (1/2),aux(73)=<it(38)*aux(72)] 

##### Pending set nub(A,B,C,D,E,F)
* Psum in Loop 38: [aux(55)=< -F+C'+F',aux(55)=<C']

###### Computing sum for aux(55)=< -F+C'+F'  in Loop 38 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [] 
 * Adding constraints: [aux(55)=<it(38)*aux(74)] 

##### Pending set nub(A,B,C,D,E,F)
* Psum in Loop 38: [aux(55)=<C']

###### Computing sum for aux(55)=<C'  in Loop 38 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [] 
 * Adding constraints: [aux(55)=<it(38)*aux(75)] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [37,38] 

#### Simplifying cost structure of phase [37,38] 
 * Joined equivalent variables [aux(78),aux(63)] into aux(78)
 * Joined equivalent variables [aux(64),aux(65),aux(66),aux(67),s(153)] into aux(64)
 * Joined equivalent variables [aux(73),s(167)] into aux(73)
 * Joined equivalent variables [aux(59),aux(62)] into aux(59)
 * Joined equivalent variables [aux(58),aux(60),s(164)] into aux(58)
 * Joined equivalent variables [aux(68),s(115)] into aux(68)

#### Cost of phase [37,38]:nub(A,B,C,D,E,F) -> [nub(A',B',C',D',E',F')] 
9*it(37)+9*it(38)+15*s(132)+14*s(133)+15*s(134)+15*s(135)+12*s(136)+18*s(137)+9*s(138)+9*s(139)+9*s(140)+9*s(141)+9*s(142)+9*s(143)+18*s(144)+9*s(145)+9*s(146)+15*s(165)+12*s(166)+0
  Such that:s(94) =< -3*A+3*B+6
it(37) =< -A+B+1
it(37) =< -A+B+A'-B'
aux(61) =< B+1
s(94) =< 3*B
aux(76) =< A
aux(77) =< A-A'
aux(78) =< B
aux(79) =< B-B'
aux(61) =< aux(76)
it(37) =< aux(76)
it(38) =< aux(76)
it(37) =< aux(77)
it(38) =< aux(77)
it(37) =< aux(78)
it(38) =< aux(78)
it(37) =< aux(79)
it(38) =< aux(79)
aux(72) =< aux(78)
aux(71) =< aux(61)
aux(57) =< s(94)* (2/3)-4
aux(56) =< s(94)
s(95) =< s(94)* (1/3)
aux(64) =< it(37)*aux(78)
s(154) =< it(37)*aux(61)
aux(73) =< it(38)*aux(72)
s(168) =< it(38)*aux(71)
s(160) =< aux(64)* (3/2)
s(132) =< aux(64)* (1/3)
s(158) =< aux(64)* (1/2)
s(161) =< aux(64)*2
aux(59) =< it(37)*aux(57)
aux(58) =< it(37)*aux(56)
s(156) =< it(37)*aux(57)
s(165) =< aux(73)* (1/2)
s(162) =< aux(59)* (3/4)
s(163) =< aux(58)* (1/3)
s(155) =< aux(59)* (1/2)
s(156) =< aux(58)* (2/3)
s(165) =< s(168)
s(166) =< s(168)
s(165) =< aux(73)
s(166) =< aux(73)
s(101) =< s(94)
s(159) =< aux(58)
s(101) =< s(95)
s(155) =< s(163)
s(160) =< s(162)
s(159) =< s(162)
s(132) =< aux(64)
s(157) =< aux(64)
s(157) =< s(158)
s(132) =< s(161)
s(133) =< s(161)
s(147) =< s(161)
s(134) =< s(161)
s(135) =< s(161)
s(133) =< s(160)
s(150) =< s(160)
s(133) =< s(159)
s(150) =< s(159)
s(136) =< s(158)
s(132) =< s(158)
s(133) =< s(158)
s(136) =< s(157)
s(134) =< s(157)
s(132) =< s(157)
s(133) =< s(157)
s(134) =< s(156)
s(132) =< s(156)
s(133) =< s(156)
s(147) =< s(156)
s(148) =< s(156)
s(133) =< s(155)
s(151) =< s(155)
s(136) =< s(154)
s(134) =< s(154)
s(132) =< s(154)
s(133) =< s(154)
s(135) =< s(154)
s(136) =< aux(64)
s(134) =< aux(64)
s(133) =< aux(64)
s(135) =< aux(64)
s(148) =< aux(64)
s(151) =< aux(64)
s(149) =< s(134)*s(101)
s(144) =< s(147)
s(141) =< s(147)
s(137) =< s(147)
s(145) =< s(151)
s(142) =< s(151)
s(139) =< s(151)
s(145) =< s(150)
s(142) =< s(150)
s(139) =< s(150)
s(146) =< s(149)
s(143) =< s(149)
s(138) =< s(149)
s(146) =< s(148)
s(143) =< s(148)
s(138) =< s(148)
s(140) =< s(147)

#### Simplifying cost structure of chain [[37,38],40] 
 * Joined equivalent variables [aux(80),aux(76),aux(77)] into aux(80)
 * Joined equivalent variables [aux(81),aux(78),aux(79)] into aux(81)
 * Joined equivalent variables [s(137),s(140),s(141),s(144)] into s(137)
 * Joined equivalent variables [s(138),s(143),s(146)] into s(138)
 * Joined equivalent variables [s(139),s(142),s(145)] into s(139)

#### Simplifying cost structure of CE 39 

#### Simplifying cost structure of chain [39,40] 

#### Found solution for phase  [37,38] in the cache 

#### Cost of phase [37,38]:nub(A,B,C,D,E,F) -> [nub(A',B',C',D',E',F')] 
9*it(37)+9*it(38)+15*s(132)+14*s(133)+15*s(134)+15*s(135)+12*s(136)+18*s(137)+9*s(138)+9*s(139)+9*s(140)+9*s(141)+9*s(142)+9*s(143)+18*s(144)+9*s(145)+9*s(146)+15*s(165)+12*s(166)+0
  Such that:s(94) =< -3*A+3*B+6
it(37) =< -A+B+1
it(37) =< -A+B+A'-B'
aux(61) =< B+1
s(94) =< 3*B
aux(76) =< A
aux(77) =< A-A'
aux(78) =< B
aux(79) =< B-B'
aux(61) =< aux(76)
it(37) =< aux(76)
it(38) =< aux(76)
it(37) =< aux(77)
it(38) =< aux(77)
it(37) =< aux(78)
it(38) =< aux(78)
it(37) =< aux(79)
it(38) =< aux(79)
aux(72) =< aux(78)
aux(71) =< aux(61)
aux(57) =< s(94)* (2/3)-4
aux(56) =< s(94)
s(95) =< s(94)* (1/3)
aux(64) =< it(37)*aux(78)
s(154) =< it(37)*aux(61)
aux(73) =< it(38)*aux(72)
s(168) =< it(38)*aux(71)
s(160) =< aux(64)* (3/2)
s(132) =< aux(64)* (1/3)
s(158) =< aux(64)* (1/2)
s(161) =< aux(64)*2
aux(59) =< it(37)*aux(57)
aux(58) =< it(37)*aux(56)
s(156) =< it(37)*aux(57)
s(165) =< aux(73)* (1/2)
s(162) =< aux(59)* (3/4)
s(163) =< aux(58)* (1/3)
s(155) =< aux(59)* (1/2)
s(156) =< aux(58)* (2/3)
s(165) =< s(168)
s(166) =< s(168)
s(165) =< aux(73)
s(166) =< aux(73)
s(101) =< s(94)
s(159) =< aux(58)
s(101) =< s(95)
s(155) =< s(163)
s(160) =< s(162)
s(159) =< s(162)
s(132) =< aux(64)
s(157) =< aux(64)
s(157) =< s(158)
s(132) =< s(161)
s(133) =< s(161)
s(147) =< s(161)
s(134) =< s(161)
s(135) =< s(161)
s(133) =< s(160)
s(150) =< s(160)
s(133) =< s(159)
s(150) =< s(159)
s(136) =< s(158)
s(132) =< s(158)
s(133) =< s(158)
s(136) =< s(157)
s(134) =< s(157)
s(132) =< s(157)
s(133) =< s(157)
s(134) =< s(156)
s(132) =< s(156)
s(133) =< s(156)
s(147) =< s(156)
s(148) =< s(156)
s(133) =< s(155)
s(151) =< s(155)
s(136) =< s(154)
s(134) =< s(154)
s(132) =< s(154)
s(133) =< s(154)
s(135) =< s(154)
s(136) =< aux(64)
s(134) =< aux(64)
s(133) =< aux(64)
s(135) =< aux(64)
s(148) =< aux(64)
s(151) =< aux(64)
s(149) =< s(134)*s(101)
s(144) =< s(147)
s(141) =< s(147)
s(137) =< s(147)
s(145) =< s(151)
s(142) =< s(151)
s(139) =< s(151)
s(145) =< s(150)
s(142) =< s(150)
s(139) =< s(150)
s(146) =< s(149)
s(143) =< s(149)
s(138) =< s(149)
s(146) =< s(148)
s(143) =< s(148)
s(138) =< s(148)
s(140) =< s(147)

#### Simplifying cost structure of chain [[37,38],39,40] 
 * Joined equivalent variables [aux(82),aux(76),aux(77)] into aux(82)
 * Joined equivalent variables [aux(83),aux(78),aux(79)] into aux(83)
 * Joined equivalent variables [s(137),s(140),s(141),s(144)] into s(137)
 * Joined equivalent variables [s(138),s(143),s(146)] into s(138)
 * Joined equivalent variables [s(139),s(142),s(145)] into s(139)

#### Cost of chains of nub(A,B,C,D,E,F):
* Chain [[37,38],40]: 9*it(37)+9*it(38)+15*s(132)+14*s(133)+15*s(134)+15*s(135)+12*s(136)+54*s(137)+27*s(138)+27*s(139)+15*s(165)+12*s(166)+3
  Such that:s(94) =< -3*A+3*B+6
it(37) =< -A+B+1
aux(61) =< B+1
aux(80) =< A
aux(81) =< B
aux(61) =< aux(80)
it(37) =< aux(80)
it(38) =< aux(80)
it(37) =< aux(81)
it(38) =< aux(81)
aux(72) =< aux(81)
aux(71) =< aux(61)
aux(57) =< s(94)* (2/3)-4
aux(56) =< s(94)
s(95) =< s(94)* (1/3)
aux(64) =< it(37)*aux(81)
s(154) =< it(37)*aux(61)
aux(73) =< it(38)*aux(72)
s(168) =< it(38)*aux(71)
s(160) =< aux(64)* (3/2)
s(132) =< aux(64)* (1/3)
s(158) =< aux(64)* (1/2)
s(161) =< aux(64)*2
aux(59) =< it(37)*aux(57)
aux(58) =< it(37)*aux(56)
s(156) =< it(37)*aux(57)
s(165) =< aux(73)* (1/2)
s(162) =< aux(59)* (3/4)
s(163) =< aux(58)* (1/3)
s(155) =< aux(59)* (1/2)
s(156) =< aux(58)* (2/3)
s(165) =< s(168)
s(166) =< s(168)
s(165) =< aux(73)
s(166) =< aux(73)
s(101) =< s(94)
s(159) =< aux(58)
s(101) =< s(95)
s(155) =< s(163)
s(160) =< s(162)
s(159) =< s(162)
s(132) =< aux(64)
s(157) =< aux(64)
s(157) =< s(158)
s(132) =< s(161)
s(133) =< s(161)
s(147) =< s(161)
s(134) =< s(161)
s(135) =< s(161)
s(133) =< s(160)
s(150) =< s(160)
s(133) =< s(159)
s(150) =< s(159)
s(136) =< s(158)
s(132) =< s(158)
s(133) =< s(158)
s(136) =< s(157)
s(134) =< s(157)
s(132) =< s(157)
s(133) =< s(157)
s(134) =< s(156)
s(132) =< s(156)
s(133) =< s(156)
s(147) =< s(156)
s(148) =< s(156)
s(133) =< s(155)
s(151) =< s(155)
s(136) =< s(154)
s(134) =< s(154)
s(132) =< s(154)
s(133) =< s(154)
s(135) =< s(154)
s(136) =< aux(64)
s(134) =< aux(64)
s(133) =< aux(64)
s(135) =< aux(64)
s(148) =< aux(64)
s(151) =< aux(64)
s(149) =< s(134)*s(101)
s(137) =< s(147)
s(139) =< s(151)
s(139) =< s(150)
s(138) =< s(149)
s(138) =< s(148)

  with precondition: [C>=0,D>=2,F>=0,A>=D+1,E+1>=D,B+D>=A+E] 

* Chain [[37,38],39,40]: 9*it(37)+9*it(38)+15*s(132)+14*s(133)+15*s(134)+15*s(135)+12*s(136)+54*s(137)+27*s(138)+27*s(139)+15*s(165)+12*s(166)+12
  Such that:s(94) =< -3*A+3*B+6
it(37) =< -A+B+1
aux(61) =< B+1
aux(82) =< A
aux(83) =< B
aux(61) =< aux(82)
it(37) =< aux(82)
it(38) =< aux(82)
it(37) =< aux(83)
it(38) =< aux(83)
aux(72) =< aux(83)
aux(71) =< aux(61)
aux(57) =< s(94)* (2/3)-4
aux(56) =< s(94)
s(95) =< s(94)* (1/3)
aux(64) =< it(37)*aux(83)
s(154) =< it(37)*aux(61)
aux(73) =< it(38)*aux(72)
s(168) =< it(38)*aux(71)
s(160) =< aux(64)* (3/2)
s(132) =< aux(64)* (1/3)
s(158) =< aux(64)* (1/2)
s(161) =< aux(64)*2
aux(59) =< it(37)*aux(57)
aux(58) =< it(37)*aux(56)
s(156) =< it(37)*aux(57)
s(165) =< aux(73)* (1/2)
s(162) =< aux(59)* (3/4)
s(163) =< aux(58)* (1/3)
s(155) =< aux(59)* (1/2)
s(156) =< aux(58)* (2/3)
s(165) =< s(168)
s(166) =< s(168)
s(165) =< aux(73)
s(166) =< aux(73)
s(101) =< s(94)
s(159) =< aux(58)
s(101) =< s(95)
s(155) =< s(163)
s(160) =< s(162)
s(159) =< s(162)
s(132) =< aux(64)
s(157) =< aux(64)
s(157) =< s(158)
s(132) =< s(161)
s(133) =< s(161)
s(147) =< s(161)
s(134) =< s(161)
s(135) =< s(161)
s(133) =< s(160)
s(150) =< s(160)
s(133) =< s(159)
s(150) =< s(159)
s(136) =< s(158)
s(132) =< s(158)
s(133) =< s(158)
s(136) =< s(157)
s(134) =< s(157)
s(132) =< s(157)
s(133) =< s(157)
s(134) =< s(156)
s(132) =< s(156)
s(133) =< s(156)
s(147) =< s(156)
s(148) =< s(156)
s(133) =< s(155)
s(151) =< s(155)
s(136) =< s(154)
s(134) =< s(154)
s(132) =< s(154)
s(133) =< s(154)
s(135) =< s(154)
s(136) =< aux(64)
s(134) =< aux(64)
s(133) =< aux(64)
s(135) =< aux(64)
s(148) =< aux(64)
s(151) =< aux(64)
s(149) =< s(134)*s(101)
s(137) =< s(147)
s(139) =< s(151)
s(139) =< s(150)
s(138) =< s(149)
s(138) =< s(148)

  with precondition: [C>=0,D>=3,F>=0,A>=D,E>=D,B+3>=A+D,B+D>=A+E] 

* Chain [40]: 3
  with precondition: [A=1,B=0,D=1,E=0,C>=0,F>=0] 

* Chain [39,40]: 12
  with precondition: [A=2,D=2,B=E,B>=1,C>=0,F>=0] 


Closed-form bounds of eqD(A,B,C,D,E): 
-------------------------------------
* Chain [[26,27,28],25] with precondition: [A=C,1>=E,A>=2,B>=0,D>=0,E>=0,B+D+E>=1] 
    - Upper bound: 9*A+9*B+9*D+5 
    - Complexity: n 
* Chain [[26,27,28],24] with precondition: [E=0,A>=2,B>=0,D>=0,C>=A+1] 
    - Upper bound: 9*A+9*B+9*D+6 
    - Complexity: n 
* Chain [[26,27,28],23] with precondition: [E=0,B>=0,C>=2,D>=0,A>=C+1] 
    - Upper bound: 9*A+9*B+9*D+6 
    - Complexity: n 
* Chain [25] with precondition: [A=1,C=1,E=1,B>=0,D>=0] 
    - Upper bound: 5 
    - Complexity: constant 
* Chain [24] with precondition: [A=1,E=0,B>=0,C>=2,D>=0] 
    - Upper bound: 6 
    - Complexity: constant 
* Chain [23] with precondition: [C=1,E=0,A>=2,B>=0,D>=0] 
    - Upper bound: 6 
    - Complexity: constant 

### Maximum cost of eqD(A,B,C,D,E): 9*A+9*B+9*D+6 
Asymptotic class: n 

Closed-form bounds of removeL(A,B,C,D,E,F,G,H): 
-------------------------------------
* Chain [[35,36],29] with precondition: [A=1,C+G=D+F,B>=0,C>=2,E>=0,F>=1,H>=0,C>=F,D+2>=C+F] 
    - Upper bound: 12*C+15/2*D+3 
    - Complexity: n 
* Chain [[30,31,32,33,34],29] with precondition: [A>=2,B>=0,C>=2,E>=0,F>=1,H>=0,C>=F,G+1>=F,D+2*F>=2*C+G] 
    - Upper bound: 60*D+36*E+3+nat(-A+2*D)*50+ (-18*C+18*D+18)+ (-36*C+36*D+36)+nat(-A/2+D/2+1/2)*12+nat(-A/3+D/3)*15 
    - Complexity: n 
* Chain [29] with precondition: [C=1,D=0,F=1,G=0,A>=0,B>=0,E>=0,H>=0] 
    - Upper bound: 3 
    - Complexity: constant 

### Maximum cost of removeL(A,B,C,D,E,F,G,H): max([12*C+15/2*D,60*D+36*E+nat(-A+2*D)*50+ (-18*C+18*D+18)+ (-36*C+36*D+36)+nat(-A/2+D/2+1/2)*12+nat(-A/3+D/3)*15])+3 
Asymptotic class: n 

Closed-form bounds of nub(A,B,C,D,E,F): 
-------------------------------------
* Chain [[37,38],40] with precondition: [C>=0,D>=2,F>=0,A>=D+1,E+1>=D,B+D>=A+E] 
    - Upper bound: 9*A+3+15/2*B*A+ (-A+B+1)* (207*B)+ (-A+B+1)* (81/2*nat(-2*A+2*B))+ (12*B+12)*A+ (-9*A+9*B+9) 
    - Complexity: n^2 
* Chain [[37,38],39,40] with precondition: [C>=0,D>=3,F>=0,A>=D,E>=D,B+3>=A+D,B+D>=A+E] 
    - Upper bound: 9*A+12+15/2*B*A+ (-A+B+1)* (207*B)+ (-A+B+1)* (-81*A+81*B)+ (12*B+12)*A+ (-9*A+9*B+9) 
    - Complexity: n^2 
* Chain [40] with precondition: [A=1,B=0,D=1,E=0,C>=0,F>=0] 
    - Upper bound: 3 
    - Complexity: constant 
* Chain [39,40] with precondition: [A=2,D=2,B=E,B>=1,C>=0,F>=0] 
    - Upper bound: 12 
    - Complexity: constant 

### Maximum cost of nub(A,B,C,D,E,F): 15/2*B*A+9*A+ (-A+B+1)* (207*B)+ (-A+B+1)* (81/2*nat(-2*A+2*B))+ (12*B+12)*A+ (-9*A+9*B+9)+12 
Asymptotic class: n^2 
* Total analysis performed in 1462 ms.


Cost relation system solved by CoFloCo in 1464 ms.

Method eqD terminates?: YES

 - l1_1: size of l1 wrt. List<Rat>
 - l1_2: size of l1 wrt. Rat
 - l2_1: size of l2 wrt. List<Rat>
 - l2_2: size of l2 wrt. Rat
UB for eqD(l1_1,l1_2,l2_1,l2_2) = 9*l1_1+9*l1_2+9*l2_2+6

Method removeL terminates?: YES

 - x_1: size of x wrt. List<Rat>
 - x_2: size of x wrt. Rat
 - l_1: size of l wrt. List<List<Rat>>
 - l_2: size of l wrt. List<Rat>
 - l_3: size of l wrt. Rat
UB for removeL(x_1,x_2,l_1,l_2,l_3) = max([12*l_1+15/2*l_2,60*l_2+36*l_3+nat(-x_1+2*l_2)*50+ (-18*l_1+18*l_2+18)+ (-36*l_1+36*l_2+36)+nat(-x_1/2+l_2/2+1/2)*12+nat(-x_1/3+l_2/3)*15])+3

Method nub terminates?: YES

 - l_1: size of l wrt. List<List<Rat>>
 - l_2: size of l wrt. List<Rat>
 - l_3: size of l wrt. Rat
UB for nub(l_1,l_2,l_3) = 15/2*l_2*l_1+9*l_1+ (-l_1+l_2+1)* (207*l_2)+ (-l_1+l_2+1)* (81/2*nat(-2*l_1+2*l_2))+ (12*l_2+12)*l_1+ (-9*l_1+9*l_2+9)+12
