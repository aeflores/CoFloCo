
Abs program loaded in 20 ms.

Rule based representation generated in 11 ms.

Rule based representation stored in /tmp/costabs/rbr.rbr

RBR properties stored in /tmp/costabs/rbr.properties

Class invariants generated and loaded in 0 ms.

Abstract compilation performed in 111 ms.

Cost relation system stored in /tmp/costabs/crs.crs

Generated 76 equations 
entry('send_msg'(A,B,C):[]).
entry('main1'(A,B,C,D,E):[]).
entry('append'(A,B,C,D,E,F,G,H,I,J,K,L):[]).
entry('main2'(A,B,C,D,E):[]).
entry('main3'(A,B,C,D,E):[]).
entry('main4'(A,B,C,D,E):[]).
entry('main5'(A,B,C,D,E):[]).
input_output_vars('and_op'(A,B,C),[A,B],[C]).
input_output_vars('append'(A,B,C,D,E,F,G,H,I,J,K,L),[A,B,C,D,E,F,G,H],[I,J,K,L]).
input_output_vars('case_0'(A,B,C),[A,B],[C]).
input_output_vars('case_1'(A,B,C,D,E),[A,B,C,D],[E]).
input_output_vars('case_10'(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R),[A,B,C,D,E,F,G,H,I,J,K,L,M,N,O],[P,Q,R]).
input_output_vars('case_11'(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S),[A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R],[S]).
input_output_vars('case_12'(A,B,C,D,E,F,G,H),[A,B,C,D,E,F,G],[H]).
input_output_vars('case_13'(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q),[A,B,C,D,E,F,G,H,I,J,K,L,M,N],[O,P,Q]).
input_output_vars('case_14'(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V),[A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S],[T,U,V]).
input_output_vars('case_15'(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R),[A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q],[R]).
input_output_vars('case_2'(A,B,C,D,E,F,G,H,I,J,K,L),[A,B,C,D,E,F,G,H,I,J,K],[L]).
input_output_vars('case_3'(A,B,C,D,E,F,G,H,I,J,K,L),[A,B,C,D,E,F,G,H],[I,J,K,L]).
input_output_vars('case_4'(A,B,C,D,E,F,G),[A,B,C,D,E,F],[G]).
input_output_vars('case_5'(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O),[A,B,C,D,E,F,G,H,I,J,K,L,M],[N,O]).
input_output_vars('case_6'(A,B,C,D,E,F,G,H,I),[A,B,C,D,E,F,G,H],[I]).
input_output_vars('case_7'(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R),[A,B,C,D,E,F,G,H,I,J,K,L,M,N,O],[P,Q,R]).
input_output_vars('case_8'(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S),[A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R],[S]).
input_output_vars('case_9'(A,B,C,D,E,F,G,H,I),[A,B,C,D,E,F,G,H],[I]).
input_output_vars('eq'(A,B,C),[A,B],[C]).
input_output_vars('fun'(A,B,C),[A,B],[C]).
input_output_vars('geq'(A,B,C),[A,B],[C]).
input_output_vars('gt'(A,B,C),[A,B],[C]).
input_output_vars('leq'(A,B,C),[A,B],[C]).
input_output_vars('lt'(A,B,C),[A,B],[C]).
input_output_vars('main1'(A,B,C,D,E),[A,B,C,D],[E]).
input_output_vars('main2'(A,B,C,D,E),[A,B,C,D],[E]).
input_output_vars('main3'(A,B,C,D,E),[A,B,C,D],[E]).
input_output_vars('main4'(A,B,C,D,E),[A,B,C,D],[E]).
input_output_vars('main5'(A,B,C,D,E),[A,B,C,D],[E]).
input_output_vars('maxNorm'(A,B,C),[A,B],[C]).
input_output_vars('neg'(A,B),[A],[B]).
input_output_vars('neq'(A,B,C),[A,B],[C]).
input_output_vars('or'(A,B,C),[A,B],[C]).
input_output_vars('process_main1'(A,B,C,D,E),[A,B,C,D],[E]).
input_output_vars('process_main2'(A,B,C,D,E,F,G),[A,B,C,D,E,F],[G]).
input_output_vars('process_main3'(A,B,C,D,E,F,G,H,I),[A,B,C,D,E,F,G,H],[I]).
input_output_vars('process_main4'(A,B,C,D,E,F,G,H,I),[A,B,C,D,E,F,G,H],[I]).
input_output_vars('process_main5'(A,B,C,D,E,F,G,H),[A,B,C,D,E,F,G],[H]).
input_output_vars('send'(A,B,C),[A,B],[C]).
input_output_vars('send_msg'(A,B,C),[A,B],[C]).
input_output_vars('transmit'(A),[],[A]).
eq('eq',[A,B,C],0,[],[A=B,C=1,A>=0,B>=0,C>=0]).
eq('eq',[A,B,C],0,[],[A>=B+1,C=0,A>=0,B>=0,C>=0]).
eq('eq',[A,B,C],0,[],[B>=A+1,C=0,A>=0,B>=0,C>=0]).
eq('neq',[A,B,C],0,[],[A=B,C=0,A>=0,B>=0,C>=0]).
eq('neq',[A,B,C],0,[],[A>=B+1,C=1,A>=0,B>=0,C>=0]).
eq('neq',[A,B,C],0,[],[B>=A+1,C=1,A>=0,B>=0,C>=0]).
eq('lt',[A,B,C],0,[],[B-A>=1,C=1,A>=0,B>=0,C>=0]).
eq('lt',[A,B,C],0,[],[B=<A,C=0,A>=0,B>=0,C>=0]).
eq('leq',[A,B,C],0,[],[A=<B,C=1,A>=0,B>=0,C>=0]).
eq('leq',[A,B,C],0,[],[A-B>=1,C=0,A>=0,B>=0,C>=0]).
eq('gt',[A,B,C],0,[],[A-B>=1,C=1,A>=0,B>=0,C>=0]).
eq('gt',[A,B,C],0,[],[A=<B,C=0,A>=0,B>=0,C>=0]).
eq('geq',[A,B,C],0,[],[B=<A,C=1,A>=0,B>=0,C>=0]).
eq('geq',[A,B,C],0,[],[B-A>=1,C=0,A>=0,B>=0,C>=0]).
eq('neg',[A,B],0,[],[A=0,B=1,A>=0,B>=0]).
eq('neg',[A,B],0,[],[A=1,B=0,A>=0,B>=0]).
eq('and_op',[A,B,C],0,[],[A=0,C=0,A>=0,B>=0,C>=0]).
eq('and_op',[A,B,C],0,[],[A=1,C=B,A>=0,B>=0,C>=0]).
eq('or',[A,B,C],0,[],[A=1,C=1,A>=0,B>=0,C>=0]).
eq('or',[A,B,C],0,[],[A=0,C=B,A>=0,B>=0,C>=0]).
eq('maxNorm',[A,B,A],0,[],[A>=1+B,A>=0,B>=0,A>=0]).
eq('maxNorm',[A,B,B],0,[],[A=<B,A>=0,B>=0,B>=0]).
eq('transmit',[A],1,[],[A=1,A>=0]).
eq('case_0',[A,B,C],2,[],[A=1,C=1,A>=0,B>=0,C>=0]).
eq('case_0',[A,B,C],6,['transmit'(D),'send'(E,F,G)],[B=H+F,A=E+1,E>=1,I=D,D>=1,C=G,G>=1,A>=0,B>=0,C>=0]).
eq('send',[A,B,C],1,['case_0'(A,B,C)],[A>=0,B>=0,C>=0]).
eq('send_msg',[A,B,C],1,['send'(A,B,C)],[A>=0,B>=0,C>=0]).
eq('case_1',[A,B,C,D,E],2,[],[D=0,B=1,A=0,E=1,A>=0,B>=0,C>=0,D>=0,E>=0]).
eq('case_2',[A,B,C,D,E,F,G,H,I,J,K,L],2,[],[G=1,E=0,L=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0]).
eq('case_2',[A,B,C,D,E,F,G,H,I,J,K,L],3,[],[G=1,E=0,L=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0]).
eq('case_2',[A,B,C,D,E,F,G,H,I,J,K,L],4,[],[G=1,E=0,L=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0]).
eq('case_2',[A,B,C,D,E,F,G,H,I,J,K,L],5,['send_msg'(M,N,L)],[G=1,F=N,E=M,M>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0]).
eq('case_1',[A,B,C,D,E],6,['case_2'(A,B,C,D,F,G,H,I,J,K,L,M),'process_main1'(I,J,K,L,N)],[D=H+L,C=G+K,B=J+1,A=F+I,J>=1,H>=1,O=M,M>=1,E=N,N>=1,A>=0,B>=0,C>=0,D>=0,E>=0]).
eq('process_main1',[A,B,C,D,E],1,['case_1'(A,B,C,D,E)],[A>=0,B>=0,C>=0,D>=0,E>=0]).
eq('main1',[A,B,C,D,E],1,['process_main1'(A,B,C,D,E)],[A>=0,B>=0,C>=0,D>=0,E>=0]).
eq('case_3',[A,B,C,D,E,F,G,H,E,F,G,H],1,[],[D=0,C=1,A=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,E>=0,F>=0,G>=0,H>=0]).
eq('case_3',[A,B,C,D,E,F,G,H,I,J,K,L],4,['append'(M,N,O,P,E,F,G,H,Q,R,S,T)],[D=U+P,C=O+1,B=V+N,A=M+1,O>=1,M>=1,U>=1,L=U+T,K=S+1,J=V+R,I=Q+1,S>=1,Q>=1,U>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0]).
eq('append',[A,B,C,D,E,F,G,H,I,J,K,L],1,['case_3'(A,B,C,D,E,F,G,H,I,J,K,L)],[A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0]).
eq('case_4',[A,B,C,D,E,F,G],2,[],[D=0,B=1,A=0,G=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0]).
eq('case_5',[A,B,C,D,E,F,G,H,I,J,K,L,M,E,F],1,[],[I=1,G=0,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0,M>=0,E>=0,F>=0]).
eq('case_5',[A,B,C,D,E,F,G,H,I,J,K,L,M,N,O],6,['send_msg'(E,F,P)],[I=1,G=0,Q=P,P>=1,R=1,O=S,N=R,R>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0,M>=0,N>=0,O>=0]).
eq('case_5',[A,B,C,D,E,F,G,H,I,J,K,L,M,E,F],3,[],[I=1,G=0,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0,M>=0,E>=0,F>=0]).
eq('case_5',[A,B,C,D,E,F,G,H,I,J,K,L,M,N,O],5,['append'(P,Q,R,S,E,F,T,U,N,O,V,W)],[I=1,H=Q,G=P,P>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0,M>=0,N>=0,O>=0]).
eq('case_4',[A,B,C,D,E,F,G],6,['case_5'(A,B,C,D,E,F,H,I,J,K,L,M,N,O,P),'process_main2'(K,L,M,N,E,F,Q)],[D=J+N,C=I+M,B=L+1,A=H+K,L>=1,J>=1,R=P,S=O,O>=1,G=Q,Q>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0]).
eq('process_main2',[A,B,C,D,E,F,G],1,['case_4'(A,B,C,D,E,F,G)],[A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0]).
eq('main2',[A,B,C,D,E],2,['process_main2'(A,B,C,D,F,G,E)],[F=1,A>=0,B>=0,C>=0,D>=0,E>=0]).
eq('case_6',[A,B,C,D,E,F,G,H,I],2,[],[D=0,B=1,A=0,I=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0]).
eq('case_7',[A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R],2,[],[K=1,I=0,R=F+H,Q=E+G,P=1,G>=1,E>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0,M>=0,N>=0,O>=0,P>=0,Q>=0,R>=0]).
eq('case_7',[A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R],7,['send_msg'(E,F,S)],[K=1,I=0,T=S,S>=1,U=1,V=W+H,X=U+G,Y=1,G>=1,U>=1,R=V,Q=X,P=Y,Y>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0,M>=0,N>=0,O>=0,P>=0,Q>=0,R>=0]).
eq('case_7',[A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R],7,['send_msg'(G,H,S)],[K=1,I=0,T=S,S>=1,U=F+H,V=E+G,W=1,G>=1,E>=1,R=U,Q=V,P=W,W>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0,M>=0,N>=0,O>=0,P>=0,Q>=0,R>=0]).
eq('case_7',[A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R],7,['append'(S,T,U,V,E,F,W,X,Y,Z,A1,B1),'append'(S,T,U,V,G,H,C1,D1,E1,F1,G1,H1)],[K=1,J=T,I=S,S>=1,R=Z+F1,Q=Y+E1,P=1,E1>=1,Y>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0,M>=0,N>=0,O>=0,P>=0,Q>=0,R>=0]).
eq('case_8',[A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S],2,['process_main3'(O,P,Q,R,T,U,V,W,S)],[C=U+W,B=T+V,A=1,V>=1,T>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0,M>=0,N>=0,O>=0,P>=0,Q>=0,R>=0,S>=0]).
eq('case_6',[A,B,C,D,E,F,G,H,I],6,['case_7'(A,B,C,D,E,F,G,H,J,K,L,M,N,O,P,Q,R,S),'case_8'(T,U,V,A,B,C,D,E,F,G,H,J,K,L,M,N,O,P,W)],[D=L+P,C=K+O,B=N+1,A=J+M,N>=1,L>=1,V=S,U=R,T=Q,Q>=1,I=W,W>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0]).
eq('process_main3',[A,B,C,D,E,F,G,H,I],1,['case_6'(A,B,C,D,E,F,G,H,I)],[A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0]).
eq('main3',[A,B,C,D,E],3,['process_main3'(A,B,C,D,F,G,H,I,E)],[F=1,H=1,A>=0,B>=0,C>=0,D>=0,E>=0]).
eq('fun',[A,B,C],1,['send_msg'(A,B,C)],[A>=0,B>=0,C>=0]).
eq('case_9',[A,B,C,D,E,F,G,H,I],2,[],[D=0,B=1,A=0,I=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0]).
eq('case_10',[A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R],2,[],[K=1,I=0,R=F+H,Q=E+G,P=1,G>=1,E>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0,M>=0,N>=0,O>=0,P>=0,Q>=0,R>=0]).
eq('case_10',[A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R],7,['send_msg'(E,F,S)],[K=1,I=0,T=S,S>=1,U=1,V=W+H,X=U+G,Y=1,G>=1,U>=1,R=V,Q=X,P=Y,Y>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0,M>=0,N>=0,O>=0,P>=0,Q>=0,R>=0]).
eq('case_10',[A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R],7,['fun'(G,H,S)],[K=1,I=0,T=S,S>=1,U=F+H,V=E+G,W=1,G>=1,E>=1,R=U,Q=V,P=W,W>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0,M>=0,N>=0,O>=0,P>=0,Q>=0,R>=0]).
eq('case_10',[A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R],7,['append'(S,T,U,V,E,F,W,X,Y,Z,A1,B1),'append'(S,T,U,V,G,H,C1,D1,E1,F1,G1,H1)],[K=1,J=T,I=S,S>=1,R=Z+F1,Q=Y+E1,P=1,E1>=1,Y>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0,M>=0,N>=0,O>=0,P>=0,Q>=0,R>=0]).
eq('case_11',[A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S],2,['process_main4'(O,P,Q,R,T,U,V,W,S)],[C=U+W,B=T+V,A=1,V>=1,T>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0,M>=0,N>=0,O>=0,P>=0,Q>=0,R>=0,S>=0]).
eq('case_9',[A,B,C,D,E,F,G,H,I],6,['case_10'(A,B,C,D,E,F,G,H,J,K,L,M,N,O,P,Q,R,S),'case_11'(T,U,V,A,B,C,D,E,F,G,H,J,K,L,M,N,O,P,W)],[D=L+P,C=K+O,B=N+1,A=J+M,N>=1,L>=1,V=S,U=R,T=Q,Q>=1,I=W,W>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0]).
eq('process_main4',[A,B,C,D,E,F,G,H,I],1,['case_9'(A,B,C,D,E,F,G,H,I)],[A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0]).
eq('main4',[A,B,C,D,E],3,['process_main4'(A,B,C,D,F,G,H,I,E)],[F=1,H=1,A>=0,B>=0,C>=0,D>=0,E>=0]).
eq('case_12',[A,B,C,D,E,F,G,H],2,[],[D=0,B=1,A=0,H=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0]).
eq('case_13',[A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q],2,[],[J=1,H=0,Q=G+E,P=F,O=1,F>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0,M>=0,N>=0,O>=0,P>=0,Q>=0]).
eq('case_13',[A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q],3,[],[J=1,H=0,Q=G+E,P=F,O=1,F>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0,M>=0,N>=0,O>=0,P>=0,Q>=0]).
eq('case_13',[A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q],4,[],[J=1,H=0,Q=G+E,P=F,O=1,F>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0,M>=0,N>=0,O>=0,P>=0,Q>=0]).
eq('case_14',[A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V],7,['send_msg'(B,C,W)],[H>=A,X=W,W>=1,Y=1,Z=1,A1=B1+Z,C1=Y,D1=1,Y>=1,V=A1,U=C1,T=D1,D1>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0,M>=0,N>=0,O>=0,P>=0,Q>=0,R>=0,S>=0,T>=0,U>=0,V>=0]).
eq('case_14',[A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V],4,[],[A>=H+1,W=1,X=H+W,V=C+X,U=B,T=1,B>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0,M>=0,N>=0,O>=0,P>=0,Q>=0,R>=0,S>=0,T>=0,U>=0,V>=0]).
eq('case_13',[A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q],9,['append'(R,S,T,U,F,G,V,W,X,Y,Z,A1),'case_14'(B1,C1,D1,A,B,C,D,E,F,G,H,I,J,K,L,M,N,R,S,E1,F1,G1)],[J=1,I=S,H=R,R>=1,D1=Y,C1=X,X>=1,B1=5,Q=G1,P=F1,O=E1,E1>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0,M>=0,N>=0,O>=0,P>=0,Q>=0]).
eq('case_15',[A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R],2,['process_main5'(N,O,P,Q,S,T,U,R)],[C=U+S,B=T,A=1,T>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0,M>=0,N>=0,O>=0,P>=0,Q>=0,R>=0]).
eq('case_12',[A,B,C,D,E,F,G,H],6,['case_13'(A,B,C,D,E,F,G,I,J,K,L,M,N,O,P,Q,R),'case_15'(S,T,U,A,B,C,D,E,F,G,I,J,K,L,M,N,O,V)],[D=K+O,C=J+N,B=M+1,A=I+L,M>=1,K>=1,U=R,T=Q,S=P,P>=1,H=V,V>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0]).
eq('process_main5',[A,B,C,D,E,F,G,H],1,['case_12'(A,B,C,D,E,F,G,H)],[A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0]).
eq('main5',[A,B,C,D,E],3,['process_main5'(A,B,C,D,F,G,H,E)],[F=0,G=1,A>=0,B>=0,C>=0,D>=0,E>=0]).

Preprocessing Cost Relations
=====================================

#### Computed strongly connected components 
0. recursive  : [append/12,case_3/12]
1. non_recursive  : [transmit/1]
2. recursive  : [case_0/3,send/3]
3. non_recursive  : [send_msg/3]
4. non_recursive  : [case_2/12]
5. recursive  : [case_1/5,process_main1/5]
6. non_recursive  : [main1/5]
7. non_recursive  : [case_5/15]
8. recursive  : [case_4/7,process_main2/7]
9. non_recursive  : [main2/5]
10. non_recursive  : [case_7/18]
11. recursive  : [case_6/9,case_8/19,process_main3/9]
12. non_recursive  : [main3/5]
13. non_recursive  : [fun/3]
14. non_recursive  : [case_10/18]
15. recursive  : [case_11/19,case_9/9,process_main4/9]
16. non_recursive  : [main4/5]
17. non_recursive  : [case_14/22]
18. non_recursive  : [case_13/17]
19. recursive  : [case_12/8,case_15/18,process_main5/8]
20. non_recursive  : [main5/5]
Warning: the following predicates are never called:[and_op/3,eq/3,geq/3,gt/3,leq/3,lt/3,maxNorm/3,neg/2,neq/3,or/3]

#### Obtained direct recursion through partial evaluation 
0. SCC is partially evaluated into append/12
1. SCC is completely evaluated into other SCCs
2. SCC is partially evaluated into send/3
3. SCC is partially evaluated into send_msg/3
4. SCC is partially evaluated into case_2/12
5. SCC is partially evaluated into process_main1/5
6. SCC is partially evaluated into main1/5
7. SCC is partially evaluated into case_5/15
8. SCC is partially evaluated into process_main2/7
9. SCC is partially evaluated into main2/5
10. SCC is partially evaluated into case_7/18
11. SCC is partially evaluated into process_main3/9
12. SCC is partially evaluated into main3/5
13. SCC is completely evaluated into other SCCs
14. SCC is partially evaluated into case_10/18
15. SCC is partially evaluated into process_main4/9
16. SCC is partially evaluated into main4/5
17. SCC is partially evaluated into case_14/22
18. SCC is partially evaluated into case_13/17
19. SCC is partially evaluated into process_main5/8
20. SCC is partially evaluated into main5/5

Control-Flow Refinement of Cost Relations
=====================================

### Specialization of cost equations append/12 
* CE 4 is refined into CE [43] 
* CE 3 is refined into CE [44] 


#### Refined cost equations append/12 
* CE 43: append(A,B,C,D,E,F,G,H,E,F,G,H) = 2
     [H>=0,G>=0,F>=0,E>=0,B>=0,D=0,C=1,A=1] 
* CE 44: append(A,B,C,D,E,F,G,H,I,J,K,L) = 5+ append(M,N,O,P,E,F,G,H,Q,R,S,T)
     [L+P>=T,J+N>=R,L>=T+1,S>=1,Q>=1,O>=1,M>=1,L>=0,J>=0,H>=0,G>=0,F>=0,E>=0,D+T=L+P,B+R=J+N,S+1=K,Q+1=I,O+1=C,M+1=A] 

### Cost equations --> "Loop" of append/12 
* CEs [44] --> Loop 36 
* CEs [43] --> Loop 37 

#### Loops of append/12 
* Loop 36: append(A,B,C,D,E,F,G,H,I,J,K,L)->  append(A',B',C',D',E,F,G,H,E',F',G',H')
                  [L+D'>=H',J+B'>=F',L>=H'+1,G'>=1,E'>=1,C'>=1,A'>=1,L>=0,J>=0,H>=0,G>=0,F>=0,E>=0,L+D'=D+H',J+B'=B+F',G'+1=K,E'+1=I,C'+1=C,A'+1=A] 
* Loop 37: append(A,B,C,D,E,F,G,H,E,F,G,H) [H>=0,G>=0,F>=0,E>=0,B>=0,D=0,C=1,A=1] 

### Ranking functions of CR append(A,B,C,D,E,F,G,H,I,J,K,L) 
* RF of phase [36]: [A-1,C-1,D+1]

#### Partial ranking functions of CR append(A,B,C,D,E,F,G,H,I,J,K,L) 
* Partial RF of phase [36]:
  - RF of loop [36:1]:
    A-1
    C-1
    D+1

Discarded unfeasible chain [[36]]...(Non-terminating chain proved terminating)

### Resulting Chains:append(A,B,C,D,E,F,G,H,I,J,K,L) 
* [[36],37]
* [37]


### Merging Chains  append/12 into  External patterns of execution 
* [[37]] --> 1 
* [[37,[36]]] --> 2 


### Specialization of cost equations send/3 
* CE 10 is refined into CE [45] 
* CE 9 is refined into CE [46] 


#### Refined cost equations send/3 
* CE 45: send(A,B,C) = 3
     [B>=0,C=1,A=1] 
* CE 46: send(A,B,C) = 8+ send(D,E,C)
     [D>=1,C>=1,B>=0,D+1=A] 

### Cost equations --> "Loop" of send/3 
* CEs [46] --> Loop 38 
* CEs [45] --> Loop 39 

#### Loops of send/3 
* Loop 38: send(A,B,C)->  send(A',B',C)
                  [A'>=1,C>=1,B>=0,A'+1=A] 
* Loop 39: send(A,B,C) [B>=0,C=1,A=1] 

### Ranking functions of CR send(A,B,C) 
* RF of phase [38]: [A-1]

#### Partial ranking functions of CR send(A,B,C) 
* Partial RF of phase [38]:
  - RF of loop [38:1]:
    A-1

Discarded unfeasible chain [[38]]...(Non-terminating chain proved terminating)

### Resulting Chains:send(A,B,C) 
* [[38],39]
* [39]


### Merging Chains  send/3 into  External patterns of execution 
* [[39]] --> 1 
* [[39,[38]]] --> 2 


### Specialization of cost equations send_msg/3 
* CE 1 is refined into CE [47,48] 


#### Refined cost equations send_msg/3 
* CE 47: send_msg(A,B,C) = 1+ send(D,B,E):1
     [B>=0,E=1,D=1,C=1,A=1] 
* CE 48: send_msg(A,B,C) = 1+ send(A,B,D):2
     [B>=0,A>=2,D=1,C=1] 

### Cost equations --> "Loop" of send_msg/3 
* CEs [48] --> Loop 40 
* CEs [47] --> Loop 41 

#### Loops of send_msg/3 
* Loop 40: send_msg(A,B,C) [B>=0,A>=2,C=1] 
* Loop 41: send_msg(A,B,C) [B>=0,C=1,A=1] 

### Ranking functions of CR send_msg(A,B,C) 

#### Partial ranking functions of CR send_msg(A,B,C) 


### Resulting Chains:send_msg(A,B,C) 
* [41]
* [40]


### Merging Chains  send_msg/3 into  External patterns of execution 
* [[41]] --> 1 
* [[40]] --> 2 


### Specialization of cost equations case_2/12 
* CE 24 is refined into CE [49,50] 
* CE 21 is refined into CE [51] 
* CE 22 is refined into CE [52] 
* CE 23 is refined into CE [53] 


#### Refined cost equations case_2/12 
* CE 49: case_2(A,B,C,D,E,F,G,H,I,J,K,L) = 5+ send_msg(M,F,N):1
     [F>=0,K>=0,J>=0,I>=1,H>=0,F+J=C,K+1=D,I+1=B,H+1=A,N=1,M=1,L=1,G=1,E=1] 
* CE 50: case_2(A,B,C,D,E,F,G,H,I,J,K,L) = 5+ send_msg(E,F,M):2
     [F>=0,E>=2,K>=0,J>=0,I>=1,H>=0,F+J=C,E+H=A,K+1=D,I+1=B,M=1,L=1,G=1] 
* CE 51: case_2(A,B,C,D,E,F,G,A,H,I,J,K) = 2
     [J>=0,I>=0,H>=1,A>=0,F>=0,F+I=C,J+1=D,H+1=B,K=1,G=1,E=0] 
* CE 52: case_2(A,B,C,D,E,F,G,A,H,I,J,K) = 3
     [J>=0,I>=0,H>=1,A>=0,F>=0,F+I=C,J+1=D,H+1=B,K=1,G=1,E=0] 
* CE 53: case_2(A,B,C,D,E,F,G,A,H,I,J,K) = 4
     [J>=0,I>=0,H>=1,A>=0,F>=0,F+I=C,J+1=D,H+1=B,K=1,G=1,E=0] 

### Cost equations --> "Loop" of case_2/12 
* CEs [50] --> Loop 42 
* CEs [49] --> Loop 43 
* CEs [51,52,53] --> Loop 44 

#### Loops of case_2/12 
* Loop 42: case_2(A,B,C,D,E,F,G,H,I,J,K,L) [C>=F,A>=E,F>=0,E>=2,D>=1,B>=2,F+J=C,E+H=A,D=K+1,B=I+1,L=1,G=1] 
* Loop 43: case_2(A,B,C,D,E,F,G,H,I,J,K,L) [C>=F,F>=0,D>=1,B>=2,A>=1,F+J=C,D=K+1,B=I+1,A=H+1,L=1,G=1,E=1] 
* Loop 44: case_2(A,B,C,D,E,F,G,A,H,I,J,K) [C>=F,F>=0,D>=1,B>=2,A>=0,F+I=C,D=J+1,B=H+1,K=1,G=1,E=0] 

### Ranking functions of CR case_2(A,B,C,D,E,F,G,H,I,J,K,L) 

#### Partial ranking functions of CR case_2(A,B,C,D,E,F,G,H,I,J,K,L) 


### Resulting Chains:case_2(A,B,C,D,E,F,G,H,I,J,K,L) 
* [44]
* [43]
* [42]


### Merging Chains  case_2/12 into  External patterns of execution 
* [[44]] --> 1 
* [[43]] --> 2 
* [[42]] --> 3 


### Specialization of cost equations process_main1/5 
* CE 12 is refined into CE [54] 
* CE 11 is refined into CE [55,56,57] 


#### Refined cost equations process_main1/5 
* CE 54: process_main1(A,B,C,D,E) = 3
     [C>=0,E=1,D=0,B=1,A=0] 
* CE 55: process_main1(A,B,C,D,E) = 7+ case_2(A,F,G,H,I,J,K,A,L,M,N,O):1+ process_main1(A,L,M,N,E)
     [N>=0,M>=0,L>=1,A>=0,J>=0,E>=1,J+M=G,J+M=C,N+1=H,L+1=F,N+1=D,L+1=B,O=1,K=1,I=0] 
* CE 56: process_main1(A,B,C,D,E) = 7+ case_2(F,G,H,I,J,K,L,M,N,O,P,Q):2+ process_main1(M,N,O,P,E)
     [P>=0,O>=0,N>=1,M>=0,K>=0,E>=1,K+O=H,K+O=C,P+1=I,N+1=G,M+1=F,P+1=D,N+1=B,M+1=A,Q=1,L=1,J=1] 
* CE 57: process_main1(A,B,C,D,E) = 7+ case_2(F,G,H,I,J,K,L,M,N,O,P,Q):3+ process_main1(M,N,O,P,E)
     [P>=0,O>=0,N>=1,M>=0,K>=0,J>=2,E>=1,K+O=H,J+M=F,K+O=C,J+M=A,P+1=I,N+1=G,P+1=D,N+1=B,Q=1,L=1] 

### Cost equations --> "Loop" of process_main1/5 
* CEs [57] --> Loop 45 
* CEs [55] --> Loop 46 
* CEs [56] --> Loop 47 
* CEs [54] --> Loop 48 

#### Loops of process_main1/5 
* Loop 45: process_main1(A,B,C,D,E)->  process_main1(A',B',C',D',E)
                  [C>=C',A>=A'+2,C'>=0,A'>=0,E>=1,D>=1,B>=2,D=D'+1,B=B'+1] 
* Loop 46: process_main1(A,B,C,D,E)->  process_main1(A,A',B',C',E)
                  [C>=B',B'>=0,E>=1,D>=1,B>=2,A>=0,D=C'+1,B=A'+1] 
* Loop 47: process_main1(A,B,C,D,E)->  process_main1(A',B',C',D',E)
                  [C>=C',C'>=0,E>=1,D>=1,B>=2,A>=1,D=D'+1,B=B'+1,A=A'+1] 
* Loop 48: process_main1(A,B,C,D,E) [C>=0,E=1,D=0,B=1,A=0] 

### Ranking functions of CR process_main1(A,B,C,D,E) 
* RF of phase [45,46,47]: [B-1,D]

#### Partial ranking functions of CR process_main1(A,B,C,D,E) 
* Partial RF of phase [45,46,47]:
  - RF of loop [45:1]:
    A/2-1/2
  - RF of loop [45:1,46:1,47:1]:
    B-1
    D
  - RF of loop [47:1]:
    A

Discarded unfeasible chain [[45,46,47]]...(Non-terminating chain proved terminating)

### Resulting Chains:process_main1(A,B,C,D,E) 
* [[45,46,47],48]
* [48]


### Merging Chains  process_main1/5 into  External patterns of execution 
* [[48]] --> 1 
* [[48,[45,46,47]]] --> 2 


### Specialization of cost equations main1/5 
* CE 2 is refined into CE [58,59] 


#### Refined cost equations main1/5 
* CE 58: main1(A,B,C,D,E) = 1+ process_main1(F,G,C,H,I):1
     [C>=0,I=1,H=0,G=1,F=0,E=1,D=0,B=1,A=0] 
* CE 59: main1(A,B,C,D,E) = 1+ process_main1(A,F,C,D,G):2
     [D>=1,C>=0,A>=0,D+1=F,D+1=B,G=1,E=1] 

### Cost equations --> "Loop" of main1/5 
* CEs [59] --> Loop 49 
* CEs [58] --> Loop 50 

#### Loops of main1/5 
* Loop 49: main1(A,B,C,D,E) [C>=0,B>=2,A>=0,B=D+1,E=1] 
* Loop 50: main1(A,B,C,D,E) [C>=0,E=1,D=0,B=1,A=0] 

### Ranking functions of CR main1(A,B,C,D,E) 

#### Partial ranking functions of CR main1(A,B,C,D,E) 


### Resulting Chains:main1(A,B,C,D,E) 
* [50]
* [49]


### Merging Chains  main1/5 into  External patterns of execution 
* [[50]] --> 1 
* [[49]] --> 2 


### Specialization of cost equations case_5/15 
* CE 28 is refined into CE [60,61] 
* CE 25 is refined into CE [62] 
* CE 27 is refined into CE [63] 
* CE 26 is refined into CE [64] 


#### Refined cost equations case_5/15 
* CE 60: case_5(A,B,C,D,E,F,G,H,I,J,K,L,M,N,F) = 5+ append(O,H,P,Q,R,F,S,T,U,F,S,T):1
     [T>=0,S>=0,F>=0,H>=0,M>=0,L>=0,K>=1,J>=0,H+L=C,M+1=D,K+1=B,J+1=A,U=1,R=1,Q=0,P=1,O=1,N=1,I=1,G=1,E=1] 
* CE 61: case_5(A,B,C,D,E,F,G,H,I,J,K,L,M,G,N) = 5+ append(G,H,G,O,P,F,Q,R,G,N,S,T):2
     [F+H>=N,T>=O,S>=G,O+1>=G,N>=0,F>=0,G>=2,H>=0,M>=0,L>=0,K>=1,J>=0,G+Q=S+1,T=O+R,H+L=C,G+J=A,M+1=D,K+1=B,P=1,I=1,E=1] 
* CE 62: case_5(A,B,C,D,E,F,G,H,I,A,J,K,L,M,F) = 1
     [L>=0,K>=0,J>=1,A>=0,H>=0,F>=0,H+K=C,L+1=D,J+1=B,M=1,I=1,G=0,E=1] 
* CE 63: case_5(A,B,C,D,E,F,G,H,I,A,J,K,L,M,F) = 3
     [L>=0,K>=0,J>=1,A>=0,H>=0,F>=0,H+K=C,L+1=D,J+1=B,M=1,I=1,G=0,E=1] 
* CE 64: case_5(A,B,C,D,E,F,G,H,I,A,J,K,L,M,N) = 6+ send_msg(O,F,P):1
     [F>=0,N>=0,L>=0,K>=0,J>=1,A>=0,H>=0,H+K=C,L+1=D,J+1=B,P=1,O=1,M=1,I=1,G=0,E=1] 

### Cost equations --> "Loop" of case_5/15 
* CEs [61] --> Loop 51 
* CEs [60] --> Loop 52 
* CEs [62,63,64] --> Loop 53 

#### Loops of case_5/15 
* Loop 51: case_5(A,B,C,D,E,F,G,H,I,J,K,L,M,G,N) [F+H>=N,C>=H,A>=G,N>=0,H>=0,G>=2,F>=0,D>=1,B>=2,H+L=C,G+J=A,D=M+1,B=K+1,I=1,E=1] 
* Loop 52: case_5(A,B,C,D,E,F,G,H,I,J,K,L,M,N,F) [C>=H,H>=0,F>=0,D>=1,B>=2,A>=1,H+L=C,D=M+1,B=K+1,A=J+1,N=1,I=1,G=1,E=1] 
* Loop 53: case_5(A,B,C,D,E,F,G,H,I,A,J,K,L,M,N) [C>=H,N>=0,H>=0,F>=0,D>=1,B>=2,A>=0,H+K=C,D=L+1,B=J+1,M=1,I=1,G=0,E=1] 

### Ranking functions of CR case_5(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O) 

#### Partial ranking functions of CR case_5(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O) 


### Resulting Chains:case_5(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O) 
* [53]
* [52]
* [51]


### Merging Chains  case_5/15 into  External patterns of execution 
* [[53]] --> 1 
* [[52]] --> 2 
* [[51]] --> 3 


### Specialization of cost equations process_main2/7 
* CE 14 is refined into CE [65] 
* CE 13 is refined into CE [66,67,68] 


#### Refined cost equations process_main2/7 
* CE 65: process_main2(A,B,C,D,E,F,G) = 3
     [F>=0,C>=0,G=1,E=1,D=0,B=1,A=0] 
* CE 66: process_main2(A,B,C,D,E,F,G) = 7+ case_5(A,H,I,J,K,F,L,M,N,A,O,P,Q,R,S):1+ process_main2(A,O,P,Q,T,F,G)
     [S>=0,Q>=0,P>=0,O>=1,A>=0,M>=0,F>=0,G>=1,M+P=I,M+P=C,Q+1=J,O+1=H,Q+1=D,O+1=B,T=1,R=1,N=1,L=0,K=1,E=1] 
* CE 67: process_main2(A,B,C,D,E,F,G) = 7+ case_5(H,I,J,K,L,F,M,N,O,P,Q,R,S,T,F):2+ process_main2(P,Q,R,S,U,F,G)
     [F>=0,S>=0,R>=0,Q>=1,P>=0,N>=0,G>=1,N+R=J,N+R=C,S+1=K,Q+1=I,P+1=H,S+1=D,Q+1=B,P+1=A,U=1,T=1,O=1,M=1,L=1,E=1] 
* CE 68: process_main2(A,B,C,D,E,F,G) = 7+ case_5(H,I,J,K,L,F,M,N,O,P,Q,R,S,M,T):3+ process_main2(P,Q,R,S,U,F,G)
     [F+N>=T,T>=0,M>=2,S>=0,R>=0,Q>=1,P>=0,N>=0,F>=0,G>=1,N+R=J,M+P=H,N+R=C,M+P=A,S+1=K,Q+1=I,S+1=D,Q+1=B,U=1,O=1,L=1,E=1] 

### Cost equations --> "Loop" of process_main2/7 
* CEs [68] --> Loop 54 
* CEs [66] --> Loop 55 
* CEs [67] --> Loop 56 
* CEs [65] --> Loop 57 

#### Loops of process_main2/7 
* Loop 54: process_main2(A,B,C,D,E,F,G)->  process_main2(A',B',C',D',E',F,G)
                  [C>=C',A>=A'+2,C'>=0,A'>=0,G>=1,F>=0,D>=1,B>=2,D=D'+1,B=B'+1,E'=1,E=1] 
* Loop 55: process_main2(A,B,C,D,E,F,G)->  process_main2(A,A',B',C',D',F,G)
                  [C>=B',B'>=0,G>=1,F>=0,D>=1,B>=2,A>=0,D=C'+1,B=A'+1,D'=1,E=1] 
* Loop 56: process_main2(A,B,C,D,E,F,G)->  process_main2(A',B',C',D',E',F,G)
                  [C>=C',C'>=0,G>=1,F>=0,D>=1,B>=2,A>=1,D=D'+1,B=B'+1,A=A'+1,E'=1,E=1] 
* Loop 57: process_main2(A,B,C,D,E,F,G) [F>=0,C>=0,G=1,E=1,D=0,B=1,A=0] 

### Ranking functions of CR process_main2(A,B,C,D,E,F,G) 
* RF of phase [54,55,56]: [B-1,D]

#### Partial ranking functions of CR process_main2(A,B,C,D,E,F,G) 
* Partial RF of phase [54,55,56]:
  - RF of loop [54:1]:
    A/2-1/2
  - RF of loop [54:1,55:1,56:1]:
    B-1
    D
  - RF of loop [56:1]:
    A

Discarded unfeasible chain [[54,55,56]]...(Non-terminating chain proved terminating)

### Resulting Chains:process_main2(A,B,C,D,E,F,G) 
* [[54,55,56],57]
* [57]


### Merging Chains  process_main2/7 into  External patterns of execution 
* [[57]] --> 1 
* [[57,[54,55,56]]] --> 2 


### Specialization of cost equations main2/5 
* CE 5 is refined into CE [69,70] 


#### Refined cost equations main2/5 
* CE 69: main2(A,B,C,D,E) = 2+ process_main2(F,G,C,H,I,J,K):1
     [J>=0,C>=0,K=1,I=1,H=0,G=1,F=0,E=1,D=0,B=1,A=0] 
* CE 70: main2(A,B,C,D,E) = 2+ process_main2(A,F,C,D,G,H,I):2
     [H>=0,D>=1,C>=0,A>=0,D+1=F,D+1=B,I=1,G=1,E=1] 

### Cost equations --> "Loop" of main2/5 
* CEs [70] --> Loop 58 
* CEs [69] --> Loop 59 

#### Loops of main2/5 
* Loop 58: main2(A,B,C,D,E) [C>=0,B>=2,A>=0,B=D+1,E=1] 
* Loop 59: main2(A,B,C,D,E) [C>=0,E=1,D=0,B=1,A=0] 

### Ranking functions of CR main2(A,B,C,D,E) 

#### Partial ranking functions of CR main2(A,B,C,D,E) 


### Resulting Chains:main2(A,B,C,D,E) 
* [59]
* [58]


### Merging Chains  main2/5 into  External patterns of execution 
* [[59]] --> 1 
* [[58]] --> 2 


### Specialization of cost equations case_7/18 
* CE 32 is refined into CE [71,72] 
* CE 29 is refined into CE [73] 
* CE 31 is refined into CE [74,75] 
* CE 30 is refined into CE [76,77] 


#### Refined cost equations case_7/18 
* CE 71: case_7(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R) = 7+ append(S,J,T,U,E,F,V,W,E,F,V,W):1+ append(X,J,Y,Z,G,H,A1,B1,G,H,A1,B1):1
     [B1>=0,A1>=0,H>=0,G>=1,J>=0,W>=0,V>=0,F>=0,E>=1,O>=0,N>=0,M>=1,L>=0,F+H=R,E+G=Q,J+N=C,O+1=D,M+1=B,L+1=A,Z=0,Y=1,X=1,U=0,T=1,S=1,P=1,K=1,I=1] 
* CE 72: case_7(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R) = 7+ append(I,J,I,S,T,F,U,V,W,X,Y,Z):2+ append(I,J,I,S,A1,H,B1,C1,D1,E1,F1,G1):2
     [H+J>=E1,F+J>=X,G1>=S,Z>=S,F1>=I,D1>=I,S+1>=I,Y>=I,W>=I,E1>=0,H>=0,I>=2,J>=0,X>=0,F>=0,O>=0,N>=0,M>=1,L>=0,I+B1=F1+1,I+A1=D1+1,G+I=D1+1,G1=S+C1,S+V=Z,I+U=Y+1,I+T=W+1,E+I=W+1,X+E1=R,W+D1=Q,J+N=C,I+L=A,O+1=D,M+1=B,P=1,K=1] 
* CE 73: case_7(A,B,C,D,E,F,G,H,I,J,K,A,L,M,N,O,P,Q) = 2
     [N>=0,M>=0,L>=1,A>=0,J>=0,H>=0,G>=1,F>=0,E>=1,F+H=Q,E+G=P,J+M=C,N+1=D,L+1=B,O=1,K=1,I=0] 
* CE 74: case_7(A,B,C,D,E,F,G,H,I,J,K,A,L,M,N,O,P,Q) = 7+ send_msg(R,H,S):1
     [Q>=H,H>=0,N>=0,M>=0,L>=1,A>=0,J>=0,E>=1,F+H=Q,J+M=C,E+1=P,N+1=D,L+1=B,S=1,R=1,O=1,K=1,I=0,G=1] 
* CE 75: case_7(A,B,C,D,E,F,G,H,I,J,K,A,L,M,N,O,P,Q) = 7+ send_msg(G,H,R):2
     [Q>=H,H>=0,G>=2,N>=0,M>=0,L>=1,A>=0,J>=0,E>=1,F+H=Q,E+G=P,J+M=C,N+1=D,L+1=B,R=1,O=1,K=1,I=0] 
* CE 76: case_7(A,B,C,D,E,F,G,H,I,J,K,A,L,M,N,O,P,Q) = 7+ send_msg(R,F,S):1
     [F>=0,Q>=0,N>=0,M>=0,L>=1,A>=0,J>=0,H>=0,G>=1,J+M=C,G+1=P,N+1=D,L+1=B,S=1,R=1,O=1,K=1,I=0,E=1] 
* CE 77: case_7(A,B,C,D,E,F,G,H,I,J,K,A,L,M,N,O,P,Q) = 7+ send_msg(E,F,R):2
     [F>=0,E>=2,Q>=0,N>=0,M>=0,L>=1,A>=0,J>=0,H>=0,G>=1,J+M=C,G+1=P,N+1=D,L+1=B,R=1,O=1,K=1,I=0] 

### Cost equations --> "Loop" of case_7/18 
* CEs [72] --> Loop 60 
* CEs [71] --> Loop 61 
* CEs [77] --> Loop 62 
* CEs [73,74,75] --> Loop 63 
* CEs [76] --> Loop 64 

#### Loops of case_7/18 
* Loop 60: case_7(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R) [F+H+2*J>=R,C>=J,A>=I,R>=0,J>=0,I>=2,H>=0,G>=1,F>=0,E>=1,D>=1,B>=2,E+G+2*I=Q+2,C=J+N,A=I+L,D=O+1,B=M+1,P=1,K=1] 
* Loop 61: case_7(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R) [C>=J,J>=0,H>=0,G>=1,F>=0,E>=1,D>=1,B>=2,A>=1,F+H=R,E+G=Q,J+N=C,D=O+1,B=M+1,A=L+1,P=1,K=1,I=1] 
* Loop 62: case_7(A,B,C,D,E,F,G,H,I,J,K,A,L,M,N,O,P,Q) [C>=J,Q>=0,J>=0,H>=0,G>=1,F>=0,E>=2,D>=1,B>=2,A>=0,J+M=C,G+1=P,D=N+1,B=L+1,O=1,K=1,I=0] 
* Loop 63: case_7(A,B,C,D,E,F,G,H,I,J,K,A,L,M,N,O,P,Q) [C>=J,J>=0,H>=0,G>=1,F>=0,E>=1,D>=1,B>=2,A>=0,F+H=Q,E+G=P,J+M=C,D=N+1,B=L+1,O=1,K=1,I=0] 
* Loop 64: case_7(A,B,C,D,E,F,G,H,I,J,K,A,L,M,N,O,P,Q) [C>=J,Q>=0,J>=0,H>=0,G>=1,F>=0,D>=1,B>=2,A>=0,J+M=C,G+1=P,D=N+1,B=L+1,O=1,K=1,I=0,E=1] 

### Ranking functions of CR case_7(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R) 

#### Partial ranking functions of CR case_7(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R) 


### Resulting Chains:case_7(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R) 
* [64]
* [63]
* [62]
* [61]
* [60]


### Merging Chains  case_7/18 into  External patterns of execution 
* [[64]] --> 1 
* [[62]] --> 2 
* [[63]] --> 3 
* [[61]] --> 4 
* [[60]] --> 5 


### Specialization of cost equations process_main3/9 
* CE 16 is refined into CE [78,79,80,81,82] 
* CE 15 is refined into CE [83] 


#### Refined cost equations process_main3/9 
* CE 78: process_main3(A,B,C,D,E,F,G,H,I) = 9+ case_7(A,J,K,L,M,F,N,H,O,P,Q,A,R,S,T,U,V,W):1+ process_main3(A,R,S,T,X,Y,Z,A1,I)
     [V>=Z+1,Z>=1,W>=0,T>=0,S>=0,R>=1,A>=0,P>=0,H>=0,F>=0,I>=1,W=Y+A1,V=X+Z,P+S=K,P+S=C,V=N+1,T+1=L,R+1=J,V=G+1,T+1=D,R+1=B,U=1,Q=1,O=0,M=1,E=1] 
* CE 79: process_main3(A,B,C,D,E,F,G,H,I) = 9+ case_7(A,J,K,L,E,F,M,H,N,O,P,A,Q,R,S,T,U,V):2+ process_main3(A,Q,R,S,W,X,Y,Z,I)
     [U>=Y+1,Y>=1,V>=0,S>=0,R>=0,Q>=1,A>=0,O>=0,H>=0,F>=0,E>=2,I>=1,V=X+Z,U=W+Y,O+R=K,O+R=C,U=M+1,S+1=L,Q+1=J,U=G+1,S+1=D,Q+1=B,T=1,P=1,N=0] 
* CE 80: process_main3(A,B,C,D,E,F,G,H,I) = 9+ case_7(A,J,K,L,E,F,M,N,O,P,Q,A,R,S,T,U,V,W):3+ process_main3(A,R,S,T,X,Y,Z,A1,I)
     [V>=Z+1,W>=F,V>=E+1,Z>=1,T>=0,S>=0,R>=1,A>=0,P>=0,F>=0,E>=1,I>=1,W=Y+A1,V=X+Z,W=F+N,V=E+M,P+S=K,W=F+H,V=E+G,P+S=C,T+1=L,R+1=J,T+1=D,R+1=B,U=1,Q=1,O=0] 
* CE 81: process_main3(A,B,C,D,E,F,G,H,I) = 9+ case_7(J,K,L,M,E,F,N,O,P,Q,R,S,T,U,V,W,X,Y):4+ process_main3(S,T,U,V,Z,A1,B1,C1,I)
     [X>=B1+1,Y>=F,X>=E+1,B1>=1,V>=0,U>=0,T>=1,S>=0,Q>=0,F>=0,E>=1,I>=1,Y=A1+C1,X=Z+B1,Y=F+O,X=E+N,Q+U=L,Y=F+H,X=E+G,Q+U=C,V+1=M,T+1=K,S+1=J,V+1=D,T+1=B,S+1=A,W=1,R=1,P=1] 
* CE 82: process_main3(A,B,C,D,E,F,G,H,I) = 9+ case_7(A,J,C,K,E,F,L,H,M,N,O,P,Q,R,S,T,U,V):5+ process_main3(W,Q,X,S,Y,Z,A1,B1,I)
     [F+H+2*N>=V,U+1>=2*M+E,U>=A1+1,C>=N,A>=M,A1>=1,V>=0,S>=0,Q>=1,N>=0,M>=2,H>=0,F>=0,E>=1,I>=1,E+L+2*M=U+2,E+G+2*M=U+2,V=Z+B1,U=Y+A1,C=N+X,C=N+R,A=M+W,A=M+P,S+1=K,Q+1=J,S+1=D,Q+1=B,T=1,O=1] 
* CE 83: process_main3(A,B,C,D,E,F,G,H,I) = 3
     [H>=0,G>=1,F>=0,E>=1,C>=0,I=1,D=0,B=1,A=0] 

### Cost equations --> "Loop" of process_main3/9 
* CEs [83] --> Loop 65 
* CEs [82] --> Loop 66 
* CEs [80] --> Loop 67 
* CEs [79] --> Loop 68 
* CEs [81] --> Loop 69 
* CEs [78] --> Loop 70 

#### Loops of process_main3/9 
* Loop 65: process_main3(A,B,C,D,E,F,G,H,I) [H>=0,G>=1,F>=0,E>=1,C>=0,I=1,D=0,B=1,A=0] 
* Loop 66: process_main3(A,B,C,D,E,F,G,H,I)->  process_main3(A',B',C',D',E',F',G',H',I)
                  [F+H+2*C>=2*C'+F'+H',E+G+2*A>=2*A'+E'+3,F'+H'>=0,C>=C',A>=A'+2,E'>=1,C'>=0,A'>=0,I>=1,H>=0,G>=1,F>=0,E>=1,D>=1,B>=2,E'+G'+2*A'+2=2*A+E+G,D=D'+1,B=B'+1] 
* Loop 67: process_main3(A,B,C,D,E,F,G,H,I)->  process_main3(A,A',B',C',D',E',F',G',I)
                  [E+G>=D'+1,C>=B',D'>=1,B'>=0,I>=1,H>=0,G>=1,F>=0,E>=1,D>=1,B>=2,A>=0,F+H=E'+G',D'+F'=E+G,D=C'+1,B=A'+1] 
* Loop 68: process_main3(A,B,C,D,E,F,G,H,I)->  process_main3(A,A',B',C',D',E',F',G',I)
                  [E'+G'>=0,G>=D',C>=B',D'>=1,B'>=0,I>=1,H>=0,F>=0,E>=2,D>=1,B>=2,A>=0,D'+F'=G+1,D=C'+1,B=A'+1] 
* Loop 69: process_main3(A,B,C,D,E,F,G,H,I)->  process_main3(A',B',C',D',E',F',G',H',I)
                  [E+G>=E'+1,C>=C',E'>=1,C'>=0,I>=1,H>=0,G>=1,F>=0,E>=1,D>=1,B>=2,A>=1,F+H=F'+H',E'+G'=E+G,D=D'+1,B=B'+1,A=A'+1] 
* Loop 70: process_main3(A,B,C,D,E,F,G,H,I)->  process_main3(A,A',B',C',D',E',F',G',I)
                  [E'+G'>=0,G>=D',C>=B',D'>=1,B'>=0,I>=1,H>=0,F>=0,D>=1,B>=2,A>=0,D'+F'=G+1,D=C'+1,B=A'+1,E=1] 

### Ranking functions of CR process_main3(A,B,C,D,E,F,G,H,I) 
* RF of phase [66,67,68,69,70]: [B-1,D]

#### Partial ranking functions of CR process_main3(A,B,C,D,E,F,G,H,I) 
* Partial RF of phase [66,67,68,69,70]:
  - RF of loop [66:1]:
    A+E/2+G/2-5/2
    A/2-1/2
  - RF of loop [66:1,67:1,68:1,69:1,70:1]:
    B-1
    D
  - RF of loop [68:1]:
    E+G-2 depends on loops [66:1] 
  - RF of loop [69:1]:
    A

Discarded unfeasible chain [[66,67,68,69,70]]...(Non-terminating chain proved terminating)

### Resulting Chains:process_main3(A,B,C,D,E,F,G,H,I) 
* [[66,67,68,69,70],65]
* [65]


### Merging Chains  process_main3/9 into  External patterns of execution 
* [[65]] --> 1 
* [[65,[66,67,68,69,70]]] --> 2 


### Specialization of cost equations main3/5 
* CE 6 is refined into CE [84,85] 


#### Refined cost equations main3/5 
* CE 84: main3(A,B,C,D,E) = 3+ process_main3(F,G,C,H,I,J,K,L,M):1
     [L>=0,J>=0,C>=0,M=1,K=1,I=1,H=0,G=1,F=0,E=1,D=0,B=1,A=0] 
* CE 85: main3(A,B,C,D,E) = 3+ process_main3(A,F,C,D,G,H,I,J,K):2
     [J>=0,H>=0,D>=1,C>=0,A>=0,D+1=F,D+1=B,K=1,I=1,G=1,E=1] 

### Cost equations --> "Loop" of main3/5 
* CEs [85] --> Loop 71 
* CEs [84] --> Loop 72 

#### Loops of main3/5 
* Loop 71: main3(A,B,C,D,E) [C>=0,B>=2,A>=0,B=D+1,E=1] 
* Loop 72: main3(A,B,C,D,E) [C>=0,E=1,D=0,B=1,A=0] 

### Ranking functions of CR main3(A,B,C,D,E) 

#### Partial ranking functions of CR main3(A,B,C,D,E) 


### Resulting Chains:main3(A,B,C,D,E) 
* [72]
* [71]


### Merging Chains  main3/5 into  External patterns of execution 
* [[72]] --> 1 
* [[71]] --> 2 


### Specialization of cost equations case_10/18 
* CE 36 is refined into CE [86,87] 
* CE 33 is refined into CE [88] 
* CE 35 is refined into CE [89,90] 
* CE 34 is refined into CE [91,92] 


#### Refined cost equations case_10/18 
* CE 86: case_10(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R) = 7+ append(S,J,T,U,E,F,V,W,E,F,V,W):1+ append(X,J,Y,Z,G,H,A1,B1,G,H,A1,B1):1
     [B1>=0,A1>=0,H>=0,G>=1,J>=0,W>=0,V>=0,F>=0,E>=1,O>=0,N>=0,M>=1,L>=0,F+H=R,E+G=Q,J+N=C,O+1=D,M+1=B,L+1=A,Z=0,Y=1,X=1,U=0,T=1,S=1,P=1,K=1,I=1] 
* CE 87: case_10(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R) = 7+ append(I,J,I,S,T,F,U,V,W,X,Y,Z):2+ append(I,J,I,S,A1,H,B1,C1,D1,E1,F1,G1):2
     [H+J>=E1,F+J>=X,G1>=S,Z>=S,F1>=I,D1>=I,S+1>=I,Y>=I,W>=I,E1>=0,H>=0,I>=2,J>=0,X>=0,F>=0,O>=0,N>=0,M>=1,L>=0,I+B1=F1+1,I+A1=D1+1,G+I=D1+1,G1=S+C1,S+V=Z,I+U=Y+1,I+T=W+1,E+I=W+1,X+E1=R,W+D1=Q,J+N=C,I+L=A,O+1=D,M+1=B,P=1,K=1] 
* CE 88: case_10(A,B,C,D,E,F,G,H,I,J,K,A,L,M,N,O,P,Q) = 2
     [N>=0,M>=0,L>=1,A>=0,J>=0,H>=0,G>=1,F>=0,E>=1,F+H=Q,E+G=P,J+M=C,N+1=D,L+1=B,O=1,K=1,I=0] 
* CE 89: case_10(A,B,C,D,E,F,G,H,I,J,K,A,L,M,N,O,P,Q) = 8+ send_msg(R,H,S):1
     [Q>=H,H>=0,N>=0,M>=0,L>=1,A>=0,J>=0,E>=1,F+H=Q,J+M=C,E+1=P,N+1=D,L+1=B,S=1,R=1,O=1,K=1,I=0,G=1] 
* CE 90: case_10(A,B,C,D,E,F,G,H,I,J,K,A,L,M,N,O,P,Q) = 8+ send_msg(G,H,R):2
     [Q>=H,H>=0,G>=2,N>=0,M>=0,L>=1,A>=0,J>=0,E>=1,F+H=Q,E+G=P,J+M=C,N+1=D,L+1=B,R=1,O=1,K=1,I=0] 
* CE 91: case_10(A,B,C,D,E,F,G,H,I,J,K,A,L,M,N,O,P,Q) = 7+ send_msg(R,F,S):1
     [F>=0,Q>=0,N>=0,M>=0,L>=1,A>=0,J>=0,H>=0,G>=1,J+M=C,G+1=P,N+1=D,L+1=B,S=1,R=1,O=1,K=1,I=0,E=1] 
* CE 92: case_10(A,B,C,D,E,F,G,H,I,J,K,A,L,M,N,O,P,Q) = 7+ send_msg(E,F,R):2
     [F>=0,E>=2,Q>=0,N>=0,M>=0,L>=1,A>=0,J>=0,H>=0,G>=1,J+M=C,G+1=P,N+1=D,L+1=B,R=1,O=1,K=1,I=0] 

### Cost equations --> "Loop" of case_10/18 
* CEs [87] --> Loop 73 
* CEs [86] --> Loop 74 
* CEs [92] --> Loop 75 
* CEs [88,89,90] --> Loop 76 
* CEs [91] --> Loop 77 

#### Loops of case_10/18 
* Loop 73: case_10(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R) [F+H+2*J>=R,C>=J,A>=I,R>=0,J>=0,I>=2,H>=0,G>=1,F>=0,E>=1,D>=1,B>=2,E+G+2*I=Q+2,C=J+N,A=I+L,D=O+1,B=M+1,P=1,K=1] 
* Loop 74: case_10(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R) [C>=J,J>=0,H>=0,G>=1,F>=0,E>=1,D>=1,B>=2,A>=1,F+H=R,E+G=Q,J+N=C,D=O+1,B=M+1,A=L+1,P=1,K=1,I=1] 
* Loop 75: case_10(A,B,C,D,E,F,G,H,I,J,K,A,L,M,N,O,P,Q) [C>=J,Q>=0,J>=0,H>=0,G>=1,F>=0,E>=2,D>=1,B>=2,A>=0,J+M=C,G+1=P,D=N+1,B=L+1,O=1,K=1,I=0] 
* Loop 76: case_10(A,B,C,D,E,F,G,H,I,J,K,A,L,M,N,O,P,Q) [C>=J,J>=0,H>=0,G>=1,F>=0,E>=1,D>=1,B>=2,A>=0,F+H=Q,E+G=P,J+M=C,D=N+1,B=L+1,O=1,K=1,I=0] 
* Loop 77: case_10(A,B,C,D,E,F,G,H,I,J,K,A,L,M,N,O,P,Q) [C>=J,Q>=0,J>=0,H>=0,G>=1,F>=0,D>=1,B>=2,A>=0,J+M=C,G+1=P,D=N+1,B=L+1,O=1,K=1,I=0,E=1] 

### Ranking functions of CR case_10(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R) 

#### Partial ranking functions of CR case_10(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R) 


### Resulting Chains:case_10(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R) 
* [77]
* [76]
* [75]
* [74]
* [73]


### Merging Chains  case_10/18 into  External patterns of execution 
* [[77]] --> 1 
* [[75]] --> 2 
* [[76]] --> 3 
* [[74]] --> 4 
* [[73]] --> 5 


### Specialization of cost equations process_main4/9 
* CE 18 is refined into CE [93,94,95,96,97] 
* CE 17 is refined into CE [98] 


#### Refined cost equations process_main4/9 
* CE 93: process_main4(A,B,C,D,E,F,G,H,I) = 9+ case_10(A,J,K,L,M,F,N,H,O,P,Q,A,R,S,T,U,V,W):1+ process_main4(A,R,S,T,X,Y,Z,A1,I)
     [V>=Z+1,Z>=1,W>=0,T>=0,S>=0,R>=1,A>=0,P>=0,H>=0,F>=0,I>=1,W=Y+A1,V=X+Z,P+S=K,P+S=C,V=N+1,T+1=L,R+1=J,V=G+1,T+1=D,R+1=B,U=1,Q=1,O=0,M=1,E=1] 
* CE 94: process_main4(A,B,C,D,E,F,G,H,I) = 9+ case_10(A,J,K,L,E,F,M,H,N,O,P,A,Q,R,S,T,U,V):2+ process_main4(A,Q,R,S,W,X,Y,Z,I)
     [U>=Y+1,Y>=1,V>=0,S>=0,R>=0,Q>=1,A>=0,O>=0,H>=0,F>=0,E>=2,I>=1,V=X+Z,U=W+Y,O+R=K,O+R=C,U=M+1,S+1=L,Q+1=J,U=G+1,S+1=D,Q+1=B,T=1,P=1,N=0] 
* CE 95: process_main4(A,B,C,D,E,F,G,H,I) = 9+ case_10(A,J,K,L,E,F,M,N,O,P,Q,A,R,S,T,U,V,W):3+ process_main4(A,R,S,T,X,Y,Z,A1,I)
     [V>=Z+1,W>=F,V>=E+1,Z>=1,T>=0,S>=0,R>=1,A>=0,P>=0,F>=0,E>=1,I>=1,W=Y+A1,V=X+Z,W=F+N,V=E+M,P+S=K,W=F+H,V=E+G,P+S=C,T+1=L,R+1=J,T+1=D,R+1=B,U=1,Q=1,O=0] 
* CE 96: process_main4(A,B,C,D,E,F,G,H,I) = 9+ case_10(J,K,L,M,E,F,N,O,P,Q,R,S,T,U,V,W,X,Y):4+ process_main4(S,T,U,V,Z,A1,B1,C1,I)
     [X>=B1+1,Y>=F,X>=E+1,B1>=1,V>=0,U>=0,T>=1,S>=0,Q>=0,F>=0,E>=1,I>=1,Y=A1+C1,X=Z+B1,Y=F+O,X=E+N,Q+U=L,Y=F+H,X=E+G,Q+U=C,V+1=M,T+1=K,S+1=J,V+1=D,T+1=B,S+1=A,W=1,R=1,P=1] 
* CE 97: process_main4(A,B,C,D,E,F,G,H,I) = 9+ case_10(A,J,C,K,E,F,L,H,M,N,O,P,Q,R,S,T,U,V):5+ process_main4(W,Q,X,S,Y,Z,A1,B1,I)
     [F+H+2*N>=V,U+1>=2*M+E,U>=A1+1,C>=N,A>=M,A1>=1,V>=0,S>=0,Q>=1,N>=0,M>=2,H>=0,F>=0,E>=1,I>=1,E+L+2*M=U+2,E+G+2*M=U+2,V=Z+B1,U=Y+A1,C=N+X,C=N+R,A=M+W,A=M+P,S+1=K,Q+1=J,S+1=D,Q+1=B,T=1,O=1] 
* CE 98: process_main4(A,B,C,D,E,F,G,H,I) = 3
     [H>=0,G>=1,F>=0,E>=1,C>=0,I=1,D=0,B=1,A=0] 

### Cost equations --> "Loop" of process_main4/9 
* CEs [98] --> Loop 78 
* CEs [97] --> Loop 79 
* CEs [95] --> Loop 80 
* CEs [94] --> Loop 81 
* CEs [96] --> Loop 82 
* CEs [93] --> Loop 83 

#### Loops of process_main4/9 
* Loop 78: process_main4(A,B,C,D,E,F,G,H,I) [H>=0,G>=1,F>=0,E>=1,C>=0,I=1,D=0,B=1,A=0] 
* Loop 79: process_main4(A,B,C,D,E,F,G,H,I)->  process_main4(A',B',C',D',E',F',G',H',I)
                  [F+H+2*C>=2*C'+F'+H',E+G+2*A>=2*A'+E'+3,F'+H'>=0,C>=C',A>=A'+2,E'>=1,C'>=0,A'>=0,I>=1,H>=0,G>=1,F>=0,E>=1,D>=1,B>=2,E'+G'+2*A'+2=2*A+E+G,D=D'+1,B=B'+1] 
* Loop 80: process_main4(A,B,C,D,E,F,G,H,I)->  process_main4(A,A',B',C',D',E',F',G',I)
                  [E+G>=D'+1,C>=B',D'>=1,B'>=0,I>=1,H>=0,G>=1,F>=0,E>=1,D>=1,B>=2,A>=0,F+H=E'+G',D'+F'=E+G,D=C'+1,B=A'+1] 
* Loop 81: process_main4(A,B,C,D,E,F,G,H,I)->  process_main4(A,A',B',C',D',E',F',G',I)
                  [E'+G'>=0,G>=D',C>=B',D'>=1,B'>=0,I>=1,H>=0,F>=0,E>=2,D>=1,B>=2,A>=0,D'+F'=G+1,D=C'+1,B=A'+1] 
* Loop 82: process_main4(A,B,C,D,E,F,G,H,I)->  process_main4(A',B',C',D',E',F',G',H',I)
                  [E+G>=E'+1,C>=C',E'>=1,C'>=0,I>=1,H>=0,G>=1,F>=0,E>=1,D>=1,B>=2,A>=1,F+H=F'+H',E'+G'=E+G,D=D'+1,B=B'+1,A=A'+1] 
* Loop 83: process_main4(A,B,C,D,E,F,G,H,I)->  process_main4(A,A',B',C',D',E',F',G',I)
                  [E'+G'>=0,G>=D',C>=B',D'>=1,B'>=0,I>=1,H>=0,F>=0,D>=1,B>=2,A>=0,D'+F'=G+1,D=C'+1,B=A'+1,E=1] 

### Ranking functions of CR process_main4(A,B,C,D,E,F,G,H,I) 
* RF of phase [79,80,81,82,83]: [B-1,D]

#### Partial ranking functions of CR process_main4(A,B,C,D,E,F,G,H,I) 
* Partial RF of phase [79,80,81,82,83]:
  - RF of loop [79:1]:
    A+E/2+G/2-5/2
    A/2-1/2
  - RF of loop [79:1,80:1,81:1,82:1,83:1]:
    B-1
    D
  - RF of loop [81:1]:
    E+G-2 depends on loops [79:1] 
  - RF of loop [82:1]:
    A

Discarded unfeasible chain [[79,80,81,82,83]]...(Non-terminating chain proved terminating)

### Resulting Chains:process_main4(A,B,C,D,E,F,G,H,I) 
* [[79,80,81,82,83],78]
* [78]


### Merging Chains  process_main4/9 into  External patterns of execution 
* [[78]] --> 1 
* [[78,[79,80,81,82,83]]] --> 2 


### Specialization of cost equations main4/5 
* CE 7 is refined into CE [99,100] 


#### Refined cost equations main4/5 
* CE 99: main4(A,B,C,D,E) = 3+ process_main4(F,G,C,H,I,J,K,L,M):1
     [L>=0,J>=0,C>=0,M=1,K=1,I=1,H=0,G=1,F=0,E=1,D=0,B=1,A=0] 
* CE 100: main4(A,B,C,D,E) = 3+ process_main4(A,F,C,D,G,H,I,J,K):2
     [J>=0,H>=0,D>=1,C>=0,A>=0,D+1=F,D+1=B,K=1,I=1,G=1,E=1] 

### Cost equations --> "Loop" of main4/5 
* CEs [100] --> Loop 84 
* CEs [99] --> Loop 85 

#### Loops of main4/5 
* Loop 84: main4(A,B,C,D,E) [C>=0,B>=2,A>=0,B=D+1,E=1] 
* Loop 85: main4(A,B,C,D,E) [C>=0,E=1,D=0,B=1,A=0] 

### Ranking functions of CR main4(A,B,C,D,E) 

#### Partial ranking functions of CR main4(A,B,C,D,E) 


### Resulting Chains:main4(A,B,C,D,E) 
* [85]
* [84]


### Merging Chains  main4/5 into  External patterns of execution 
* [[85]] --> 1 
* [[84]] --> 2 


### Specialization of cost equations case_14/22 
* CE 42 is refined into CE [101] 
* CE 41 is refined into CE [102,103] 


#### Refined cost equations case_14/22 
* CE 101: case_14(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,K,L,R,B,S) = 4
     [C+5>=S,S>=C+1,L>=0,K>=1,Q>=0,P>=0,O>=1,N>=0,J>=0,I>=1,C>=0,B>=1,L+P=F,K+N=D,S=C+H+1,Q+1=G,O+1=E,R=1,M=1,A=5] 
* CE 102: case_14(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,K,L,R,S,T) = 7+ send_msg(U,C,V):1
     [C>=0,T>=0,L>=0,K>=1,Q>=0,P>=0,O>=1,N>=0,J>=0,I>=1,H>=5,L+P=F,K+N=D,Q+1=G,O+1=E,V=1,U=1,S=1,R=1,M=1,B=1,A=5] 
* CE 103: case_14(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,K,L,R,S,T) = 7+ send_msg(B,C,U):2
     [C>=0,B>=2,T>=0,L>=0,K>=1,Q>=0,P>=0,O>=1,N>=0,J>=0,I>=1,H>=5,L+P=F,K+N=D,Q+1=G,O+1=E,U=1,S=1,R=1,M=1,A=5] 

### Cost equations --> "Loop" of case_14/22 
* CEs [101] --> Loop 86 
* CEs [103] --> Loop 87 
* CEs [102] --> Loop 88 

#### Loops of case_14/22 
* Loop 86: case_14(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,K,L,R,B,S) [F>=L,D>=K,L>=0,K>=1,J>=0,I>=1,H>=0,G>=1,E>=2,C>=0,B>=1,4>=H,C+H+1=S,L+P=F,K+N=D,G=Q+1,E=O+1,R=1,M=1,A=5] 
* Loop 87: case_14(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,K,L,R,S,T) [F>=L,D>=K,T>=0,L>=0,K>=1,J>=0,I>=1,H>=5,G>=1,E>=2,C>=0,B>=2,L+P=F,K+N=D,G=Q+1,E=O+1,S=1,R=1,M=1,A=5] 
* Loop 88: case_14(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,K,L,R,S,T) [F>=L,D>=K,T>=0,L>=0,K>=1,J>=0,I>=1,H>=5,G>=1,E>=2,C>=0,L+P=F,K+N=D,G=Q+1,E=O+1,S=1,R=1,M=1,B=1,A=5] 

### Ranking functions of CR case_14(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V) 

#### Partial ranking functions of CR case_14(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V) 


### Resulting Chains:case_14(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V) 
* [88]
* [87]
* [86]


### Merging Chains  case_14/22 into  External patterns of execution 
* [[88]] --> 1 
* [[87]] --> 2 
* [[86]] --> 3 


### Specialization of cost equations case_13/17 
* CE 40 is refined into CE [104,105,106,107,108] 
* CE 37 is refined into CE [109] 
* CE 38 is refined into CE [110] 
* CE 39 is refined into CE [111] 


#### Refined cost equations case_13/17 
* CE 104: case_13(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q) = 9+ append(R,I,S,T,U,G,V,W,X,G,V,W):1+ case_14(Y,Z,G,A1,B1,C1,D1,E,E1,G,F1,I,G1,K,L,M,N,H1,I,I1,J1,Q):1
     [Q>=0,I>=0,N>=0,M>=0,L>=1,K>=0,E>=5,G>=0,W>=0,V>=0,I+M=C1,I+M=C,N+1=D1,L+1=B1,K+1=A1,N+1=D,L+1=B,K+1=A,J1=1,I1=1,H1=1,G1=1,F1=1,E1=1,Z=1,Y=5,X=1,U=1,T=0,S=1,R=1,P=1,O=1,J=1,H=1,F=1] 
* CE 105: case_13(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q) = 9+ append(R,I,S,T,F,G,U,V,F,G,U,V):1+ case_14(W,F,G,X,Y,Z,A1,E,F,G,B1,I,C1,K,L,M,N,D1,I,E1,F1,Q):2
     [Q>=0,I>=0,N>=0,M>=0,L>=1,K>=0,E>=5,G>=0,F>=2,V>=0,U>=0,I+M=Z,I+M=C,N+1=A1,L+1=Y,K+1=X,N+1=D,L+1=B,K+1=A,F1=1,E1=1,D1=1,C1=1,B1=1,W=5,T=0,S=1,R=1,P=1,O=1,J=1,H=1] 
* CE 106: case_13(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,F,P) = 9+ append(Q,I,R,S,F,G,T,U,F,G,T,U):1+ case_14(V,F,G,W,X,Y,Z,A1,F,G,B1,I,C1,K,L,M,N,D1,I,E1,F,P):3
     [G+5>=P,P>=G+1,F>=1,I>=0,N>=0,M>=0,L>=1,K>=0,G>=0,U>=0,T>=0,I+M=Y,P=G+A1+1,P=E+G+1,I+M=C,N+1=Z,L+1=X,K+1=W,N+1=D,L+1=B,K+1=A,E1=1,D1=1,C1=1,B1=1,V=5,S=0,R=1,Q=1,O=1,J=1,H=1] 
* CE 107: case_13(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q) = 9+ append(H,I,H,R,S,G,T,U,V,W,X,Y):2+ case_14(Z,V,W,A1,B1,C1,D1,E,E1,G,H,I,F1,K,L,M,N,H,I,G1,H1,Q):2
     [G+I>=W,V>=H,X>=H,R+1>=H,Y>=R,Q>=0,I>=0,H>=2,N>=0,M>=0,L>=1,K>=0,G>=0,E>=5,W>=0,I+M=C1,H+K=A1,H+E1=V+1,H+S=V+1,F+H=V+1,H+T=X+1,Y=R+U,I+M=C,H+K=A,N+1=D1,L+1=B1,N+1=D,L+1=B,H1=1,G1=1,F1=1,Z=5,P=1,O=1,J=1] 
* CE 108: case_13(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q) = 9+ append(H,I,H,R,S,G,T,U,P,V,W,X):2+ case_14(Y,P,V,Z,A1,B1,C1,D1,E1,G,H,I,F1,K,L,M,N,H,I,G1,P,Q):3
     [G+I>=V,V+5>=Q,P>=H,W>=H,R+1>=H,Q>=V+1,X>=R,I>=0,H>=2,N>=0,M>=0,L>=1,K>=0,G>=0,V>=0,H+E1=P+1,H+S=P+1,F+H=P+1,I+M=B1,H+K=Z,Q=V+D1+1,H+T=W+1,X=R+U,Q=E+V+1,I+M=C,H+K=A,N+1=C1,L+1=A1,N+1=D,L+1=B,G1=1,F1=1,Y=5,O=1,J=1] 
* CE 109: case_13(A,B,C,D,E,F,G,H,I,J,A,K,L,M,N,F,O) = 2
     [M>=0,L>=0,K>=1,A>=0,I>=0,G>=0,F>=1,E>=0,E+G=O,I+L=C,M+1=D,K+1=B,N=1,J=1,H=0] 
* CE 110: case_13(A,B,C,D,E,F,G,H,I,J,A,K,L,M,N,F,O) = 3
     [M>=0,L>=0,K>=1,A>=0,I>=0,G>=0,F>=1,E>=0,E+G=O,I+L=C,M+1=D,K+1=B,N=1,J=1,H=0] 
* CE 111: case_13(A,B,C,D,E,F,G,H,I,J,A,K,L,M,N,F,O) = 4
     [M>=0,L>=0,K>=1,A>=0,I>=0,G>=0,F>=1,E>=0,E+G=O,I+L=C,M+1=D,K+1=B,N=1,J=1,H=0] 

### Cost equations --> "Loop" of case_13/17 
* CEs [108] --> Loop 89 
* CEs [107] --> Loop 90 
* CEs [106] --> Loop 91 
* CEs [105] --> Loop 92 
* CEs [109,110,111] --> Loop 93 
* CEs [104] --> Loop 94 

#### Loops of case_13/17 
* Loop 89: case_13(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q) [E+G+I+1>=Q,C>=I,A>=H,Q>=E+1,I>=0,H>=2,G>=0,F>=1,E>=0,D>=1,B>=2,4>=E,F+H=P+1,C=I+M,A=H+K,D=N+1,B=L+1,O=1,J=1] 
* Loop 90: case_13(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q) [C>=I,A>=H,Q>=0,I>=0,H>=2,G>=0,F>=1,E>=5,D>=1,B>=2,A=H+K,I+M=C,D=N+1,B=L+1,P=1,O=1,J=1] 
* Loop 91: case_13(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,F,P) [C>=I,I>=0,G>=0,F>=1,E>=0,D>=1,B>=2,A>=1,4>=E,E+G+1=P,I+M=C,D=N+1,B=L+1,A=K+1,O=1,J=1,H=1] 
* Loop 92: case_13(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q) [C>=I,Q>=0,I>=0,G>=0,F>=2,E>=5,D>=1,B>=2,A>=1,I+M=C,D=N+1,B=L+1,A=K+1,P=1,O=1,J=1,H=1] 
* Loop 93: case_13(A,B,C,D,E,F,G,H,I,J,A,K,L,M,N,F,O) [C>=I,I>=0,G>=0,F>=1,E>=0,D>=1,B>=2,A>=0,E+G=O,I+L=C,D=M+1,B=K+1,N=1,J=1,H=0] 
* Loop 94: case_13(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q) [C>=I,Q>=0,I>=0,G>=0,E>=5,D>=1,B>=2,A>=1,I+M=C,D=N+1,B=L+1,A=K+1,P=1,O=1,J=1,H=1,F=1] 

### Ranking functions of CR case_13(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q) 

#### Partial ranking functions of CR case_13(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q) 


### Resulting Chains:case_13(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q) 
* [94]
* [93]
* [92]
* [91]
* [90]
* [89]


### Merging Chains  case_13/17 into  External patterns of execution 
* [[94]] --> 1 
* [[93]] --> 2 
* [[92]] --> 3 
* [[91]] --> 4 
* [[90]] --> 5 
* [[89]] --> 6 


### Specialization of cost equations process_main5/8 
* CE 20 is refined into CE [112,113,114,115,116,117] 
* CE 19 is refined into CE [118] 


#### Refined cost equations process_main5/8 
* CE 112: process_main5(A,B,C,D,E,F,G,H) = 9+ case_13(I,J,K,L,E,M,G,N,O,P,Q,R,S,T,U,V,W):1+ process_main5(Q,R,S,T,X,Y,Z,H)
     [W>=0,T>=0,S>=0,R>=1,Q>=0,O>=0,G>=0,E>=5,H>=1,W=X+Z,O+S=K,O+S=C,T+1=L,R+1=J,Q+1=I,T+1=D,R+1=B,Q+1=A,Y=1,V=1,U=1,P=1,N=1,M=1,F=1] 
* CE 113: process_main5(A,B,C,D,E,F,G,H) = 9+ case_13(A,I,J,K,E,F,L,M,N,O,A,P,Q,R,S,F,T):2+ process_main5(A,P,Q,R,U,F,V,H)
     [T>=E,F>=1,R>=0,Q>=0,P>=1,A>=0,N>=0,E>=0,H>=1,T=U+V,T=E+L,N+Q=J,T=E+G,N+Q=C,R+1=K,P+1=I,R+1=D,P+1=B,S=1,O=1,M=0] 
* CE 114: process_main5(A,B,C,D,E,F,G,H) = 9+ case_13(I,J,K,L,E,F,G,M,N,O,P,Q,R,S,T,U,V):3+ process_main5(P,Q,R,S,W,X,Y,H)
     [V>=0,S>=0,R>=0,Q>=1,P>=0,N>=0,G>=0,F>=2,E>=5,H>=1,V=W+Y,N+R=K,N+R=C,S+1=L,Q+1=J,P+1=I,S+1=D,Q+1=B,P+1=A,X=1,U=1,T=1,O=1,M=1] 
* CE 115: process_main5(A,B,C,D,E,F,G,H) = 9+ case_13(I,J,C,K,E,F,L,M,N,O,P,Q,R,S,T,F,U):4+ process_main5(P,Q,V,S,W,F,X,H)
     [C>=N,U>=E+1,F>=1,S>=0,Q>=1,P>=0,N>=0,E>=0,H>=1,4>=E,U=W+X,C=N+V,C=N+R,U=E+L+1,U=E+G+1,S+1=K,Q+1=J,P+1=I,S+1=D,Q+1=B,P+1=A,T=1,O=1,M=1] 
* CE 116: process_main5(A,B,C,D,E,F,G,H) = 9+ case_13(A,I,J,K,E,F,G,L,M,N,O,P,Q,R,S,T,U):5+ process_main5(V,P,Q,R,W,X,Y,H)
     [A>=L,U>=0,R>=0,Q>=0,P>=1,M>=0,L>=2,G>=0,F>=1,E>=5,H>=1,U=W+Y,A=L+V,A=L+O,M+Q=J,M+Q=C,R+1=K,P+1=I,R+1=D,P+1=B,X=1,T=1,S=1,N=1] 
* CE 117: process_main5(A,B,C,D,E,F,G,H) = 9+ case_13(A,I,C,J,E,K,G,L,M,N,O,P,Q,R,S,T,U):6+ process_main5(V,P,W,R,X,T,Y,H)
     [E+G+M+1>=U,C>=M,T>=L,A>=L,U>=E+1,R>=0,P>=1,M>=0,L>=2,G>=0,E>=0,H>=1,4>=E,U=X+Y,K+L=T+1,F+L=T+1,C=M+W,C=M+Q,A=L+V,A=L+O,R+1=J,P+1=I,R+1=D,P+1=B,S=1,N=1] 
* CE 118: process_main5(A,B,C,D,E,F,G,H) = 3
     [G>=0,F>=1,E>=0,C>=0,H=1,D=0,B=1,A=0] 

### Cost equations --> "Loop" of process_main5/8 
* CEs [118] --> Loop 95 
* CEs [117] --> Loop 96 
* CEs [113] --> Loop 97 
* CEs [115] --> Loop 98 
* CEs [116] --> Loop 99 
* CEs [114] --> Loop 100 
* CEs [112] --> Loop 101 

#### Loops of process_main5/8 
* Loop 95: process_main5(A,B,C,D,E,F,G,H) [G>=0,F>=1,E>=0,C>=0,H=1,D=0,B=1,A=0] 
* Loop 96: process_main5(A,B,C,D,E,F,G,H)->  process_main5(A',B',C',D',E',F',G',H)
                  [C+E+G+1>=C'+E'+G',E'+G'>=E+1,C>=C',A>=A'+2,C'>=0,A'>=0,H>=1,G>=0,F>=1,E>=0,D>=1,B>=2,4>=E,A+F=A'+F'+1,D=D'+1,B=B'+1] 
* Loop 97: process_main5(A,B,C,D,E,F,G,H)->  process_main5(A,A',B',C',D',F,E',H)
                  [C>=B',B'>=0,H>=1,G>=0,F>=1,E>=0,D>=1,B>=2,A>=0,E+G=D'+E',D=C'+1,B=A'+1] 
* Loop 98: process_main5(A,B,C,D,E,F,G,H)->  process_main5(A',B',C',D',E',F,F',H)
                  [C>=C',C'>=0,H>=1,G>=0,F>=1,E>=0,D>=1,B>=2,A>=1,4>=E,E+G+1=E'+F',D=D'+1,B=B'+1,A=A'+1] 
* Loop 99: process_main5(A,B,C,D,E,F,G,H)->  process_main5(A',B',C',D',E',F',G',H)
                  [E'+G'>=0,C>=C',A>=A'+2,C'>=0,A'>=0,H>=1,G>=0,F>=1,E>=5,D>=1,B>=2,D=D'+1,B=B'+1,F'=1] 
* Loop 100: process_main5(A,B,C,D,E,F,G,H)->  process_main5(A',B',C',D',E',F',G',H)
                  [E'+G'>=0,C>=C',C'>=0,H>=1,G>=0,F>=2,E>=5,D>=1,B>=2,A>=1,D=D'+1,B=B'+1,A=A'+1,F'=1] 
* Loop 101: process_main5(A,B,C,D,E,F,G,H)->  process_main5(A',B',C',D',E',F',G',H)
                  [E'+G'>=0,C>=C',C'>=0,H>=1,G>=0,E>=5,D>=1,B>=2,A>=1,D=D'+1,B=B'+1,A=A'+1,F'=1,F=1] 

### Ranking functions of CR process_main5(A,B,C,D,E,F,G,H) 
* RF of phase [96,97,98,99,100,101]: [B-1,D]

#### Partial ranking functions of CR process_main5(A,B,C,D,E,F,G,H) 
* Partial RF of phase [96,97,98,99,100,101]:
  - RF of loop [96:1]:
    A+F-2
  - RF of loop [96:1,97:1,98:1,99:1,100:1,101:1]:
    B-1
    D
  - RF of loop [96:1,99:1]:
    A/2-1/2
  - RF of loop [98:1,100:1,101:1]:
    A
  - RF of loop [100:1]:
    F-1 depends on loops [96:1] 

Discarded unfeasible chain [[96,97,98,99,100,101]]...(Non-terminating chain proved terminating)

### Resulting Chains:process_main5(A,B,C,D,E,F,G,H) 
* [[96,97,98,99,100,101],95]
* [95]


### Merging Chains  process_main5/8 into  External patterns of execution 
* [[95]] --> 1 
* [[95,[96,97,98,99,100,101]]] --> 2 


### Specialization of cost equations main5/5 
* CE 8 is refined into CE [119,120] 


#### Refined cost equations main5/5 
* CE 119: main5(A,B,C,D,E) = 3+ process_main5(F,G,C,H,I,J,K,L):1
     [K>=0,C>=0,L=1,J=1,I=0,H=0,G=1,F=0,E=1,D=0,B=1,A=0] 
* CE 120: main5(A,B,C,D,E) = 3+ process_main5(A,F,C,D,G,H,I,J):2
     [I>=0,D>=1,C>=0,A>=0,D+1=F,D+1=B,J=1,H=1,G=0,E=1] 

### Cost equations --> "Loop" of main5/5 
* CEs [120] --> Loop 102 
* CEs [119] --> Loop 103 

#### Loops of main5/5 
* Loop 102: main5(A,B,C,D,E) [C>=0,B>=2,A>=0,B=D+1,E=1] 
* Loop 103: main5(A,B,C,D,E) [C>=0,E=1,D=0,B=1,A=0] 

### Ranking functions of CR main5(A,B,C,D,E) 

#### Partial ranking functions of CR main5(A,B,C,D,E) 


### Resulting Chains:main5(A,B,C,D,E) 
* [103]
* [102]


### Merging Chains  main5/5 into  External patterns of execution 
* [[103]] --> 1 
* [[102]] --> 2 


Computing Bounds
=====================================

#### Simplifying cost structure of CE 43 

#### Computing cost of phase [36] 

#### Simplifying cost structure of CE 44 

#### Cost of loops [36] 

 * loop 36:append(A,B,C,D,E,F,G,H,I,J,K,L) -> [append(A',B',C',D',E',F',G',H',I',J',K',L')] 
5
##### Pending set append(A,B,C,D,E,F,G,H,I,J,K,L)
* Psum in Loop 36: [it(36)=<1]

###### Computing sum for it(36)=<1  in Loop 36 
   - Applying inductive sum strategy 
     - head Candidate: C-1 
     - head Candidate: D+1 
     - head Candidate: A-1 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: D+1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
     - tail Candidate: D+1 
     - tail Candidate: A-1 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: D+1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(36)=<C-1,it(36)=<D+1,it(36)=<A-1,it(36)=<A-1,it(36)=<C-1,it(36)=<D+1,it(36)=<C-C',it(36)=<D-D',it(36)=<A-A',it(36)=<A-A',it(36)=<C-C',it(36)=<D-D'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [36] 

#### Simplifying cost structure of phase [36] 

#### Cost of phase [36]:append(A,B,C,D,E,F,G,H,I,J,K,L) -> [append(A',B',C',D',E',F',G',H',I',J',K',L')] 
5*it(36)+0
  Such that:it(36) =< A
it(36) =< A-A'
it(36) =< C
it(36) =< C-C'
it(36) =< D+1
it(36) =< D-D'

#### Simplifying cost structure of chain [[36],37] 

#### Cost of chains of append(A,B,C,D,E,F,G,H,I,J,K,L):
* Chain [[36],37]: 5*it(36)+2
  Such that:it(36) =< -E+I

  with precondition: [A=C,L=D+H,A+E=I+1,A+G=K+1,A>=2,B>=0,E>=1,F>=0,G>=1,J>=0,D+1>=A,L>=D,B+F>=J] 

* Chain [37]: 2
  with precondition: [A=1,C=1,D=0,E=I,F=J,G=K,H=L,B>=0,E>=0,F>=0,G>=0,H>=0] 


#### Simplifying cost structure of CE 45 

#### Computing cost of phase [38] 

#### Simplifying cost structure of CE 46 

#### Cost of loops [38] 

 * loop 38:send(A,B,C) -> [send(A',B',C')] 
8
##### Pending set send(A,B,C)
* Psum in Loop 38: [it(38)=<1]

###### Computing sum for it(38)=<1  in Loop 38 
   - Applying inductive sum strategy 
     - head Candidate: A-1 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(38)=<A-1,it(38)=<A-1,it(38)=<A-A',it(38)=<A-A'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [38] 

#### Simplifying cost structure of phase [38] 

#### Cost of phase [38]:send(A,B,C) -> [send(A',B',C')] 
8*it(38)+0
  Such that:it(38) =< A
it(38) =< A-A'

#### Simplifying cost structure of chain [[38],39] 

#### Cost of chains of send(A,B,C):
* Chain [[38],39]: 8*it(38)+3
  Such that:it(38) =< A

  with precondition: [C=1,A>=2,B>=0] 

* Chain [39]: 3
  with precondition: [A=1,C=1,B>=0] 


#### Simplifying cost structure of CE 47 
 * Renamed intermediate variables: 
[ (eq(48,1),it(38))>>s(1)]

#### Simplifying cost structure of CE 48 

#### Cost of chains of send_msg(A,B,C):
* Chain [41]: 4
  with precondition: [A=1,C=1,B>=0] 

* Chain [40]: 8*s(1)+4
  Such that:s(1) =< A

  with precondition: [C=1,A>=2,B>=0] 


#### Simplifying cost structure of CE 51 

#### Simplifying cost structure of CE 52 

#### Simplifying cost structure of CE 53 

#### Simplifying cost structure of CE 49 
 * Renamed intermediate variables: 
[ (eq(50,1),s(1))>>s(2)]

#### Simplifying cost structure of CE 50 

#### Cost of chains of case_2(A,B,C,D,E,F,G,H,I,J,K,L):
* Chain [44]: 4
  with precondition: [E=0,G=1,L=1,H=A,I+1=B,K+1=D,C=F+J,F>=0,H>=0,I>=1,K>=0,C>=F] 

* Chain [43]: 9
  with precondition: [E=1,G=1,L=1,H+1=A,I+1=B,K+1=D,C=F+J,F>=0,H>=0,I>=1,K>=0,C>=F] 

* Chain [42]: 8*s(2)+9
  Such that:s(2) =< A-H

  with precondition: [G=1,L=1,I+1=B,K+1=D,A=E+H,C=F+J,E>=2,F>=0,I>=1,K>=0,A>=E,C>=F] 


#### Simplifying cost structure of CE 54 

#### Computing cost of phase [45,46,47] 
 * Renamed intermediate variables: 
[ (eq(57,1),s(2))>>s(3)]

#### Simplifying cost structure of CE 57 
 * Renamed intermediate variables: 
[ (it(45),s(3))>>s(4)]

#### Simplifying cost structure of CE 55 

#### Simplifying cost structure of CE 56 

#### Cost of loops [45,46,47] 

 * loop 45:process_main1(A,B,C,D,E) -> [process_main1(A',B',C',D',E')] 
8*s(4)+16
  Such that:s(4) =< A-A'

 * loop 46:process_main1(A,B,C,D,E) -> [process_main1(A',B',C',D',E')] 
11
 * loop 47:process_main1(A,B,C,D,E) -> [process_main1(A',B',C',D',E')] 
16
##### Pending set process_main1(A,B,C,D,E)
* Psum in Loop 45: [it(45)=<1,s(5)=<A-A']
* Psum in Loop 46: [it(46)=<1]
* Psum in Loop 47: [it(47)=<1]

###### Computing sum for it(45)=<1  in Loop 45 
   - Applying inductive sum strategy 
     - head Candidate: D 
       - Loop 46 is collaborative and bounds [it(46)] 
       - Loop 47 is collaborative and bounds [it(47)] 
     - head Candidate: B-1 
       - Loop 46 is collaborative and bounds [it(46)] 
       - Loop 47 is collaborative and bounds [it(47)] 
     - head Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: D 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A/2-1/2 
       - Loop 46 is collaborative
       - Loop 47 is collaborative
     - tail Candidate: D 
       - Loop 46 is collaborative and bounds [it(46)] 
       - Loop 47 is collaborative and bounds [it(47)] 
     - tail Candidate: B-1 
       - Loop 46 is collaborative and bounds [it(46)] 
       - Loop 47 is collaborative and bounds [it(47)] 
     - tail Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: D 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A/2-1/2 
       - Loop 46 is collaborative
       - Loop 47 is collaborative
 * Adding constraints: [it(45)+it(46)+it(47)=<D,it(45)+it(46)+it(47)=<B-1,it(45)+it(46)+it(47)=<B-1,it(45)+it(46)+it(47)=<D,it(45)=<A/2-1/2,it(45)+it(46)+it(47)=<D-D',it(45)+it(46)+it(47)=<B-B',it(45)+it(46)+it(47)=<B-B',it(45)+it(46)+it(47)=<D-D',it(45)=<A/2-A'/2] 

##### Pending set A
* Psum in Loop 45: [s(5)=<A-A']
* Psum in Loop 46: [it(46)=<1]
* Psum in Loop 47: [it(47)=<1]

###### Computing sum for s(5)=<A-A'  in Loop 45 
   - Applying inductive sum strategy 
     - head Candidate: A 
       - Loop 46 is collaborative
       - Loop 47 is collaborative and bounds [it(47)] 
     - tail Candidate: A 
       - Loop 46 is collaborative
       - Loop 47 is collaborative and bounds [it(47)] 
 * Adding constraints: [it(47)+s(5)=<A,it(47)+s(5)=<A-A'] 

##### Pending set A
* Psum in Loop 46: [it(46)=<1]
* Psum in Loop 47: [it(47)=<1]

###### Computing sum for it(46)=<1  in Loop 46 
   - Applying inductive sum strategy 
     - head Candidate: D 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: D 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: D 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: D 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(45)+it(46)+it(47)=<D,it(45)+it(46)+it(47)=<B-1,it(45)+it(46)+it(47)=<B-1,it(45)+it(46)+it(47)=<D,it(45)+it(46)+it(47)=<D-D',it(45)+it(46)+it(47)=<B-B',it(45)+it(46)+it(47)=<B-B',it(45)+it(46)+it(47)=<D-D'] 

##### Pending set A
* Psum in Loop 47: [it(47)=<1]

###### Computing sum for it(47)=<1  in Loop 47 
   - Applying inductive sum strategy 
     - head Candidate: D 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: D 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: D 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: D 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(45)+it(46)+it(47)=<D,it(45)+it(46)+it(47)=<B-1,it(47)+s(5)=<A,it(45)+it(46)+it(47)=<B-1,it(45)+it(46)+it(47)=<D,it(45)+it(46)+it(47)=<D-D',it(45)+it(46)+it(47)=<B-B',it(47)+s(5)=<A-A',it(45)+it(46)+it(47)=<B-B',it(45)+it(46)+it(47)=<D-D'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [45,46,47] 

#### Simplifying cost structure of phase [45,46,47] 

#### Cost of phase [45,46,47]:process_main1(A,B,C,D,E) -> [process_main1(A',B',C',D',E')] 
16*it(45)+11*it(46)+16*it(47)+8*s(5)+0
  Such that:it(45) =< A/2
it(45) =< A/2-A'/2
aux(1) =< A
aux(2) =< A-A'
aux(3) =< B
aux(4) =< B-B'
aux(5) =< D
aux(6) =< D-D'
it(47) =< aux(1)
s(5) =< aux(1)
it(47) =< aux(2)
s(5) =< aux(2)
it(45) =< aux(3)
it(46) =< aux(3)
it(47) =< aux(3)
it(45) =< aux(4)
it(46) =< aux(4)
it(47) =< aux(4)
it(45) =< aux(5)
it(46) =< aux(5)
it(47) =< aux(5)
it(45) =< aux(6)
it(46) =< aux(6)
it(47) =< aux(6)

#### Simplifying cost structure of chain [[45,46,47],48] 
 * Joined equivalent variables [aux(7),aux(1),aux(2)] into aux(7)
 * Joined equivalent variables [aux(8),aux(4),aux(5),aux(6)] into aux(8)

#### Cost of chains of process_main1(A,B,C,D,E):
* Chain [[45,46,47],48]: 16*it(45)+11*it(46)+16*it(47)+8*s(5)+3
  Such that:it(45) =< A/2
aux(3) =< D+1
aux(7) =< A
aux(8) =< D
it(47) =< aux(7)
s(5) =< aux(7)
it(45) =< aux(3)
it(46) =< aux(3)
it(47) =< aux(3)
it(45) =< aux(8)
it(46) =< aux(8)
it(47) =< aux(8)

  with precondition: [E=1,B=D+1,A>=0,B>=2,C>=0] 

* Chain [48]: 3
  with precondition: [A=0,B=1,D=0,E=1,C>=0] 


#### Simplifying cost structure of CE 58 
 * Renamed intermediate variables: 
[ (eq(59,1),it(45))>>s(6), (eq(59,1),aux(3))>>s(7), (eq(59,1),aux(7))>>s(8), (eq(59,1),aux(8))>>s(9), (eq(59,1),it(47))>>s(10), (eq(59,1),s(5))>>s(11), (eq(59,1),it(46))>>s(12)]

#### Simplifying cost structure of CE 59 

#### Cost of chains of main1(A,B,C,D,E):
* Chain [50]: 4
  with precondition: [A=0,B=1,D=0,E=1,C>=0] 

* Chain [49]: 16*s(6)+16*s(10)+8*s(11)+11*s(12)+4
  Such that:s(8) =< A
s(6) =< A/2
s(9) =< D
s(7) =< D+1
s(10) =< s(8)
s(11) =< s(8)
s(6) =< s(7)
s(12) =< s(7)
s(10) =< s(7)
s(6) =< s(9)
s(12) =< s(9)
s(10) =< s(9)

  with precondition: [E=1,B=D+1,A>=0,B>=2,C>=0] 


#### Simplifying cost structure of CE 62 

#### Simplifying cost structure of CE 63 

#### Simplifying cost structure of CE 64 

#### Simplifying cost structure of CE 60 
 * Renamed intermediate variables: 
[ (eq(61,1),it(36))>>s(13)]

#### Simplifying cost structure of CE 61 

#### Cost of chains of case_5(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O):
* Chain [53]: 10
  with precondition: [E=1,G=0,I=1,N=1,J=A,K+1=B,M+1=D,C=H+L,F>=0,H>=0,J>=0,K>=1,M>=0,O>=0,C>=H] 

* Chain [52]: 7
  with precondition: [E=1,G=1,I=1,N=1,J+1=A,K+1=B,M+1=D,F=O,C=H+L,F>=0,H>=0,J>=0,K>=1,M>=0,C>=H] 

* Chain [51]: 5*s(13)+7
  Such that:s(13) =< G

  with precondition: [E=1,I=1,K+1=B,M+1=D,G=N,G+J=A,C=H+L,F>=0,G>=2,H>=0,K>=1,M>=0,O>=0,A>=G,C>=H,F+H>=O] 


#### Simplifying cost structure of CE 65 

#### Computing cost of phase [54,55,56] 
 * Renamed intermediate variables: 
[ (eq(68,1),s(13))>>s(14)]

#### Simplifying cost structure of CE 68 
 * Renamed intermediate variables: 
[ (it(54),s(14))>>s(15)]

#### Simplifying cost structure of CE 66 

#### Simplifying cost structure of CE 67 

#### Cost of loops [54,55,56] 

 * loop 54:process_main2(A,B,C,D,E,F,G) -> [process_main2(A',B',C',D',E',F',G')] 
5*s(15)+14
  Such that:s(15) =< A-A'

 * loop 55:process_main2(A,B,C,D,E,F,G) -> [process_main2(A',B',C',D',E',F',G')] 
17
 * loop 56:process_main2(A,B,C,D,E,F,G) -> [process_main2(A',B',C',D',E',F',G')] 
14
##### Pending set process_main2(A,B,C,D,E,F,G)
* Psum in Loop 54: [it(54)=<1,s(16)=<A-A']
* Psum in Loop 55: [it(55)=<1]
* Psum in Loop 56: [it(56)=<1]

###### Computing sum for it(54)=<1  in Loop 54 
   - Applying inductive sum strategy 
     - head Candidate: D 
       - Loop 55 is collaborative and bounds [it(55)] 
       - Loop 56 is collaborative and bounds [it(56)] 
     - head Candidate: B-1 
       - Loop 55 is collaborative and bounds [it(55)] 
       - Loop 56 is collaborative and bounds [it(56)] 
     - head Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: D 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A/2-1/2 
       - Loop 55 is collaborative
       - Loop 56 is collaborative
     - tail Candidate: D 
       - Loop 55 is collaborative and bounds [it(55)] 
       - Loop 56 is collaborative and bounds [it(56)] 
     - tail Candidate: B-1 
       - Loop 55 is collaborative and bounds [it(55)] 
       - Loop 56 is collaborative and bounds [it(56)] 
     - tail Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: D 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A/2-1/2 
       - Loop 55 is collaborative
       - Loop 56 is collaborative
 * Adding constraints: [it(54)+it(55)+it(56)=<D,it(54)+it(55)+it(56)=<B-1,it(54)+it(55)+it(56)=<B-1,it(54)+it(55)+it(56)=<D,it(54)=<A/2-1/2,it(54)+it(55)+it(56)=<D-D',it(54)+it(55)+it(56)=<B-B',it(54)+it(55)+it(56)=<B-B',it(54)+it(55)+it(56)=<D-D',it(54)=<A/2-A'/2] 

##### Pending set A
* Psum in Loop 54: [s(16)=<A-A']
* Psum in Loop 55: [it(55)=<1]
* Psum in Loop 56: [it(56)=<1]

###### Computing sum for s(16)=<A-A'  in Loop 54 
   - Applying inductive sum strategy 
     - head Candidate: A 
       - Loop 55 is collaborative
       - Loop 56 is collaborative and bounds [it(56)] 
     - tail Candidate: A 
       - Loop 55 is collaborative
       - Loop 56 is collaborative and bounds [it(56)] 
 * Adding constraints: [it(56)+s(16)=<A,it(56)+s(16)=<A-A'] 

##### Pending set A
* Psum in Loop 55: [it(55)=<1]
* Psum in Loop 56: [it(56)=<1]

###### Computing sum for it(55)=<1  in Loop 55 
   - Applying inductive sum strategy 
     - head Candidate: D 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: D 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: D 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: D 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(54)+it(55)+it(56)=<D,it(54)+it(55)+it(56)=<B-1,it(54)+it(55)+it(56)=<B-1,it(54)+it(55)+it(56)=<D,it(54)+it(55)+it(56)=<D-D',it(54)+it(55)+it(56)=<B-B',it(54)+it(55)+it(56)=<B-B',it(54)+it(55)+it(56)=<D-D'] 

##### Pending set A
* Psum in Loop 56: [it(56)=<1]

###### Computing sum for it(56)=<1  in Loop 56 
   - Applying inductive sum strategy 
     - head Candidate: D 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: D 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: D 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: D 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(54)+it(55)+it(56)=<D,it(54)+it(55)+it(56)=<B-1,it(56)+s(16)=<A,it(54)+it(55)+it(56)=<B-1,it(54)+it(55)+it(56)=<D,it(54)+it(55)+it(56)=<D-D',it(54)+it(55)+it(56)=<B-B',it(56)+s(16)=<A-A',it(54)+it(55)+it(56)=<B-B',it(54)+it(55)+it(56)=<D-D'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [54,55,56] 

#### Simplifying cost structure of phase [54,55,56] 

#### Cost of phase [54,55,56]:process_main2(A,B,C,D,E,F,G) -> [process_main2(A',B',C',D',E',F',G')] 
14*it(54)+17*it(55)+14*it(56)+5*s(16)+0
  Such that:it(54) =< A/2
it(54) =< A/2-A'/2
aux(9) =< A
aux(10) =< A-A'
aux(11) =< B
aux(12) =< B-B'
aux(13) =< D
aux(14) =< D-D'
it(56) =< aux(9)
s(16) =< aux(9)
it(56) =< aux(10)
s(16) =< aux(10)
it(54) =< aux(11)
it(55) =< aux(11)
it(56) =< aux(11)
it(54) =< aux(12)
it(55) =< aux(12)
it(56) =< aux(12)
it(54) =< aux(13)
it(55) =< aux(13)
it(56) =< aux(13)
it(54) =< aux(14)
it(55) =< aux(14)
it(56) =< aux(14)

#### Simplifying cost structure of chain [[54,55,56],57] 
 * Joined equivalent variables [aux(15),aux(9),aux(10)] into aux(15)
 * Joined equivalent variables [aux(16),aux(12),aux(13),aux(14)] into aux(16)

#### Cost of chains of process_main2(A,B,C,D,E,F,G):
* Chain [[54,55,56],57]: 14*it(54)+17*it(55)+14*it(56)+5*s(16)+3
  Such that:it(54) =< A/2
aux(11) =< D+1
aux(15) =< A
aux(16) =< D
it(56) =< aux(15)
s(16) =< aux(15)
it(54) =< aux(11)
it(55) =< aux(11)
it(56) =< aux(11)
it(54) =< aux(16)
it(55) =< aux(16)
it(56) =< aux(16)

  with precondition: [E=1,G=1,B=D+1,A>=0,B>=2,C>=0,F>=0] 

* Chain [57]: 3
  with precondition: [A=0,B=1,D=0,E=1,G=1,C>=0,F>=0] 


#### Simplifying cost structure of CE 69 
 * Renamed intermediate variables: 
[ (eq(70,1),it(54))>>s(17), (eq(70,1),aux(11))>>s(18), (eq(70,1),aux(15))>>s(19), (eq(70,1),aux(16))>>s(20), (eq(70,1),it(56))>>s(21), (eq(70,1),s(16))>>s(22), (eq(70,1),it(55))>>s(23)]

#### Simplifying cost structure of CE 70 

#### Cost of chains of main2(A,B,C,D,E):
* Chain [59]: 5
  with precondition: [A=0,B=1,D=0,E=1,C>=0] 

* Chain [58]: 14*s(17)+14*s(21)+5*s(22)+17*s(23)+5
  Such that:s(19) =< A
s(17) =< A/2
s(20) =< D
s(18) =< D+1
s(21) =< s(19)
s(22) =< s(19)
s(17) =< s(18)
s(23) =< s(18)
s(21) =< s(18)
s(17) =< s(20)
s(23) =< s(20)
s(21) =< s(20)

  with precondition: [E=1,B=D+1,A>=0,B>=2,C>=0] 


#### Simplifying cost structure of CE 76 

#### Simplifying cost structure of CE 73 

#### Simplifying cost structure of CE 74 
 * Renamed intermediate variables: 
[ (eq(75,1),s(1))>>s(24)]

#### Simplifying cost structure of CE 75 
 * Renamed intermediate variables: 
[ (eq(77,1),s(1))>>s(25)]

#### Simplifying cost structure of CE 77 

#### Simplifying cost structure of CE 71 
 * Renamed intermediate variables: 
[ (eq(72,1),it(36))>>s(26)]
 * Renamed intermediate variables: 
[ (eq(72,2),it(36))>>s(27)]

#### Simplifying cost structure of CE 72 
 * Joined equivalent variables [s(26),s(27)] into s(26)

#### Cost of chains of case_7(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R):
* Chain [64]: 11
  with precondition: [E=1,I=0,K=1,P=1,L=A,M+1=B,O+1=D,G+1=Q,C=J+N,F>=0,G>=1,H>=0,J>=0,L>=0,M>=1,O>=0,R>=0,C>=J] 

* Chain [63]: 8*s(24)+11
  Such that:s(24) =< G

  with precondition: [I=0,K=1,P=1,L=A,M+1=B,O+1=D,C=J+N,E+G=Q,F+H=R,E>=1,F>=0,G>=1,H>=0,J>=0,L>=0,M>=1,O>=0,C>=J] 

* Chain [62]: 8*s(25)+11
  Such that:s(25) =< E

  with precondition: [I=0,K=1,P=1,L=A,M+1=B,O+1=D,G+1=Q,C=J+N,E>=2,F>=0,G>=1,H>=0,J>=0,L>=0,M>=1,O>=0,R>=0,C>=J] 

* Chain [61]: 11
  with precondition: [I=1,K=1,P=1,L+1=A,M+1=B,O+1=D,C=J+N,E+G=Q,F+H=R,E>=1,F>=0,G>=1,H>=0,J>=0,L>=0,M>=1,O>=0,C>=J] 

* Chain [60]: 10*s(26)+11
  Such that:aux(17) =< I
s(26) =< aux(17)

  with precondition: [K=1,P=1,M+1=B,O+1=D,I+L=A,J+N=C,E+G+2*I=Q+2,E>=1,F>=0,G>=1,H>=0,I>=2,J>=0,L>=0,M>=1,N>=0,O>=0,R>=0,F+H+2*J>=R] 


#### Simplifying cost structure of CE 83 

#### Computing cost of phase [66,67,68,69,70] 
 * Renamed intermediate variables: 
[ (eq(82,1),aux(17))>>s(28), (eq(82,1),s(26))>>s(29)]

#### Simplifying cost structure of CE 82 
 * Renamed intermediate variables: 
[ (it(66),s(28))>>s(30), (it(66),s(29))>>s(31)]
 * Renamed intermediate variables: 
[ (eq(80,1),s(24))>>s(32)]

#### Simplifying cost structure of CE 80 
 * Renamed intermediate variables: 
[ (it(67),s(32))>>s(33)]
 * Renamed intermediate variables: 
[ (eq(79,1),s(25))>>s(34)]

#### Simplifying cost structure of CE 79 
 * Renamed intermediate variables: 
[ (it(68),s(34))>>s(35)]

#### Simplifying cost structure of CE 81 

#### Simplifying cost structure of CE 78 

#### Cost of loops [66,67,68,69,70] 

 * loop 66:process_main3(A,B,C,D,E,F,G,H,I) -> [process_main3(A',B',C',D',E',F',G',H',I')] 
10*s(31)+20
  Such that:s(30) =< A-A'
s(31) =< s(30)

 * loop 67:process_main3(A,B,C,D,E,F,G,H,I) -> [process_main3(A',B',C',D',E',F',G',H',I')] 
8*s(33)+20
  Such that:s(33) =< G

 * loop 68:process_main3(A,B,C,D,E,F,G,H,I) -> [process_main3(A',B',C',D',E',F',G',H',I')] 
8*s(35)+20
  Such that:s(35) =< E

 * loop 69:process_main3(A,B,C,D,E,F,G,H,I) -> [process_main3(A',B',C',D',E',F',G',H',I')] 
20
 * loop 70:process_main3(A,B,C,D,E,F,G,H,I) -> [process_main3(A',B',C',D',E',F',G',H',I')] 
20
##### Pending set process_main3(A,B,C,D,E,F,G,H,I)
* Psum in Loop 66: [it(66)=<1,s(37)=<A-A']
* Psum in Loop 67: [it(67)=<1,s(38)=<G]
* Psum in Loop 68: [it(68)=<1,s(39)=<E]
* Psum in Loop 69: [it(69)=<1]
* Psum in Loop 70: [it(70)=<1]

###### Computing sum for it(66)=<1  in Loop 66 
   - Applying inductive sum strategy 
     - head Candidate: D 
       - Loop 67 is collaborative and bounds [it(67)] 
       - Loop 68 is collaborative and bounds [it(68)] 
       - Loop 69 is collaborative and bounds [it(69)] 
       - Loop 70 is collaborative and bounds [it(70)] 
     - head Candidate: B-1 
       - Loop 67 is collaborative and bounds [it(67)] 
       - Loop 68 is collaborative and bounds [it(68)] 
       - Loop 69 is collaborative and bounds [it(69)] 
       - Loop 70 is collaborative and bounds [it(70)] 
     - head Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: D 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A/2-1/2 
       - Loop 67 is collaborative
       - Loop 68 is collaborative
       - Loop 69 is collaborative
       - Loop 70 is collaborative
     - head Candidate: A+E/2+G/2-5/2 
       - Loop 67 is collaborative
       - Loop 68 is collaborative
       - Loop 69 is collaborative
       - Loop 70 is collaborative
     - tail Candidate: D 
       - Loop 67 is collaborative and bounds [it(67)] 
       - Loop 68 is collaborative and bounds [it(68)] 
       - Loop 69 is collaborative and bounds [it(69)] 
       - Loop 70 is collaborative and bounds [it(70)] 
     - tail Candidate: B-1 
       - Loop 67 is collaborative and bounds [it(67)] 
       - Loop 68 is collaborative and bounds [it(68)] 
       - Loop 69 is collaborative and bounds [it(69)] 
       - Loop 70 is collaborative and bounds [it(70)] 
     - tail Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: D 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A/2-1/2 
       - Loop 67 is collaborative
       - Loop 68 is collaborative
       - Loop 69 is collaborative
       - Loop 70 is collaborative
     - tail Candidate: A+E/2+G/2-5/2 
       - Loop 67 is collaborative
       - Loop 68 is collaborative
       - Loop 69 is collaborative and bounds [it(69)] 
       - Loop 70 is collaborative
 * Adding constraints: [it(66)+it(67)+it(68)+it(69)+it(70)=<D,it(66)+it(67)+it(68)+it(69)+it(70)=<B-1,it(66)+it(67)+it(68)+it(69)+it(70)=<B-1,it(66)+it(67)+it(68)+it(69)+it(70)=<D,it(66)=<A/2-1/2,it(66)=<A+E/2+G/2-5/2,it(66)+it(67)+it(68)+it(69)+it(70)=<D-D',it(66)+it(67)+it(68)+it(69)+it(70)=<B-B',it(66)+it(67)+it(68)+it(69)+it(70)=<B-B',it(66)+it(67)+it(68)+it(69)+it(70)=<D-D',it(66)=<A/2-A'/2,it(66)+it(69)=<A+E/2+G/2-A'-E'/2-G'/2] 

##### Pending set A
* Psum in Loop 66: [s(37)=<A-A']
* Psum in Loop 67: [it(67)=<1,s(38)=<G]
* Psum in Loop 68: [it(68)=<1,s(39)=<E]
* Psum in Loop 69: [it(69)=<1]
* Psum in Loop 70: [it(70)=<1]

###### Computing sum for s(37)=<A-A'  in Loop 66 
   - Applying inductive sum strategy 
     - head Candidate: A 
       - Loop 67 is collaborative
       - Loop 68 is collaborative
       - Loop 69 is collaborative and bounds [it(69)] 
       - Loop 70 is collaborative
     - tail Candidate: A 
       - Loop 67 is collaborative
       - Loop 68 is collaborative
       - Loop 69 is collaborative and bounds [it(69)] 
       - Loop 70 is collaborative
 * Adding constraints: [it(69)+s(37)=<A,it(69)+s(37)=<A-A'] 

##### Pending set A
* Psum in Loop 67: [it(67)=<1,s(38)=<G]
* Psum in Loop 68: [it(68)=<1,s(39)=<E]
* Psum in Loop 69: [it(69)=<1]
* Psum in Loop 70: [it(70)=<1]

###### Computing sum for it(67)=<1  in Loop 67 
   - Applying inductive sum strategy 
     - head Candidate: D 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: D 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: D 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: D 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(66)+it(67)+it(68)+it(69)+it(70)=<D,it(66)+it(67)+it(68)+it(69)+it(70)=<B-1,it(66)+it(67)+it(68)+it(69)+it(70)=<B-1,it(66)+it(67)+it(68)+it(69)+it(70)=<D,it(66)+it(67)+it(68)+it(69)+it(70)=<D-D',it(66)+it(67)+it(68)+it(69)+it(70)=<B-B',it(66)+it(67)+it(68)+it(69)+it(70)=<B-B',it(66)+it(67)+it(68)+it(69)+it(70)=<D-D'] 

##### Pending set A
* Psum in Loop 67: [s(38)=<G]
* Psum in Loop 68: [it(68)=<1,s(39)=<E]
* Psum in Loop 69: [it(69)=<1]
* Psum in Loop 70: [it(70)=<1]

###### Computing sum for s(38)=<G  in Loop 67 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(18)=<G] 
 * Adding constraints: [s(38)=<it(67)*aux(18)] 

##### Pending set process_main3(A,B,C,D,E,F,G,H,I)
* Pmax/min: [aux(18)=<G]
* Psum in Loop 68: [it(68)=<1,s(39)=<E]
* Psum in Loop 69: [it(69)=<1]
* Psum in Loop 70: [it(70)=<1]

###### Computing max_min for aux(18)=<G  
   - Found a solution using transitive invariants 
 * Adding constraints:[aux(18)=<2*A+E+G-1] 

##### Pending set process_main3(A,B,C,D,E,F,G,H,I)
* Psum in Loop 68: [it(68)=<1,s(39)=<E]
* Psum in Loop 69: [it(69)=<1]
* Psum in Loop 70: [it(70)=<1]

###### Computing sum for it(68)=<1  in Loop 68 
   - Applying inductive sum strategy 
     - head Candidate: D 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: D 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: E+G-2 
       - Loop 66 adds an expression [2*A-2*A'-2]
       - Loop 67 is collaborative
       - Loop 69 is collaborative
       - Loop 70 is collaborative
     - tail Candidate: D 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: D 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: E+G-2 
       - Loop 66 adds an expression [2*A-2*A'-2]
       - Loop 67 is collaborative
       - Loop 69 is collaborative
       - Loop 70 is collaborative
 * Adding constraints: [it(68)=<aux(19)+aux(20),it(68)=<aux(21)+aux(22),it(66)+it(67)+it(68)+it(69)+it(70)=<D,it(66)+it(67)+it(68)+it(69)+it(70)=<B-1,it(66)+it(67)+it(68)+it(69)+it(70)=<B-1,it(66)+it(67)+it(68)+it(69)+it(70)=<D,aux(20)=<E+G-2,it(66)+it(67)+it(68)+it(69)+it(70)=<D-D',it(66)+it(67)+it(68)+it(69)+it(70)=<B-B',it(66)+it(67)+it(68)+it(69)+it(70)=<B-B',it(66)+it(67)+it(68)+it(69)+it(70)=<D-D',aux(22)=<E+G-E'-G'] 

##### Pending set process_main3(A,B,C,D,E,F,G,H,I)
* Psum in Loop 66: [aux(19)=<2*A-2*A'-2,aux(21)=<2*A-2*A'-2]
* Psum in Loop 68: [s(39)=<E]
* Psum in Loop 69: [it(69)=<1]
* Psum in Loop 70: [it(70)=<1]

###### Computing sum for aux(19)=<2*A-2*A'-2  in Loop 66 
   - Applying inductive sum strategy 
     - head Candidate: 2*A-2 
       - Loop 67 is collaborative
       - Loop 68 is collaborative
       - Loop 69 is collaborative
       - Loop 70 is collaborative
     - tail Candidate: 2*A-2 
       - Loop 67 is collaborative
       - Loop 68 is collaborative
       - Loop 69 is collaborative and bounds [it(69)] 
       - Loop 70 is collaborative
 * Adding constraints: [aux(19)=<2*A-2,aux(19)+it(69)=<2*A-2*A'] 

##### Pending set process_main3(A,B,C,D,E,F,G,H,I)
* Psum in Loop 66: [aux(21)=<2*A-2*A'-2]
* Psum in Loop 68: [s(39)=<E]
* Psum in Loop 69: [it(69)=<1]
* Psum in Loop 70: [it(70)=<1]

###### Computing sum for aux(21)=<2*A-2*A'-2  in Loop 66 
   - Found a solution using cacheing 
 * Adding constraints: [aux(21)=<aux(23),aux(23)=<2*A-2,aux(23)+it(69)=<2*A-2*A'] 

##### Pending set process_main3(A,B,C,D,E,F,G,H,I)
* Psum in Loop 68: [s(39)=<E]
* Psum in Loop 69: [it(69)=<1]
* Psum in Loop 70: [it(70)=<1]

###### Computing sum for s(39)=<E  in Loop 68 
   - Applying inductive sum strategy 
     - head Candidate: B+E+G-3 
       - Loop 66 adds an expression [2*A-2*A'-3]
       - Loop 67 is collaborative
       - Loop 69 is collaborative and bounds [it(69)] 
       - Loop 70 is collaborative and bounds [it(70)] 
     - head Candidate: 2*E+2*G-4 
       - Loop 66 adds an expression [4*A-4*A'-4]
       - Loop 67 is collaborative
       - Loop 69 is collaborative
       - Loop 70 is collaborative
     - tail Candidate: B+E+G-3 
       - Loop 66 adds an expression [2*A-2*A'-3]
       - Loop 67 is collaborative
       - Loop 69 is collaborative and bounds [it(69)] 
       - Loop 70 is collaborative and bounds [it(70)] 
     - tail Candidate: 2*E+2*G-4 
       - Loop 66 adds an expression [4*A-4*A'-4]
       - Loop 67 is collaborative
       - Loop 69 is collaborative
       - Loop 70 is collaborative
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(32)=<E] 
 * Adding constraints: [s(39)=<it(68)*aux(32),it(69)+it(70)+s(39)=<aux(24)+aux(25),s(39)=<aux(26)+aux(27),it(69)+it(70)+s(39)=<aux(28)+aux(29),s(39)=<aux(30)+aux(31),aux(25)=<B+E+G-3,aux(27)=<2*E+2*G-4,aux(29)=<B+E+G-B'-E'-G',aux(31)=<2*E+2*G-2*E'-2*G'] 

##### Pending set process_main3(A,B,C,D,E,F,G,H,I)
* Pmax/min: [aux(32)=<E]
* Psum in Loop 66: [aux(24)=<2*A-2*A'-3,aux(28)=<2*A-2*A'-3,aux(26)=<4*A-4*A'-4,aux(30)=<4*A-4*A'-4]
* Psum in Loop 69: [it(69)=<1]
* Psum in Loop 70: [it(70)=<1]

###### Computing max_min for aux(32)=<E  
   - Found a solution using transitive invariants 
 * Adding constraints:[aux(32)=<2*A+E+G-1] 

##### Pending set process_main3(A,B,C,D,E,F,G,H,I)
* Psum in Loop 66: [aux(24)=<2*A-2*A'-3,aux(28)=<2*A-2*A'-3,aux(26)=<4*A-4*A'-4,aux(30)=<4*A-4*A'-4]
* Psum in Loop 69: [it(69)=<1]
* Psum in Loop 70: [it(70)=<1]

###### Computing sum for aux(24)=<2*A-2*A'-3  in Loop 66 
   - Applying inductive sum strategy 
     - head Candidate: 2*A-3 
       - Loop 67 is collaborative
       - Loop 68 is collaborative
       - Loop 69 is collaborative
       - Loop 70 is collaborative
     - tail Candidate: 2*A-3 
       - Loop 67 is collaborative
       - Loop 68 is collaborative
       - Loop 69 is collaborative and bounds [it(69)] 
       - Loop 70 is collaborative
 * Adding constraints: [aux(24)=<2*A-3,aux(24)+it(69)=<2*A-2*A'] 

##### Pending set process_main3(A,B,C,D,E,F,G,H,I)
* Psum in Loop 66: [aux(28)=<2*A-2*A'-3,aux(26)=<4*A-4*A'-4,aux(30)=<4*A-4*A'-4]
* Psum in Loop 69: [it(69)=<1]
* Psum in Loop 70: [it(70)=<1]

###### Computing sum for aux(28)=<2*A-2*A'-3  in Loop 66 
   - Found a solution using cacheing 
 * Adding constraints: [aux(28)=<aux(33),aux(33)=<2*A-3,aux(33)+it(69)=<2*A-2*A'] 

##### Pending set process_main3(A,B,C,D,E,F,G,H,I)
* Psum in Loop 66: [aux(26)=<4*A-4*A'-4,aux(30)=<4*A-4*A'-4]
* Psum in Loop 69: [it(69)=<1]
* Psum in Loop 70: [it(70)=<1]

###### Computing sum for aux(26)=<4*A-4*A'-4  in Loop 66 
   - Found a solution using cacheing 
 * Adding constraints: [aux(26)=<aux(34)*2,aux(34)=<2*A-2,aux(34)+it(69)=<2*A-2*A'] 

##### Pending set process_main3(A,B,C,D,E,F,G,H,I)
* Psum in Loop 66: [aux(30)=<4*A-4*A'-4]
* Psum in Loop 69: [it(69)=<1]
* Psum in Loop 70: [it(70)=<1]

###### Computing sum for aux(30)=<4*A-4*A'-4  in Loop 66 
   - Found a solution using cacheing 
 * Adding constraints: [aux(30)=<aux(35)*2,aux(35)=<2*A-2,aux(35)+it(69)=<2*A-2*A'] 

##### Pending set process_main3(A,B,C,D,E,F,G,H,I)
* Psum in Loop 69: [it(69)=<1]
* Psum in Loop 70: [it(70)=<1]

###### Computing sum for it(69)=<1  in Loop 69 
   - Applying inductive sum strategy 
     - head Candidate: D 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: D 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: D 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: D 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(66)+it(67)+it(68)+it(69)+it(70)=<D,it(66)+it(67)+it(68)+it(69)+it(70)=<B-1,it(69)+s(37)=<A,it(66)+it(67)+it(68)+it(69)+it(70)=<B-1,it(66)+it(67)+it(68)+it(69)+it(70)=<D,it(66)+it(67)+it(68)+it(69)+it(70)=<D-D',it(66)+it(67)+it(68)+it(69)+it(70)=<B-B',it(69)+s(37)=<A-A',it(66)+it(67)+it(68)+it(69)+it(70)=<B-B',it(66)+it(67)+it(68)+it(69)+it(70)=<D-D'] 

##### Pending set process_main3(A,B,C,D,E,F,G,H,I)
* Psum in Loop 70: [it(70)=<1]

###### Computing sum for it(70)=<1  in Loop 70 
   - Applying inductive sum strategy 
     - head Candidate: D 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: D 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: D 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: D 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(66)+it(67)+it(68)+it(69)+it(70)=<D,it(66)+it(67)+it(68)+it(69)+it(70)=<B-1,it(66)+it(67)+it(68)+it(69)+it(70)=<B-1,it(66)+it(67)+it(68)+it(69)+it(70)=<D,it(66)+it(67)+it(68)+it(69)+it(70)=<D-D',it(66)+it(67)+it(68)+it(69)+it(70)=<B-B',it(66)+it(67)+it(68)+it(69)+it(70)=<B-B',it(66)+it(67)+it(68)+it(69)+it(70)=<D-D'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [66,67,68,69,70] 

#### Simplifying cost structure of phase [66,67,68,69,70] 
 * Joined equivalent variables [aux(23),aux(21)] into aux(23)
 * Joined equivalent variables [aux(33),aux(28)] into aux(33)
 * Joined equivalent variables [aux(40),aux(18),aux(32)] into aux(40)
 * Joined equivalent variables [aux(19),aux(23),aux(24),aux(33),aux(34),aux(35)] into aux(19)
 * Joined equivalent variables [aux(26),aux(30)] into aux(26)

#### Cost of phase [66,67,68,69,70]:process_main3(A,B,C,D,E,F,G,H,I) -> [process_main3(A',B',C',D',E',F',G',H',I')] 
20*it(66)+20*it(67)+20*it(68)+20*it(69)+20*it(70)+10*s(36)+8*s(38)+8*s(39)+0
  Such that:it(66) =< A+E/2+G/2
it(66) =< A/2
it(66) =< A/2-A'/2
aux(25) =< B+E+G
aux(29) =< B+E+G-B'-E'-G'
aux(20) =< E+G
aux(22) =< E+G-E'-G'
aux(27) =< 2*E+2*G
aux(31) =< 2*E+2*G-2*E'-2*G'
aux(36) =< A
aux(37) =< A+E/2+G/2-A'-E'/2-G'/2
aux(38) =< A-A'
aux(39) =< 2*A
aux(40) =< 2*A+E+G
aux(41) =< 2*A-2*A'
aux(42) =< B
aux(43) =< B-B'
aux(44) =< D
aux(45) =< D-D'
it(69) =< aux(36)
s(37) =< aux(36)
it(66) =< aux(37)
it(69) =< aux(37)
it(69) =< aux(38)
s(37) =< aux(38)
aux(19) =< aux(39)
aux(19) =< aux(41)
it(69) =< aux(41)
it(66) =< aux(42)
it(67) =< aux(42)
it(68) =< aux(42)
it(69) =< aux(42)
it(70) =< aux(42)
it(66) =< aux(43)
it(67) =< aux(43)
it(68) =< aux(43)
it(69) =< aux(43)
it(70) =< aux(43)
it(66) =< aux(44)
it(67) =< aux(44)
it(68) =< aux(44)
it(69) =< aux(44)
it(70) =< aux(44)
it(66) =< aux(45)
it(67) =< aux(45)
it(68) =< aux(45)
it(69) =< aux(45)
it(70) =< aux(45)
aux(26) =< aux(19)*2
it(69) =< aux(19)+aux(25)
it(70) =< aux(19)+aux(25)
s(39) =< aux(19)+aux(25)
it(68) =< aux(19)+aux(20)
s(38) =< it(67)*aux(40)
s(39) =< aux(26)+aux(31)
it(69) =< aux(19)+aux(29)
it(70) =< aux(19)+aux(29)
s(39) =< aux(19)+aux(29)
s(39) =< aux(26)+aux(27)
it(68) =< aux(19)+aux(22)
s(39) =< it(68)*aux(40)
s(36) =< s(37)

#### Simplifying cost structure of chain [[66,67,68,69,70],65] 
 * Joined equivalent variables [aux(46),aux(36),aux(38)] into aux(46)
 * Joined equivalent variables [aux(47),aux(39),aux(41)] into aux(47)
 * Joined equivalent variables [aux(48),aux(42),aux(43),aux(44),aux(45)] into aux(48)
 * Joined equivalent variables [aux(49),aux(25)] into aux(49)
 * Joined equivalent variables [aux(50),aux(20),aux(22)] into aux(50)
 * Joined equivalent variables [aux(51),aux(27),aux(31)] into aux(51)
 * Joined equivalent variables [aux(46),s(37)] into aux(46)
 * Joined equivalent variables [aux(47),aux(19)] into aux(47)

#### Cost of chains of process_main3(A,B,C,D,E,F,G,H,I):
* Chain [[66,67,68,69,70],65]: 20*it(66)+20*it(67)+20*it(68)+20*it(69)+20*it(70)+10*s(36)+8*s(38)+8*s(39)+3
  Such that:aux(37) =< A+E/2+G/2
aux(40) =< 2*A+E+G
it(66) =< A/2
aux(29) =< D+E+G
aux(46) =< A
aux(47) =< 2*A
aux(48) =< B
aux(49) =< B+E+G
aux(50) =< E+G
aux(51) =< 2*E+2*G
aux(29) =< aux(49)
it(69) =< aux(46)
it(66) =< aux(37)
it(69) =< aux(37)
it(69) =< aux(47)
it(66) =< aux(48)
it(67) =< aux(48)
it(68) =< aux(48)
it(69) =< aux(48)
it(70) =< aux(48)
aux(26) =< aux(47)*2
it(69) =< aux(47)+aux(49)
it(70) =< aux(47)+aux(49)
s(39) =< aux(47)+aux(49)
it(68) =< aux(47)+aux(50)
s(38) =< it(67)*aux(40)
s(39) =< aux(26)+aux(51)
it(69) =< aux(47)+aux(29)
it(70) =< aux(47)+aux(29)
s(39) =< aux(47)+aux(29)
s(39) =< it(68)*aux(40)
s(36) =< aux(46)

  with precondition: [I=1,B=D+1,A>=0,B>=2,C>=0,E>=1,F>=0,G>=1,H>=0] 

* Chain [65]: 3
  with precondition: [A=0,B=1,D=0,I=1,C>=0,E>=1,F>=0,G>=1,H>=0] 


#### Simplifying cost structure of CE 84 
 * Renamed intermediate variables: 
[ (eq(85,1),aux(37))>>s(40), (eq(85,1),aux(40))>>s(41), (eq(85,1),it(66))>>s(42), (eq(85,1),aux(29))>>s(43), (eq(85,1),aux(46))>>s(44), (eq(85,1),aux(47))>>s(45), (eq(85,1),aux(48))>>s(46), (eq(85,1),aux(49))>>s(47), (eq(85,1),aux(50))>>s(48), (eq(85,1),aux(51))>>s(49), (eq(85,1),it(69))>>s(50), (eq(85,1),it(67))>>s(51), (eq(85,1),it(68))>>s(52), (eq(85,1),it(70))>>s(53), (eq(85,1),aux(26))>>s(54), (eq(85,1),s(39))>>s(55), (eq(85,1),s(38))>>s(56), (eq(85,1),s(36))>>s(57)]

#### Simplifying cost structure of CE 85 

#### Cost of chains of main3(A,B,C,D,E):
* Chain [72]: 6
  with precondition: [A=0,B=1,D=0,E=1,C>=0] 

* Chain [71]: 20*s(42)+20*s(50)+20*s(51)+20*s(52)+20*s(53)+8*s(55)+8*s(56)+10*s(57)+6
  Such that:s(48) =< 2
s(49) =< 4
s(44) =< A
s(40) =< A+1
s(45) =< 2*A
s(41) =< 2*A+2
s(42) =< A/2
s(46) =< D+1
s(43) =< D+2
s(47) =< D+3
s(43) =< s(47)
s(50) =< s(44)
s(42) =< s(40)
s(50) =< s(40)
s(50) =< s(45)
s(42) =< s(46)
s(51) =< s(46)
s(52) =< s(46)
s(50) =< s(46)
s(53) =< s(46)
s(54) =< s(45)*2
s(50) =< s(45)+s(47)
s(53) =< s(45)+s(47)
s(55) =< s(45)+s(47)
s(52) =< s(45)+s(48)
s(56) =< s(51)*s(41)
s(55) =< s(54)+s(49)
s(50) =< s(45)+s(43)
s(53) =< s(45)+s(43)
s(55) =< s(45)+s(43)
s(55) =< s(52)*s(41)
s(57) =< s(44)

  with precondition: [E=1,B=D+1,A>=0,B>=2,C>=0] 


#### Simplifying cost structure of CE 91 

#### Simplifying cost structure of CE 88 

#### Simplifying cost structure of CE 89 
 * Renamed intermediate variables: 
[ (eq(90,1),s(1))>>s(58)]

#### Simplifying cost structure of CE 90 
 * Renamed intermediate variables: 
[ (eq(92,1),s(1))>>s(59)]

#### Simplifying cost structure of CE 92 

#### Simplifying cost structure of CE 86 
 * Renamed intermediate variables: 
[ (eq(87,1),it(36))>>s(60)]
 * Renamed intermediate variables: 
[ (eq(87,2),it(36))>>s(61)]

#### Simplifying cost structure of CE 87 
 * Joined equivalent variables [s(60),s(61)] into s(60)

#### Cost of chains of case_10(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R):
* Chain [77]: 11
  with precondition: [E=1,I=0,K=1,P=1,L=A,M+1=B,O+1=D,G+1=Q,C=J+N,F>=0,G>=1,H>=0,J>=0,L>=0,M>=1,O>=0,R>=0,C>=J] 

* Chain [76]: 8*s(58)+12
  Such that:s(58) =< G

  with precondition: [I=0,K=1,P=1,L=A,M+1=B,O+1=D,C=J+N,E+G=Q,F+H=R,E>=1,F>=0,G>=1,H>=0,J>=0,L>=0,M>=1,O>=0,C>=J] 

* Chain [75]: 8*s(59)+11
  Such that:s(59) =< E

  with precondition: [I=0,K=1,P=1,L=A,M+1=B,O+1=D,G+1=Q,C=J+N,E>=2,F>=0,G>=1,H>=0,J>=0,L>=0,M>=1,O>=0,R>=0,C>=J] 

* Chain [74]: 11
  with precondition: [I=1,K=1,P=1,L+1=A,M+1=B,O+1=D,C=J+N,E+G=Q,F+H=R,E>=1,F>=0,G>=1,H>=0,J>=0,L>=0,M>=1,O>=0,C>=J] 

* Chain [73]: 10*s(60)+11
  Such that:aux(52) =< I
s(60) =< aux(52)

  with precondition: [K=1,P=1,M+1=B,O+1=D,I+L=A,J+N=C,E+G+2*I=Q+2,E>=1,F>=0,G>=1,H>=0,I>=2,J>=0,L>=0,M>=1,N>=0,O>=0,R>=0,F+H+2*J>=R] 


#### Simplifying cost structure of CE 98 

#### Computing cost of phase [79,80,81,82,83] 
 * Renamed intermediate variables: 
[ (eq(97,1),aux(52))>>s(62), (eq(97,1),s(60))>>s(63)]

#### Simplifying cost structure of CE 97 
 * Renamed intermediate variables: 
[ (it(79),s(62))>>s(64), (it(79),s(63))>>s(65)]
 * Renamed intermediate variables: 
[ (eq(95,1),s(58))>>s(66)]

#### Simplifying cost structure of CE 95 
 * Renamed intermediate variables: 
[ (it(80),s(66))>>s(67)]
 * Renamed intermediate variables: 
[ (eq(94,1),s(59))>>s(68)]

#### Simplifying cost structure of CE 94 
 * Renamed intermediate variables: 
[ (it(81),s(68))>>s(69)]

#### Simplifying cost structure of CE 96 

#### Simplifying cost structure of CE 93 

#### Cost of loops [79,80,81,82,83] 

 * loop 79:process_main4(A,B,C,D,E,F,G,H,I) -> [process_main4(A',B',C',D',E',F',G',H',I')] 
10*s(65)+20
  Such that:s(64) =< A-A'
s(65) =< s(64)

 * loop 80:process_main4(A,B,C,D,E,F,G,H,I) -> [process_main4(A',B',C',D',E',F',G',H',I')] 
8*s(67)+21
  Such that:s(67) =< G

 * loop 81:process_main4(A,B,C,D,E,F,G,H,I) -> [process_main4(A',B',C',D',E',F',G',H',I')] 
8*s(69)+20
  Such that:s(69) =< E

 * loop 82:process_main4(A,B,C,D,E,F,G,H,I) -> [process_main4(A',B',C',D',E',F',G',H',I')] 
20
 * loop 83:process_main4(A,B,C,D,E,F,G,H,I) -> [process_main4(A',B',C',D',E',F',G',H',I')] 
20
##### Pending set process_main4(A,B,C,D,E,F,G,H,I)
* Psum in Loop 79: [it(79)=<1,s(71)=<A-A']
* Psum in Loop 80: [it(80)=<1,s(72)=<G]
* Psum in Loop 81: [it(81)=<1,s(73)=<E]
* Psum in Loop 82: [it(82)=<1]
* Psum in Loop 83: [it(83)=<1]

###### Computing sum for it(79)=<1  in Loop 79 
   - Applying inductive sum strategy 
     - head Candidate: D 
       - Loop 80 is collaborative and bounds [it(80)] 
       - Loop 81 is collaborative and bounds [it(81)] 
       - Loop 82 is collaborative and bounds [it(82)] 
       - Loop 83 is collaborative and bounds [it(83)] 
     - head Candidate: B-1 
       - Loop 80 is collaborative and bounds [it(80)] 
       - Loop 81 is collaborative and bounds [it(81)] 
       - Loop 82 is collaborative and bounds [it(82)] 
       - Loop 83 is collaborative and bounds [it(83)] 
     - head Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: D 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A/2-1/2 
       - Loop 80 is collaborative
       - Loop 81 is collaborative
       - Loop 82 is collaborative
       - Loop 83 is collaborative
     - head Candidate: A+E/2+G/2-5/2 
       - Loop 80 is collaborative
       - Loop 81 is collaborative
       - Loop 82 is collaborative
       - Loop 83 is collaborative
     - tail Candidate: D 
       - Loop 80 is collaborative and bounds [it(80)] 
       - Loop 81 is collaborative and bounds [it(81)] 
       - Loop 82 is collaborative and bounds [it(82)] 
       - Loop 83 is collaborative and bounds [it(83)] 
     - tail Candidate: B-1 
       - Loop 80 is collaborative and bounds [it(80)] 
       - Loop 81 is collaborative and bounds [it(81)] 
       - Loop 82 is collaborative and bounds [it(82)] 
       - Loop 83 is collaborative and bounds [it(83)] 
     - tail Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: D 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A/2-1/2 
       - Loop 80 is collaborative
       - Loop 81 is collaborative
       - Loop 82 is collaborative
       - Loop 83 is collaborative
     - tail Candidate: A+E/2+G/2-5/2 
       - Loop 80 is collaborative
       - Loop 81 is collaborative
       - Loop 82 is collaborative and bounds [it(82)] 
       - Loop 83 is collaborative
 * Adding constraints: [it(79)+it(80)+it(81)+it(82)+it(83)=<D,it(79)+it(80)+it(81)+it(82)+it(83)=<B-1,it(79)+it(80)+it(81)+it(82)+it(83)=<B-1,it(79)+it(80)+it(81)+it(82)+it(83)=<D,it(79)=<A/2-1/2,it(79)=<A+E/2+G/2-5/2,it(79)+it(80)+it(81)+it(82)+it(83)=<D-D',it(79)+it(80)+it(81)+it(82)+it(83)=<B-B',it(79)+it(80)+it(81)+it(82)+it(83)=<B-B',it(79)+it(80)+it(81)+it(82)+it(83)=<D-D',it(79)=<A/2-A'/2,it(79)+it(82)=<A+E/2+G/2-A'-E'/2-G'/2] 

##### Pending set A
* Psum in Loop 79: [s(71)=<A-A']
* Psum in Loop 80: [it(80)=<1,s(72)=<G]
* Psum in Loop 81: [it(81)=<1,s(73)=<E]
* Psum in Loop 82: [it(82)=<1]
* Psum in Loop 83: [it(83)=<1]

###### Computing sum for s(71)=<A-A'  in Loop 79 
   - Applying inductive sum strategy 
     - head Candidate: A 
       - Loop 80 is collaborative
       - Loop 81 is collaborative
       - Loop 82 is collaborative and bounds [it(82)] 
       - Loop 83 is collaborative
     - tail Candidate: A 
       - Loop 80 is collaborative
       - Loop 81 is collaborative
       - Loop 82 is collaborative and bounds [it(82)] 
       - Loop 83 is collaborative
 * Adding constraints: [it(82)+s(71)=<A,it(82)+s(71)=<A-A'] 

##### Pending set A
* Psum in Loop 80: [it(80)=<1,s(72)=<G]
* Psum in Loop 81: [it(81)=<1,s(73)=<E]
* Psum in Loop 82: [it(82)=<1]
* Psum in Loop 83: [it(83)=<1]

###### Computing sum for it(80)=<1  in Loop 80 
   - Applying inductive sum strategy 
     - head Candidate: D 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: D 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: D 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: D 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(79)+it(80)+it(81)+it(82)+it(83)=<D,it(79)+it(80)+it(81)+it(82)+it(83)=<B-1,it(79)+it(80)+it(81)+it(82)+it(83)=<B-1,it(79)+it(80)+it(81)+it(82)+it(83)=<D,it(79)+it(80)+it(81)+it(82)+it(83)=<D-D',it(79)+it(80)+it(81)+it(82)+it(83)=<B-B',it(79)+it(80)+it(81)+it(82)+it(83)=<B-B',it(79)+it(80)+it(81)+it(82)+it(83)=<D-D'] 

##### Pending set A
* Psum in Loop 80: [s(72)=<G]
* Psum in Loop 81: [it(81)=<1,s(73)=<E]
* Psum in Loop 82: [it(82)=<1]
* Psum in Loop 83: [it(83)=<1]

###### Computing sum for s(72)=<G  in Loop 80 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(53)=<G] 
 * Adding constraints: [s(72)=<it(80)*aux(53)] 

##### Pending set process_main4(A,B,C,D,E,F,G,H,I)
* Pmax/min: [aux(53)=<G]
* Psum in Loop 81: [it(81)=<1,s(73)=<E]
* Psum in Loop 82: [it(82)=<1]
* Psum in Loop 83: [it(83)=<1]

###### Computing max_min for aux(53)=<G  
   - Found a solution using transitive invariants 
 * Adding constraints:[aux(53)=<2*A+E+G-1] 

##### Pending set process_main4(A,B,C,D,E,F,G,H,I)
* Psum in Loop 81: [it(81)=<1,s(73)=<E]
* Psum in Loop 82: [it(82)=<1]
* Psum in Loop 83: [it(83)=<1]

###### Computing sum for it(81)=<1  in Loop 81 
   - Applying inductive sum strategy 
     - head Candidate: D 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: D 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: E+G-2 
       - Loop 79 adds an expression [2*A-2*A'-2]
       - Loop 80 is collaborative
       - Loop 82 is collaborative
       - Loop 83 is collaborative
     - tail Candidate: D 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: D 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: E+G-2 
       - Loop 79 adds an expression [2*A-2*A'-2]
       - Loop 80 is collaborative
       - Loop 82 is collaborative
       - Loop 83 is collaborative
 * Adding constraints: [it(81)=<aux(54)+aux(55),it(81)=<aux(56)+aux(57),it(79)+it(80)+it(81)+it(82)+it(83)=<D,it(79)+it(80)+it(81)+it(82)+it(83)=<B-1,it(79)+it(80)+it(81)+it(82)+it(83)=<B-1,it(79)+it(80)+it(81)+it(82)+it(83)=<D,aux(55)=<E+G-2,it(79)+it(80)+it(81)+it(82)+it(83)=<D-D',it(79)+it(80)+it(81)+it(82)+it(83)=<B-B',it(79)+it(80)+it(81)+it(82)+it(83)=<B-B',it(79)+it(80)+it(81)+it(82)+it(83)=<D-D',aux(57)=<E+G-E'-G'] 

##### Pending set process_main4(A,B,C,D,E,F,G,H,I)
* Psum in Loop 79: [aux(54)=<2*A-2*A'-2,aux(56)=<2*A-2*A'-2]
* Psum in Loop 81: [s(73)=<E]
* Psum in Loop 82: [it(82)=<1]
* Psum in Loop 83: [it(83)=<1]

###### Computing sum for aux(54)=<2*A-2*A'-2  in Loop 79 
   - Applying inductive sum strategy 
     - head Candidate: 2*A-2 
       - Loop 80 is collaborative
       - Loop 81 is collaborative
       - Loop 82 is collaborative
       - Loop 83 is collaborative
     - tail Candidate: 2*A-2 
       - Loop 80 is collaborative
       - Loop 81 is collaborative
       - Loop 82 is collaborative and bounds [it(82)] 
       - Loop 83 is collaborative
 * Adding constraints: [aux(54)=<2*A-2,aux(54)+it(82)=<2*A-2*A'] 

##### Pending set process_main4(A,B,C,D,E,F,G,H,I)
* Psum in Loop 79: [aux(56)=<2*A-2*A'-2]
* Psum in Loop 81: [s(73)=<E]
* Psum in Loop 82: [it(82)=<1]
* Psum in Loop 83: [it(83)=<1]

###### Computing sum for aux(56)=<2*A-2*A'-2  in Loop 79 
   - Found a solution using cacheing 
 * Adding constraints: [aux(56)=<aux(58),aux(58)=<2*A-2,aux(58)+it(82)=<2*A-2*A'] 

##### Pending set process_main4(A,B,C,D,E,F,G,H,I)
* Psum in Loop 81: [s(73)=<E]
* Psum in Loop 82: [it(82)=<1]
* Psum in Loop 83: [it(83)=<1]

###### Computing sum for s(73)=<E  in Loop 81 
   - Applying inductive sum strategy 
     - head Candidate: B+E+G-3 
       - Loop 79 adds an expression [2*A-2*A'-3]
       - Loop 80 is collaborative
       - Loop 82 is collaborative and bounds [it(82)] 
       - Loop 83 is collaborative and bounds [it(83)] 
     - head Candidate: 2*E+2*G-4 
       - Loop 79 adds an expression [4*A-4*A'-4]
       - Loop 80 is collaborative
       - Loop 82 is collaborative
       - Loop 83 is collaborative
     - tail Candidate: B+E+G-3 
       - Loop 79 adds an expression [2*A-2*A'-3]
       - Loop 80 is collaborative
       - Loop 82 is collaborative and bounds [it(82)] 
       - Loop 83 is collaborative and bounds [it(83)] 
     - tail Candidate: 2*E+2*G-4 
       - Loop 79 adds an expression [4*A-4*A'-4]
       - Loop 80 is collaborative
       - Loop 82 is collaborative
       - Loop 83 is collaborative
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(67)=<E] 
 * Adding constraints: [s(73)=<it(81)*aux(67),it(82)+it(83)+s(73)=<aux(59)+aux(60),s(73)=<aux(61)+aux(62),it(82)+it(83)+s(73)=<aux(63)+aux(64),s(73)=<aux(65)+aux(66),aux(60)=<B+E+G-3,aux(62)=<2*E+2*G-4,aux(64)=<B+E+G-B'-E'-G',aux(66)=<2*E+2*G-2*E'-2*G'] 

##### Pending set process_main4(A,B,C,D,E,F,G,H,I)
* Pmax/min: [aux(67)=<E]
* Psum in Loop 79: [aux(59)=<2*A-2*A'-3,aux(63)=<2*A-2*A'-3,aux(61)=<4*A-4*A'-4,aux(65)=<4*A-4*A'-4]
* Psum in Loop 82: [it(82)=<1]
* Psum in Loop 83: [it(83)=<1]

###### Computing max_min for aux(67)=<E  
   - Found a solution using transitive invariants 
 * Adding constraints:[aux(67)=<2*A+E+G-1] 

##### Pending set process_main4(A,B,C,D,E,F,G,H,I)
* Psum in Loop 79: [aux(59)=<2*A-2*A'-3,aux(63)=<2*A-2*A'-3,aux(61)=<4*A-4*A'-4,aux(65)=<4*A-4*A'-4]
* Psum in Loop 82: [it(82)=<1]
* Psum in Loop 83: [it(83)=<1]

###### Computing sum for aux(59)=<2*A-2*A'-3  in Loop 79 
   - Applying inductive sum strategy 
     - head Candidate: 2*A-3 
       - Loop 80 is collaborative
       - Loop 81 is collaborative
       - Loop 82 is collaborative
       - Loop 83 is collaborative
     - tail Candidate: 2*A-3 
       - Loop 80 is collaborative
       - Loop 81 is collaborative
       - Loop 82 is collaborative and bounds [it(82)] 
       - Loop 83 is collaborative
 * Adding constraints: [aux(59)=<2*A-3,aux(59)+it(82)=<2*A-2*A'] 

##### Pending set process_main4(A,B,C,D,E,F,G,H,I)
* Psum in Loop 79: [aux(63)=<2*A-2*A'-3,aux(61)=<4*A-4*A'-4,aux(65)=<4*A-4*A'-4]
* Psum in Loop 82: [it(82)=<1]
* Psum in Loop 83: [it(83)=<1]

###### Computing sum for aux(63)=<2*A-2*A'-3  in Loop 79 
   - Found a solution using cacheing 
 * Adding constraints: [aux(63)=<aux(68),aux(68)=<2*A-3,aux(68)+it(82)=<2*A-2*A'] 

##### Pending set process_main4(A,B,C,D,E,F,G,H,I)
* Psum in Loop 79: [aux(61)=<4*A-4*A'-4,aux(65)=<4*A-4*A'-4]
* Psum in Loop 82: [it(82)=<1]
* Psum in Loop 83: [it(83)=<1]

###### Computing sum for aux(61)=<4*A-4*A'-4  in Loop 79 
   - Found a solution using cacheing 
 * Adding constraints: [aux(61)=<aux(69)*2,aux(69)=<2*A-2,aux(69)+it(82)=<2*A-2*A'] 

##### Pending set process_main4(A,B,C,D,E,F,G,H,I)
* Psum in Loop 79: [aux(65)=<4*A-4*A'-4]
* Psum in Loop 82: [it(82)=<1]
* Psum in Loop 83: [it(83)=<1]

###### Computing sum for aux(65)=<4*A-4*A'-4  in Loop 79 
   - Found a solution using cacheing 
 * Adding constraints: [aux(65)=<aux(70)*2,aux(70)=<2*A-2,aux(70)+it(82)=<2*A-2*A'] 

##### Pending set process_main4(A,B,C,D,E,F,G,H,I)
* Psum in Loop 82: [it(82)=<1]
* Psum in Loop 83: [it(83)=<1]

###### Computing sum for it(82)=<1  in Loop 82 
   - Applying inductive sum strategy 
     - head Candidate: D 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: D 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: D 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: D 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(79)+it(80)+it(81)+it(82)+it(83)=<D,it(79)+it(80)+it(81)+it(82)+it(83)=<B-1,it(82)+s(71)=<A,it(79)+it(80)+it(81)+it(82)+it(83)=<B-1,it(79)+it(80)+it(81)+it(82)+it(83)=<D,it(79)+it(80)+it(81)+it(82)+it(83)=<D-D',it(79)+it(80)+it(81)+it(82)+it(83)=<B-B',it(82)+s(71)=<A-A',it(79)+it(80)+it(81)+it(82)+it(83)=<B-B',it(79)+it(80)+it(81)+it(82)+it(83)=<D-D'] 

##### Pending set process_main4(A,B,C,D,E,F,G,H,I)
* Psum in Loop 83: [it(83)=<1]

###### Computing sum for it(83)=<1  in Loop 83 
   - Applying inductive sum strategy 
     - head Candidate: D 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: D 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: D 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: D 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(79)+it(80)+it(81)+it(82)+it(83)=<D,it(79)+it(80)+it(81)+it(82)+it(83)=<B-1,it(79)+it(80)+it(81)+it(82)+it(83)=<B-1,it(79)+it(80)+it(81)+it(82)+it(83)=<D,it(79)+it(80)+it(81)+it(82)+it(83)=<D-D',it(79)+it(80)+it(81)+it(82)+it(83)=<B-B',it(79)+it(80)+it(81)+it(82)+it(83)=<B-B',it(79)+it(80)+it(81)+it(82)+it(83)=<D-D'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [79,80,81,82,83] 

#### Simplifying cost structure of phase [79,80,81,82,83] 
 * Joined equivalent variables [aux(58),aux(56)] into aux(58)
 * Joined equivalent variables [aux(68),aux(63)] into aux(68)
 * Joined equivalent variables [aux(75),aux(53),aux(67)] into aux(75)
 * Joined equivalent variables [aux(54),aux(58),aux(59),aux(68),aux(69),aux(70)] into aux(54)
 * Joined equivalent variables [aux(61),aux(65)] into aux(61)

#### Cost of phase [79,80,81,82,83]:process_main4(A,B,C,D,E,F,G,H,I) -> [process_main4(A',B',C',D',E',F',G',H',I')] 
20*it(79)+21*it(80)+20*it(81)+20*it(82)+20*it(83)+10*s(70)+8*s(72)+8*s(73)+0
  Such that:it(79) =< A+E/2+G/2
it(79) =< A/2
it(79) =< A/2-A'/2
aux(60) =< B+E+G
aux(64) =< B+E+G-B'-E'-G'
aux(55) =< E+G
aux(57) =< E+G-E'-G'
aux(62) =< 2*E+2*G
aux(66) =< 2*E+2*G-2*E'-2*G'
aux(71) =< A
aux(72) =< A+E/2+G/2-A'-E'/2-G'/2
aux(73) =< A-A'
aux(74) =< 2*A
aux(75) =< 2*A+E+G
aux(76) =< 2*A-2*A'
aux(77) =< B
aux(78) =< B-B'
aux(79) =< D
aux(80) =< D-D'
it(82) =< aux(71)
s(71) =< aux(71)
it(79) =< aux(72)
it(82) =< aux(72)
it(82) =< aux(73)
s(71) =< aux(73)
aux(54) =< aux(74)
aux(54) =< aux(76)
it(82) =< aux(76)
it(79) =< aux(77)
it(80) =< aux(77)
it(81) =< aux(77)
it(82) =< aux(77)
it(83) =< aux(77)
it(79) =< aux(78)
it(80) =< aux(78)
it(81) =< aux(78)
it(82) =< aux(78)
it(83) =< aux(78)
it(79) =< aux(79)
it(80) =< aux(79)
it(81) =< aux(79)
it(82) =< aux(79)
it(83) =< aux(79)
it(79) =< aux(80)
it(80) =< aux(80)
it(81) =< aux(80)
it(82) =< aux(80)
it(83) =< aux(80)
aux(61) =< aux(54)*2
it(82) =< aux(54)+aux(60)
it(83) =< aux(54)+aux(60)
s(73) =< aux(54)+aux(60)
it(81) =< aux(54)+aux(55)
s(72) =< it(80)*aux(75)
s(73) =< aux(61)+aux(66)
it(82) =< aux(54)+aux(64)
it(83) =< aux(54)+aux(64)
s(73) =< aux(54)+aux(64)
s(73) =< aux(61)+aux(62)
it(81) =< aux(54)+aux(57)
s(73) =< it(81)*aux(75)
s(70) =< s(71)

#### Simplifying cost structure of chain [[79,80,81,82,83],78] 
 * Joined equivalent variables [aux(81),aux(71),aux(73)] into aux(81)
 * Joined equivalent variables [aux(82),aux(74),aux(76)] into aux(82)
 * Joined equivalent variables [aux(83),aux(77),aux(78),aux(79),aux(80)] into aux(83)
 * Joined equivalent variables [aux(84),aux(60)] into aux(84)
 * Joined equivalent variables [aux(85),aux(55),aux(57)] into aux(85)
 * Joined equivalent variables [aux(86),aux(62),aux(66)] into aux(86)
 * Joined equivalent variables [aux(81),s(71)] into aux(81)
 * Joined equivalent variables [aux(82),aux(54)] into aux(82)

#### Cost of chains of process_main4(A,B,C,D,E,F,G,H,I):
* Chain [[79,80,81,82,83],78]: 20*it(79)+21*it(80)+20*it(81)+20*it(82)+20*it(83)+10*s(70)+8*s(72)+8*s(73)+3
  Such that:aux(72) =< A+E/2+G/2
aux(75) =< 2*A+E+G
it(79) =< A/2
aux(64) =< D+E+G
aux(81) =< A
aux(82) =< 2*A
aux(83) =< B
aux(84) =< B+E+G
aux(85) =< E+G
aux(86) =< 2*E+2*G
aux(64) =< aux(84)
it(82) =< aux(81)
it(79) =< aux(72)
it(82) =< aux(72)
it(82) =< aux(82)
it(79) =< aux(83)
it(80) =< aux(83)
it(81) =< aux(83)
it(82) =< aux(83)
it(83) =< aux(83)
aux(61) =< aux(82)*2
it(82) =< aux(82)+aux(84)
it(83) =< aux(82)+aux(84)
s(73) =< aux(82)+aux(84)
it(81) =< aux(82)+aux(85)
s(72) =< it(80)*aux(75)
s(73) =< aux(61)+aux(86)
it(82) =< aux(82)+aux(64)
it(83) =< aux(82)+aux(64)
s(73) =< aux(82)+aux(64)
s(73) =< it(81)*aux(75)
s(70) =< aux(81)

  with precondition: [I=1,B=D+1,A>=0,B>=2,C>=0,E>=1,F>=0,G>=1,H>=0] 

* Chain [78]: 3
  with precondition: [A=0,B=1,D=0,I=1,C>=0,E>=1,F>=0,G>=1,H>=0] 


#### Simplifying cost structure of CE 99 
 * Renamed intermediate variables: 
[ (eq(100,1),aux(72))>>s(74), (eq(100,1),aux(75))>>s(75), (eq(100,1),it(79))>>s(76), (eq(100,1),aux(64))>>s(77), (eq(100,1),aux(81))>>s(78), (eq(100,1),aux(82))>>s(79), (eq(100,1),aux(83))>>s(80), (eq(100,1),aux(84))>>s(81), (eq(100,1),aux(85))>>s(82), (eq(100,1),aux(86))>>s(83), (eq(100,1),it(82))>>s(84), (eq(100,1),it(80))>>s(85), (eq(100,1),it(81))>>s(86), (eq(100,1),it(83))>>s(87), (eq(100,1),aux(61))>>s(88), (eq(100,1),s(73))>>s(89), (eq(100,1),s(72))>>s(90), (eq(100,1),s(70))>>s(91)]

#### Simplifying cost structure of CE 100 

#### Cost of chains of main4(A,B,C,D,E):
* Chain [85]: 6
  with precondition: [A=0,B=1,D=0,E=1,C>=0] 

* Chain [84]: 20*s(76)+20*s(84)+21*s(85)+20*s(86)+20*s(87)+8*s(89)+8*s(90)+10*s(91)+6
  Such that:s(82) =< 2
s(83) =< 4
s(78) =< A
s(74) =< A+1
s(79) =< 2*A
s(75) =< 2*A+2
s(76) =< A/2
s(80) =< D+1
s(77) =< D+2
s(81) =< D+3
s(77) =< s(81)
s(84) =< s(78)
s(76) =< s(74)
s(84) =< s(74)
s(84) =< s(79)
s(76) =< s(80)
s(85) =< s(80)
s(86) =< s(80)
s(84) =< s(80)
s(87) =< s(80)
s(88) =< s(79)*2
s(84) =< s(79)+s(81)
s(87) =< s(79)+s(81)
s(89) =< s(79)+s(81)
s(86) =< s(79)+s(82)
s(90) =< s(85)*s(75)
s(89) =< s(88)+s(83)
s(84) =< s(79)+s(77)
s(87) =< s(79)+s(77)
s(89) =< s(79)+s(77)
s(89) =< s(86)*s(75)
s(91) =< s(78)

  with precondition: [E=1,B=D+1,A>=0,B>=2,C>=0] 


#### Simplifying cost structure of CE 102 
 * Renamed intermediate variables: 
[ (eq(103,1),s(1))>>s(92)]

#### Simplifying cost structure of CE 103 

#### Simplifying cost structure of CE 101 

#### Cost of chains of case_14(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V):
* Chain [88]: 11
  with precondition: [A=5,B=1,M=1,T=1,U=1,O+1=E,Q+1=G,K=R,L=S,K+N=D,L+P=F,C>=0,H>=5,I>=1,J>=0,K>=1,L>=0,O>=1,Q>=0,V>=0,D>=K,F>=L] 

* Chain [87]: 8*s(92)+11
  Such that:s(92) =< B

  with precondition: [A=5,M=1,T=1,U=1,O+1=E,Q+1=G,K=R,L=S,K+N=D,L+P=F,B>=2,C>=0,H>=5,I>=1,J>=0,K>=1,L>=0,O>=1,Q>=0,V>=0,D>=K,F>=L] 

* Chain [86]: 4
  with precondition: [A=5,M=1,T=1,O+1=E,Q+1=G,K=R,L=S,B=U,K+N=D,L+P=F,C+H+1=V,4>=H,B>=1,H>=0,I>=1,J>=0,K>=1,L>=0,O>=1,Q>=0,V>=H+1,D>=K,F>=L] 


#### Simplifying cost structure of CE 104 

#### Simplifying cost structure of CE 109 

#### Simplifying cost structure of CE 110 

#### Simplifying cost structure of CE 111 
 * Renamed intermediate variables: 
[ (eq(105,2),s(92))>>s(93)]

#### Simplifying cost structure of CE 105 

#### Simplifying cost structure of CE 106 
 * Renamed intermediate variables: 
[ (eq(107,1),it(36))>>s(94)]
 * Renamed intermediate variables: 
[ (eq(107,2),s(92))>>s(95)]

#### Simplifying cost structure of CE 107 
 * Renamed intermediate variables: 
[ (eq(108,1),it(36))>>s(96)]

#### Simplifying cost structure of CE 108 

#### Cost of chains of case_13(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q):
* Chain [94]: 22
  with precondition: [F=1,H=1,J=1,O=1,P=1,K+1=A,L+1=B,N+1=D,C=I+M,E>=5,G>=0,I>=0,K>=0,L>=1,N>=0,Q>=0,C>=I] 

* Chain [93]: 4
  with precondition: [H=0,J=1,O=1,K=A,L+1=B,N+1=D,F=P,C=I+M,E+G=Q,E>=0,F>=1,G>=0,I>=0,K>=0,L>=1,N>=0,C>=I] 

* Chain [92]: 8*s(93)+22
  Such that:s(93) =< F

  with precondition: [H=1,J=1,O=1,P=1,K+1=A,L+1=B,N+1=D,C=I+M,E>=5,F>=2,G>=0,I>=0,K>=0,L>=1,N>=0,Q>=0,C>=I] 

* Chain [91]: 15
  with precondition: [H=1,J=1,O=1,K+1=A,L+1=B,N+1=D,F=P,C=I+M,E+G+1=Q,4>=E,E>=0,F>=1,G>=0,I>=0,K>=0,L>=1,N>=0,C>=I] 

* Chain [90]: 5*s(94)+8*s(95)+22
  Such that:s(95) =< F+H
s(94) =< H

  with precondition: [J=1,O=1,P=1,L+1=B,N+1=D,H+K=A,C=I+M,E>=5,F>=1,G>=0,H>=2,I>=0,K>=0,L>=1,N>=0,Q>=0,C>=I] 

* Chain [89]: 5*s(96)+15
  Such that:s(96) =< A-K

  with precondition: [J=1,O=1,L+1=B,N+1=D,H+K=A,I+M=C,F+H=P+1,4>=E,E>=0,F>=1,G>=0,H>=2,I>=0,K>=0,L>=1,M>=0,N>=0,Q>=E+1,E+G+I+1>=Q] 


#### Simplifying cost structure of CE 118 

#### Computing cost of phase [96,97,98,99,100,101] 
 * Renamed intermediate variables: 
[ (eq(117,1),s(96))>>s(97)]

#### Simplifying cost structure of CE 117 
 * Renamed intermediate variables: 
[ (it(96),s(97))>>s(98)]

#### Simplifying cost structure of CE 113 

#### Simplifying cost structure of CE 115 
 * Renamed intermediate variables: 
[ (eq(116,1),s(95))>>s(99), (eq(116,1),s(94))>>s(100)]

#### Simplifying cost structure of CE 116 
 * Renamed intermediate variables: 
[ (it(99),s(99))>>s(101), (it(99),s(100))>>s(102)]
 * Renamed intermediate variables: 
[ (eq(114,1),s(93))>>s(103)]

#### Simplifying cost structure of CE 114 
 * Renamed intermediate variables: 
[ (it(100),s(103))>>s(104)]

#### Simplifying cost structure of CE 112 

#### Cost of loops [96,97,98,99,100,101] 

 * loop 96:process_main5(A,B,C,D,E,F,G,H) -> [process_main5(A',B',C',D',E',F',G',H')] 
5*s(98)+24
  Such that:s(98) =< -F+F'+1

 * loop 97:process_main5(A,B,C,D,E,F,G,H) -> [process_main5(A',B',C',D',E',F',G',H')] 
13
 * loop 98:process_main5(A,B,C,D,E,F,G,H) -> [process_main5(A',B',C',D',E',F',G',H')] 
24
 * loop 99:process_main5(A,B,C,D,E,F,G,H) -> [process_main5(A',B',C',D',E',F',G',H')] 
8*s(101)+5*s(102)+31
  Such that:s(101) =< A+F-A'
s(102) =< A-A'

 * loop 100:process_main5(A,B,C,D,E,F,G,H) -> [process_main5(A',B',C',D',E',F',G',H')] 
8*s(104)+31
  Such that:s(104) =< F

 * loop 101:process_main5(A,B,C,D,E,F,G,H) -> [process_main5(A',B',C',D',E',F',G',H')] 
31
##### Pending set process_main5(A,B,C,D,E,F,G,H)
* Psum in Loop 96: [it(96)=<1,s(105)=< -F+F'+1]
* Psum in Loop 97: [it(97)=<1]
* Psum in Loop 98: [it(98)=<1]
* Psum in Loop 99: [it(99)=<1,s(106)=<A+F-A',s(107)=<A-A']
* Psum in Loop 100: [it(100)=<1,s(108)=<F]
* Psum in Loop 101: [it(101)=<1]

###### Computing sum for it(96)=<1  in Loop 96 
   - Applying inductive sum strategy 
     - head Candidate: D 
       - Loop 97 is collaborative and bounds [it(97)] 
       - Loop 98 is collaborative and bounds [it(98)] 
       - Loop 99 is collaborative and bounds [it(99)] 
       - Loop 100 is collaborative and bounds [it(100)] 
       - Loop 101 is collaborative and bounds [it(101)] 
     - head Candidate: B-1 
       - Loop 97 is collaborative and bounds [it(97)] 
       - Loop 98 is collaborative and bounds [it(98)] 
       - Loop 99 is collaborative and bounds [it(99)] 
       - Loop 100 is collaborative and bounds [it(100)] 
       - Loop 101 is collaborative and bounds [it(101)] 
     - head Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: D 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A/2-1/2 
       - Loop 97 is collaborative
       - Loop 98 is collaborative
       - Loop 99 is collaborative
       - Loop 100 is collaborative
       - Loop 101 is collaborative
     - head Candidate: A+F-2 
       - Loop 97 is collaborative
       - Loop 98 is collaborative
       - Loop 99 is collaborative and bounds [it(99)] 
       - Loop 100 is collaborative and bounds [it(100)] 
       - Loop 101 is collaborative
     - tail Candidate: D 
       - Loop 97 is collaborative and bounds [it(97)] 
       - Loop 98 is collaborative and bounds [it(98)] 
       - Loop 99 is collaborative and bounds [it(99)] 
       - Loop 100 is collaborative and bounds [it(100)] 
       - Loop 101 is collaborative and bounds [it(101)] 
     - tail Candidate: B-1 
       - Loop 97 is collaborative and bounds [it(97)] 
       - Loop 98 is collaborative and bounds [it(98)] 
       - Loop 99 is collaborative and bounds [it(99)] 
       - Loop 100 is collaborative and bounds [it(100)] 
       - Loop 101 is collaborative and bounds [it(101)] 
     - tail Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: D 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A/2-1/2 
       - Loop 97 is collaborative
       - Loop 98 is collaborative
       - Loop 99 is collaborative and bounds [it(99)] 
       - Loop 100 is collaborative
       - Loop 101 is collaborative
     - tail Candidate: A+F-2 
       - Loop 97 is collaborative
       - Loop 98 is collaborative and bounds [it(98)] 
       - Loop 99 is collaborative and bounds [it(99)] 
       - Loop 100 is collaborative and bounds [it(100)] 
       - Loop 101 is collaborative and bounds [it(101)] 
 * Adding constraints: [it(96)+it(97)+it(98)+it(99)+it(100)+it(101)=<D,it(96)+it(97)+it(98)+it(99)+it(100)+it(101)=<B-1,it(96)+it(97)+it(98)+it(99)+it(100)+it(101)=<B-1,it(96)+it(97)+it(98)+it(99)+it(100)+it(101)=<D,it(96)=<A/2-1/2,it(96)+it(99)+it(100)=<A+F-2,it(96)+it(97)+it(98)+it(99)+it(100)+it(101)=<D-D',it(96)+it(97)+it(98)+it(99)+it(100)+it(101)=<B-B',it(96)+it(97)+it(98)+it(99)+it(100)+it(101)=<B-B',it(96)+it(97)+it(98)+it(99)+it(100)+it(101)=<D-D',it(96)+it(99)=<A/2-A'/2,it(96)+it(98)+it(99)+it(100)+it(101)=<A+F-A'-F'] 

##### Pending set A
* Psum in Loop 96: [s(105)=< -F+F'+1]
* Psum in Loop 97: [it(97)=<1]
* Psum in Loop 98: [it(98)=<1]
* Psum in Loop 99: [it(99)=<1,s(106)=<A+F-A',s(107)=<A-A']
* Psum in Loop 100: [it(100)=<1,s(108)=<F]
* Psum in Loop 101: [it(101)=<1]

###### Computing sum for s(105)=< -F+F'+1  in Loop 96 
   - Applying inductive sum strategy 
     - head Candidate: A 
       - Loop 97 is collaborative
       - Loop 98 is collaborative and bounds [it(98)] 
       - Loop 99 is collaborative and bounds [it(99)] 
       - Loop 100 is collaborative and bounds [it(100)] 
       - Loop 101 is collaborative and bounds [it(101)] 
     - tail Candidate: A 
       - Loop 97 is collaborative
       - Loop 98 is collaborative and bounds [it(98)] 
       - Loop 99 is collaborative and bounds [it(99)] 
       - Loop 100 is collaborative and bounds [it(100)] 
       - Loop 101 is collaborative and bounds [it(101)] 
 * Adding constraints: [it(98)+it(99)+it(100)+it(101)+s(105)=<A,it(98)+it(99)+it(100)+it(101)+s(105)=<A-A'] 

##### Pending set A
* Psum in Loop 97: [it(97)=<1]
* Psum in Loop 98: [it(98)=<1]
* Psum in Loop 99: [it(99)=<1,s(106)=<A+F-A',s(107)=<A-A']
* Psum in Loop 100: [it(100)=<1,s(108)=<F]
* Psum in Loop 101: [it(101)=<1]

###### Computing sum for it(97)=<1  in Loop 97 
   - Applying inductive sum strategy 
     - head Candidate: D 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: D 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: D 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: D 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(96)+it(97)+it(98)+it(99)+it(100)+it(101)=<D,it(96)+it(97)+it(98)+it(99)+it(100)+it(101)=<B-1,it(96)+it(97)+it(98)+it(99)+it(100)+it(101)=<B-1,it(96)+it(97)+it(98)+it(99)+it(100)+it(101)=<D,it(96)+it(97)+it(98)+it(99)+it(100)+it(101)=<D-D',it(96)+it(97)+it(98)+it(99)+it(100)+it(101)=<B-B',it(96)+it(97)+it(98)+it(99)+it(100)+it(101)=<B-B',it(96)+it(97)+it(98)+it(99)+it(100)+it(101)=<D-D'] 

##### Pending set A
* Psum in Loop 98: [it(98)=<1]
* Psum in Loop 99: [it(99)=<1,s(106)=<A+F-A',s(107)=<A-A']
* Psum in Loop 100: [it(100)=<1,s(108)=<F]
* Psum in Loop 101: [it(101)=<1]

###### Computing sum for it(98)=<1  in Loop 98 
   - Applying inductive sum strategy 
     - head Candidate: D 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: D 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: D 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: D 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(96)+it(97)+it(98)+it(99)+it(100)+it(101)=<D,it(96)+it(97)+it(98)+it(99)+it(100)+it(101)=<B-1,it(98)+it(99)+it(100)+it(101)+s(105)=<A,it(96)+it(97)+it(98)+it(99)+it(100)+it(101)=<B-1,it(96)+it(97)+it(98)+it(99)+it(100)+it(101)=<D,it(96)+it(97)+it(98)+it(99)+it(100)+it(101)=<D-D',it(96)+it(97)+it(98)+it(99)+it(100)+it(101)=<B-B',it(98)+it(99)+it(100)+it(101)+s(105)=<A-A',it(96)+it(97)+it(98)+it(99)+it(100)+it(101)=<B-B',it(96)+it(97)+it(98)+it(99)+it(100)+it(101)=<D-D'] 

##### Pending set A
* Psum in Loop 99: [it(99)=<1,s(106)=<A+F-A',s(107)=<A-A']
* Psum in Loop 100: [it(100)=<1,s(108)=<F]
* Psum in Loop 101: [it(101)=<1]

###### Computing sum for it(99)=<1  in Loop 99 
   - Applying inductive sum strategy 
     - head Candidate: D 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: D 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A/2-1/2 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: D 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: D 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A/2-1/2 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(96)+it(97)+it(98)+it(99)+it(100)+it(101)=<D,it(96)+it(97)+it(98)+it(99)+it(100)+it(101)=<B-1,it(96)+it(97)+it(98)+it(99)+it(100)+it(101)=<B-1,it(96)+it(97)+it(98)+it(99)+it(100)+it(101)=<D,it(96)+it(99)=<A/2-1/2,it(96)+it(97)+it(98)+it(99)+it(100)+it(101)=<D-D',it(96)+it(97)+it(98)+it(99)+it(100)+it(101)=<B-B',it(96)+it(97)+it(98)+it(99)+it(100)+it(101)=<B-B',it(96)+it(97)+it(98)+it(99)+it(100)+it(101)=<D-D',it(96)+it(99)=<A/2-A'/2] 

##### Pending set A
* Psum in Loop 99: [s(106)=<A+F-A',s(107)=<A-A']
* Psum in Loop 100: [it(100)=<1,s(108)=<F]
* Psum in Loop 101: [it(101)=<1]

###### Computing sum for s(106)=<A+F-A'  in Loop 99 
   - Applying inductive sum strategy 
     - head Candidate: A+B+F-2 
       - Loop 96 is collaborative
       - Loop 97 is collaborative
       - Loop 98 is collaborative
       - Loop 100 is collaborative and bounds [it(100)] 
       - Loop 101 is collaborative and bounds [it(101)] 
     - head Candidate: A+D+F-1 
       - Loop 96 is collaborative
       - Loop 97 is collaborative
       - Loop 98 is collaborative
       - Loop 100 is collaborative and bounds [it(100)] 
       - Loop 101 is collaborative and bounds [it(101)] 
     - tail Candidate: A+B+F-2 
       - Loop 96 is collaborative
       - Loop 97 is collaborative
       - Loop 98 is collaborative
       - Loop 100 is collaborative and bounds [it(100)] 
       - Loop 101 is collaborative and bounds [it(101)] 
     - tail Candidate: A+D+F-1 
       - Loop 96 is collaborative
       - Loop 97 is collaborative
       - Loop 98 is collaborative
       - Loop 100 is collaborative and bounds [it(100)] 
       - Loop 101 is collaborative and bounds [it(101)] 
 * Adding constraints: [it(100)+it(101)+s(106)=<A+B+F-2,it(100)+it(101)+s(106)=<A+D+F-1,it(100)+it(101)+s(106)=<A+B+F-A'-B'-F',it(100)+it(101)+s(106)=<A+D+F-A'-D'-F'] 

##### Pending set A
* Psum in Loop 99: [s(107)=<A-A']
* Psum in Loop 100: [it(100)=<1,s(108)=<F]
* Psum in Loop 101: [it(101)=<1]

###### Computing sum for s(107)=<A-A'  in Loop 99 
   - Applying inductive sum strategy 
     - head Candidate: A 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(98)+it(100)+it(101)+s(105)+s(107)=<A,it(98)+it(100)+it(101)+s(105)+s(107)=<A-A'] 

##### Pending set A
* Psum in Loop 100: [it(100)=<1,s(108)=<F]
* Psum in Loop 101: [it(101)=<1]

###### Computing sum for it(100)=<1  in Loop 100 
   - Applying inductive sum strategy 
     - head Candidate: D 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: D 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: F-1 
       - Loop 96 adds an expression [A-A'-1]
       - Loop 97 is collaborative
       - Loop 98 is collaborative
       - Loop 99 is collaborative
       - Loop 101 is collaborative
     - tail Candidate: D 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: D 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: F-1 
       - Loop 96 adds an expression [A-A'-1]
       - Loop 97 is collaborative
       - Loop 98 is collaborative
       - Loop 99 is collaborative
       - Loop 101 is collaborative
 * Adding constraints: [it(100)=<aux(87)+aux(88),it(100)=<aux(89)+aux(90),it(96)+it(97)+it(98)+it(99)+it(100)+it(101)=<D,it(96)+it(97)+it(98)+it(99)+it(100)+it(101)=<B-1,it(98)+it(99)+it(100)+it(101)+s(105)=<A,it(96)+it(97)+it(98)+it(99)+it(100)+it(101)=<B-1,it(96)+it(97)+it(98)+it(99)+it(100)+it(101)=<D,aux(88)=<F-1,it(96)+it(97)+it(98)+it(99)+it(100)+it(101)=<D-D',it(96)+it(97)+it(98)+it(99)+it(100)+it(101)=<B-B',it(98)+it(99)+it(100)+it(101)+s(105)=<A-A',it(96)+it(97)+it(98)+it(99)+it(100)+it(101)=<B-B',it(96)+it(97)+it(98)+it(99)+it(100)+it(101)=<D-D',aux(90)=<F-F'] 

##### Pending set A
* Psum in Loop 96: [aux(87)=<A-A'-1,aux(89)=<A-A'-1]
* Psum in Loop 100: [s(108)=<F]
* Psum in Loop 101: [it(101)=<1]

###### Computing sum for aux(87)=<A-A'-1  in Loop 96 
   - Applying inductive sum strategy 
     - head Candidate: A+C+E+G 
       - Loop 97 is collaborative
       - Loop 98 is collaborative
       - Loop 99 has undefined behavior 
     - head Candidate: A+C+E+G-1 
       - Loop 97 is collaborative
       - Loop 98 is collaborative
       - Loop 99 has undefined behavior 
     - tail Candidate: A+C+E+G 
       - Loop 97 is collaborative
       - Loop 98 is collaborative
       - Loop 99 has undefined behavior 
     - tail Candidate: A+C+E+G-1 
       - Loop 97 is collaborative
       - Loop 98 is collaborative
       - Loop 99 has undefined behavior 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(91)=<A-1] 
 * Adding constraints: [aux(87)=<it(96)*aux(91)] 

##### Pending set process_main5(A,B,C,D,E,F,G,H)
* Pmax/min: [aux(91)=<A-1]
* Psum in Loop 96: [aux(89)=<A-A'-1]
* Psum in Loop 100: [s(108)=<F]
* Psum in Loop 101: [it(101)=<1]

###### Computing max_min for aux(91)=<A-1  
   - Found a solution using transitive invariants 
 * Adding constraints:[aux(91)=<A-1] 

##### Pending set process_main5(A,B,C,D,E,F,G,H)
* Psum in Loop 96: [aux(89)=<A-A'-1]
* Psum in Loop 100: [s(108)=<F]
* Psum in Loop 101: [it(101)=<1]

###### Computing sum for aux(89)=<A-A'-1  in Loop 96 
   - Found a solution using cacheing 
 * Adding constraints: [aux(89)=<aux(92),aux(92)=<it(96)*aux(91)] 

##### Pending set process_main5(A,B,C,D,E,F,G,H)
* Psum in Loop 100: [s(108)=<F]
* Psum in Loop 101: [it(101)=<1]

###### Computing sum for s(108)=<F  in Loop 100 
   - Applying inductive sum strategy 
     - head Candidate: A+F-1 
       - Loop 96 is collaborative
       - Loop 97 is collaborative
       - Loop 98 is collaborative
       - Loop 99 is collaborative
       - Loop 101 is collaborative and bounds [it(101)] 
     - head Candidate: D+F-1 
       - Loop 96 adds an expression [A-A'-2]
       - Loop 97 is collaborative
       - Loop 98 is collaborative
       - Loop 99 is collaborative
       - Loop 101 is collaborative and bounds [it(101)] 
     - tail Candidate: A+F-1 
       - Loop 96 is collaborative
       - Loop 97 is collaborative
       - Loop 98 is collaborative
       - Loop 99 is collaborative
       - Loop 101 is collaborative and bounds [it(101)] 
     - tail Candidate: D+F-1 
       - Loop 96 adds an expression [A-A'-2]
       - Loop 97 is collaborative
       - Loop 98 is collaborative
       - Loop 99 is collaborative
       - Loop 101 is collaborative and bounds [it(101)] 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(97)=<F] 
 * Adding constraints: [s(108)=<it(100)*aux(97),it(101)+s(108)=<aux(93)+aux(94),it(101)+s(108)=<aux(95)+aux(96),it(101)+s(108)=<A+F-1,aux(94)=<D+F-1,it(101)+s(108)=<A+F-A'-F',aux(96)=<D+F-D'-F'] 

##### Pending set process_main5(A,B,C,D,E,F,G,H)
* Pmax/min: [aux(97)=<F]
* Psum in Loop 96: [aux(93)=<A-A'-2,aux(95)=<A-A'-2]
* Psum in Loop 101: [it(101)=<1]

###### Computing max_min for aux(97)=<F  
   - Found a solution using transitive invariants 
 * Adding constraints:[aux(97)=<A+F] 

##### Pending set process_main5(A,B,C,D,E,F,G,H)
* Psum in Loop 96: [aux(93)=<A-A'-2,aux(95)=<A-A'-2]
* Psum in Loop 101: [it(101)=<1]

###### Computing sum for aux(93)=<A-A'-2  in Loop 96 
   - Applying inductive sum strategy 
     - head Candidate: A+2*C+2*E+2*G 
       - Loop 97 is collaborative
       - Loop 98 adds a constant 1/1 
       - Loop 99 has undefined behavior 
     - head Candidate: A+2*C+2*E+2*G-2 
       - Loop 97 is collaborative
       - Loop 98 adds a constant 1/1 
       - Loop 99 has undefined behavior 
     - tail Candidate: A+2*C+2*E+2*G 
       - Loop 97 is collaborative
       - Loop 98 adds a constant 1/1 
       - Loop 99 has undefined behavior 
     - tail Candidate: A+2*C+2*E+2*G-2 
       - Loop 97 is collaborative
       - Loop 98 adds a constant 1/1 
       - Loop 99 has undefined behavior 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(98)=<A-2] 
 * Adding constraints: [aux(93)=<it(96)*aux(98)] 

##### Pending set process_main5(A,B,C,D,E,F,G,H)
* Pmax/min: [aux(98)=<A-2]
* Psum in Loop 96: [aux(95)=<A-A'-2]
* Psum in Loop 101: [it(101)=<1]

###### Computing max_min for aux(98)=<A-2  
   - Found a solution using cacheing 
 * Adding constraints:[aux(98)=<aux(91)-1] 

##### Pending set process_main5(A,B,C,D,E,F,G,H)
* Psum in Loop 96: [aux(95)=<A-A'-2]
* Psum in Loop 101: [it(101)=<1]

###### Computing sum for aux(95)=<A-A'-2  in Loop 96 
   - Found a solution using cacheing 
 * Adding constraints: [aux(95)=<aux(99),aux(99)=<it(96)*aux(98)] 

##### Pending set process_main5(A,B,C,D,E,F,G,H)
* Psum in Loop 101: [it(101)=<1]

###### Computing sum for it(101)=<1  in Loop 101 
   - Applying inductive sum strategy 
     - head Candidate: D 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: D 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: D 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: D 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(96)+it(97)+it(98)+it(99)+it(100)+it(101)=<D,it(96)+it(97)+it(98)+it(99)+it(100)+it(101)=<B-1,it(98)+it(99)+it(100)+it(101)+s(105)=<A,it(96)+it(97)+it(98)+it(99)+it(100)+it(101)=<B-1,it(96)+it(97)+it(98)+it(99)+it(100)+it(101)=<D,it(96)+it(97)+it(98)+it(99)+it(100)+it(101)=<D-D',it(96)+it(97)+it(98)+it(99)+it(100)+it(101)=<B-B',it(98)+it(99)+it(100)+it(101)+s(105)=<A-A',it(96)+it(97)+it(98)+it(99)+it(100)+it(101)=<B-B',it(96)+it(97)+it(98)+it(99)+it(100)+it(101)=<D-D'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [96,97,98,99,100,101] 

#### Simplifying cost structure of phase [96,97,98,99,100,101] 
 * Joined equivalent variables [aux(92),aux(89)] into aux(92)
 * Joined equivalent variables [aux(99),aux(95)] into aux(99)
 * Joined equivalent variables [aux(100),aux(91)] into aux(100)
 * Joined equivalent variables [aux(105),aux(97)] into aux(105)
 * Joined equivalent variables [aux(87),aux(92)] into aux(87)
 * Joined equivalent variables [aux(93),aux(99)] into aux(93)
 * Joined equivalent variables [s(105),s(107)] into s(105)

#### Cost of phase [96,97,98,99,100,101]:process_main5(A,B,C,D,E,F,G,H) -> [process_main5(A',B',C',D',E',F',G',H')] 
24*it(96)+13*it(97)+24*it(98)+31*it(99)+31*it(100)+31*it(101)+10*s(105)+8*s(106)+8*s(108)+0
  Such that:aux(94) =< D+F
aux(96) =< D+F-D'-F'
aux(88) =< F
aux(90) =< F-F'
aux(100) =< A
aux(101) =< A+B+F
aux(102) =< A+B+F-A'-B'-F'
aux(103) =< A+D+F
aux(104) =< A+D+F-A'-D'-F'
aux(105) =< A+F
aux(106) =< A+F-A'-F'
aux(107) =< A-A'
aux(108) =< A/2
aux(109) =< A/2-A'/2
aux(110) =< B
aux(111) =< B-B'
aux(112) =< D
aux(113) =< D-D'
it(98) =< aux(100)
it(99) =< aux(100)
it(100) =< aux(100)
it(101) =< aux(100)
s(105) =< aux(100)
it(100) =< aux(101)
it(101) =< aux(101)
s(106) =< aux(101)
it(100) =< aux(102)
it(101) =< aux(102)
s(106) =< aux(102)
it(100) =< aux(103)
it(101) =< aux(103)
s(106) =< aux(103)
it(100) =< aux(104)
it(101) =< aux(104)
s(106) =< aux(104)
it(96) =< aux(105)
it(99) =< aux(105)
it(100) =< aux(105)
it(101) =< aux(105)
s(108) =< aux(105)
it(96) =< aux(106)
it(98) =< aux(106)
it(99) =< aux(106)
it(100) =< aux(106)
it(101) =< aux(106)
s(108) =< aux(106)
it(98) =< aux(107)
it(99) =< aux(107)
it(100) =< aux(107)
it(101) =< aux(107)
s(105) =< aux(107)
it(96) =< aux(108)
it(99) =< aux(108)
it(96) =< aux(109)
it(99) =< aux(109)
it(96) =< aux(110)
it(97) =< aux(110)
it(98) =< aux(110)
it(99) =< aux(110)
it(100) =< aux(110)
it(101) =< aux(110)
it(96) =< aux(111)
it(97) =< aux(111)
it(98) =< aux(111)
it(99) =< aux(111)
it(100) =< aux(111)
it(101) =< aux(111)
it(96) =< aux(112)
it(97) =< aux(112)
it(98) =< aux(112)
it(99) =< aux(112)
it(100) =< aux(112)
it(101) =< aux(112)
it(96) =< aux(113)
it(97) =< aux(113)
it(98) =< aux(113)
it(99) =< aux(113)
it(100) =< aux(113)
it(101) =< aux(113)
aux(98) =< aux(100)-1
aux(87) =< it(96)*aux(100)
aux(93) =< it(96)*aux(98)
it(100) =< aux(87)+aux(88)
it(101) =< aux(93)+aux(94)
s(108) =< aux(93)+aux(94)
it(100) =< aux(87)+aux(90)
it(101) =< aux(93)+aux(96)
s(108) =< aux(93)+aux(96)
s(108) =< it(100)*aux(105)

#### Simplifying cost structure of chain [[96,97,98,99,100,101],95] 
 * Joined equivalent variables [aux(114),aux(100),aux(107)] into aux(114)
 * Joined equivalent variables [aux(115),aux(102),aux(103),aux(104)] into aux(115)
 * Joined equivalent variables [aux(116),aux(105),aux(106)] into aux(116)
 * Joined equivalent variables [aux(117),aux(108),aux(109)] into aux(117)
 * Joined equivalent variables [aux(118),aux(111),aux(112),aux(113)] into aux(118)
 * Joined equivalent variables [aux(119),aux(94)] into aux(119)
 * Joined equivalent variables [aux(120),aux(88),aux(90)] into aux(120)

#### Cost of chains of process_main5(A,B,C,D,E,F,G,H):
* Chain [[96,97,98,99,100,101],95]: 24*it(96)+13*it(97)+24*it(98)+31*it(99)+31*it(100)+31*it(101)+10*s(105)+8*s(106)+8*s(108)+3
  Such that:aux(101) =< A+D+F+1
aux(96) =< B+F
aux(110) =< D+1
aux(114) =< A
aux(115) =< A+D+F
aux(116) =< A+F
aux(117) =< A/2
aux(118) =< D
aux(119) =< D+F
aux(120) =< F
aux(96) =< aux(119)
it(98) =< aux(114)
it(99) =< aux(114)
it(100) =< aux(114)
it(101) =< aux(114)
s(105) =< aux(114)
it(100) =< aux(101)
it(101) =< aux(101)
s(106) =< aux(101)
it(100) =< aux(115)
it(101) =< aux(115)
s(106) =< aux(115)
it(96) =< aux(116)
it(99) =< aux(116)
it(100) =< aux(116)
it(101) =< aux(116)
s(108) =< aux(116)
it(98) =< aux(116)
it(96) =< aux(117)
it(99) =< aux(117)
it(96) =< aux(110)
it(97) =< aux(110)
it(98) =< aux(110)
it(99) =< aux(110)
it(100) =< aux(110)
it(101) =< aux(110)
it(96) =< aux(118)
it(97) =< aux(118)
it(98) =< aux(118)
it(99) =< aux(118)
it(100) =< aux(118)
it(101) =< aux(118)
aux(98) =< aux(114)-1
aux(87) =< it(96)*aux(114)
aux(93) =< it(96)*aux(98)
it(100) =< aux(87)+aux(120)
it(101) =< aux(93)+aux(119)
s(108) =< aux(93)+aux(119)
it(101) =< aux(93)+aux(96)
s(108) =< aux(93)+aux(96)
s(108) =< it(100)*aux(116)

  with precondition: [H=1,B=D+1,A>=0,B>=2,C>=0,E>=0,F>=1,G>=0] 

* Chain [95]: 3
  with precondition: [A=0,B=1,D=0,H=1,C>=0,E>=0,F>=1,G>=0] 


#### Simplifying cost structure of CE 119 
 * Renamed intermediate variables: 
[ (eq(120,1),aux(101))>>s(109), (eq(120,1),aux(96))>>s(110), (eq(120,1),aux(110))>>s(111), (eq(120,1),aux(114))>>s(112), (eq(120,1),aux(115))>>s(113), (eq(120,1),aux(116))>>s(114), (eq(120,1),aux(117))>>s(115), (eq(120,1),aux(118))>>s(116), (eq(120,1),aux(119))>>s(117), (eq(120,1),aux(120))>>s(118), (eq(120,1),it(98))>>s(119), (eq(120,1),it(99))>>s(120), (eq(120,1),it(100))>>s(121), (eq(120,1),it(101))>>s(122), (eq(120,1),s(105))>>s(123), (eq(120,1),s(106))>>s(124), (eq(120,1),it(96))>>s(125), (eq(120,1),s(108))>>s(126), (eq(120,1),it(97))>>s(127), (eq(120,1),aux(98))>>s(128), (eq(120,1),aux(87))>>s(129), (eq(120,1),aux(93))>>s(130)]

#### Simplifying cost structure of CE 120 
 * Joined equivalent variables [aux(121),s(111),s(117)] into aux(121)

#### Cost of chains of main5(A,B,C,D,E):
* Chain [103]: 6
  with precondition: [A=0,B=1,D=0,E=1,C>=0] 

* Chain [102]: 24*s(119)+31*s(120)+31*s(121)+31*s(122)+10*s(123)+8*s(124)+24*s(125)+8*s(126)+13*s(127)+6
  Such that:s(118) =< 1
s(112) =< A
s(114) =< A+1
s(113) =< A+D+1
s(109) =< A+D+2
s(115) =< A/2
s(116) =< D
s(110) =< D+2
aux(121) =< D+1
s(110) =< aux(121)
s(119) =< s(112)
s(120) =< s(112)
s(121) =< s(112)
s(122) =< s(112)
s(123) =< s(112)
s(121) =< s(109)
s(122) =< s(109)
s(124) =< s(109)
s(121) =< s(113)
s(122) =< s(113)
s(124) =< s(113)
s(125) =< s(114)
s(120) =< s(114)
s(121) =< s(114)
s(122) =< s(114)
s(126) =< s(114)
s(119) =< s(114)
s(125) =< s(115)
s(120) =< s(115)
s(125) =< aux(121)
s(127) =< aux(121)
s(119) =< aux(121)
s(120) =< aux(121)
s(121) =< aux(121)
s(122) =< aux(121)
s(125) =< s(116)
s(127) =< s(116)
s(119) =< s(116)
s(120) =< s(116)
s(121) =< s(116)
s(122) =< s(116)
s(128) =< s(112)-1
s(129) =< s(125)*s(112)
s(130) =< s(125)*s(128)
s(121) =< s(129)+s(118)
s(122) =< s(130)+aux(121)
s(126) =< s(130)+aux(121)
s(122) =< s(130)+s(110)
s(126) =< s(130)+s(110)
s(126) =< s(121)*s(114)

  with precondition: [E=1,B=D+1,A>=0,B>=2,C>=0] 


Closed-form bounds of send_msg(A,B,C): 
-------------------------------------
* Chain [41] with precondition: [A=1,C=1,B>=0] 
    - Upper bound: 4 
    - Complexity: constant 
* Chain [40] with precondition: [C=1,A>=2,B>=0] 
    - Upper bound: 8*A+4 
    - Complexity: n 

### Maximum cost of send_msg(A,B,C): 8*A+4 
Asymptotic class: n 

Closed-form bounds of main1(A,B,C,D,E): 
-------------------------------------
* Chain [50] with precondition: [A=0,B=1,D=0,E=1,C>=0] 
    - Upper bound: 4 
    - Complexity: constant 
* Chain [49] with precondition: [E=1,B=D+1,A>=0,B>=2,C>=0] 
    - Upper bound: 32*A+11*D+15 
    - Complexity: n 

### Maximum cost of main1(A,B,C,D,E): 32*A+11*D+15 
Asymptotic class: n 

Closed-form bounds of append(A,B,C,D,E,F,G,H,I,J,K,L): 
-------------------------------------
* Chain [[36],37] with precondition: [A=C,L=D+H,A+E=I+1,A+G=K+1,A>=2,B>=0,E>=1,F>=0,G>=1,J>=0,D+1>=A,L>=D,B+F>=J] 
    - Upper bound: 5*A+2 
    - Complexity: n 
* Chain [37] with precondition: [A=1,C=1,D=0,E=I,F=J,G=K,H=L,B>=0,E>=0,F>=0,G>=0,H>=0] 
    - Upper bound: 2 
    - Complexity: constant 

### Maximum cost of append(A,B,C,D,E,F,G,H,I,J,K,L): 5*A+2 
Asymptotic class: n 

Closed-form bounds of main2(A,B,C,D,E): 
-------------------------------------
* Chain [59] with precondition: [A=0,B=1,D=0,E=1,C>=0] 
    - Upper bound: 5 
    - Complexity: constant 
* Chain [58] with precondition: [E=1,B=D+1,A>=0,B>=2,C>=0] 
    - Upper bound: 26*A+17*D+22 
    - Complexity: n 

### Maximum cost of main2(A,B,C,D,E): 26*A+17*D+22 
Asymptotic class: n 

Closed-form bounds of main3(A,B,C,D,E): 
-------------------------------------
* Chain [72] with precondition: [A=0,B=1,D=0,E=1,C>=0] 
    - Upper bound: 6 
    - Complexity: constant 
* Chain [71] with precondition: [E=1,B=D+1,A>=0,B>=2,C>=0] 
    - Upper bound: 46*A+68*D+90+ (16*A+16)* (D+1)+10*A 
    - Complexity: n^2 

### Maximum cost of main3(A,B,C,D,E): 46*A+68*D+84+ (16*A+16)* (D+1)+10*A+6 
Asymptotic class: n^2 

Closed-form bounds of main4(A,B,C,D,E): 
-------------------------------------
* Chain [85] with precondition: [A=0,B=1,D=0,E=1,C>=0] 
    - Upper bound: 6 
    - Complexity: constant 
* Chain [84] with precondition: [E=1,B=D+1,A>=0,B>=2,C>=0] 
    - Upper bound: 46*A+69*D+91+ (16*A+16)* (D+1)+10*A 
    - Complexity: n^2 

### Maximum cost of main4(A,B,C,D,E): 46*A+69*D+85+ (16*A+16)* (D+1)+10*A+6 
Asymptotic class: n^2 

Closed-form bounds of main5(A,B,C,D,E): 
-------------------------------------
* Chain [103] with precondition: [A=0,B=1,D=0,E=1,C>=0] 
    - Upper bound: 6 
    - Complexity: constant 
* Chain [102] with precondition: [E=1,B=D+1,A>=0,B>=2,C>=0] 
    - Upper bound: 167*A+21*D+67 
    - Complexity: n 

### Maximum cost of main5(A,B,C,D,E): 167*A+21*D+67 
Asymptotic class: n 
* Total analysis performed in 10707 ms.


Cost relation system solved by CoFloCo in 10719 ms.

Method send_msg terminates?: YES

 - msg_1: size of msg wrt. List<Rat>
 - msg_2: size of msg wrt. Rat
UB for send_msg(msg_1,msg_2) = 8*msg_1+4

Method main1 terminates?: YES

 - events_1: size of events wrt. List<Rat>
 - events_2: size of events wrt. List<Event>
 - events_3: size of events wrt. Rat
 - events_4: size of events wrt. Event
UB for main1(events_1,events_2,events_3,events_4) = 32*events_1+11*events_4+15

Method append terminates?: YES

 - l1_1: size of l1 wrt. List<Rat>
 - l1_2: size of l1 wrt. Rat
 - l1_3: size of l1 wrt. List<A>
 - l1_4: size of l1 wrt. A
 - l2_1: size of l2 wrt. List<Rat>
 - l2_2: size of l2 wrt. Rat
 - l2_3: size of l2 wrt. List<A>
 - l2_4: size of l2 wrt. A
UB for append(l1_1,l1_2,l1_3,l1_4,l2_1,l2_2,l2_3,l2_4) = 5*l1_1+2

Method main2 terminates?: YES

 - events_1: size of events wrt. List<Rat>
 - events_2: size of events wrt. List<Event>
 - events_3: size of events wrt. Rat
 - events_4: size of events wrt. Event
UB for main2(events_1,events_2,events_3,events_4) = 26*events_1+17*events_4+22

Method main3 terminates?: YES

 - events_1: size of events wrt. List<Rat>
 - events_2: size of events wrt. List<Event>
 - events_3: size of events wrt. Rat
 - events_4: size of events wrt. Event
UB for main3(events_1,events_2,events_3,events_4) = 46*events_1+68*events_4+84+ (16*events_1+16)* (events_4+1)+10*events_1+6

Method main4 terminates?: YES

 - events_1: size of events wrt. List<Rat>
 - events_2: size of events wrt. List<Event>
 - events_3: size of events wrt. Rat
 - events_4: size of events wrt. Event
UB for main4(events_1,events_2,events_3,events_4) = 46*events_1+69*events_4+85+ (16*events_1+16)* (events_4+1)+10*events_1+6

Method main5 terminates?: YES

 - events_1: size of events wrt. List<Rat>
 - events_2: size of events wrt. List<Event>
 - events_3: size of events wrt. Rat
 - events_4: size of events wrt. Event
UB for main5(events_1,events_2,events_3,events_4) = 167*events_1+21*events_4+67
