
Abs program loaded in 16 ms.

Rule based representation generated in 2 ms.

Rule based representation stored in /tmp/costabs/rbr.rbr

RBR properties stored in /tmp/costabs/rbr.properties

Class invariants generated and loaded in 0 ms.

Abstract compilation performed in 13 ms.

Cost relation system stored in /tmp/costabs/crs.crs

Generated 28 equations 
entry('append'(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O):[]).
entry('subtrees'(A,B,C,D,E):[]).
input_output_vars('and_op'(A,B,C),[A,B],[C]).
input_output_vars('append'(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O),[A,B,C,D,E,F,G,H,I,J],[K,L,M,N,O]).
input_output_vars('case_0'(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O),[A,B,C,D,E,F,G,H,I,J],[K,L,M,N,O]).
input_output_vars('case_1'(A,B,C,D,E),[A,B],[C,D,E]).
input_output_vars('eq'(A,B,C),[A,B],[C]).
input_output_vars('geq'(A,B,C),[A,B],[C]).
input_output_vars('gt'(A,B,C),[A,B],[C]).
input_output_vars('leq'(A,B,C),[A,B],[C]).
input_output_vars('lt'(A,B,C),[A,B],[C]).
input_output_vars('maxNorm'(A,B,C),[A,B],[C]).
input_output_vars('neg'(A,B),[A],[B]).
input_output_vars('neq'(A,B,C),[A,B],[C]).
input_output_vars('or'(A,B,C),[A,B],[C]).
input_output_vars('subtrees'(A,B,C,D,E),[A,B],[C,D,E]).
eq('eq',[A,B,C],0,[],[A=B,C=1]).
eq('eq',[A,B,C],0,[],[A>=B+1,C=0]).
eq('eq',[A,B,C],0,[],[B>=A+1,C=0]).
eq('neq',[A,B,C],0,[],[A=B,C=0]).
eq('neq',[A,B,C],0,[],[A>=B+1,C=1]).
eq('neq',[A,B,C],0,[],[B>=A+1,C=1]).
eq('lt',[A,B,C],0,[],[B-A>=1,C=1]).
eq('lt',[A,B,C],0,[],[B=<A,C=0]).
eq('leq',[A,B,C],0,[],[A=<B,C=1]).
eq('leq',[A,B,C],0,[],[A-B>=1,C=0]).
eq('gt',[A,B,C],0,[],[A-B>=1,C=1]).
eq('gt',[A,B,C],0,[],[A=<B,C=0]).
eq('geq',[A,B,C],0,[],[B=<A,C=1]).
eq('geq',[A,B,C],0,[],[B-A>=1,C=0]).
eq('neg',[A,B],0,[],[A=0,B=1]).
eq('neg',[A,B],0,[],[A=1,B=0]).
eq('and_op',[A,B,C],0,[],[A=0,C=0]).
eq('and_op',[A,B,C],0,[],[A=1,C=B]).
eq('or',[A,B,C],0,[],[A=1,C=1]).
eq('or',[A,B,C],0,[],[A=0,C=B]).
eq('maxNorm',[A,B,A],0,[],[A>=1+B]).
eq('maxNorm',[A,B,B],0,[],[A=<B]).
eq('case_0',[A,B,C,D,E,F,G,H,I,J,F,G,H,I,J],1,[],[E=0,D=1,C=0,A=1]).
eq('case_0',[A,B,C,D,E,F,G,H,I,J,K,L,M,N,O],4,['append'(P,Q,R,S,T,F,G,H,I,J,U,V,W,X,Y)],[E=Z+T,D=S+1,C=A1+R,B=B1+Q,A=P+1,S>=1,P>=1,Z>=1,A1>=1,O=Z+Y,N=X+1,M=A1+W,L=B1+V,K=U+1,X>=1,U>=1,Z>=1,A1>=1]).
eq('append',[A,B,C,D,E,F,G,H,I,J,K,L,M,N,O],1,['case_0'(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O)],[]).
eq('case_1',[A,B,C,D,E],2,[],[B=1,E=0,C=1]).
eq('case_1',[A,B,C,D,E],7,['subtrees'(F,G,H,I,J),'subtrees'(K,L,M,N,O),'append'(H,I,J,P,Q,M,N,O,R,S,T,U,V,W,X)],[B=L+G+1,A=Y+F+K,L>=1,G>=1,Z=L+G+1,A1=Y+F+K,L>=1,G>=1,E=Z+V,D=A1+U,C=T+1,T>=1,Z>=1]).
eq('subtrees',[A,B,C,D,E],1,['case_1'(A,B,C,D,E)],[]).

Preprocessing Cost Relations
=====================================

#### Computed strongly connected components 
0. recursive  : [append/15,case_0/15]
1. recursive [non_tail,multiple] : [case_1/5,subtrees/5]
Warning: the following predicates are never called:[and_op/3,eq/3,geq/3,gt/3,leq/3,lt/3,maxNorm/3,neg/2,neq/3,or/3]

#### Obtained direct recursion through partial evaluation 
0. SCC is partially evaluated into append/15
1. SCC is partially evaluated into subtrees/5

Control-Flow Refinement of Cost Relations
=====================================

### Specialization of cost equations append/15 
* CE 3 is refined into CE [6] 
* CE 2 is refined into CE [7] 


#### Refined cost equations append/15 
* CE 6: append(A,B,C,D,E,F,G,H,I,J,F,G,H,I,J) = 2
     [E=0,D=1,C=0,A=1] 
* CE 7: append(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O) = 5+ append(P,Q,R,S,T,F,G,H,I,J,U,V,W,X,Y)
     [E>=T+1,C>=R+1,X>=1,U>=1,S>=1,P>=1,O+T=E+Y,M+R=C+W,L+Q=B+V,X+1=N,U+1=K,S+1=D,P+1=A] 

### Cost equations --> "Loop" of append/15 
* CEs [7] --> Loop 5 
* CEs [6] --> Loop 6 

#### Loops of append/15 
* Loop 5: append(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O)->  append(A',B',C',D',E',F,G,H,I,J,F',G',H',I',J')
                  [E>=E'+1,C>=C'+1,I'>=1,F'>=1,D'>=1,A'>=1,E+J'=O+E',C+H'=M+C',B+G'=L+B',I'+1=N,F'+1=K,D'+1=D,A'+1=A] 
* Loop 6: append(A,B,C,D,E,F,G,H,I,J,F,G,H,I,J) [E=0,D=1,C=0,A=1] 

### Ranking functions of CR append(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O) 
* RF of phase [5]: [A-1,D-1]

#### Partial ranking functions of CR append(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O) 
* Partial RF of phase [5]:
  - RF of loop [5:1]:
    A-1
    D-1

Discarded unfeasible chain [[5]]...(Non-terminating chain proved terminating)

### Resulting Chains:append(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O) 
* [[5],6]
* [6]


### Merging Chains  append/15 into  External patterns of execution 
* [[6]] --> 1 
* [[6,[5]]] --> 2 


### Specialization of cost equations subtrees/5 
* CE 5 is refined into CE [8] 
* CE 4 is refined into CE [9,10] 


#### Refined cost equations subtrees/5 
* CE 8: subtrees(A,B,C,D,E) = 3
     [E=0,C=1,B=1] 
* CE 9: subtrees(A,B,C,D,E) = 8+ subtrees(F,G,H,I,J)+ subtrees(K,L,M,N,O)+ append(P,I,Q,R,S,M,N,O,T,U,M,N,O,T,U):1
     [B>=L+2,L>=1,M>=1,B=G+L+1,B+O=E,A+N=D,M+1=C,J=0,H=1,S=0,R=1,Q=0,P=1] 
* CE 10: subtrees(A,B,C,D,E) = 8+ subtrees(F,G,H,I,J)+ subtrees(K,L,M,N,O)+ append(H,I,J,H,P,Q,N,R,S,T,U,V,W,X,Y):2
     [B>=L+2,X>=H,U>=H,P+1>=H,J+1>=H,L>=1,H>=2,B=G+L+1,H+S=X+1,H+M=U+1,H+Q=U+1,Y=P+T,W=J+O,W=J+R,B+W=E,D=A+V,U+1=C] 

### Cost equations --> "Loop" of subtrees/5 
* CEs [10] --> Loop 7 
* CEs [9] --> Loop 8 
* CEs [8] --> Loop 9 

#### Loops of subtrees/5 
* Loop 7: subtrees(A,B,C,D,E)->  subtrees(A',B',C',D',E')  subtrees(A'2,B'2,C'2,D'2,E'2)
                  [E'+1>=C',C>=C'+1,B>=B'+2,C'>=2,B'>=1,B+E'+E'2=E,C'+C'2=C,B'+B'2+1=B] 
* Loop 8: subtrees(A,B,C,D,E)->  subtrees(A',B',C',D',E')  subtrees(A'2,B'2,C'2,D'2,E'2)
                  [B>=B'+2,B'>=1,C>=2,B+E'2=E,A+D'2=D,B'+B'2+1=B,C=C'2+1,E'=0,C'=1] 
* Loop 9: subtrees(A,B,C,D,E) [E=0,C=1,B=1] 

### Ranking functions of CR subtrees(A,B,C,D,E) 
* RF of phase [7,8]: [B/2-1]

#### Partial ranking functions of CR subtrees(A,B,C,D,E) 
* Partial RF of phase [7,8]:
  - RF of loop [7:1,7:2,8:1,8:2]:
    B/2-1

Discarded unfeasible chain [multiple([7,8],[[],[9]])]...(Non-terminating chain proved terminating)
Remaining chain: [multiple([7,8],[[9]])]

### Resulting Chains:subtrees(A,B,C,D,E) 
* [9]
* [multiple([7,8],[[9]])]


### Merging Chains  subtrees/5 into  External patterns of execution 
* [[9]] --> 1 
* [[multiple([7,8],[[9]])]] --> 2 


Computing Bounds
=====================================

#### Simplifying cost structure of CE 6 

#### Computing cost of phase [5] 

#### Simplifying cost structure of CE 7 

#### Cost of loops [5] 

 * loop 5:append(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O) -> [append(A',B',C',D',E',F',G',H',I',J',K',L',M',N',O')] 
5
##### Pending set append(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O)
* Psum in Loop 5: [it(5)=<1]

###### Computing sum for it(5)=<1  in Loop 5 
   - Applying inductive sum strategy 
     - head Candidate: D-1 
     - head Candidate: A-1 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: D-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: D-1 
     - tail Candidate: A-1 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: D-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(5)=<D-1,it(5)=<A-1,it(5)=<A-1,it(5)=<D-1,it(5)=<D-D',it(5)=<A-A',it(5)=<A-A',it(5)=<D-D'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [5] 

#### Simplifying cost structure of phase [5] 

#### Cost of phase [5]:append(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O) -> [append(A',B',C',D',E',F',G',H',I',J',K',L',M',N',O')] 
5*it(5)+0
  Such that:it(5) =< A
it(5) =< A-A'
it(5) =< D
it(5) =< D-D'

#### Simplifying cost structure of chain [[5],6] 

#### Cost of chains of append(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O):
* Chain [[5],6]: 5*it(5)+2
  Such that:it(5) =< -F+K

  with precondition: [A=D,A+F=K+1,C+H=M,A+I=N+1,E+J=O,A>=2,C+1>=A,E+1>=A,K>=A,N>=A] 

* Chain [6]: 2
  with precondition: [A=1,C=0,D=1,E=0,K=F,L=G,M=H,N=I,O=J] 


#### Simplifying cost structure of CE 8 

#### Computing cost of chain [multiple([7,8],[[9]])] with multiple recursion
 * Renamed intermediate variables: 
[ (eq(10,1),it(5))>>s(1)]

#### Simplifying cost structure of CE 10 
 * Renamed intermediate variables: 
[ (it(7),s(1))>>s(2)]

#### Simplifying cost structure of CE 9 

#### Cost of loops [7,8] 

 * loop 7:subtrees(A,B,C,D,E) -> [subtrees(A',B',C',D',E'),subtrees(A'2,B'2,C'2,D'2,E'2)] 
5*s(2)+10
  Such that:s(2) =< B/2-B'2/2

 * loop 8:subtrees(A,B,C,D,E) -> [subtrees(A',B',C',D',E'),subtrees(A'2,B'2,C'2,D'2,E'2)] 
10
##### Pending set subtrees(A,B,C,D,E)
* Psum in Loop 7: [it(7)=<1,s(3)=<B/2-B'2/2]
* Psum in Loop 8: [it(8)=<1]
* Psum in Chain-Tail [9]: [it([9])=<1]

###### Computing sum for it(7)=<1  in Loop 7 
   - Applying inductive sum strategy 
     - head Candidate: B/3-2/3 
       - Loop 8 is collaborative
       - Chain [9] is ignored
     - tail Candidate: B/3-2/3 
       - Loop 8 is collaborative and bounds [it(8)] 
       - Chain-Tail [9] adds a constant 1/3 
 * Adding constraints: [it(7)+it(8)=<it([9])* (1/3)+aux(1),it(7)=<B/3-2/3,aux(1)=<B/3-2/3] 

##### Pending set A
* Psum in Loop 7: [s(3)=<B/2-B'2/2]
* Psum in Loop 8: [it(8)=<1]
* Psum in Chain-Tail [9]: [it([9])=<1]

###### Computing sum for s(3)=<B/2-B'2/2  in Loop 7 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(2)=<B/2-1/2] 
 * Adding constraints: [s(3)=<it(7)*aux(2)] 

##### Pending set subtrees(A,B,C,D,E)
* Pmax/min: [aux(2)=<B/2-1/2]
* Psum in Loop 8: [it(8)=<1]
* Psum in Chain-Tail [9]: [it([9])=<1]

###### Computing max_min for aux(2)=<B/2-1/2  
   - Found a solution using transitive invariants 
 * Adding constraints:[aux(2)=<B/2-1/2] 

##### Pending set subtrees(A,B,C,D,E)
* Psum in Loop 8: [it(8)=<1]
* Psum in Chain-Tail [9]: [it([9])=<1]

###### Computing sum for it(8)=<1  in Loop 8 
   - Applying inductive sum strategy 
     - head Candidate: B/2-1/2 
       - Loop 7 is collaborative
       - Chain-Tail [9] is collaborative
     - tail Candidate: B/2-1/2 
       - Loop 7 is collaborative
       - Chain-Tail [9] is collaborative
 * Adding constraints: [it(8)=<B/2-1/2,it(8)=<B/2-1/2] 

##### Pending set subtrees(A,B,C,D,E)
* Psum in Chain-Tail [9]: [it([9])=<1]

###### Computing sum for it([9])=<1  in Chain-Tail [9] 
   - Applying inductive sum strategy 
     - head Candidate: B/2+1/2 
       - Loop 7 is collaborative
       - Loop 8 is collaborative
     - tail Candidate: B/2+1/2 
       - Loop 7 is collaborative
       - Loop 8 is collaborative
 * Adding constraints: [it([9])=<B/2+1/2,it([9])=<B/2+1/2] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [7,8,[9]] 

#### Simplifying cost structure of phase [7,8,[9]] 
 * Joined equivalent variables [aux(3),aux(2)] into aux(3)
 * Joined equivalent variables [aux(4),aux(1)] into aux(4)

#### Cost of phase [7,8]:subtrees(A,B,C,D,E) -> [] 
10*it(7)+10*it(8)+3*it([9])+5*s(3)+0
  Such that:it([9]) =< B/2+1/2
aux(3) =< B/2
aux(4) =< B/3
it(8) =< aux(3)
it(7) =< aux(4)
it(7) =< it([9])* (1/3)+aux(4)
it(8) =< it([9])* (1/3)+aux(4)
s(3) =< it(7)*aux(3)

#### Cost of chains of subtrees(A,B,C,D,E):
* Chain [9]: 3
  with precondition: [B=1,C=1,E=0] 

* Chain [multiple([7,8],[[9]])]: 10*it(7)+10*it(8)+3*it([9])+5*s(3)+0
  Such that:it([9]) =< B/2+1/2
aux(3) =< B/2
aux(4) =< B/3
it(8) =< aux(3)
it(7) =< aux(4)
it(7) =< it([9])* (1/3)+aux(4)
it(8) =< it([9])* (1/3)+aux(4)
s(3) =< it(7)*aux(3)

  with precondition: [B+1=2*C,B>=3,2*E+53>=9*B,2*E+23>=7*B,2*E+9>=5*B] 


Closed-form bounds of append(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O): 
-------------------------------------
* Chain [[5],6] with precondition: [A=D,A+F=K+1,C+H=M,A+I=N+1,E+J=O,A>=2,C+1>=A,E+1>=A,K>=A,N>=A] 
    - Upper bound: 5*A+2 
    - Complexity: n 
* Chain [6] with precondition: [A=1,C=0,D=1,E=0,K=F,L=G,M=H,N=I,O=J] 
    - Upper bound: 2 
    - Complexity: constant 

### Maximum cost of append(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O): 5*A+2 
Asymptotic class: n 

Closed-form bounds of subtrees(A,B,C,D,E): 
-------------------------------------
* Chain [9] with precondition: [B=1,C=1,E=0] 
    - Upper bound: 3 
    - Complexity: constant 
* Chain [multiple([7,8],[[9]])] with precondition: [B+1=2*C,B>=3,2*E+53>=9*B,2*E+23>=7*B,2*E+9>=5*B] 
    - Upper bound: 13/2*B+3/2+B/3* (5/2*B)+10/3*B 
    - Complexity: n^2 

### Maximum cost of subtrees(A,B,C,D,E): max([3,13/2*B+3/2+B/3* (5/2*B)+10/3*B]) 
Asymptotic class: n^2 
* Total analysis performed in 837 ms.


Cost relation system solved by CoFloCo in 841 ms.

Method append terminates?: YES

 - l1_1: size of l1 wrt. List<Tree>
 - l1_2: size of l1 wrt. Rat
 - l1_3: size of l1 wrt. Tree
 - l1_4: size of l1 wrt. List<A>
 - l1_5: size of l1 wrt. A
 - l2_1: size of l2 wrt. List<Tree>
 - l2_2: size of l2 wrt. Rat
 - l2_3: size of l2 wrt. Tree
 - l2_4: size of l2 wrt. List<A>
 - l2_5: size of l2 wrt. A
UB for append(l1_1,l1_2,l1_3,l1_4,l1_5,l2_1,l2_2,l2_3,l2_4,l2_5) = 5*l1_1+2

Method subtrees terminates?: YES

 - t_1: size of t wrt. Rat
 - t_2: size of t wrt. Tree
UB for subtrees(t_1,t_2) = max([3,13/2*t_2+3/2+t_2/3* (5/2*t_2)+10/3*t_2])
