
Abs program loaded in 5 ms.

Rule based representation generated in 2 ms.

Rule based representation stored in /tmp/costabs/rbr.rbr

RBR properties stored in /tmp/costabs/rbr.properties

Class invariants generated and loaded in 0 ms.

Abstract compilation performed in 13 ms.

Cost relation system stored in /tmp/costabs/crs.crs

Generated 45 equations 
entry('msplit'(A,B,C,D,E):[]).
entry('merge'(A,B,C,D,E,F):[]).
entry('mergesortBuggy'(A,B,C,D):[]).
entry('mergesort'(A,B,C,D):[]).
input_output_vars('and_op'(A,B,C),[A,B],[C]).
input_output_vars('case_0'(A,B,C,D,E),[A,B],[C,D,E]).
input_output_vars('case_1'(A,B,C,D,E,F,G,H),[A,B,C,D,E],[F,G,H]).
input_output_vars('case_10'(A,B,C,D,E,F,G,H,I,J,K,L,M),[A,B,C,D,E,F,G,H,I,J,K],[L,M]).
input_output_vars('case_2'(A,B,C,D,E,F,G,H,I,J,K,L,M,N),[A,B,C,D,E,F,G,H,I,J,K],[L,M,N]).
input_output_vars('case_3'(A,B,C,D,E,F),[A,B,C,D],[E,F]).
input_output_vars('case_4'(A,B,C,D,E,F,G,H,I),[A,B,C,D,E,F,G],[H,I]).
input_output_vars('case_5'(A,B,C,D,E,F,G,H,I,J,K,L),[A,B,C,D,E,F,G,H,I,J],[K,L]).
input_output_vars('case_6'(A,B,C,D),[A,B],[C,D]).
input_output_vars('case_7'(A,B,C,D,E,F,G,H,I,J),[A,B,C,D,E,F,G,H],[I,J]).
input_output_vars('case_8'(A,B,C,D),[A,B],[C,D]).
input_output_vars('case_9'(A,B,C,D,E,F,G),[A,B,C,D,E],[F,G]).
input_output_vars('eq'(A,B,C),[A,B],[C]).
input_output_vars('geq'(A,B,C),[A,B],[C]).
input_output_vars('gt'(A,B,C),[A,B],[C]).
input_output_vars('leq'(A,B,C),[A,B],[C]).
input_output_vars('lt'(A,B,C),[A,B],[C]).
input_output_vars('maxNorm'(A,B,C),[A,B],[C]).
input_output_vars('merge'(A,B,C,D,E,F),[A,B,C,D],[E,F]).
input_output_vars('mergesort'(A,B,C,D),[A,B],[C,D]).
input_output_vars('mergesortBuggy'(A,B,C,D),[A,B],[C,D]).
input_output_vars('msplit'(A,B,C,D,E),[A,B],[C,D,E]).
input_output_vars('neg'(A,B),[A],[B]).
input_output_vars('neq'(A,B,C),[A,B],[C]).
input_output_vars('or'(A,B,C),[A,B],[C]).
eq('eq',[A,B,C],0,[],[A=B,C=1,A>=0,B>=0,C>=0]).
eq('eq',[A,B,C],0,[],[A>=B+1,C=0,A>=0,B>=0,C>=0]).
eq('eq',[A,B,C],0,[],[B>=A+1,C=0,A>=0,B>=0,C>=0]).
eq('neq',[A,B,C],0,[],[A=B,C=0,A>=0,B>=0,C>=0]).
eq('neq',[A,B,C],0,[],[A>=B+1,C=1,A>=0,B>=0,C>=0]).
eq('neq',[A,B,C],0,[],[B>=A+1,C=1,A>=0,B>=0,C>=0]).
eq('lt',[A,B,C],0,[],[B-A>=1,C=1,A>=0,B>=0,C>=0]).
eq('lt',[A,B,C],0,[],[B=<A,C=0,A>=0,B>=0,C>=0]).
eq('leq',[A,B,C],0,[],[A=<B,C=1,A>=0,B>=0,C>=0]).
eq('leq',[A,B,C],0,[],[A-B>=1,C=0,A>=0,B>=0,C>=0]).
eq('gt',[A,B,C],0,[],[A-B>=1,C=1,A>=0,B>=0,C>=0]).
eq('gt',[A,B,C],0,[],[A=<B,C=0,A>=0,B>=0,C>=0]).
eq('geq',[A,B,C],0,[],[B=<A,C=1,A>=0,B>=0,C>=0]).
eq('geq',[A,B,C],0,[],[B-A>=1,C=0,A>=0,B>=0,C>=0]).
eq('neg',[A,B],0,[],[A=0,B=1,A>=0,B>=0]).
eq('neg',[A,B],0,[],[A=1,B=0,A>=0,B>=0]).
eq('and_op',[A,B,C],0,[],[A=0,C=0,A>=0,B>=0,C>=0]).
eq('and_op',[A,B,C],0,[],[A=1,C=B,A>=0,B>=0,C>=0]).
eq('or',[A,B,C],0,[],[A=1,C=1,A>=0,B>=0,C>=0]).
eq('or',[A,B,C],0,[],[A=0,C=B,A>=0,B>=0,C>=0]).
eq('maxNorm',[A,B,A],0,[],[A>=1+B,A>=0,B>=0,A>=0]).
eq('maxNorm',[A,B,B],0,[],[A=<B,A>=0,B>=0,B>=0]).
eq('case_0',[A,B,C,D,E],4,[],[A=1,F=1,G=1,E=H+I,D=F+G,C=1,G>=1,F>=1,A>=0,B>=0,C>=0,D>=0,E>=0]).
eq('case_1',[A,B,C,D,E,F,G,H],5,[],[D=1,I=1,J=C+K,L=I+1,I>=1,M=1,H=J+N,G=L+M,F=1,M>=1,L>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0]).
eq('case_2',[A,B,C,D,E,F,G,H,I,J,K,L,M,N],4,[],[C=O+P,B=Q+R,A=1,R>=1,Q>=1,S=F+O,T=Q+1,Q>=1,U=I+P,V=R+1,R>=1,N=S+U,M=T+V,L=1,V>=1,T>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0,M>=0,N>=0]).
eq('case_1',[A,B,C,D,E,F,G,H],6,['msplit'(I,J,K,L,M),'case_2'(N,O,P,A,B,C,D,E,Q,I,J,R,S,T)],[E=Q+J,D=I+1,I>=1,P=M,O=L,N=K,K>=1,H=T,G=S,F=R,R>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0]).
eq('case_0',[A,B,C,D,E],3,['case_1'(A,B,F,G,H,C,D,E)],[B=F+H,A=G+1,G>=1,A>=0,B>=0,C>=0,D>=0,E>=0]).
eq('msplit',[A,B,C,D,E],1,['case_0'(A,B,C,D,E)],[A>=0,B>=0,C>=0,D>=0,E>=0]).
eq('case_3',[A,B,C,D,C,D],1,[],[A=1,A>=0,B>=0,C>=0,D>=0,C>=0,D>=0]).
eq('case_4',[A,B,C,D,E,F,G,H,I],2,[],[C=1,I=E+G,H=F+1,F>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0]).
eq('case_5',[A,B,C,D,E,F,G,H,I,J,K,L],4,['merge'(F,G,M,N,O,P)],[H>=E+1,N=H+J,M=I+1,I>=1,L=E+P,K=O+1,O>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0]).
eq('case_5',[A,B,C,D,E,F,G,H,I,J,K,L],4,['merge'(M,N,I,J,O,P)],[E>=H,N=E+G,M=F+1,F>=1,L=H+P,K=O+1,O>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0]).
eq('case_4',[A,B,C,D,E,F,G,H,I],3,['case_5'(A,B,C,D,E,F,G,J,K,L,H,I)],[D=J+L,C=K+1,K>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0]).
eq('case_3',[A,B,C,D,E,F],3,['case_4'(A,B,C,D,G,H,I,E,F)],[B=G+I,A=H+1,H>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0]).
eq('merge',[A,B,C,D,E,F],1,['case_3'(A,B,C,D,E,F)],[A>=0,B>=0,C>=0,D>=0,E>=0,F>=0]).
eq('case_6',[A,B,C,D],2,[],[A=1,C=1,A>=0,B>=0,C>=0,D>=0]).
eq('case_7',[A,B,C,D,E,F,G,H,I,J],4,['mergesortBuggy'(K,L,M,N),'mergesortBuggy'(O,P,Q,R),'merge'(M,N,Q,R,I,J)],[C=L+P,B=K+O,A=1,O>=1,K>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0]).
eq('case_6',[A,B,C,D],6,['msplit'(A,B,E,F,G),'case_7'(H,I,J,A,B,K,L,M,N,O)],[B=K+M,A=L+1,L>=1,J=G,I=F,H=E,E>=1,D=O,C=N,N>=1,A>=0,B>=0,C>=0,D>=0]).
eq('mergesortBuggy',[A,B,C,D],1,['case_6'(A,B,C,D)],[A>=0,B>=0,C>=0,D>=0]).
eq('case_8',[A,B,C,D],2,[],[A=1,C=1,A>=0,B>=0,C>=0,D>=0]).
eq('case_9',[A,B,C,D,E,F,G],2,[],[D=1,G=C+E,F=D+1,D>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0]).
eq('case_10',[A,B,C,D,E,F,G,H,I,J,K,L,M],4,['mergesort'(N,O,P,Q),'mergesort'(R,S,T,U),'merge'(P,Q,T,U,L,M)],[C=O+S,B=N+R,A=1,R>=1,N>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0,M>=0]).
eq('case_9',[A,B,C,D,E,F,G],8,['msplit'(H,I,J,K,L),'case_10'(M,N,O,A,B,C,D,E,P,Q,R,S,T)],[E=P+R,D=Q+1,Q>=1,U=P+R,V=Q+1,Q>=1,I=C+U,H=V+1,V>=1,O=L,N=K,M=J,J>=1,G=T,F=S,S>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0]).
eq('case_8',[A,B,C,D],3,['case_9'(A,B,E,F,G,C,D)],[B=E+G,A=F+1,F>=1,A>=0,B>=0,C>=0,D>=0]).
eq('mergesort',[A,B,C,D],1,['case_8'(A,B,C,D)],[A>=0,B>=0,C>=0,D>=0]).

Preprocessing Cost Relations
=====================================

#### Computed strongly connected components 
0. recursive  : [case_3/6,case_4/9,case_5/12,merge/6]
1. non_recursive  : [case_2/14]
2. recursive [non_tail] : [case_0/5,case_1/8,msplit/5]
3. recursive [non_tail,multiple] : [case_10/13,case_8/4,case_9/7,mergesort/4]
4. recursive [non_tail,multiple] : [case_6/4,case_7/10,mergesortBuggy/4]
Warning: the following predicates are never called:[and_op/3,eq/3,geq/3,gt/3,leq/3,lt/3,maxNorm/3,neg/2,neq/3,or/3]

#### Obtained direct recursion through partial evaluation 
0. SCC is partially evaluated into merge/6
1. SCC is completely evaluated into other SCCs
2. SCC is partially evaluated into msplit/5
3. SCC is partially evaluated into mergesort/4
4. SCC is partially evaluated into mergesortBuggy/4

Control-Flow Refinement of Cost Relations
=====================================

### Specialization of cost equations merge/6 
* CE 4 is refined into CE [13] 
* CE 7 is refined into CE [14] 
* CE 6 is refined into CE [15] 
* CE 5 is refined into CE [16] 


#### Refined cost equations merge/6 
* CE 13: merge(A,B,C,D,A,B) = 6
     [D>=0,B>=0,A>=2,C=1] 
* CE 14: merge(A,B,C,D,C,D) = 2
     [D>=0,C>=0,B>=0,A=1] 
* CE 15: merge(A,B,C,D,E,F) = 11+ merge(A,B,G,H,I,J)
     [B+J>=F,F>=J,I>=1,H>=0,G>=1,F>=0,A>=2,D+J=F+H,I+1=E,G+1=C] 
* CE 16: merge(A,B,C,D,E,F) = 11+ merge(G,H,C,D,I,J)
     [D+J>=F+1,B+J>=F,F>=J,I>=1,G>=1,F>=0,C>=2,B+J=F+H,I+1=E,G+1=A] 

### Cost equations --> "Loop" of merge/6 
* CEs [15] --> Loop 13 
* CEs [16] --> Loop 14 
* CEs [13] --> Loop 15 
* CEs [14] --> Loop 16 

#### Loops of merge/6 
* Loop 13: merge(A,B,C,D,E,F)->  merge(A,B,A',B',C',D')
                  [B+B'>=D,D>=B',B'>=0,F>=0,E>=2,C>=2,A>=2,D+D'=F+B',E=C'+1,C=A'+1] 
* Loop 14: merge(A,B,C,D,E,F)->  merge(A',B',C,D,C',D')
                  [D+B'>=B+1,B>=B',B'>=0,F>=0,E>=2,C>=2,A>=2,F+B'=B+D',E=C'+1,A=A'+1] 
* Loop 15: merge(A,B,C,D,A,B) [D>=0,B>=0,A>=2,C=1] 
* Loop 16: merge(A,B,C,D,C,D) [D>=0,C>=0,B>=0,A=1] 

### Ranking functions of CR merge(A,B,C,D,E,F) 
* RF of phase [13,14]: [A+C-3]

#### Partial ranking functions of CR merge(A,B,C,D,E,F) 
* Partial RF of phase [13,14]:
  - RF of loop [13:1]:
    C-1
  - RF of loop [14:1]:
    A-1

Discarded unfeasible chain [[13,14]]...(Non-terminating chain proved terminating)

### Resulting Chains:merge(A,B,C,D,E,F) 
* [[13,14],16]
* [[13,14],15]
* [16]
* [15]


### Merging Chains  merge/6 into  External patterns of execution 
* [[16]] --> 1 
* [[15]] --> 2 
* [[15,[13,14]]] --> 3 
* [[16,[13,14]]] --> 4 


### Specialization of cost equations msplit/5 
* CE 3 is refined into CE [17] 
* CE 2 is refined into CE [18] 
* CE 1 is refined into CE [19] 


#### Refined cost equations msplit/5 
* CE 17: msplit(A,B,C,D,E) = 14+ msplit(F,G,H,I,J)
     [E>=J,J>=0,G>=0,D>=4,A>=3,E+G=B+J,D=I+2,A=F+2,H=1,C=1] 
* CE 18: msplit(A,B,C,D,E) = 9
     [E>=0,B>=0,D=3,C=1,A=2] 
* CE 19: msplit(A,B,C,D,E) = 5
     [E>=0,B>=0,D=2,C=1,A=1] 

### Cost equations --> "Loop" of msplit/5 
* CEs [18] --> Loop 17 
* CEs [19] --> Loop 18 
* CEs [17] --> Loop 19 

#### Loops of msplit/5 
* Loop 17: msplit(A,B,C,D,E) [E>=0,B>=0,D=3,C=1,A=2] 
* Loop 18: msplit(A,B,C,D,E) [E>=0,B>=0,D=2,C=1,A=1] 
* Loop 19: msplit(A,B,C,D,E)->  msplit(A',B',C',D',E')
                  [E>=E',E'>=0,B'>=0,D>=4,A>=3,E+B'=B+E',D=D'+2,A=A'+2,C'=1,C=1] 

### Ranking functions of CR msplit(A,B,C,D,E) 
* RF of phase [19]: [A/2-1]

#### Partial ranking functions of CR msplit(A,B,C,D,E) 
* Partial RF of phase [19]:
  - RF of loop [19:1]:
    A/2-1

Discarded unfeasible chain [[19]]...(Non-terminating chain proved terminating)

### Resulting Chains:msplit(A,B,C,D,E) 
* [[19],18]
* [[19],17]
* [18]
* [17]


### Merging Chains  msplit/5 into  External patterns of execution 
* [[18]] --> 1 
* [[17]] --> 2 
* [[17,[19]],[18,[19]]] --> 3 


### Specialization of cost equations mergesort/4 
* CE 12 is refined into CE [20] 
* CE 10 is refined into CE [21] 
* CE 11 is refined into CE [22,23,24,25] 


#### Refined cost equations mergesort/4 
* CE 20: mergesort(A,B,C,B) = 6
     [B>=0,C=2,A=2] 
* CE 21: mergesort(A,B,C,D) = 3
     [D>=0,B>=0,C=1,A=1] 
* CE 22: mergesort(A,B,C,D) = 16+ msplit(E,B,F,G,H):3+ mergesort(I,J,K,L)+ mergesort(M,N,C,D)+ merge(O,L,C,D,C,D):1
     [G>=M+1,M>=1,D>=0,C>=1,L>=0,H>=0,G>=4,B>=0,H=J+N,G=I+M,G=E+1,G=A+1,K=1,O=1,F=1] 
* CE 23: mergesort(A,B,C,D) = 16+ msplit(E,B,F,G,H):3+ mergesort(I,J,C,D)+ mergesort(K,L,M,N)+ merge(C,D,O,N,C,D):2
     [G>=K+1,K>=1,D>=0,C>=2,N>=0,H>=0,G>=4,B>=0,H=J+L,G=I+K,G=E+1,G=A+1,M=1,O=1,F=1] 
* CE 24: mergesort(A,B,C,D) = 16+ msplit(E,B,F,G,H):3+ mergesort(I,J,K,L)+ mergesort(M,N,O,P)+ merge(K,L,Q,P,C,D):3
     [L+P>=D,G>=M+1,D>=L,C>=K+1,M>=1,L>=0,K>=2,H>=0,G>=4,B>=0,H=J+N,G=I+M,C+1=K+O,C+1=K+Q,G=E+1,G=A+1,F=1] 
* CE 25: mergesort(A,B,C,D) = 16+ msplit(E,B,F,G,H):3+ mergesort(I,J,K,L)+ mergesort(M,N,O,P)+ merge(K,L,Q,P,C,D):4
     [L+P>=D,G>=M+1,D>=P,C>=K+1,M>=1,P>=0,K>=2,H>=0,G>=4,B>=0,H=J+N,G=I+M,C+1=K+O,C+1=K+Q,G=E+1,G=A+1,F=1] 

### Cost equations --> "Loop" of mergesort/4 
* CEs [25] --> Loop 20 
* CEs [24] --> Loop 21 
* CEs [23] --> Loop 22 
* CEs [22] --> Loop 23 
* CEs [20] --> Loop 24 
* CEs [21] --> Loop 25 

#### Loops of mergesort/4 
* Loop 20: mergesort(A,B,C,D)->  mergesort(A',B',C',D')  mergesort(A'2,B'2,C'2,D'2)
                  [D'+D'2>=D,B'+B'2>=0,D>=D'2,C>=C'+1,A>=A',D'2>=0,C'>=2,A'>=1,B>=0,A>=3,A+1=A'+A'2,C'+C'2=C+1] 
* Loop 21: mergesort(A,B,C,D)->  mergesort(A',B',C',D')  mergesort(A'2,B'2,C'2,D'2)
                  [D'+D'2>=D,B'+B'2>=0,D>=D',C>=C'+1,A>=A',D'>=0,C'>=2,A'>=1,B>=0,A>=3,A+1=A'+A'2,C'+C'2=C+1] 
* Loop 22: mergesort(A,B,C,D)->  mergesort(A',B',C,D)  mergesort(A'2,B'2,C'2,D'2)
                  [B'+B'2>=0,A>=A',D'2>=0,A'>=1,D>=0,C>=2,B>=0,A>=3,A+1=A'+A'2,C'2=1] 
* Loop 23: mergesort(A,B,C,D)->  mergesort(A',B',C',D')  mergesort(A'2,B'2,C,D)
                  [B'+B'2>=0,A>=A',D'>=0,A'>=1,D>=0,C>=1,B>=0,A>=3,A+1=A'+A'2,C'=1] 
* Loop 24: mergesort(A,B,C,B) [B>=0,C=2,A=2] 
* Loop 25: mergesort(A,B,C,D) [D>=0,B>=0,C=1,A=1] 

### Ranking functions of CR mergesort(A,B,C,D) 

#### Partial ranking functions of CR mergesort(A,B,C,D) 


### Resulting Chains:mergesort(A,B,C,D) 
* [multiple([20,21,22,23],[[],[25],[24]])]...
* [25]
* [24]


### Merging Chains  mergesort/4 into  External patterns of execution 
* [[25]] --> 1 
* [[24]] --> 2 
* [[multiple([20,21,22,23],[[],[25],[24]])]] --> 3 


### Specialization of cost equations mergesortBuggy/4 
* CE 9 is refined into CE [26,27,28,29,30,31,32,33] 
* CE 8 is refined into CE [34] 


#### Refined cost equations mergesortBuggy/4 
* CE 26: mergesortBuggy(A,B,C,D) = 11+ msplit(E,B,F,G,H):2+ mergesortBuggy(I,J,K,L)+ mergesortBuggy(M,N,C,D)+ merge(O,L,C,D,C,D):1
     [M>=1,D>=0,C>=1,L>=0,H>=0,B>=0,2>=M,H=J+N,I+M=3,K=1,O=1,G=3,F=1,E=2,A=2] 
* CE 27: mergesortBuggy(A,B,C,D) = 11+ msplit(E,B,F,G,H):2+ mergesortBuggy(I,J,C,D)+ mergesortBuggy(K,L,M,N)+ merge(C,D,O,N,C,D):2
     [K>=1,D>=0,C>=2,N>=0,H>=0,B>=0,2>=K,H=J+L,I+K=3,M=1,O=1,G=3,F=1,E=2,A=2] 
* CE 28: mergesortBuggy(A,B,C,D) = 11+ msplit(E,B,F,G,H):2+ mergesortBuggy(I,J,K,L)+ mergesortBuggy(M,N,O,P)+ merge(K,L,Q,P,C,D):3
     [L+P>=D,D>=L,C>=K+1,M>=1,L>=0,K>=2,H>=0,B>=0,2>=M,H=J+N,C+1=K+O,C+1=K+Q,I+M=3,G=3,F=1,E=2,A=2] 
* CE 29: mergesortBuggy(A,B,C,D) = 11+ msplit(E,B,F,G,H):2+ mergesortBuggy(I,J,K,L)+ mergesortBuggy(M,N,O,P)+ merge(K,L,Q,P,C,D):4
     [L+P>=D,D>=P,C>=K+1,M>=1,P>=0,K>=2,H>=0,B>=0,2>=M,H=J+N,C+1=K+O,C+1=K+Q,I+M=3,G=3,F=1,E=2,A=2] 
* CE 30: mergesortBuggy(A,B,C,D) = 11+ msplit(E,B,F,G,H):3+ mergesortBuggy(I,J,K,L)+ mergesortBuggy(M,N,C,D)+ merge(O,L,C,D,C,D):1
     [G>=M+1,M>=1,D>=0,C>=1,L>=0,H>=0,G>=4,B>=0,H=J+N,G=I+M,G=E+1,G=A+1,K=1,O=1,F=1] 
* CE 31: mergesortBuggy(A,B,C,D) = 11+ msplit(E,B,F,G,H):3+ mergesortBuggy(I,J,C,D)+ mergesortBuggy(K,L,M,N)+ merge(C,D,O,N,C,D):2
     [G>=K+1,K>=1,D>=0,C>=2,N>=0,H>=0,G>=4,B>=0,H=J+L,G=I+K,G=E+1,G=A+1,M=1,O=1,F=1] 
* CE 32: mergesortBuggy(A,B,C,D) = 11+ msplit(E,B,F,G,H):3+ mergesortBuggy(I,J,K,L)+ mergesortBuggy(M,N,O,P)+ merge(K,L,Q,P,C,D):3
     [L+P>=D,G>=M+1,D>=L,C>=K+1,M>=1,L>=0,K>=2,H>=0,G>=4,B>=0,H=J+N,G=I+M,C+1=K+O,C+1=K+Q,G=E+1,G=A+1,F=1] 
* CE 33: mergesortBuggy(A,B,C,D) = 11+ msplit(E,B,F,G,H):3+ mergesortBuggy(I,J,K,L)+ mergesortBuggy(M,N,O,P)+ merge(K,L,Q,P,C,D):4
     [L+P>=D,G>=M+1,D>=P,C>=K+1,M>=1,P>=0,K>=2,H>=0,G>=4,B>=0,H=J+N,G=I+M,C+1=K+O,C+1=K+Q,G=E+1,G=A+1,F=1] 
* CE 34: mergesortBuggy(A,B,C,D) = 3
     [D>=0,B>=0,C=1,A=1] 

### Cost equations --> "Loop" of mergesortBuggy/4 
* CEs [34] --> Loop 26 
* CEs [33] --> Loop 27 
* CEs [32] --> Loop 28 
* CEs [31] --> Loop 29 
* CEs [30] --> Loop 30 
* CEs [29] --> Loop 31 
* CEs [28] --> Loop 32 
* CEs [27] --> Loop 33 
* CEs [26] --> Loop 34 

#### Loops of mergesortBuggy/4 
* Loop 26: mergesortBuggy(A,B,C,D) [D>=0,B>=0,C=1,A=1] 
* Loop 27: mergesortBuggy(A,B,C,D)->  mergesortBuggy(A',B',C',D')  mergesortBuggy(A'2,B'2,C'2,D'2)
                  [D'+D'2>=D,B'+B'2>=0,D>=D'2,C>=C'+1,A>=A',D'2>=0,C'>=2,A'>=1,B>=0,A>=3,A+1=A'+A'2,C'+C'2=C+1] 
* Loop 28: mergesortBuggy(A,B,C,D)->  mergesortBuggy(A',B',C',D')  mergesortBuggy(A'2,B'2,C'2,D'2)
                  [D'+D'2>=D,B'+B'2>=0,D>=D',C>=C'+1,A>=A',D'>=0,C'>=2,A'>=1,B>=0,A>=3,A+1=A'+A'2,C'+C'2=C+1] 
* Loop 29: mergesortBuggy(A,B,C,D)->  mergesortBuggy(A',B',C,D)  mergesortBuggy(A'2,B'2,C'2,D'2)
                  [B'+B'2>=0,A>=A',D'2>=0,A'>=1,D>=0,C>=2,B>=0,A>=3,A+1=A'+A'2,C'2=1] 
* Loop 30: mergesortBuggy(A,B,C,D)->  mergesortBuggy(A',B',C',D')  mergesortBuggy(A'2,B'2,C,D)
                  [B'+B'2>=0,A>=A',D'>=0,A'>=1,D>=0,C>=1,B>=0,A>=3,A+1=A'+A'2,C'=1] 
* Loop 31: mergesortBuggy(A,B,C,D)->  mergesortBuggy(A',B',C',D')  mergesortBuggy(A'2,B'2,C'2,D'2)
                  [D'+D'2>=D,B'+B'2>=0,D>=D'2,C>=C'+1,D'2>=0,C'>=2,A'>=1,B>=0,2>=A',C'+C'2=C+1,A'+A'2=3,A=2] 
* Loop 32: mergesortBuggy(A,B,C,D)->  mergesortBuggy(A',B',C',D')  mergesortBuggy(A'2,B'2,C'2,D'2)
                  [D'+D'2>=D,B'+B'2>=0,D>=D',C>=C'+1,D'>=0,C'>=2,A'>=1,B>=0,2>=A',C'+C'2=C+1,A'+A'2=3,A=2] 
* Loop 33: mergesortBuggy(A,B,C,D)->  mergesortBuggy(A',B',C,D)  mergesortBuggy(A'2,B'2,C'2,D'2)
                  [B'+B'2>=0,D'2>=0,A'>=1,D>=0,C>=2,B>=0,2>=A',A'+A'2=3,C'2=1,A=2] 
* Loop 34: mergesortBuggy(A,B,C,D)->  mergesortBuggy(A',B',C',D')  mergesortBuggy(A'2,B'2,C,D)
                  [B'+B'2>=0,D'>=0,A'>=1,D>=0,C>=1,B>=0,2>=A',A'+A'2=3,C'=1,A=2] 

### Ranking functions of CR mergesortBuggy(A,B,C,D) 

#### Partial ranking functions of CR mergesortBuggy(A,B,C,D) 


### Resulting Chains:mergesortBuggy(A,B,C,D) 
* [multiple([31,32,33,34],[[],[26]])]...
* [multiple([27,28,29,30],[[],[multiple([31,32,33,34],[[],[26]])],[26]])]...
* [26]


### Merging Chains  mergesortBuggy/4 into  External patterns of execution 
* [[26]] --> 1 
* [[multiple([31,32,33,34],[[],[26]])]] --> 2 
* [[multiple([27,28,29,30],[[],[multiple([31,32,33,34],[[],[26]])],[26]])]] --> 3 


Computing Bounds
=====================================

#### Simplifying cost structure of CE 14 

#### Computing cost of phase [13,14] 

#### Simplifying cost structure of CE 15 

#### Simplifying cost structure of CE 16 

#### Cost of loops [13,14] 

 * loop 13:merge(A,B,C,D,E,F) -> [merge(A',B',C',D',E',F')] 
11
 * loop 14:merge(A,B,C,D,E,F) -> [merge(A',B',C',D',E',F')] 
11
##### Pending set merge(A,B,C,D,E,F)
* Psum in Loop 13: [it(13)=<1]
* Psum in Loop 14: [it(14)=<1]

###### Computing sum for it(13)=<1  in Loop 13 
   - Applying inductive sum strategy 
     - head Candidate: A+C-3 
       - Loop 14 is collaborative and bounds [it(14)] 
     - head Candidate: C-1 
       - Loop 14 is collaborative
     - tail Candidate: A+C-3 
       - Loop 14 is collaborative and bounds [it(14)] 
     - tail Candidate: C-1 
       - Loop 14 is collaborative
 * Adding constraints: [it(13)+it(14)=<A+C-3,it(13)=<C-1,it(13)+it(14)=<A+C-A'-C',it(13)=<C-C'] 

##### Pending set A
* Psum in Loop 14: [it(14)=<1]

###### Computing sum for it(14)=<1  in Loop 14 
   - Applying inductive sum strategy 
     - head Candidate: A+C-3 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A-1 
       - Loop 13 is collaborative
     - tail Candidate: A+C-3 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
       - Loop 13 is collaborative
 * Adding constraints: [it(13)+it(14)=<A+C-3,it(14)=<A-1,it(13)+it(14)=<A+C-A'-C',it(14)=<A-A'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [13,14] 

#### Simplifying cost structure of phase [13,14] 

#### Cost of phase [13,14]:merge(A,B,C,D,E,F) -> [merge(A',B',C',D',E',F')] 
11*it(13)+11*it(14)+0
  Such that:it(14) =< A
it(14) =< A-A'
it(13) =< C
it(13) =< C-C'
aux(1) =< A+C
aux(2) =< A+C-A'-C'
it(13) =< aux(1)
it(14) =< aux(1)
it(13) =< aux(2)
it(14) =< aux(2)

#### Simplifying cost structure of chain [[13,14],16] 

#### Simplifying cost structure of CE 13 

#### Found solution for phase  [13,14] in the cache 

#### Cost of phase [13,14]:merge(A,B,C,D,E,F) -> [merge(A',B',C',D',E',F')] 
11*it(13)+11*it(14)+0
  Such that:it(14) =< A
it(14) =< A-A'
it(13) =< C
it(13) =< C-C'
aux(1) =< A+C
aux(2) =< A+C-A'-C'
it(13) =< aux(1)
it(14) =< aux(1)
it(13) =< aux(2)
it(14) =< aux(2)

#### Simplifying cost structure of chain [[13,14],15] 
 * Joined equivalent variables [aux(3),aux(1),aux(2)] into aux(3)

#### Cost of chains of merge(A,B,C,D,E,F):
* Chain [[13,14],16]: 11*it(13)+11*it(14)+2
  Such that:it(13) =< -A+E
it(14) =< A
aux(2) =< E
aux(1) =< E+1
it(13) =< aux(1)
it(14) =< aux(1)
it(13) =< aux(2)
it(14) =< aux(2)

  with precondition: [A+C=E+1,A>=2,C>=2,D>=0,F>=D,B+D>=F] 

* Chain [[13,14],15]: 11*it(13)+11*it(14)+6
  Such that:it(14) =< A
it(13) =< C
aux(3) =< A+C
it(13) =< aux(3)
it(14) =< aux(3)

  with precondition: [A+C=E+1,A>=2,B>=0,C>=2,F>=B,B+D>=F] 

* Chain [16]: 2
  with precondition: [A=1,C=E,D=F,B>=0,C>=0,D>=0] 

* Chain [15]: 6
  with precondition: [C=1,A=E,B=F,A>=2,B>=0,D>=0] 


#### Simplifying cost structure of CE 19 

#### Computing cost of phase [19] 

#### Simplifying cost structure of CE 17 

#### Cost of loops [19] 

 * loop 19:msplit(A,B,C,D,E) -> [msplit(A',B',C',D',E')] 
14
##### Pending set msplit(A,B,C,D,E)
* Psum in Loop 19: [it(19)=<1]

###### Computing sum for it(19)=<1  in Loop 19 
   - Applying inductive sum strategy 
     - head Candidate: A/2-1 
     - head Candidate: A/2-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A/2-1 
     - tail Candidate: A/2-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(19)=<A/2-1,it(19)=<A/2-1,it(19)=<A/2-A'/2,it(19)=<A/2-A'/2] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [19] 

#### Simplifying cost structure of phase [19] 

#### Cost of phase [19]:msplit(A,B,C,D,E) -> [msplit(A',B',C',D',E')] 
14*it(19)+0
  Such that:it(19) =< A/2
it(19) =< A/2-A'/2

#### Simplifying cost structure of chain [[19],18] 

#### Simplifying cost structure of CE 18 

#### Found solution for phase  [19] in the cache 

#### Cost of phase [19]:msplit(A,B,C,D,E) -> [msplit(A',B',C',D',E')] 
14*it(19)+0
  Such that:it(19) =< A/2
it(19) =< A/2-A'/2

#### Simplifying cost structure of chain [[19],17] 
 * Renamed intermediate variables: 
[ (ch([[19],17]),it(19))>>s(1)]
 * Renamed intermediate variables: 
[ (ch([[19],18]),it(19))>>s(2)]
 * Joined equivalent variables [s(1),s(2)] into s(1)

#### Cost of chains of msplit(A,B,C,D,E):
* Chain [[19],18]: 14*it(19)+5
  Such that:it(19) =< D/2

  with precondition: [C=1,A+1=D,A>=3,B>=0,E>=0] 

* Chain [[19],17]: 14*it(19)+9
  Such that:it(19) =< D/2

  with precondition: [C=1,A+1=D,A>=4,B>=0,E>=0] 

* Chain [18]: 5
  with precondition: [A=1,C=1,D=2,B>=0,E>=0] 

* Chain [17]: 9
  with precondition: [A=2,C=1,D=3,B>=0,E>=0] 


#### Simplifying cost structure of CE 21 

#### Simplifying cost structure of CE 20 

#### Computing cost of chain [multiple([20,21,22,23],[[],[25],[24]])] with multiple recursion
 * Renamed intermediate variables: 
[ (eq(25,1),aux(4))>>s(3), (eq(25,1),s(1))>>s(4)]
 * Renamed intermediate variables: 
[ (eq(25,2),it(13))>>s(5), (eq(25,2),it(14))>>s(6), (eq(25,2),aux(2))>>s(7), (eq(25,2),aux(1))>>s(8)]

#### Simplifying cost structure of CE 25 
 * Joined equivalent variables [s(5),s(6)] into s(5)
 * Renamed intermediate variables: 
[ (it(20),s(3))>>s(9), (it(20),s(4))>>s(10), (it(20),s(5))>>s(11)]
 * Renamed intermediate variables: 
[ (eq(24,1),aux(4))>>s(12), (eq(24,1),s(1))>>s(13)]
 * Renamed intermediate variables: 
[ (eq(24,2),it(14))>>s(14), (eq(24,2),it(13))>>s(15), (eq(24,2),aux(3))>>s(16)]

#### Simplifying cost structure of CE 24 
 * Joined equivalent variables [s(14),s(15)] into s(14)
 * Renamed intermediate variables: 
[ (it(21),s(12))>>s(17), (it(21),s(13))>>s(18), (it(21),s(14))>>s(19)]
 * Renamed intermediate variables: 
[ (eq(23,1),aux(4))>>s(20), (eq(23,1),s(1))>>s(21)]

#### Simplifying cost structure of CE 23 
 * Renamed intermediate variables: 
[ (it(22),s(20))>>s(22), (it(22),s(21))>>s(23)]
 * Renamed intermediate variables: 
[ (eq(22,1),aux(4))>>s(24), (eq(22,1),s(1))>>s(25)]

#### Simplifying cost structure of CE 22 
 * Renamed intermediate variables: 
[ (it(23),s(24))>>s(26), (it(23),s(25))>>s(27)]

#### Cost of loops [20,21,22,23] 

 * loop 20:mergesort(A,B,C,D) -> [mergesort(A',B',C',D'),mergesort(A'2,B'2,C'2,D'2)] 
28*s(10)+22*s(11)+27
  Such that:s(9) =< A'/2+A'2/2
s(10) =< s(9)

Unbounded itvars
s(11) :  it(20),s(5)

 * loop 21:mergesort(A,B,C,D) -> [mergesort(A',B',C',D'),mergesort(A'2,B'2,C'2,D'2)] 
28*s(18)+22*s(19)+31
  Such that:s(17) =< A'/2+A'2/2
s(18) =< s(17)

Unbounded itvars
s(19) :  it(21),s(14)

 * loop 22:mergesort(A,B,C,D) -> [mergesort(A',B',C',D'),mergesort(A'2,B'2,C'2,D'2)] 
28*s(23)+31
  Such that:s(22) =< A'/2+A'2/2
s(23) =< s(22)

 * loop 23:mergesort(A,B,C,D) -> [mergesort(A',B',C',D'),mergesort(A'2,B'2,C'2,D'2)] 
28*s(27)+27
  Such that:s(26) =< A'/2+A'2/2
s(27) =< s(26)

##### Pending set mergesort(A,B,C,D)
* Psum in Loop 20: [it(20)=<1,s(30)=<A'/2+A'2/2]
* Psum in Loop 21: [it(21)=<1,s(33)=<A'/2+A'2/2]
* Psum in Loop 22: [it(22)=<1,s(35)=<A'/2+A'2/2]
* Psum in Loop 23: [it(23)=<1,s(37)=<A'/2+A'2/2]
* Psum in Chain-Tail [24]: [it([24])=<1]
* Psum in Chain-Tail [25]: [it([25])=<1]

###### Computing sum for it(20)=<1  in Loop 20 
   - Applying inductive sum strategy 
     - head Candidate: A-2 
       - Loop 21 is collaborative and bounds [it(21)] 
       - Loop 22 is collaborative and bounds [it(22)] 
       - Loop 23 is collaborative and bounds [it(23)] 
       - Chain [25] is ignored
       - Chain-Tail [24] is collaborative
 * Adding constraints: [it(20)+it(21)+it(22)+it(23)=<A-2] 

##### Pending set A
* Psum in Loop 20: [s(30)=<A'/2+A'2/2]
* Psum in Loop 21: [s(33)=<A'/2+A'2/2]
* Psum in Loop 22: [s(35)=<A'/2+A'2/2]
* Psum in Loop 23: [s(37)=<A'/2+A'2/2]
* Psum in Chain-Tail [24]: [it([24])=<1]
* Psum in Chain-Tail [25]: [it([25])=<1]

###### Computing sum for s(30)=<A'/2+A'2/2  in Loop 20 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(5)=<A/2+1/2] 
 * Adding constraints: [s(30)=<it(20)*aux(5)] 

##### Pending set mergesort(A,B,C,D)
* Pmax/min: [aux(5)=<A/2+1/2]
* Psum in Loop 21: [s(33)=<A'/2+A'2/2]
* Psum in Loop 22: [s(35)=<A'/2+A'2/2]
* Psum in Loop 23: [s(37)=<A'/2+A'2/2]
* Psum in Chain-Tail [24]: [it([24])=<1]
* Psum in Chain-Tail [25]: [it([25])=<1]

###### Computing max_min for aux(5)=<A/2+1/2  
   - Found a solution using transitive invariants 
 * Adding constraints:[aux(5)=<A/2+1/2] 

##### Pending set mergesort(A,B,C,D)
* Psum in Loop 21: [s(33)=<A'/2+A'2/2]
* Psum in Loop 22: [s(35)=<A'/2+A'2/2]
* Psum in Loop 23: [s(37)=<A'/2+A'2/2]
* Psum in Chain-Tail [24]: [it([24])=<1]
* Psum in Chain-Tail [25]: [it([25])=<1]

###### Computing sum for s(33)=<A'/2+A'2/2  in Loop 21 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(6)=<A/2+1/2] 
 * Adding constraints: [s(33)=<it(21)*aux(6)] 

##### Pending set mergesort(A,B,C,D)
* Pmax/min: [aux(6)=<A/2+1/2]
* Psum in Loop 22: [s(35)=<A'/2+A'2/2]
* Psum in Loop 23: [s(37)=<A'/2+A'2/2]
* Psum in Chain-Tail [24]: [it([24])=<1]
* Psum in Chain-Tail [25]: [it([25])=<1]

###### Computing max_min for aux(6)=<A/2+1/2  
   - Found a solution using cacheing 
 * Adding constraints:[aux(6)=<aux(5)] 

##### Pending set mergesort(A,B,C,D)
* Psum in Loop 22: [s(35)=<A'/2+A'2/2]
* Psum in Loop 23: [s(37)=<A'/2+A'2/2]
* Psum in Chain-Tail [24]: [it([24])=<1]
* Psum in Chain-Tail [25]: [it([25])=<1]

###### Computing sum for s(35)=<A'/2+A'2/2  in Loop 22 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(7)=<A/2+1/2] 
 * Adding constraints: [s(35)=<it(22)*aux(7)] 

##### Pending set mergesort(A,B,C,D)
* Pmax/min: [aux(7)=<A/2+1/2]
* Psum in Loop 23: [s(37)=<A'/2+A'2/2]
* Psum in Chain-Tail [24]: [it([24])=<1]
* Psum in Chain-Tail [25]: [it([25])=<1]

###### Computing max_min for aux(7)=<A/2+1/2  
   - Found a solution using cacheing 
 * Adding constraints:[aux(7)=<aux(5)] 

##### Pending set mergesort(A,B,C,D)
* Psum in Loop 23: [s(37)=<A'/2+A'2/2]
* Psum in Chain-Tail [24]: [it([24])=<1]
* Psum in Chain-Tail [25]: [it([25])=<1]

###### Computing sum for s(37)=<A'/2+A'2/2  in Loop 23 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(8)=<A/2+1/2] 
 * Adding constraints: [s(37)=<it(23)*aux(8)] 

##### Pending set mergesort(A,B,C,D)
* Pmax/min: [aux(8)=<A/2+1/2]
* Psum in Chain-Tail [24]: [it([24])=<1]
* Psum in Chain-Tail [25]: [it([25])=<1]

###### Computing max_min for aux(8)=<A/2+1/2  
   - Found a solution using cacheing 
 * Adding constraints:[aux(8)=<aux(5)] 

##### Pending set mergesort(A,B,C,D)
* Psum in Chain-Tail [24]: [it([24])=<1]
* Psum in Chain-Tail [25]: [it([25])=<1]

###### Computing sum for it([24])=<1  in Chain-Tail [24] 
   - Applying inductive sum strategy 
     - head Candidate: A-1 
       - Loop 20 is collaborative
       - Loop 21 is collaborative
       - Loop 22 is collaborative
       - Loop 23 is collaborative
       - Chain-Tail [25] is collaborative
 * Adding constraints: [it([24])=<A-1] 

##### Pending set mergesort(A,B,C,D)
* Psum in Chain-Tail [25]: [it([25])=<1]

###### Computing sum for it([25])=<1  in Chain-Tail [25] 
   - Applying inductive sum strategy 
     - head Candidate: 1 
       - Loop 20 adds a constant 1/1 
       - Loop 21 adds a constant 1/1 
       - Loop 22 adds a constant 1/1 
       - Loop 23 adds a constant 1/1 
       - Chain-Tail [24] is collaborative
 * Adding constraints: [it([25])=<it(23)+it(22)+it(21)+it(20)+aux(9),aux(9)=<1] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [20,21,22,23,[25],[24]] 

#### Simplifying cost structure of phase [20,21,22,23,[25],[24]] 
 * Joined equivalent variables [aux(6),aux(7),aux(8)] into aux(6)
 * Joined equivalent variables [s(29),s(32)] into s(29)
 * Joined equivalent variables [it(20),it(21),it(22),it(23),it([24])] into it(20)
 * Joined equivalent variables [s(33),s(35),s(37)] into s(33)
 * Joined equivalent variables [s(31),s(34),s(36)] into s(31)

#### Cost of phase [20,21,22,23]:mergesort(A,B,C,D) -> [] 
122*it(20)+3*it([25])+28*s(28)+44*s(29)+84*s(31)+0
  Such that:aux(9) =< 1
aux(5) =< A/2+1/2
aux(10) =< A
it(20) =< aux(10)
aux(6) =< aux(5)
it([25]) =< it(20)+it(20)+it(20)+it(20)+aux(9)
s(30) =< it(20)*aux(5)
s(33) =< it(20)*aux(6)
s(31) =< s(33)
s(28) =< s(30)

Unbounded itvars
s(29) :  sum(20),s(11)

#### Cost of chains of mergesort(A,B,C,D):
* Chain [multiple([20,21,22,23],[[],[25],[24]])]...: 122*it(20)+3*it([25])+28*s(28)+44*s(29)+84*s(31)+0
  Such that:aux(9) =< 1
aux(5) =< A/2+1/2
aux(10) =< A
it(20) =< aux(10)
aux(6) =< aux(5)
it([25]) =< it(20)+it(20)+it(20)+it(20)+aux(9)
s(30) =< it(20)*aux(5)
s(33) =< it(20)*aux(6)
s(31) =< s(33)
s(28) =< s(30)

Unbounded itvars
s(29) :  sum(20),s(11)

  with precondition: [A>=3,B>=0,C>=1,D>=0] 

* Chain [25]: 3
  with precondition: [A=1,C=1,B>=0,D>=0] 

* Chain [24]: 6
  with precondition: [A=2,C=2,B=D,B>=0] 


#### Simplifying cost structure of CE 34 

#### Computing cost of chain [multiple([31,32,33,34],[[],[26]])] with multiple recursion
 * Renamed intermediate variables: 
[ (eq(29,2),it(13))>>s(38), (eq(29,2),it(14))>>s(39), (eq(29,2),aux(2))>>s(40), (eq(29,2),aux(1))>>s(41)]

#### Simplifying cost structure of CE 29 
 * Joined equivalent variables [s(38),s(39)] into s(38)
 * Renamed intermediate variables: 
[ (it(31),s(38))>>s(42)]
 * Renamed intermediate variables: 
[ (eq(28,2),it(14))>>s(43), (eq(28,2),it(13))>>s(44), (eq(28,2),aux(3))>>s(45)]

#### Simplifying cost structure of CE 28 
 * Joined equivalent variables [s(43),s(44)] into s(43)
 * Renamed intermediate variables: 
[ (it(32),s(43))>>s(46)]

#### Simplifying cost structure of CE 27 

#### Simplifying cost structure of CE 26 

#### Cost of loops [31,32,33,34] 

 * loop 31:mergesortBuggy(A,B,C,D) -> [mergesortBuggy(A',B',C',D'),mergesortBuggy(A'2,B'2,C'2,D'2)] 
22*s(42)+22
Unbounded itvars
s(42) :  it(31),s(38)

 * loop 32:mergesortBuggy(A,B,C,D) -> [mergesortBuggy(A',B',C',D'),mergesortBuggy(A'2,B'2,C'2,D'2)] 
22*s(46)+26
Unbounded itvars
s(46) :  it(32),s(43)

 * loop 33:mergesortBuggy(A,B,C,D) -> [mergesortBuggy(A',B',C',D'),mergesortBuggy(A'2,B'2,C'2,D'2)] 
26
 * loop 34:mergesortBuggy(A,B,C,D) -> [mergesortBuggy(A',B',C',D'),mergesortBuggy(A'2,B'2,C'2,D'2)] 
22
##### Pending set mergesortBuggy(A,B,C,D)
* Psum in Loop 31: [it(31)=<1]
* Psum in Loop 32: [it(32)=<1]
* Psum in Loop 33: [it(33)=<1]
* Psum in Loop 34: [it(34)=<1]
* Psum in Chain-Tail [26]: [it([26])=<1]

###### Computing sum for it(31)=<1  in Loop 31 
   - Applying inductive sum strategy 
     - head Candidate: 2*A-3 
       - Loop 32 is collaborative and bounds [it(32)] 
       - Loop 33 is collaborative and bounds [it(33)] 
       - Loop 34 is collaborative and bounds [it(34)] 
       - Chain [26] is ignored
 * Adding constraints: [it(31)+it(32)+it(33)+it(34)=<2*A-3] 

##### Pending set A
* Psum in Chain-Tail [26]: [it([26])=<1]

###### Computing sum for it([26])=<1  in Chain-Tail [26] 
   - Applying inductive sum strategy 
     - head Candidate: 1 
       - Loop 31 adds a constant 1/1 
       - Loop 32 adds a constant 1/1 
       - Loop 33 adds a constant 1/1 
       - Loop 34 adds a constant 1/1 
 * Adding constraints: [it([26])=<it(34)+it(33)+it(32)+it(31)+aux(11),aux(11)=<1] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [31,32,33,34,[26]] 

#### Simplifying cost structure of phase [31,32,33,34,[26]] 
 * Joined equivalent variables [s(47),s(48)] into s(47)
 * Joined equivalent variables [it(31),it(32),it(33),it(34)] into it(31)

#### Cost of phase [31,32,33,34]:mergesortBuggy(A,B,C,D) -> [] 
96*it(31)+3*it([26])+44*s(47)+0
  Such that:aux(11) =< 1
aux(12) =< 2*A
it(31) =< aux(12)
it([26]) =< it(31)+it(31)+it(31)+it(31)+aux(11)

Unbounded itvars
s(47) :  sum(31),s(42)

#### Computing cost of chain [multiple([27,28,29,30],[[],[multiple([31,32,33,34],[[],[26]])],[26]])] with multiple recursion
 * Renamed intermediate variables: 
[ (eq(33,1),aux(4))>>s(49), (eq(33,1),s(1))>>s(50)]
 * Renamed intermediate variables: 
[ (eq(33,2),it(13))>>s(51), (eq(33,2),it(14))>>s(52), (eq(33,2),aux(2))>>s(53), (eq(33,2),aux(1))>>s(54)]

#### Simplifying cost structure of CE 33 
 * Joined equivalent variables [s(51),s(52)] into s(51)
 * Renamed intermediate variables: 
[ (it(27),s(49))>>s(55), (it(27),s(50))>>s(56), (it(27),s(51))>>s(57)]
 * Renamed intermediate variables: 
[ (eq(32,1),aux(4))>>s(58), (eq(32,1),s(1))>>s(59)]
 * Renamed intermediate variables: 
[ (eq(32,2),it(14))>>s(60), (eq(32,2),it(13))>>s(61), (eq(32,2),aux(3))>>s(62)]

#### Simplifying cost structure of CE 32 
 * Joined equivalent variables [s(60),s(61)] into s(60)
 * Renamed intermediate variables: 
[ (it(28),s(58))>>s(63), (it(28),s(59))>>s(64), (it(28),s(60))>>s(65)]
 * Renamed intermediate variables: 
[ (eq(31,1),aux(4))>>s(66), (eq(31,1),s(1))>>s(67)]

#### Simplifying cost structure of CE 31 
 * Renamed intermediate variables: 
[ (it(29),s(66))>>s(68), (it(29),s(67))>>s(69)]
 * Renamed intermediate variables: 
[ (eq(30,1),aux(4))>>s(70), (eq(30,1),s(1))>>s(71)]

#### Simplifying cost structure of CE 30 
 * Renamed intermediate variables: 
[ (it(30),s(70))>>s(72), (it(30),s(71))>>s(73)]

#### Cost of loops [27,28,29,30] 

 * loop 27:mergesortBuggy(A,B,C,D) -> [mergesortBuggy(A',B',C',D'),mergesortBuggy(A'2,B'2,C'2,D'2)] 
28*s(56)+22*s(57)+22
  Such that:s(55) =< A'/2+A'2/2
s(56) =< s(55)

Unbounded itvars
s(57) :  it(27),s(51)

 * loop 28:mergesortBuggy(A,B,C,D) -> [mergesortBuggy(A',B',C',D'),mergesortBuggy(A'2,B'2,C'2,D'2)] 
28*s(64)+22*s(65)+26
  Such that:s(63) =< A'/2+A'2/2
s(64) =< s(63)

Unbounded itvars
s(65) :  it(28),s(60)

 * loop 29:mergesortBuggy(A,B,C,D) -> [mergesortBuggy(A',B',C',D'),mergesortBuggy(A'2,B'2,C'2,D'2)] 
28*s(69)+26
  Such that:s(68) =< A'/2+A'2/2
s(69) =< s(68)

 * loop 30:mergesortBuggy(A,B,C,D) -> [mergesortBuggy(A',B',C',D'),mergesortBuggy(A'2,B'2,C'2,D'2)] 
28*s(73)+22
  Such that:s(72) =< A'/2+A'2/2
s(73) =< s(72)

##### Pending set mergesortBuggy(A,B,C,D)
* Psum in Loop 27: [it(27)=<1,s(76)=<A'/2+A'2/2]
* Psum in Loop 28: [it(28)=<1,s(79)=<A'/2+A'2/2]
* Psum in Loop 29: [it(29)=<1,s(81)=<A'/2+A'2/2]
* Psum in Loop 30: [it(30)=<1,s(83)=<A'/2+A'2/2]
* Psum in Chain-Tail [26]: [it([26])=<1]
* Psum in Chain-Tail [multiple([31,32,33,34],[[],[26]])]: [it([multiple([31,32,33,34],[[],[26]])])=<1,s(87)=<1,s(88)=<2*A]

###### Computing sum for it(27)=<1  in Loop 27 
   - Applying inductive sum strategy 
     - head Candidate: A-2 
       - Loop 28 is collaborative and bounds [it(28)] 
       - Loop 29 is collaborative and bounds [it(29)] 
       - Loop 30 is collaborative and bounds [it(30)] 
       - Chain-Tail [multiple([31,32,33,34],[[],[26]])] is collaborative
       - Chain [26] is ignored
 * Adding constraints: [it(27)+it(28)+it(29)+it(30)=<A-2] 

##### Pending set A
* Psum in Loop 27: [s(76)=<A'/2+A'2/2]
* Psum in Loop 28: [s(79)=<A'/2+A'2/2]
* Psum in Loop 29: [s(81)=<A'/2+A'2/2]
* Psum in Loop 30: [s(83)=<A'/2+A'2/2]
* Psum in Chain-Tail [26]: [it([26])=<1]
* Psum in Chain-Tail [multiple([31,32,33,34],[[],[26]])]: [it([multiple([31,32,33,34],[[],[26]])])=<1,s(87)=<1,s(88)=<2*A]

###### Computing sum for s(76)=<A'/2+A'2/2  in Loop 27 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(13)=<A/2+1/2] 
 * Adding constraints: [s(76)=<it(27)*aux(13)] 

##### Pending set mergesortBuggy(A,B,C,D)
* Pmax/min: [aux(13)=<A/2+1/2]
* Psum in Loop 28: [s(79)=<A'/2+A'2/2]
* Psum in Loop 29: [s(81)=<A'/2+A'2/2]
* Psum in Loop 30: [s(83)=<A'/2+A'2/2]
* Psum in Chain-Tail [26]: [it([26])=<1]
* Psum in Chain-Tail [multiple([31,32,33,34],[[],[26]])]: [it([multiple([31,32,33,34],[[],[26]])])=<1,s(87)=<1,s(88)=<2*A]

###### Computing max_min for aux(13)=<A/2+1/2  
   - Found a solution using transitive invariants 
 * Adding constraints:[aux(13)=<A/2+1/2] 

##### Pending set mergesortBuggy(A,B,C,D)
* Psum in Loop 28: [s(79)=<A'/2+A'2/2]
* Psum in Loop 29: [s(81)=<A'/2+A'2/2]
* Psum in Loop 30: [s(83)=<A'/2+A'2/2]
* Psum in Chain-Tail [26]: [it([26])=<1]
* Psum in Chain-Tail [multiple([31,32,33,34],[[],[26]])]: [it([multiple([31,32,33,34],[[],[26]])])=<1,s(87)=<1,s(88)=<2*A]

###### Computing sum for s(79)=<A'/2+A'2/2  in Loop 28 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(14)=<A/2+1/2] 
 * Adding constraints: [s(79)=<it(28)*aux(14)] 

##### Pending set mergesortBuggy(A,B,C,D)
* Pmax/min: [aux(14)=<A/2+1/2]
* Psum in Loop 29: [s(81)=<A'/2+A'2/2]
* Psum in Loop 30: [s(83)=<A'/2+A'2/2]
* Psum in Chain-Tail [26]: [it([26])=<1]
* Psum in Chain-Tail [multiple([31,32,33,34],[[],[26]])]: [it([multiple([31,32,33,34],[[],[26]])])=<1,s(87)=<1,s(88)=<2*A]

###### Computing max_min for aux(14)=<A/2+1/2  
   - Found a solution using cacheing 
 * Adding constraints:[aux(14)=<aux(13)] 

##### Pending set mergesortBuggy(A,B,C,D)
* Psum in Loop 29: [s(81)=<A'/2+A'2/2]
* Psum in Loop 30: [s(83)=<A'/2+A'2/2]
* Psum in Chain-Tail [26]: [it([26])=<1]
* Psum in Chain-Tail [multiple([31,32,33,34],[[],[26]])]: [it([multiple([31,32,33,34],[[],[26]])])=<1,s(87)=<1,s(88)=<2*A]

###### Computing sum for s(81)=<A'/2+A'2/2  in Loop 29 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(15)=<A/2+1/2] 
 * Adding constraints: [s(81)=<it(29)*aux(15)] 

##### Pending set mergesortBuggy(A,B,C,D)
* Pmax/min: [aux(15)=<A/2+1/2]
* Psum in Loop 30: [s(83)=<A'/2+A'2/2]
* Psum in Chain-Tail [26]: [it([26])=<1]
* Psum in Chain-Tail [multiple([31,32,33,34],[[],[26]])]: [it([multiple([31,32,33,34],[[],[26]])])=<1,s(87)=<1,s(88)=<2*A]

###### Computing max_min for aux(15)=<A/2+1/2  
   - Found a solution using cacheing 
 * Adding constraints:[aux(15)=<aux(13)] 

##### Pending set mergesortBuggy(A,B,C,D)
* Psum in Loop 30: [s(83)=<A'/2+A'2/2]
* Psum in Chain-Tail [26]: [it([26])=<1]
* Psum in Chain-Tail [multiple([31,32,33,34],[[],[26]])]: [it([multiple([31,32,33,34],[[],[26]])])=<1,s(87)=<1,s(88)=<2*A]

###### Computing sum for s(83)=<A'/2+A'2/2  in Loop 30 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(16)=<A/2+1/2] 
 * Adding constraints: [s(83)=<it(30)*aux(16)] 

##### Pending set mergesortBuggy(A,B,C,D)
* Pmax/min: [aux(16)=<A/2+1/2]
* Psum in Chain-Tail [26]: [it([26])=<1]
* Psum in Chain-Tail [multiple([31,32,33,34],[[],[26]])]: [it([multiple([31,32,33,34],[[],[26]])])=<1,s(87)=<1,s(88)=<2*A]

###### Computing max_min for aux(16)=<A/2+1/2  
   - Found a solution using cacheing 
 * Adding constraints:[aux(16)=<aux(13)] 

##### Pending set mergesortBuggy(A,B,C,D)
* Psum in Chain-Tail [26]: [it([26])=<1]
* Psum in Chain-Tail [multiple([31,32,33,34],[[],[26]])]: [it([multiple([31,32,33,34],[[],[26]])])=<1,s(87)=<1,s(88)=<2*A]

###### Computing sum for it([26])=<1  in Chain-Tail [26] 
   - Applying inductive sum strategy 
     - head Candidate: 1 
       - Loop 27 adds a constant 1/1 
       - Loop 28 adds a constant 1/1 
       - Loop 29 adds a constant 1/1 
       - Loop 30 adds a constant 1/1 
       - Chain-Tail [multiple([31,32,33,34],[[],[26]])] is collaborative and bounds [it([multiple([31,32,33,34],[[],[26]])])] 
 * Adding constraints: [it([26])+it([multiple([31,32,33,34],[[],[26]])])=<it(30)+it(29)+it(28)+it(27)+aux(17),aux(17)=<1] 

##### Pending set mergesortBuggy(A,B,C,D)
* Psum in Chain-Tail [multiple([31,32,33,34],[[],[26]])]: [s(87)=<1,s(88)=<2*A]

###### Computing sum for s(87)=<1  in Chain-Tail [multiple([31,32,33,34],[[],[26]])] 
   - Applying inductive sum strategy 
     - head Candidate: A-1 
       - Loop 27 is collaborative
       - Loop 28 is collaborative
       - Loop 29 is collaborative
       - Loop 30 is collaborative
       - Chain-Tail [26] is collaborative
 * Adding constraints: [s(87)=<A-1] 

##### Pending set mergesortBuggy(A,B,C,D)
* Psum in Chain-Tail [multiple([31,32,33,34],[[],[26]])]: [s(88)=<2*A]

###### Computing sum for s(88)=<2*A  in Chain-Tail [multiple([31,32,33,34],[[],[26]])] 
   - Applying inductive sum strategy 
     - head Candidate: 4*A-4 
       - Loop 27 is collaborative
       - Loop 28 is collaborative
       - Loop 29 is collaborative
       - Loop 30 is collaborative
       - Chain-Tail [26] is collaborative
 * Adding constraints: [s(88)=<4*A-4] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [27,28,29,30,[multiple([31,32,33,34],[[],[26]])],[26]] 

#### Simplifying cost structure of phase [27,28,29,30,[multiple([31,32,33,34],[[],[26]])],[26]] 
 * Joined equivalent variables [aux(18),s(87)] into aux(18)
 * Joined equivalent variables [aux(14),aux(15),aux(16)] into aux(14)
 * Joined equivalent variables [s(75),s(78),s(86)] into s(75)
 * Joined equivalent variables [it(27),it(28),it(29),it(30)] into it(27)
 * Joined equivalent variables [s(79),s(81),s(83)] into s(79)
 * Joined equivalent variables [s(77),s(80),s(82)] into s(77)

#### Cost of phase [27,28,29,30]:mergesortBuggy(A,B,C,D) -> [] 
96*it(27)+3*it([26])+28*s(74)+88*s(75)+84*s(77)+96*s(84)+3*s(85)+0
  Such that:aux(17) =< 1
s(88) =< 4*A
aux(13) =< A/2+1/2
aux(18) =< A
it(27) =< aux(18)
aux(14) =< aux(13)
it([26]) =< it(27)+it(27)+it(27)+it(27)+aux(17)
s(76) =< it(27)*aux(13)
s(79) =< it(27)*aux(14)
s(84) =< s(88)
s(85) =< s(84)+s(84)+s(84)+s(84)+aux(18)
s(77) =< s(79)
s(74) =< s(76)

Unbounded itvars
s(75) :  sum(27),s(57)

#### Cost of chains of mergesortBuggy(A,B,C,D):
* Chain [multiple([31,32,33,34],[[],[26]])]...: 96*it(31)+3*it([26])+44*s(47)+0
  Such that:aux(11) =< 1
aux(12) =< 2*A
it(31) =< aux(12)
it([26]) =< it(31)+it(31)+it(31)+it(31)+aux(11)

Unbounded itvars
s(47) :  sum(31),s(42)

  with precondition: [A=2,B>=0,C>=1,D>=0] 

* Chain [multiple([27,28,29,30],[[],[multiple([31,32,33,34],[[],[26]])],[26]])]...: 96*it(27)+3*it([26])+28*s(74)+88*s(75)+84*s(77)+96*s(84)+3*s(85)+0
  Such that:aux(17) =< 1
s(88) =< 4*A
aux(13) =< A/2+1/2
aux(18) =< A
it(27) =< aux(18)
aux(14) =< aux(13)
it([26]) =< it(27)+it(27)+it(27)+it(27)+aux(17)
s(76) =< it(27)*aux(13)
s(79) =< it(27)*aux(14)
s(84) =< s(88)
s(85) =< s(84)+s(84)+s(84)+s(84)+aux(18)
s(77) =< s(79)
s(74) =< s(76)

Unbounded itvars
s(75) :  sum(27),s(57)

  with precondition: [A>=3,B>=0,C>=1,D>=0] 

* Chain [26]: 3
  with precondition: [A=1,C=1,B>=0,D>=0] 


Closed-form bounds of msplit(A,B,C,D,E): 
-------------------------------------
* Chain [[19],18] with precondition: [C=1,A+1=D,A>=3,B>=0,E>=0] 
    - Upper bound: 7*A+12 
    - Complexity: n 
* Chain [[19],17] with precondition: [C=1,A+1=D,A>=4,B>=0,E>=0] 
    - Upper bound: 7*A+16 
    - Complexity: n 
* Chain [18] with precondition: [A=1,C=1,D=2,B>=0,E>=0] 
    - Upper bound: 5 
    - Complexity: constant 
* Chain [17] with precondition: [A=2,C=1,D=3,B>=0,E>=0] 
    - Upper bound: 9 
    - Complexity: constant 

### Maximum cost of msplit(A,B,C,D,E): 7*A+16 
Asymptotic class: n 
 * Joined equivalent variables [aux(19),aux(1),aux(2)] into aux(19)

Closed-form bounds of merge(A,B,C,D,E,F): 
-------------------------------------
* Chain [[13,14],16] with precondition: [A+C=E+1,A>=2,C>=2,D>=0,F>=D,B+D>=F] 
    - Upper bound: 11*A+11*C+2 
    - Complexity: n 
* Chain [[13,14],15] with precondition: [A+C=E+1,A>=2,B>=0,C>=2,F>=B,B+D>=F] 
    - Upper bound: 11*A+11*C+6 
    - Complexity: n 
* Chain [16] with precondition: [A=1,C=E,D=F,B>=0,C>=0,D>=0] 
    - Upper bound: 2 
    - Complexity: constant 
* Chain [15] with precondition: [C=1,A=E,B=F,A>=2,B>=0,D>=0] 
    - Upper bound: 6 
    - Complexity: constant 

### Maximum cost of merge(A,B,C,D,E,F): 11*A+11*C+6 
Asymptotic class: n 

Closed-form bounds of mergesortBuggy(A,B,C,D): 
-------------------------------------
* Chain [multiple([31,32,33,34],[[],[26]])]... with precondition: [A=2,B>=0,C>=1,D>=0] 
    - Upper bound: inf 
    - Complexity: infinity 
* Chain [multiple([27,28,29,30],[[],[multiple([31,32,33,34],[[],[26]])],[26]])]... with precondition: [A>=3,B>=0,C>=1,D>=0] 
    - Upper bound: inf 
    - Complexity: infinity 
* Chain [26] with precondition: [A=1,C=1,B>=0,D>=0] 
    - Upper bound: 3 
    - Complexity: constant 

### Maximum cost of mergesortBuggy(A,B,C,D): inf 
Asymptotic class: infinity 

Closed-form bounds of mergesort(A,B,C,D): 
-------------------------------------
* Chain [multiple([20,21,22,23],[[],[25],[24]])]... with precondition: [A>=3,B>=0,C>=1,D>=0] 
    - Upper bound: inf 
    - Complexity: infinity 
* Chain [25] with precondition: [A=1,C=1,B>=0,D>=0] 
    - Upper bound: 3 
    - Complexity: constant 
* Chain [24] with precondition: [A=2,C=2,B=D,B>=0] 
    - Upper bound: 6 
    - Complexity: constant 

### Maximum cost of mergesort(A,B,C,D): inf 
Asymptotic class: infinity 
* Total analysis performed in 1995 ms.


Cost relation system solved by CoFloCo in 1997 ms.

Method msplit terminates?: YES

 - l_1: size of l wrt. List<Rat>
 - l_2: size of l wrt. Rat
UB for msplit(l_1,l_2) = 7*l_1+16

Method merge terminates?: YES

 - l1_1: size of l1 wrt. List<Rat>
 - l1_2: size of l1 wrt. Rat
 - l2_1: size of l2 wrt. List<Rat>
 - l2_2: size of l2 wrt. Rat
UB for merge(l1_1,l1_2,l2_1,l2_2) = 11*l1_1+11*l2_1+6

Method mergesortBuggy terminates?: YES

 - l_1: size of l wrt. List<Rat>
 - l_2: size of l wrt. Rat
UB for mergesortBuggy(l_1,l_2) = inf

Method mergesort terminates?: YES

 - l_1: size of l wrt. List<Rat>
 - l_2: size of l wrt. Rat
UB for mergesort(l_1,l_2) = inf
