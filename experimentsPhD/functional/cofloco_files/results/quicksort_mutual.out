
Abs program loaded in 15 ms.

Rule based representation generated in 1 ms.

Rule based representation stored in /tmp/costabs/rbr.rbr

RBR properties stored in /tmp/costabs/rbr.properties

Class invariants generated and loaded in 0 ms.

Abstract compilation performed in 6 ms.

Cost relation system stored in /tmp/costabs/crs.crs

Generated 33 equations 
entry('append'(A,B,C,D,E,F,G,H,I,J,K,L):[]).
entry('part'(A,B,C,D,E,F,G,H,I):[]).
entry('qs'(A,B,C,D):[]).
input_output_vars('and_op'(A,B,C),[A,B],[C]).
input_output_vars('append'(A,B,C,D,E,F,G,H,I,J,K,L),[A,B,C,D,E,F,G,H],[I,J,K,L]).
input_output_vars('case_0'(A,B,C,D,E,F,G,H,I,J,K,L),[A,B,C,D,E,F,G,H],[I,J,K,L]).
input_output_vars('case_1'(A,B,C,D,E,F,G,H,I),[A,B,C,D,E,F,G],[H,I]).
input_output_vars('case_2'(A,B,C,D,E,F,G,H,I,J,K,L),[A,B,C,D,E,F,G,H,I,J],[K,L]).
input_output_vars('case_3'(A,B,C,D),[A,B],[C,D]).
input_output_vars('eq'(A,B,C),[A,B],[C]).
input_output_vars('geq'(A,B,C),[A,B],[C]).
input_output_vars('gt'(A,B,C),[A,B],[C]).
input_output_vars('leq'(A,B,C),[A,B],[C]).
input_output_vars('lt'(A,B,C),[A,B],[C]).
input_output_vars('maxNorm'(A,B,C),[A,B],[C]).
input_output_vars('neg'(A,B),[A],[B]).
input_output_vars('neq'(A,B,C),[A,B],[C]).
input_output_vars('or'(A,B,C),[A,B],[C]).
input_output_vars('part'(A,B,C,D,E,F,G,H,I),[A,B,C,D,E,F,G],[H,I]).
input_output_vars('qs'(A,B,C,D),[A,B],[C,D]).
eq('eq',[A,B,C],0,[],[A=B,C=1,A>=0,B>=0,C>=0]).
eq('eq',[A,B,C],0,[],[A>=B+1,C=0,A>=0,B>=0,C>=0]).
eq('eq',[A,B,C],0,[],[B>=A+1,C=0,A>=0,B>=0,C>=0]).
eq('neq',[A,B,C],0,[],[A=B,C=0,A>=0,B>=0,C>=0]).
eq('neq',[A,B,C],0,[],[A>=B+1,C=1,A>=0,B>=0,C>=0]).
eq('neq',[A,B,C],0,[],[B>=A+1,C=1,A>=0,B>=0,C>=0]).
eq('lt',[A,B,C],0,[],[B-A>=1,C=1,A>=0,B>=0,C>=0]).
eq('lt',[A,B,C],0,[],[B=<A,C=0,A>=0,B>=0,C>=0]).
eq('leq',[A,B,C],0,[],[A=<B,C=1,A>=0,B>=0,C>=0]).
eq('leq',[A,B,C],0,[],[A-B>=1,C=0,A>=0,B>=0,C>=0]).
eq('gt',[A,B,C],0,[],[A-B>=1,C=1,A>=0,B>=0,C>=0]).
eq('gt',[A,B,C],0,[],[A=<B,C=0,A>=0,B>=0,C>=0]).
eq('geq',[A,B,C],0,[],[B=<A,C=1,A>=0,B>=0,C>=0]).
eq('geq',[A,B,C],0,[],[B-A>=1,C=0,A>=0,B>=0,C>=0]).
eq('neg',[A,B],0,[],[A=0,B=1,A>=0,B>=0]).
eq('neg',[A,B],0,[],[A=1,B=0,A>=0,B>=0]).
eq('and_op',[A,B,C],0,[],[A=0,C=0,A>=0,B>=0,C>=0]).
eq('and_op',[A,B,C],0,[],[A=1,C=B,A>=0,B>=0,C>=0]).
eq('or',[A,B,C],0,[],[A=1,C=1,A>=0,B>=0,C>=0]).
eq('or',[A,B,C],0,[],[A=0,C=B,A>=0,B>=0,C>=0]).
eq('maxNorm',[A,B,A],0,[],[A>=1+B,A>=0,B>=0,A>=0]).
eq('maxNorm',[A,B,B],0,[],[A=<B,A>=0,B>=0,B>=0]).
eq('case_0',[A,B,C,D,E,F,G,H,E,F,G,H],1,[],[D=0,C=1,A=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,E>=0,F>=0,G>=0,H>=0]).
eq('case_0',[A,B,C,D,E,F,G,H,I,J,K,L],4,['append'(M,N,O,P,E,F,G,H,Q,R,S,T)],[D=U+P,C=O+1,B=V+N,A=M+1,O>=1,M>=1,U>=1,L=U+T,K=S+1,J=V+R,I=Q+1,S>=1,Q>=1,U>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0]).
eq('append',[A,B,C,D,E,F,G,H,I,J,K,L],1,['case_0'(A,B,C,D,E,F,G,H,I,J,K,L)],[A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0]).
eq('case_1',[A,B,C,D,E,F,G,H,I],5,['qs'(B,C,J,K),'qs'(D,E,L,M),'append'(J,K,N,O,P,Q,R,S,H,I,T,U)],[F=1,Q=A+M,P=L+1,L>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0]).
eq('case_2',[A,B,C,D,E,F,G,H,I,J,K,L],3,['part'(A,M,N,D,E,I,J,K,L)],[A>=H+1,N=H+C,M=B+1,B>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0]).
eq('case_2',[A,B,C,D,E,F,G,H,I,J,K,L],3,['part'(A,B,C,M,N,I,J,K,L)],[H>=A,N=H+E,M=D+1,D>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0]).
eq('case_1',[A,B,C,D,E,F,G,H,I],3,['case_2'(A,B,C,D,E,F,G,J,K,L,H,I)],[G=J+L,F=K+1,K>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0]).
eq('part',[A,B,C,D,E,F,G,H,I],1,['case_1'(A,B,C,D,E,F,G,H,I)],[A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0]).
eq('case_3',[A,B,C,D],2,[],[A=1,C=1,A>=0,B>=0,C>=0,D>=0]).
eq('case_3',[A,B,C,D],5,['part'(E,F,G,H,I,J,K,C,D)],[B=E+K,A=J+1,J>=1,F=1,H=1,A>=0,B>=0,C>=0,D>=0]).
eq('qs',[A,B,C,D],1,['case_3'(A,B,C,D)],[A>=0,B>=0,C>=0,D>=0]).

Preprocessing Cost Relations
=====================================

#### Computed strongly connected components 
0. recursive  : [append/12,case_0/12]
1. recursive [non_tail,multiple] : [case_1/9,case_2/12,case_3/4,part/9,qs/4]
* The entry qs/4 is not a cutpoint so it becomes a new SCC 2
Warning: the following predicates are never called:[and_op/3,eq/3,geq/3,gt/3,leq/3,lt/3,maxNorm/3,neg/2,neq/3,or/3]

#### Obtained direct recursion through partial evaluation 
0. SCC is partially evaluated into append/12
1. SCC is partially evaluated into part/9
2. SCC is partially evaluated into qs/4

Control-Flow Refinement of Cost Relations
=====================================

### Specialization of cost equations append/12 
* CE 2 is refined into CE [11] 
* CE 1 is refined into CE [12] 


#### Refined cost equations append/12 
* CE 11: append(A,B,C,D,E,F,G,H,E,F,G,H) = 2
     [H>=0,G>=0,F>=0,E>=0,B>=0,D=0,C=1,A=1] 
* CE 12: append(A,B,C,D,E,F,G,H,I,J,K,L) = 5+ append(M,N,O,P,E,F,G,H,Q,R,S,T)
     [L+P>=T,J+N>=R,L>=T+1,S>=1,Q>=1,O>=1,M>=1,L>=0,J>=0,H>=0,G>=0,F>=0,E>=0,D+T=L+P,B+R=J+N,S+1=K,Q+1=I,O+1=C,M+1=A] 

### Cost equations --> "Loop" of append/12 
* CEs [12] --> Loop 11 
* CEs [11] --> Loop 12 

#### Loops of append/12 
* Loop 11: append(A,B,C,D,E,F,G,H,I,J,K,L)->  append(A',B',C',D',E,F,G,H,E',F',G',H')
                  [L+D'>=H',J+B'>=F',L>=H'+1,G'>=1,E'>=1,C'>=1,A'>=1,L>=0,J>=0,H>=0,G>=0,F>=0,E>=0,L+D'=D+H',J+B'=B+F',G'+1=K,E'+1=I,C'+1=C,A'+1=A] 
* Loop 12: append(A,B,C,D,E,F,G,H,E,F,G,H) [H>=0,G>=0,F>=0,E>=0,B>=0,D=0,C=1,A=1] 

### Ranking functions of CR append(A,B,C,D,E,F,G,H,I,J,K,L) 
* RF of phase [11]: [A-1,C-1,D+1]

#### Partial ranking functions of CR append(A,B,C,D,E,F,G,H,I,J,K,L) 
* Partial RF of phase [11]:
  - RF of loop [11:1]:
    A-1
    C-1
    D+1

Discarded unfeasible chain [[11]]...(Non-terminating chain proved terminating)

### Resulting Chains:append(A,B,C,D,E,F,G,H,I,J,K,L) 
* [[11],12]
* [12]


### Merging Chains  append/12 into  External patterns of execution 
* [[12]] --> 1 
* [[12,[11]]] --> 2 


### Specialization of cost equations part/9 
* CE 8 is refined into CE [13] 
* CE 7 is refined into CE [14] 
* CE 4 is refined into CE [15,16] 
* CE 5 is refined into CE [17] 
* CE 6 is refined into CE [18] 
* CE 3 is refined into CE [19,20] 


#### Refined cost equations part/9 
* CE 13: part(A,B,C,D,E,F,G,H,I) = 7+ part(A,B,C,J,K,L,M,H,I)
     [K+M>=G,G>=A+M,M>=0,L>=1,I>=0,H>=0,D>=1,C>=0,B>=0,A>=0,K+M=E+G,D+1=J,L+1=F] 
* CE 14: part(A,B,C,D,E,F,G,H,I) = 7+ part(A,J,K,D,E,L,M,H,I)
     [C+G>=K,A+C>=K+1,K>=C,L>=1,I>=0,H>=0,E>=0,D>=0,C>=0,B>=1,K+M=C+G,B+1=J,L+1=F] 
* CE 15: part(A,B,C,D,E,F,G,H,I) = 15+ part(J,K,L,M,N,O,P,Q,R)+ append(S,R,T,U,V,I,W,X,Y,I,W,X):1
     [J+P>=0,I>=A,O>=1,X>=0,W>=0,R>=0,G>=0,E>=0,A>=0,J+P=C,O+1=B,Q=1,M=1,K=1,Y=2,V=2,U=0,T=1,S=1,H=2,F=1,D=1] 
* CE 16: part(A,B,C,D,E,F,G,H,I) = 15+ part(J,K,L,M,N,O,P,Q,R)+ append(Q,R,Q,S,T,U,V,W,X,I,Y,Z):2
     [R+U>=I,J+P>=0,Z>=S,Y>=Q,S+1>=Q,U>=A,O>=1,I>=0,Q>=2,R>=0,G>=0,E>=0,A>=0,Q+V=Y+1,Z=S+W,J+P=C,Q+1=X,Q+1=H,O+1=B,M=1,K=1,T=2,F=1,D=1] 
* CE 17: part(A,B,C,D,E,F,G,H,I) = 15+ part(J,K,L,M,N,O,P,Q,R)+ append(S,T,U,V,H,I,W,X,H,I,W,X):1
     [J+P>=0,I>=R,R>=0,O>=1,X>=0,W>=0,H>=2,T>=0,G>=0,C>=0,J+P=E,I=A+R,H=Q+1,O+1=D,M=1,K=1,V=0,U=1,S=1,F=1,B=1] 
* CE 18: part(A,B,C,D,E,F,G,H,I) = 12+ append(J,K,L,M,N,I,O,P,Q,I,O,P):1
     [I>=A,P>=0,O>=0,K>=0,G>=0,E>=0,C>=0,A>=0,Q=2,N=2,M=0,L=1,J=1,H=2,F=1,D=1,B=1] 
* CE 19: part(A,B,C,D,E,F,G,H,I) = 18+ part(J,K,L,M,N,O,P,Q,R)+ part(S,T,U,V,W,X,Y,Z,A1)+ append(B1,R,C1,D1,H,I,E1,F1,H,I,E1,F1):1
     [S+Y>=0,J+P>=0,I>=A1,A1>=0,X>=1,O>=1,F1>=0,E1>=0,H>=2,R>=0,G>=0,S+Y=E,J+P=C,I=A+A1,H=Z+1,X+1=D,O+1=B,V=1,T=1,Q=1,M=1,K=1,D1=0,C1=1,B1=1,F=1] 
* CE 20: part(A,B,C,D,E,F,G,H,I) = 18+ part(J,K,L,M,N,O,P,Q,R)+ part(S,T,U,V,W,X,Y,Z,A1)+ append(Q,R,Q,B1,C1,D1,E1,F1,H,I,G1,H1):2
     [R+D1>=I,S+Y>=0,J+P>=0,D1>=A1,H1>=B1,G1>=Q,H>=Q+1,B1+1>=Q,A1>=0,X>=1,O>=1,I>=0,Q>=2,R>=0,G>=0,Q+E1=G1+1,Q+Z=H,Q+C1=H+1,H1=B1+F1,S+Y=E,J+P=C,D1=A+A1,X+1=D,O+1=B,V=1,T=1,M=1,K=1,F=1] 

### Cost equations --> "Loop" of part/9 
* CEs [20] --> Loop 13 
* CEs [19] --> Loop 14 
* CEs [18] --> Loop 15 
* CEs [13] --> Loop 16 
* CEs [14] --> Loop 17 
* CEs [16] --> Loop 18 
* CEs [15] --> Loop 19 
* CEs [17] --> Loop 20 

#### Loops of part/9 
* Loop 13: part(A,B,C,D,E,F,G,H,I)->  part(A',B',C',D',E',F',G',H',I')  part(A'2,B'2,C'2,D'2,E'2,F'2,G'2,H'2,I'2)
                  [A+I'+I'2>=I,H>=H'+1,I'2>=0,I'>=0,H'>=2,I>=0,G>=0,E>=0,D>=2,C>=0,B>=2,A>=0,E=A'2+G'2,C=A'+G',H'+H'2=H,D=F'2+1,B=F'+1,D'2=1,B'2=1,D'=1,B'=1,F=1] 
* Loop 14: part(A,B,C,D,E,F,G,H,I)->  part(A',B',C',D',E',F',G',H',I')  part(A'2,B'2,C'2,D'2,E'2,F'2,G'2,H'2,I'2)
                  [I>=A,I'>=0,H>=2,G>=0,E>=0,D>=2,C>=0,B>=2,A>=0,E=A'2+G'2,C=A'+G',A+I'2=I,H=H'2+1,D=F'2+1,B=F'+1,D'2=1,B'2=1,H'=1,D'=1,B'=1,F=1] 
* Loop 15: part(A,B,C,D,E,F,G,H,I) [I>=A,G>=0,E>=0,C>=0,A>=0,H=2,F=1,D=1,B=1] 
* Loop 16: part(A,B,C,D,E,F,G,H,I)->  part(A,B,C,A',B',C',D',H,I)
                  [E+G>=B',B'>=A+E,I>=0,H>=0,F>=2,E>=0,D>=1,C>=0,B>=0,A>=0,E+G=B'+D',F=C'+1,D+1=A'] 
* Loop 17: part(A,B,C,D,E,F,G,H,I)->  part(A,A',B',D,E,C',D',H,I)
                  [C+G>=B',A+C>=B'+1,B'>=C,I>=0,H>=0,F>=2,E>=0,D>=0,C>=0,B>=1,C+G=B'+D',F=C'+1,B+1=A'] 
* Loop 18: part(A,B,C,D,E,F,G,H,I)->  part(A',B',C',D',E',F',G',H',I')
                  [I'>=0,I>=0,H>=3,G>=0,E>=0,C>=0,B>=2,A>=0,C=A'+G',H=H'+1,B=F'+1,D'=1,B'=1,F=1,D=1] 
* Loop 19: part(A,B,C,D,E,F,G,H,I)->  part(A',B',C',D',E',F',G',H',I')
                  [I>=A,I'>=0,G>=0,E>=0,C>=0,B>=2,A>=0,C=A'+G',B=F'+1,H'=1,D'=1,B'=1,H=2,F=1,D=1] 
* Loop 20: part(A,B,C,D,E,F,G,H,I)->  part(A',B',C',D',E',F',G',H',I')
                  [I>=A,H>=2,G>=0,E>=0,D>=2,C>=0,A>=0,E=A'+G',A+I'=I,H=H'+1,D=F'+1,D'=1,B'=1,F=1,B=1] 

### Ranking functions of CR part(A,B,C,D,E,F,G,H,I) 

#### Partial ranking functions of CR part(A,B,C,D,E,F,G,H,I) 
* Partial RF of phase [13,14,16,17,18,19,20]:
  - RF of loop [13:1,13:2,14:1,14:2,18:1,19:1]:
    B-1 depends on loops [17:1] 
  - RF of loop [13:1,13:2,14:1,14:2,20:1]:
    D-1 depends on loops [16:1] 
  - RF of loop [13:1,14:1,18:1,19:1]:
    B+F-2 depends on loops [13:2,14:2,20:1] 
  - RF of loop [13:2,14:2,20:1]:
    D+F-2 depends on loops [13:1,14:1,18:1,19:1] 
  - RF of loop [16:1,17:1]:
    F-1 depends on loops [13:1,13:2,14:1,14:2,18:1,19:1,20:1] 


### Resulting Chains:part(A,B,C,D,E,F,G,H,I) 
* [multiple([13,14,16,17,18,19,20],[[],[15]])]...
* [15]


### Merging Chains  part/9 into  External patterns of execution 
* [[15]] --> 1 
* [[multiple([13,14,16,17,18,19,20],[[],[15]])]] --> 2 


### Specialization of cost equations qs/4 
* CE 9 is refined into CE [21,22] 
* CE 10 is refined into CE [23] 


#### Refined cost equations qs/4 
* CE 21: qs(A,B,C,D) = 6+ part(E,F,G,H,I,J,K,L,D):1
     [D>=E,K>=0,I>=0,G>=0,E>=0,E+K=B,L=2,J=1,H=1,F=1,C=2,A=2] 
* CE 22: qs(A,B,C,D) = 6+ part(E,F,G,H,I,J,K,C,D):2
     [C+2*J>=4,2*J>=3,D>=0,C>=0,K>=0,I>=0,G>=0,E>=0,E+K=B,J+1=A,H=1,F=1] 
* CE 23: qs(A,B,C,D) = 3
     [D>=0,B>=0,C=1,A=1] 

### Cost equations --> "Loop" of qs/4 
* CEs [21] --> Loop 21 
* CEs [23] --> Loop 22 
* CEs [22] --> Loop 23 

#### Loops of qs/4 
* Loop 21: qs(A,B,C,D) [D>=0,B>=0,C=2,A=2] 
* Loop 22: qs(A,B,C,D) [D>=0,B>=0,C=1,A=1] 
* Loop 23: qs(A,B,C,D) [C+2*A>=6,2*A>=5,D>=0,C>=0,B>=0] 

### Ranking functions of CR qs(A,B,C,D) 

#### Partial ranking functions of CR qs(A,B,C,D) 


### Resulting Chains:qs(A,B,C,D) 
* [23]...
* [22]
* [21]


### Merging Chains  qs/4 into  External patterns of execution 
* [[22]] --> 1 
* [[21]] --> 2 
* [[23]] --> 3 


Computing Bounds
=====================================

#### Simplifying cost structure of CE 11 

#### Computing cost of phase [11] 

#### Simplifying cost structure of CE 12 

#### Cost of loops [11] 

 * loop 11:append(A,B,C,D,E,F,G,H,I,J,K,L) -> [append(A',B',C',D',E',F',G',H',I',J',K',L')] 
5
##### Pending set append(A,B,C,D,E,F,G,H,I,J,K,L)
* Psum in Loop 11: [it(11)=<1]

###### Computing sum for it(11)=<1  in Loop 11 
   - Applying inductive sum strategy 
     - head Candidate: C-1 
     - head Candidate: D+1 
     - head Candidate: A-1 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: D+1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
     - tail Candidate: D+1 
     - tail Candidate: A-1 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: D+1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(11)=<C-1,it(11)=<D+1,it(11)=<A-1,it(11)=<A-1,it(11)=<C-1,it(11)=<D+1,it(11)=<C-C',it(11)=<D-D',it(11)=<A-A',it(11)=<A-A',it(11)=<C-C',it(11)=<D-D'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [11] 

#### Simplifying cost structure of phase [11] 

#### Cost of phase [11]:append(A,B,C,D,E,F,G,H,I,J,K,L) -> [append(A',B',C',D',E',F',G',H',I',J',K',L')] 
5*it(11)+0
  Such that:it(11) =< A
it(11) =< A-A'
it(11) =< C
it(11) =< C-C'
it(11) =< D+1
it(11) =< D-D'

#### Simplifying cost structure of chain [[11],12] 

#### Cost of chains of append(A,B,C,D,E,F,G,H,I,J,K,L):
* Chain [[11],12]: 5*it(11)+2
  Such that:it(11) =< -E+I

  with precondition: [A=C,L=D+H,A+E=I+1,A+G=K+1,A>=2,B>=0,E>=1,F>=0,G>=1,J>=0,D+1>=A,L>=D,B+F>=J] 

* Chain [12]: 2
  with precondition: [A=1,C=1,D=0,E=I,F=J,G=K,H=L,B>=0,E>=0,F>=0,G>=0,H>=0] 


#### Simplifying cost structure of CE 18 

#### Computing cost of chain [multiple([13,14,16,17,18,19,20],[[],[15]])] with multiple recursion
 * Renamed intermediate variables: 
[ (eq(20,1),it(11))>>s(1)]

#### Simplifying cost structure of CE 20 
 * Renamed intermediate variables: 
[ (it(13),s(1))>>s(2)]

#### Simplifying cost structure of CE 19 

#### Simplifying cost structure of CE 13 

#### Simplifying cost structure of CE 14 
 * Renamed intermediate variables: 
[ (eq(16,1),it(11))>>s(3)]

#### Simplifying cost structure of CE 16 
 * Renamed intermediate variables: 
[ (it(18),s(3))>>s(4)]

#### Simplifying cost structure of CE 15 

#### Simplifying cost structure of CE 17 

#### Cost of loops [13,14,16,17,18,19,20] 

 * loop 13:part(A,B,C,D,E,F,G,H,I) -> [part(A',B',C',D',E',F',G',H',I'),part(A'2,B'2,C'2,D'2,E'2,F'2,G'2,H'2,I'2)] 
5*s(2)+20
Unbounded itvars
s(2) :  it(13),s(1)

 * loop 14:part(A,B,C,D,E,F,G,H,I) -> [part(A',B',C',D',E',F',G',H',I'),part(A'2,B'2,C'2,D'2,E'2,F'2,G'2,H'2,I'2)] 
20
 * loop 16:part(A,B,C,D,E,F,G,H,I) -> [part(A',B',C',D',E',F',G',H',I')] 
7
 * loop 17:part(A,B,C,D,E,F,G,H,I) -> [part(A',B',C',D',E',F',G',H',I')] 
7
 * loop 18:part(A,B,C,D,E,F,G,H,I) -> [part(A',B',C',D',E',F',G',H',I')] 
5*s(4)+17
Unbounded itvars
s(4) :  it(18),s(3)

 * loop 19:part(A,B,C,D,E,F,G,H,I) -> [part(A',B',C',D',E',F',G',H',I')] 
17
 * loop 20:part(A,B,C,D,E,F,G,H,I) -> [part(A',B',C',D',E',F',G',H',I')] 
17
##### Pending set part(A,B,C,D,E,F,G,H,I)
* Psum in Loop 13: [it(13)=<1]
* Psum in Loop 14: [it(14)=<1]
* Psum in Loop 16: [it(16)=<1]
* Psum in Loop 17: [it(17)=<1]
* Psum in Loop 18: [it(18)=<1]
* Psum in Loop 19: [it(19)=<1]
* Psum in Loop 20: [it(20)=<1]
* Psum in Chain-Tail [15]: [it([15])=<1]

###### Computing sum for it(13)=<1  in Loop 13 
   - Applying inductive sum strategy 
     - head Candidate: D-1 
       - Loop 14 is collaborative and bounds [it(14)] 
       - Loop 16 adds a constant 1/1 
       - Loop 17 is collaborative
       - Loop 18 is collaborative
       - Loop 19 is collaborative
       - Loop 20 is collaborative and bounds [it(20)] 
       - Chain-Tail [15] is collaborative
     - head Candidate: B/2+D/2+F/2-3/2 
       - Loop 14 is collaborative and bounds [it(14)] 
       - Loop 16 is collaborative
       - Loop 17 is collaborative
       - Loop 18 is collaborative
       - Loop 19 is collaborative
       - Loop 20 is collaborative
       - Chain-Tail [15] is collaborative
 * Adding constraints: [it(13)+it(14)+it(20)=<it(16)+aux(1),aux(1)=<D-1,it(13)+it(14)=<B/2+D/2+F/2-3/2] 

##### Pending set A
* Psum in Loop 16: [it(16)=<1]
* Psum in Loop 17: [it(17)=<1]
* Psum in Loop 18: [it(18)=<1]
* Psum in Loop 19: [it(19)=<1]
* Psum in Loop 20: [it(20)=<1]
* Psum in Chain-Tail [15]: [it([15])=<1]

###### Computing sum for it(16)=<1  in Loop 16 
   - Applying inductive sum strategy 
     - head Candidate: F-1 
       - Loop 13 adds an expression [B+D-4]
       - Loop 14 adds an expression [B+D-4]
       - Loop 17 is collaborative and bounds [it(17)] 
       - Loop 18 adds an expression [B-2]
       - Loop 19 adds an expression [B-2]
       - Loop 20 adds an expression [D-2]
       - Chain-Tail [15] is collaborative
     - tail Candidate: F-1 
       - Loop 13 adds an expression [B+D-4]
       - Loop 14 adds an expression [B+D-4]
       - Loop 17 is collaborative and bounds [it(17)] 
       - Loop 18 adds an expression [B-2]
       - Loop 19 adds an expression [B-2]
       - Loop 20 adds an expression [D-2]
       - Chain-Tail [15] is collaborative
 * Adding constraints: [it(16)+it(17)=<aux(6)+aux(5)+aux(4)+aux(3)+aux(2)+aux(7),it(16)+it(17)=<aux(12)+aux(11)+aux(10)+aux(9)+aux(8)+aux(13),aux(7)=<F-1,aux(13)=<F-1] 

##### Pending set A
* Psum in Loop 13: [aux(2)=<B+D-4,aux(8)=<B+D-4]
* Psum in Loop 14: [aux(3)=<B+D-4,aux(9)=<B+D-4]
* Psum in Loop 17: [it(17)=<1]
* Psum in Loop 18: [it(18)=<1,aux(4)=<B-2,aux(10)=<B-2]
* Psum in Loop 19: [it(19)=<1,aux(5)=<B-2,aux(11)=<B-2]
* Psum in Loop 20: [it(20)=<1,aux(6)=<D-2,aux(12)=<D-2]
* Psum in Chain-Tail [15]: [it([15])=<1]

###### Computing sum for aux(2)=<B+D-4  in Loop 13 
   - Applying inductive sum strategy 
     - head Candidate: B+D 
       - Loop 14 is collaborative and bounds [aux(3)] 
       - Loop 16 adds a constant 1/1 
       - Loop 17 adds a constant 1/1 
       - Loop 18 is collaborative and bounds [it(18)] 
       - Loop 19 is collaborative and bounds [it(19)] 
       - Loop 20 is collaborative and bounds [it(20)] 
       - Chain-Tail [15] is collaborative and bounds [it([15])] 
     - head Candidate: B+D-4 
       - Loop 14 is collaborative and bounds [aux(3)] 
       - Loop 16 adds a constant 1/1 
       - Loop 17 adds a constant 1/1 
       - Loop 18 is collaborative
       - Loop 19 is collaborative
       - Loop 20 is collaborative
       - Chain [15] is ignored
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(16)=<B+D-4] 
 * Adding constraints: [aux(2)=<it(13)*aux(16),aux(2)+aux(3)+it(18)+it(19)+it(20)+it([15])=<it(17)+it(16)+aux(14),aux(2)+aux(3)=<it(17)+it(16)+aux(15),aux(14)=<B+D,aux(15)=<B+D-4] 

##### Pending set part(A,B,C,D,E,F,G,H,I)
* Pmax/min: [aux(16)=<B+D-4]
* Psum in Loop 13: [aux(8)=<B+D-4]
* Psum in Loop 14: [aux(9)=<B+D-4]
* Psum in Loop 17: [it(17)=<1]
* Psum in Loop 18: [it(18)=<1,aux(4)=<B-2,aux(10)=<B-2]
* Psum in Loop 19: [it(19)=<1,aux(5)=<B-2,aux(11)=<B-2]
* Psum in Loop 20: [it(20)=<1,aux(6)=<D-2,aux(12)=<D-2]
* Psum in Chain-Tail [15]: [it([15])=<1]

###### Computing max_min for aux(16)=<B+D-4  
   - Found a solution using transitive invariants 
 * Adding constraints:[aux(16)=<B+D+F-5,aux(16)=<2*B+2*D+2*F-9] 

##### Pending set part(A,B,C,D,E,F,G,H,I)
* Psum in Loop 13: [aux(8)=<B+D-4]
* Psum in Loop 14: [aux(9)=<B+D-4]
* Psum in Loop 17: [it(17)=<1]
* Psum in Loop 18: [it(18)=<1,aux(4)=<B-2,aux(10)=<B-2]
* Psum in Loop 19: [it(19)=<1,aux(5)=<B-2,aux(11)=<B-2]
* Psum in Loop 20: [it(20)=<1,aux(6)=<D-2,aux(12)=<D-2]
* Psum in Chain-Tail [15]: [it([15])=<1]

###### Computing sum for aux(8)=<B+D-4  in Loop 13 
   - Found a solution using cacheing 
 * Adding constraints: [aux(8)=<aux(17),aux(17)=<it(13)*aux(16),aux(17)+aux(3)+it(18)+it(19)+it(20)+it([15])=<it(17)+it(16)+aux(14),aux(17)+aux(3)=<it(17)+it(16)+aux(15)] 

##### Pending set part(A,B,C,D,E,F,G,H,I)
* Psum in Loop 14: [aux(9)=<B+D-4]
* Psum in Loop 17: [it(17)=<1]
* Psum in Loop 18: [it(18)=<1,aux(4)=<B-2,aux(10)=<B-2]
* Psum in Loop 19: [it(19)=<1,aux(5)=<B-2,aux(11)=<B-2]
* Psum in Loop 20: [it(20)=<1,aux(6)=<D-2,aux(12)=<D-2]
* Psum in Chain-Tail [15]: [it([15])=<1]

###### Computing sum for aux(9)=<B+D-4  in Loop 14 
   - Applying inductive sum strategy 
     - head Candidate: B+D 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: B+D-4 
       - The candidate was classified before. We reuse its previous classification 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(20)=<B+D-4] 
 * Adding constraints: [aux(9)=<it(14)*aux(20),aux(2)+aux(9)+it(18)+it(19)+it(20)+it([15])=<it(17)+it(16)+aux(18),aux(2)+aux(9)=<it(17)+it(16)+aux(19),aux(18)=<B+D,aux(19)=<B+D-4] 

##### Pending set part(A,B,C,D,E,F,G,H,I)
* Pmax/min: [aux(20)=<B+D-4]
* Psum in Loop 17: [it(17)=<1]
* Psum in Loop 18: [it(18)=<1,aux(4)=<B-2,aux(10)=<B-2]
* Psum in Loop 19: [it(19)=<1,aux(5)=<B-2,aux(11)=<B-2]
* Psum in Loop 20: [it(20)=<1,aux(6)=<D-2,aux(12)=<D-2]
* Psum in Chain-Tail [15]: [it([15])=<1]

###### Computing max_min for aux(20)=<B+D-4  
   - Found a solution using cacheing 
 * Adding constraints:[aux(20)=<aux(16)] 

##### Pending set part(A,B,C,D,E,F,G,H,I)
* Psum in Loop 17: [it(17)=<1]
* Psum in Loop 18: [it(18)=<1,aux(4)=<B-2,aux(10)=<B-2]
* Psum in Loop 19: [it(19)=<1,aux(5)=<B-2,aux(11)=<B-2]
* Psum in Loop 20: [it(20)=<1,aux(6)=<D-2,aux(12)=<D-2]
* Psum in Chain-Tail [15]: [it([15])=<1]

###### Computing sum for it(17)=<1  in Loop 17 
   - Applying inductive sum strategy 
     - head Candidate: F-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: F-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(16)+it(17)=<aux(6)+aux(5)+aux(4)+aux(3)+aux(2)+aux(21),it(16)+it(17)=<aux(12)+aux(11)+aux(10)+aux(9)+aux(8)+aux(22),aux(21)=<F-1,aux(22)=<F-1] 

##### Pending set part(A,B,C,D,E,F,G,H,I)
* Psum in Loop 18: [it(18)=<1,aux(4)=<B-2,aux(10)=<B-2]
* Psum in Loop 19: [it(19)=<1,aux(5)=<B-2,aux(11)=<B-2]
* Psum in Loop 20: [it(20)=<1,aux(6)=<D-2,aux(12)=<D-2]
* Psum in Chain-Tail [15]: [it([15])=<1]

###### Computing sum for it(18)=<1  in Loop 18 
   - Applying inductive sum strategy 
     - head Candidate: B-1 
       - Loop 13 is collaborative
       - Loop 14 is collaborative
       - Loop 16 is collaborative
       - Loop 17 adds a constant 1/1 
       - Loop 19 is collaborative and bounds [it(19)] 
       - Loop 20 is collaborative
       - Chain-Tail [15] is collaborative
     - head Candidate: B+F-2 
       - Loop 13 adds an expression [D-3]
       - Loop 14 adds an expression [D-3]
       - Loop 16 is collaborative
       - Loop 17 is collaborative
       - Loop 19 is collaborative and bounds [it(19)] 
       - Loop 20 adds an expression [D-2]
       - Chain-Tail [15] is collaborative
     - tail Candidate: B-1 
       - Loop 13 is collaborative
       - Loop 14 is collaborative
       - Loop 16 is collaborative
       - Loop 17 adds a constant 1/1 
       - Loop 19 is collaborative and bounds [it(19)] 
       - Loop 20 is collaborative
       - Chain-Tail [15] is collaborative
     - tail Candidate: B+F-2 
       - Loop 13 adds an expression [D-3]
       - Loop 14 adds an expression [D-3]
       - Loop 16 is collaborative
       - Loop 17 is collaborative
       - Loop 19 is collaborative and bounds [it(19)] 
       - Loop 20 adds an expression [D-2]
       - Chain-Tail [15] is collaborative
 * Adding constraints: [it(18)+it(19)=<it(17)+aux(23),it(18)+it(19)=<aux(26)+aux(25)+aux(24)+aux(27),it(18)+it(19)=<it(17)+aux(28),it(18)+it(19)=<aux(31)+aux(30)+aux(29)+aux(32),aux(23)=<B-1,aux(27)=<B+F-2,aux(28)=<B-1,aux(32)=<B+F-2] 

##### Pending set part(A,B,C,D,E,F,G,H,I)
* Psum in Loop 13: [aux(24)=<D-3,aux(29)=<D-3]
* Psum in Loop 14: [aux(25)=<D-3,aux(30)=<D-3]
* Psum in Loop 18: [aux(4)=<B-2,aux(10)=<B-2]
* Psum in Loop 19: [it(19)=<1,aux(5)=<B-2,aux(11)=<B-2]
* Psum in Loop 20: [it(20)=<1,aux(6)=<D-2,aux(12)=<D-2,aux(26)=<D-2,aux(31)=<D-2]
* Psum in Chain-Tail [15]: [it([15])=<1]

###### Computing sum for aux(24)=<D-3  in Loop 13 
   - Applying inductive sum strategy 
     - head Candidate: D-3 
       - Loop 14 is collaborative and bounds [aux(25)] 
       - Loop 16 adds a constant 1/1 
       - Loop 17 is collaborative
       - Loop 18 is collaborative
       - Loop 19 is collaborative
       - Loop 20 is collaborative
       - Chain [15] is ignored
     - head Candidate: D 
       - Loop 14 is collaborative and bounds [aux(25)] 
       - Loop 16 adds a constant 1/1 
       - Loop 17 is collaborative
       - Loop 18 is collaborative
       - Loop 19 is collaborative
       - Loop 20 is collaborative and bounds [it(20)] 
       - Chain-Tail [15] is collaborative and bounds [it([15])] 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(35)=<D-3] 
 * Adding constraints: [aux(24)=<it(13)*aux(35),aux(24)+aux(25)=<it(16)+aux(33),aux(24)+aux(25)+it(20)+it([15])=<it(16)+aux(34),aux(33)=<D-3,aux(34)=<D] 

##### Pending set part(A,B,C,D,E,F,G,H,I)
* Pmax/min: [aux(35)=<D-3]
* Psum in Loop 13: [aux(29)=<D-3]
* Psum in Loop 14: [aux(30)=<D-3]
* Psum in Loop 18: [aux(4)=<B-2,aux(10)=<B-2]
* Psum in Loop 19: [it(19)=<1,aux(5)=<B-2,aux(11)=<B-2]
* Psum in Loop 20: [it(20)=<1,aux(6)=<D-2,aux(12)=<D-2,aux(26)=<D-2,aux(31)=<D-2]
* Psum in Chain-Tail [15]: [it([15])=<1]

###### Computing max_min for aux(35)=<D-3  
   - Found a solution using transitive invariants 
 * Adding constraints:[aux(35)=<B+D+F-5,aux(35)=<B+2*D+4*F-10] 

##### Pending set part(A,B,C,D,E,F,G,H,I)
* Psum in Loop 13: [aux(29)=<D-3]
* Psum in Loop 14: [aux(30)=<D-3]
* Psum in Loop 18: [aux(4)=<B-2,aux(10)=<B-2]
* Psum in Loop 19: [it(19)=<1,aux(5)=<B-2,aux(11)=<B-2]
* Psum in Loop 20: [it(20)=<1,aux(6)=<D-2,aux(12)=<D-2,aux(26)=<D-2,aux(31)=<D-2]
* Psum in Chain-Tail [15]: [it([15])=<1]

###### Computing sum for aux(29)=<D-3  in Loop 13 
   - Found a solution using cacheing 
 * Adding constraints: [aux(29)=<aux(36),aux(36)=<it(13)*aux(35),aux(36)+aux(25)=<it(16)+aux(33),aux(36)+aux(25)+it(20)+it([15])=<it(16)+aux(34)] 

##### Pending set part(A,B,C,D,E,F,G,H,I)
* Psum in Loop 14: [aux(30)=<D-3]
* Psum in Loop 18: [aux(4)=<B-2,aux(10)=<B-2]
* Psum in Loop 19: [it(19)=<1,aux(5)=<B-2,aux(11)=<B-2]
* Psum in Loop 20: [it(20)=<1,aux(6)=<D-2,aux(12)=<D-2,aux(26)=<D-2,aux(31)=<D-2]
* Psum in Chain-Tail [15]: [it([15])=<1]

###### Computing sum for aux(30)=<D-3  in Loop 14 
   - Applying inductive sum strategy 
     - head Candidate: D-3 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: D 
       - The candidate was classified before. We reuse its previous classification 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(39)=<D-3] 
 * Adding constraints: [aux(30)=<it(14)*aux(39),aux(24)+aux(30)=<it(16)+aux(37),aux(24)+aux(30)+it(20)+it([15])=<it(16)+aux(38),aux(37)=<D-3,aux(38)=<D] 

##### Pending set part(A,B,C,D,E,F,G,H,I)
* Pmax/min: [aux(39)=<D-3]
* Psum in Loop 18: [aux(4)=<B-2,aux(10)=<B-2]
* Psum in Loop 19: [it(19)=<1,aux(5)=<B-2,aux(11)=<B-2]
* Psum in Loop 20: [it(20)=<1,aux(6)=<D-2,aux(12)=<D-2,aux(26)=<D-2,aux(31)=<D-2]
* Psum in Chain-Tail [15]: [it([15])=<1]

###### Computing max_min for aux(39)=<D-3  
   - Found a solution using cacheing 
 * Adding constraints:[aux(39)=<aux(35)] 

##### Pending set part(A,B,C,D,E,F,G,H,I)
* Psum in Loop 18: [aux(4)=<B-2,aux(10)=<B-2]
* Psum in Loop 19: [it(19)=<1,aux(5)=<B-2,aux(11)=<B-2]
* Psum in Loop 20: [it(20)=<1,aux(6)=<D-2,aux(12)=<D-2,aux(26)=<D-2,aux(31)=<D-2]
* Psum in Chain-Tail [15]: [it([15])=<1]

###### Computing sum for aux(4)=<B-2  in Loop 18 
   - Applying inductive sum strategy 
     - head Candidate: B-2 
       - Loop 13 is collaborative
       - Loop 14 is collaborative
       - Loop 16 is collaborative
       - Loop 17 adds a constant 1/1 
       - Loop 19 is collaborative and bounds [aux(5)] 
       - Loop 20 is collaborative
       - Chain [15] is ignored
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(41)=<B-2] 
 * Adding constraints: [aux(4)=<it(18)*aux(41),aux(4)+aux(5)=<it(17)+aux(40),aux(40)=<B-2] 

##### Pending set part(A,B,C,D,E,F,G,H,I)
* Pmax/min: [aux(41)=<B-2]
* Psum in Loop 18: [aux(10)=<B-2]
* Psum in Loop 19: [it(19)=<1,aux(11)=<B-2]
* Psum in Loop 20: [it(20)=<1,aux(6)=<D-2,aux(12)=<D-2,aux(26)=<D-2,aux(31)=<D-2]
* Psum in Chain-Tail [15]: [it([15])=<1]

###### Computing max_min for aux(41)=<B-2  
   - Found a solution using transitive invariants 
 * Adding constraints:[aux(41)=<B+D+F-4,aux(41)=<2*B+D+4*F-9] 

##### Pending set part(A,B,C,D,E,F,G,H,I)
* Psum in Loop 18: [aux(10)=<B-2]
* Psum in Loop 19: [it(19)=<1,aux(11)=<B-2]
* Psum in Loop 20: [it(20)=<1,aux(6)=<D-2,aux(12)=<D-2,aux(26)=<D-2,aux(31)=<D-2]
* Psum in Chain-Tail [15]: [it([15])=<1]

###### Computing sum for aux(10)=<B-2  in Loop 18 
   - Found a solution using cacheing 
 * Adding constraints: [aux(10)=<aux(42),aux(42)=<it(18)*aux(41),aux(42)+aux(5)=<it(17)+aux(40)] 

##### Pending set part(A,B,C,D,E,F,G,H,I)
* Psum in Loop 19: [it(19)=<1,aux(11)=<B-2]
* Psum in Loop 20: [it(20)=<1,aux(6)=<D-2,aux(12)=<D-2,aux(26)=<D-2,aux(31)=<D-2]
* Psum in Chain-Tail [15]: [it([15])=<1]

###### Computing sum for it(19)=<1  in Loop 19 
   - Applying inductive sum strategy 
     - head Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: B+F-2 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B+F-2 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(18)+it(19)=<it(17)+aux(43),it(18)+it(19)=<aux(26)+aux(25)+aux(24)+aux(44),it(18)+it(19)=<it(17)+aux(45),it(18)+it(19)=<aux(31)+aux(30)+aux(29)+aux(46),aux(43)=<B-1,aux(44)=<B+F-2,aux(45)=<B-1,aux(46)=<B+F-2] 

##### Pending set part(A,B,C,D,E,F,G,H,I)
* Psum in Loop 19: [aux(11)=<B-2]
* Psum in Loop 20: [it(20)=<1,aux(6)=<D-2,aux(12)=<D-2,aux(26)=<D-2,aux(31)=<D-2]
* Psum in Chain-Tail [15]: [it([15])=<1]

###### Computing sum for aux(11)=<B-2  in Loop 19 
   - Applying inductive sum strategy 
     - head Candidate: B-2 
       - The candidate was classified before. We reuse its previous classification 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(48)=<B-2] 
 * Adding constraints: [aux(11)=<it(19)*aux(48),aux(4)+aux(11)=<it(17)+aux(47),aux(47)=<B-2] 

##### Pending set part(A,B,C,D,E,F,G,H,I)
* Pmax/min: [aux(48)=<B-2]
* Psum in Loop 20: [it(20)=<1,aux(6)=<D-2,aux(12)=<D-2,aux(26)=<D-2,aux(31)=<D-2]
* Psum in Chain-Tail [15]: [it([15])=<1]

###### Computing max_min for aux(48)=<B-2  
   - Found a solution using cacheing 
 * Adding constraints:[aux(48)=<aux(41)] 

##### Pending set part(A,B,C,D,E,F,G,H,I)
* Psum in Loop 20: [it(20)=<1,aux(6)=<D-2,aux(12)=<D-2,aux(26)=<D-2,aux(31)=<D-2]
* Psum in Chain-Tail [15]: [it([15])=<1]

###### Computing sum for it(20)=<1  in Loop 20 
   - Applying inductive sum strategy 
     - head Candidate: D-1 
       - Loop 13 is collaborative
       - Loop 14 is collaborative
       - Loop 16 adds a constant 1/1 
       - Loop 17 is collaborative
       - Loop 18 is collaborative
       - Loop 19 is collaborative
       - Chain-Tail [15] is collaborative
     - head Candidate: D+F-2 
       - Loop 13 adds an expression [B-3]
       - Loop 14 adds an expression [B-3]
       - Loop 16 is collaborative
       - Loop 17 is collaborative
       - Loop 18 adds an expression [B-2]
       - Loop 19 adds an expression [B-2]
       - Chain-Tail [15] is collaborative
     - tail Candidate: D-1 
       - Loop 13 is collaborative
       - Loop 14 is collaborative
       - Loop 16 adds a constant 1/1 
       - Loop 17 is collaborative
       - Loop 18 is collaborative
       - Loop 19 is collaborative
       - Chain-Tail [15] is collaborative
     - tail Candidate: D+F-2 
       - Loop 13 adds an expression [B-3]
       - Loop 14 adds an expression [B-3]
       - Loop 16 is collaborative
       - Loop 17 is collaborative
       - Loop 18 adds an expression [B-2]
       - Loop 19 adds an expression [B-2]
       - Chain-Tail [15] is collaborative
 * Adding constraints: [it(20)=<it(16)+aux(49),it(20)=<aux(53)+aux(52)+aux(51)+aux(50)+aux(54),it(20)=<it(16)+aux(55),it(20)=<aux(59)+aux(58)+aux(57)+aux(56)+aux(60),aux(49)=<D-1,aux(54)=<D+F-2,aux(55)=<D-1,aux(60)=<D+F-2] 

##### Pending set part(A,B,C,D,E,F,G,H,I)
* Psum in Loop 13: [aux(50)=<B-3,aux(56)=<B-3]
* Psum in Loop 14: [aux(51)=<B-3,aux(57)=<B-3]
* Psum in Loop 18: [aux(52)=<B-2,aux(58)=<B-2]
* Psum in Loop 19: [aux(53)=<B-2,aux(59)=<B-2]
* Psum in Loop 20: [aux(6)=<D-2,aux(12)=<D-2,aux(26)=<D-2,aux(31)=<D-2]
* Psum in Chain-Tail [15]: [it([15])=<1]

###### Computing sum for aux(50)=<B-3  in Loop 13 
   - Applying inductive sum strategy 
     - head Candidate: B-3 
       - Loop 14 is collaborative and bounds [aux(51)] 
       - Loop 16 is collaborative
       - Loop 17 adds a constant 1/1 
       - Loop 18 is collaborative
       - Loop 19 is collaborative
       - Loop 20 is collaborative
       - Chain [15] is ignored
     - head Candidate: B 
       - Loop 14 is collaborative and bounds [aux(51)] 
       - Loop 16 is collaborative
       - Loop 17 adds a constant 1/1 
       - Loop 18 is collaborative and bounds [aux(52)] 
       - Loop 19 is collaborative and bounds [aux(53)] 
       - Loop 20 is collaborative
       - Chain-Tail [15] is collaborative and bounds [it([15])] 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(63)=<B-3] 
 * Adding constraints: [aux(50)=<it(13)*aux(63),aux(50)+aux(51)=<it(17)+aux(61),aux(50)+aux(51)+aux(52)+aux(53)+it([15])=<it(17)+aux(62),aux(61)=<B-3,aux(62)=<B] 

##### Pending set part(A,B,C,D,E,F,G,H,I)
* Pmax/min: [aux(63)=<B-3]
* Psum in Loop 13: [aux(56)=<B-3]
* Psum in Loop 14: [aux(57)=<B-3]
* Psum in Loop 18: [aux(52)=<B-2,aux(58)=<B-2]
* Psum in Loop 19: [aux(53)=<B-2,aux(59)=<B-2]
* Psum in Loop 20: [aux(6)=<D-2,aux(12)=<D-2,aux(26)=<D-2,aux(31)=<D-2]
* Psum in Chain-Tail [15]: [it([15])=<1]

###### Computing max_min for aux(63)=<B-3  
   - Found a solution using cacheing 
 * Adding constraints:[aux(63)=<aux(41)-1] 

##### Pending set part(A,B,C,D,E,F,G,H,I)
* Psum in Loop 13: [aux(56)=<B-3]
* Psum in Loop 14: [aux(57)=<B-3]
* Psum in Loop 18: [aux(52)=<B-2,aux(58)=<B-2]
* Psum in Loop 19: [aux(53)=<B-2,aux(59)=<B-2]
* Psum in Loop 20: [aux(6)=<D-2,aux(12)=<D-2,aux(26)=<D-2,aux(31)=<D-2]
* Psum in Chain-Tail [15]: [it([15])=<1]

###### Computing sum for aux(56)=<B-3  in Loop 13 
   - Found a solution using cacheing 
 * Adding constraints: [aux(56)=<aux(64),aux(64)=<it(13)*aux(63),aux(64)+aux(51)=<it(17)+aux(61),aux(64)+aux(51)+aux(52)+aux(53)+it([15])=<it(17)+aux(62)] 

##### Pending set part(A,B,C,D,E,F,G,H,I)
* Psum in Loop 14: [aux(57)=<B-3]
* Psum in Loop 18: [aux(52)=<B-2,aux(58)=<B-2]
* Psum in Loop 19: [aux(53)=<B-2,aux(59)=<B-2]
* Psum in Loop 20: [aux(6)=<D-2,aux(12)=<D-2,aux(26)=<D-2,aux(31)=<D-2]
* Psum in Chain-Tail [15]: [it([15])=<1]

###### Computing sum for aux(57)=<B-3  in Loop 14 
   - Applying inductive sum strategy 
     - head Candidate: B-3 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: B 
       - The candidate was classified before. We reuse its previous classification 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(67)=<B-3] 
 * Adding constraints: [aux(57)=<it(14)*aux(67),aux(50)+aux(57)=<it(17)+aux(65),aux(50)+aux(52)+aux(53)+aux(57)+it([15])=<it(17)+aux(66),aux(65)=<B-3,aux(66)=<B] 

##### Pending set part(A,B,C,D,E,F,G,H,I)
* Pmax/min: [aux(67)=<B-3]
* Psum in Loop 18: [aux(52)=<B-2,aux(58)=<B-2]
* Psum in Loop 19: [aux(53)=<B-2,aux(59)=<B-2]
* Psum in Loop 20: [aux(6)=<D-2,aux(12)=<D-2,aux(26)=<D-2,aux(31)=<D-2]
* Psum in Chain-Tail [15]: [it([15])=<1]

###### Computing max_min for aux(67)=<B-3  
   - Found a solution using cacheing 
 * Adding constraints:[aux(67)=<aux(41)-1] 

##### Pending set part(A,B,C,D,E,F,G,H,I)
* Psum in Loop 18: [aux(52)=<B-2,aux(58)=<B-2]
* Psum in Loop 19: [aux(53)=<B-2,aux(59)=<B-2]
* Psum in Loop 20: [aux(6)=<D-2,aux(12)=<D-2,aux(26)=<D-2,aux(31)=<D-2]
* Psum in Chain-Tail [15]: [it([15])=<1]

###### Computing sum for aux(52)=<B-2  in Loop 18 
   - Found a solution using cacheing 
 * Adding constraints: [aux(52)=<aux(68),aux(68)=<it(18)*aux(41),aux(68)+aux(5)=<it(17)+aux(40)] 

##### Pending set part(A,B,C,D,E,F,G,H,I)
* Psum in Loop 18: [aux(58)=<B-2]
* Psum in Loop 19: [aux(53)=<B-2,aux(59)=<B-2]
* Psum in Loop 20: [aux(6)=<D-2,aux(12)=<D-2,aux(26)=<D-2,aux(31)=<D-2]
* Psum in Chain-Tail [15]: [it([15])=<1]

###### Computing sum for aux(58)=<B-2  in Loop 18 
   - Found a solution using cacheing 
 * Adding constraints: [aux(58)=<aux(69),aux(69)=<it(18)*aux(41),aux(69)+aux(5)=<it(17)+aux(40)] 

##### Pending set part(A,B,C,D,E,F,G,H,I)
* Psum in Loop 19: [aux(53)=<B-2,aux(59)=<B-2]
* Psum in Loop 20: [aux(6)=<D-2,aux(12)=<D-2,aux(26)=<D-2,aux(31)=<D-2]
* Psum in Chain-Tail [15]: [it([15])=<1]

###### Computing sum for aux(53)=<B-2  in Loop 19 
   - Found a solution using cacheing 
 * Adding constraints: [aux(53)=<aux(70),aux(70)=<it(19)*aux(48),aux(70)+aux(4)=<it(17)+aux(47)] 

##### Pending set part(A,B,C,D,E,F,G,H,I)
* Psum in Loop 19: [aux(59)=<B-2]
* Psum in Loop 20: [aux(6)=<D-2,aux(12)=<D-2,aux(26)=<D-2,aux(31)=<D-2]
* Psum in Chain-Tail [15]: [it([15])=<1]

###### Computing sum for aux(59)=<B-2  in Loop 19 
   - Found a solution using cacheing 
 * Adding constraints: [aux(59)=<aux(71),aux(71)=<it(19)*aux(48),aux(71)+aux(4)=<it(17)+aux(47)] 

##### Pending set part(A,B,C,D,E,F,G,H,I)
* Psum in Loop 20: [aux(6)=<D-2,aux(12)=<D-2,aux(26)=<D-2,aux(31)=<D-2]
* Psum in Chain-Tail [15]: [it([15])=<1]

###### Computing sum for aux(6)=<D-2  in Loop 20 
   - Applying inductive sum strategy 
     - head Candidate: D-2 
       - Loop 13 is collaborative
       - Loop 14 is collaborative
       - Loop 16 adds a constant 1/1 
       - Loop 17 is collaborative
       - Loop 18 is collaborative
       - Loop 19 is collaborative
       - Chain [15] is ignored
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(73)=<D-2] 
 * Adding constraints: [aux(6)=<it(20)*aux(73),aux(6)=<it(16)+aux(72),aux(72)=<D-2] 

##### Pending set part(A,B,C,D,E,F,G,H,I)
* Pmax/min: [aux(73)=<D-2]
* Psum in Loop 20: [aux(12)=<D-2,aux(26)=<D-2,aux(31)=<D-2]
* Psum in Chain-Tail [15]: [it([15])=<1]

###### Computing max_min for aux(73)=<D-2  
   - Found a solution using cacheing 
 * Adding constraints:[aux(73)=<aux(35)+1] 

##### Pending set part(A,B,C,D,E,F,G,H,I)
* Psum in Loop 20: [aux(12)=<D-2,aux(26)=<D-2,aux(31)=<D-2]
* Psum in Chain-Tail [15]: [it([15])=<1]

###### Computing sum for aux(12)=<D-2  in Loop 20 
   - Found a solution using cacheing 
 * Adding constraints: [aux(12)=<aux(74),aux(74)=<it(20)*aux(73),aux(74)=<it(16)+aux(72)] 

##### Pending set part(A,B,C,D,E,F,G,H,I)
* Psum in Loop 20: [aux(26)=<D-2,aux(31)=<D-2]
* Psum in Chain-Tail [15]: [it([15])=<1]

###### Computing sum for aux(26)=<D-2  in Loop 20 
   - Found a solution using cacheing 
 * Adding constraints: [aux(26)=<aux(75),aux(75)=<it(20)*aux(73),aux(75)=<it(16)+aux(72)] 

##### Pending set part(A,B,C,D,E,F,G,H,I)
* Psum in Loop 20: [aux(31)=<D-2]
* Psum in Chain-Tail [15]: [it([15])=<1]

###### Computing sum for aux(31)=<D-2  in Loop 20 
   - Found a solution using cacheing 
 * Adding constraints: [aux(31)=<aux(76),aux(76)=<it(20)*aux(73),aux(76)=<it(16)+aux(72)] 

##### Pending set part(A,B,C,D,E,F,G,H,I)
* Psum in Chain-Tail [15]: [it([15])=<1]

###### Computing sum for it([15])=<1  in Chain-Tail [15] 
   - Applying inductive sum strategy 
     - head Candidate: B/2+D/2+F/2-1/2 
       - Loop 13 is collaborative
       - Loop 14 is collaborative
       - Loop 16 is collaborative
       - Loop 17 is collaborative
       - Loop 18 is collaborative
       - Loop 19 is collaborative
       - Loop 20 is collaborative
     - head Candidate: B 
       - Loop 13 is collaborative
       - Loop 14 is collaborative
       - Loop 16 is collaborative
       - Loop 17 adds a constant 1/1 
       - Loop 18 is collaborative
       - Loop 19 is collaborative
       - Loop 20 is collaborative
 * Adding constraints: [it([15])=<it(17)+aux(77),it([15])=<B/2+D/2+F/2-1/2,aux(77)=<B] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [13,14,16,17,18,19,20,[15]] 
Found a cycle in the non-final constraints
 Removed possibly redundant constraints to solve a cycle in the cost structure 
it([15])=<it(17)+aux(77)
Found a cycle in the non-final constraints
Could not solve cycle in cost structure.
 Discarded constraints:  
aux(76)=<it(16)+aux(72)
aux(76)=<it(20)*aux(73)
aux(31)=<aux(76)
aux(75)=<it(16)+aux(72)
aux(75)=<it(20)*aux(73)
aux(26)=<aux(75)
aux(74)=<it(16)+aux(72)
aux(74)=<it(20)*aux(73)
aux(12)=<aux(74)
aux(6)=<it(16)+aux(72)
aux(6)=<it(20)*aux(73)
aux(4)+aux(71)=<it(17)+aux(47)
aux(71)=<it(19)*aux(48)
aux(59)=<aux(71)
aux(4)+aux(70)=<it(17)+aux(47)
aux(70)=<it(19)*aux(48)
aux(53)=<aux(70)
aux(5)+aux(69)=<it(17)+aux(40)
aux(69)=<it(18)*aux(41)
aux(58)=<aux(69)
aux(5)+aux(68)=<it(17)+aux(40)
aux(68)=<it(18)*aux(41)
aux(52)=<aux(68)
aux(50)+aux(52)+aux(53)+aux(57)+it([15])=<it(17)+aux(66)
aux(50)+aux(57)=<it(17)+aux(65)
aux(57)=<it(14)*aux(67)
aux(51)+aux(52)+aux(53)+aux(64)+it([15])=<it(17)+aux(62)
aux(51)+aux(64)=<it(17)+aux(61)
aux(64)=<it(13)*aux(63)
aux(56)=<aux(64)
aux(50)+aux(51)+aux(52)+aux(53)+it([15])=<it(17)+aux(62)
aux(50)+aux(51)=<it(17)+aux(61)
aux(50)=<it(13)*aux(63)
it(20)=<aux(59)+aux(58)+aux(57)+aux(56)+aux(60)
it(20)=<it(16)+aux(55)
it(20)=<aux(53)+aux(52)+aux(51)+aux(50)+aux(54)
it(20)=<it(16)+aux(49)
aux(4)+aux(11)=<it(17)+aux(47)
aux(11)=<it(19)*aux(48)
it(18)+it(19)=<aux(31)+aux(30)+aux(29)+aux(46)
it(18)+it(19)=<it(17)+aux(45)
it(18)+it(19)=<aux(26)+aux(25)+aux(24)+aux(44)
it(18)+it(19)=<it(17)+aux(43)
aux(5)+aux(42)=<it(17)+aux(40)
aux(42)=<it(18)*aux(41)
aux(10)=<aux(42)
aux(4)+aux(5)=<it(17)+aux(40)
aux(4)=<it(18)*aux(41)
aux(24)+aux(30)+it(20)+it([15])=<it(16)+aux(38)
aux(24)+aux(30)=<it(16)+aux(37)
aux(30)=<it(14)*aux(39)
aux(25)+aux(36)+it(20)+it([15])=<it(16)+aux(34)
aux(25)+aux(36)=<it(16)+aux(33)
aux(36)=<it(13)*aux(35)
aux(29)=<aux(36)
aux(24)+aux(25)+it(20)+it([15])=<it(16)+aux(34)
aux(24)+aux(25)=<it(16)+aux(33)
aux(24)=<it(13)*aux(35)
it(18)+it(19)=<aux(31)+aux(30)+aux(29)+aux(32)
it(18)+it(19)=<it(17)+aux(28)
it(18)+it(19)=<aux(26)+aux(25)+aux(24)+aux(27)
it(18)+it(19)=<it(17)+aux(23)
it(16)+it(17)=<aux(12)+aux(11)+aux(10)+aux(9)+aux(8)+aux(22)
it(16)+it(17)=<aux(6)+aux(5)+aux(4)+aux(3)+aux(2)+aux(21)
aux(2)+aux(9)=<it(17)+it(16)+aux(19)
aux(2)+aux(9)+it(18)+it(19)+it(20)+it([15])=<it(17)+it(16)+aux(18)
aux(9)=<it(14)*aux(20)
aux(3)+aux(17)=<it(17)+it(16)+aux(15)
aux(3)+aux(17)+it(18)+it(19)+it(20)+it([15])=<it(17)+it(16)+aux(14)
aux(17)=<it(13)*aux(16)
aux(8)=<aux(17)
aux(2)+aux(3)=<it(17)+it(16)+aux(15)
aux(2)+aux(3)+it(18)+it(19)+it(20)+it([15])=<it(17)+it(16)+aux(14)
aux(2)=<it(13)*aux(16)
it(16)+it(17)=<aux(12)+aux(11)+aux(10)+aux(9)+aux(8)+aux(13)
it(16)+it(17)=<aux(6)+aux(5)+aux(4)+aux(3)+aux(2)+aux(7)
it(13)+it(14)+it(20)=<it(16)+aux(1)

#### Simplifying cost structure of phase [13,14,16,17,18,19,20,[15]] 
 * Joined equivalent variables [aux(78),aux(23),aux(28),aux(40),aux(43),aux(45),aux(47),aux(61),aux(62),aux(65),aux(66),aux(77)] into aux(78)
 * Joined equivalent variables [aux(79),aux(14),aux(15),aux(18),aux(19)] into aux(79)
 * Joined equivalent variables [aux(81),aux(27),aux(32),aux(44),aux(46)] into aux(81)
 * Joined equivalent variables [aux(83),aux(1),aux(33),aux(34),aux(37),aux(38),aux(49),aux(55),aux(72)] into aux(83)
 * Joined equivalent variables [aux(84),aux(54),aux(60)] into aux(84)
 * Joined equivalent variables [aux(85),aux(7),aux(13),aux(21),aux(22)] into aux(85)
 * Joined equivalent variables [aux(63),aux(67)] into aux(63)
 * Joined equivalent variables [it(16),it(17),it(18),it(19),it(20),s(5),s(6)] into it(16)
 * Joined equivalent variables [it(13),it(14),it([15])] into it(13)

#### Cost of phase [13,14,16,17,18,19,20]:part(A,B,C,D,E,F,G,H,I) -> [] 
54*it(13)+75*it(16)+0
  Such that:aux(82) =< B/2+D/2+F/2
it(13) =< aux(82)

Unbounded itvars
it(16) :  it(16)

#### Cost of chains of part(A,B,C,D,E,F,G,H,I):
* Chain [multiple([13,14,16,17,18,19,20],[[],[15]])]...: 54*it(13)+75*it(16)+0
  Such that:aux(82) =< B/2+D/2+F/2
it(13) =< aux(82)

Unbounded itvars
it(16) :  it(16)

  with precondition: [B+D>=1,D>=0,A+D>=1,D+F>=2,B+F>=2,F>=1,B>=0,A>=0,H>=0,H+2*F>=4,B+D+2*F>=5,G>=0,E>=0,C>=0,I>=0] 

* Chain [15]: 14
  with precondition: [B=1,D=1,F=1,H=2,A>=0,C>=0,E>=0,G>=0,I>=A] 

 * Renamed intermediate variables: 
[ (eq(22,1),aux(82))>>s(7), (eq(22,1),it(13))>>s(8), (eq(22,1),it(16))>>s(9)]

#### Simplifying cost structure of CE 22 

#### Simplifying cost structure of CE 23 

#### Simplifying cost structure of CE 21 

#### Cost of chains of qs(A,B,C,D):
* Chain [23]...: 54*s(8)+75*s(9)+6
  Such that:s(7) =< A/2+1/2
s(8) =< s(7)

Unbounded itvars
s(9) :  eq(22,1),it(16)

  with precondition: [B>=0,C>=0,D>=0,2*A>=5,C+2*A>=6] 

* Chain [22]: 3
  with precondition: [A=1,C=1,B>=0,D>=0] 

* Chain [21]: 20
  with precondition: [A=2,C=2,B>=0,D>=0] 


Closed-form bounds of append(A,B,C,D,E,F,G,H,I,J,K,L): 
-------------------------------------
* Chain [[11],12] with precondition: [A=C,L=D+H,A+E=I+1,A+G=K+1,A>=2,B>=0,E>=1,F>=0,G>=1,J>=0,D+1>=A,L>=D,B+F>=J] 
    - Upper bound: 5*A+2 
    - Complexity: n 
* Chain [12] with precondition: [A=1,C=1,D=0,E=I,F=J,G=K,H=L,B>=0,E>=0,F>=0,G>=0,H>=0] 
    - Upper bound: 2 
    - Complexity: constant 

### Maximum cost of append(A,B,C,D,E,F,G,H,I,J,K,L): 5*A+2 
Asymptotic class: n 

Closed-form bounds of part(A,B,C,D,E,F,G,H,I): 
-------------------------------------
* Chain [multiple([13,14,16,17,18,19,20],[[],[15]])]... with precondition: [B+D>=1,D>=0,A+D>=1,D+F>=2,B+F>=2,F>=1,B>=0,A>=0,H>=0,H+2*F>=4,B+D+2*F>=5,G>=0,E>=0,C>=0,I>=0] 
    - Upper bound: inf 
    - Complexity: infinity 
* Chain [15] with precondition: [B=1,D=1,F=1,H=2,A>=0,C>=0,E>=0,G>=0,I>=A] 
    - Upper bound: 14 
    - Complexity: constant 

### Maximum cost of part(A,B,C,D,E,F,G,H,I): inf 
Asymptotic class: infinity 

Closed-form bounds of qs(A,B,C,D): 
-------------------------------------
* Chain [23]... with precondition: [B>=0,C>=0,D>=0,2*A>=5,C+2*A>=6] 
    - Upper bound: inf 
    - Complexity: infinity 
* Chain [22] with precondition: [A=1,C=1,B>=0,D>=0] 
    - Upper bound: 3 
    - Complexity: constant 
* Chain [21] with precondition: [A=2,C=2,B>=0,D>=0] 
    - Upper bound: 20 
    - Complexity: constant 

### Maximum cost of qs(A,B,C,D): inf 
Asymptotic class: infinity 
* Total analysis performed in 1638 ms.


Cost relation system solved by CoFloCo in 1639 ms.

Method append terminates?: YES

 - l1_1: size of l1 wrt. List<Rat>
 - l1_2: size of l1 wrt. Rat
 - l1_3: size of l1 wrt. List<A>
 - l1_4: size of l1 wrt. A
 - l2_1: size of l2 wrt. List<Rat>
 - l2_2: size of l2 wrt. Rat
 - l2_3: size of l2 wrt. List<A>
 - l2_4: size of l2 wrt. A
UB for append(l1_1,l1_2,l1_3,l1_4,l2_1,l2_2,l2_3,l2_4) = 5*l1_1+2

Method part terminates?: YES

 - y_1: size of y wrt. Rat
 - l_1: size of l wrt. List<Rat>
 - l_2: size of l wrt. Rat
 - r_1: size of r wrt. List<Rat>
 - r_2: size of r wrt. Rat
 - xs_1: size of xs wrt. List<Rat>
 - xs_2: size of xs wrt. Rat
UB for part(y_1,l_1,l_2,r_1,r_2,xs_1,xs_2) = inf

Method qs terminates?: YES

 - l_1: size of l wrt. List<Rat>
 - l_2: size of l wrt. Rat
UB for qs(l_1,l_2) = inf
