
Abs program loaded in 15 ms.

Rule based representation generated in 2 ms.

Rule based representation stored in /tmp/costabs/rbr.rbr

RBR properties stored in /tmp/costabs/rbr.properties

Class invariants generated and loaded in 0 ms.

Abstract compilation performed in 13 ms.

Cost relation system stored in /tmp/costabs/crs.crs

Generated 48 equations 
entry('firstline'(A,B,C,D):[]).
entry('newline'(A,B,C,D,E,F,G):[]).
entry('lcstable'(A,B,C,D,E,F,G):[]).
entry('lcs'(A,B,C,D,E):[]).
input_output_vars('and_op'(A,B,C),[A,B],[C]).
input_output_vars('case_0'(A,B,C,D),[A,B],[C,D]).
input_output_vars('case_1'(A,B,C),[A,B],[C]).
input_output_vars('case_2'(A,B,C),[A,B],[C]).
input_output_vars('case_3'(A,B,C,D,E,F,G),[A,B,C,D,E],[F,G]).
input_output_vars('case_4'(A,B,C,D,E,F,G,H,I,J),[A,B,C,D,E,F,G,H],[I,J]).
input_output_vars('case_5'(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P),[A,B,C,D,E,F,G,H,I,J,K,L,M,N,O],[P]).
input_output_vars('case_6'(A,B,C,D,E,F,G),[A,B,C,D],[E,F,G]).
input_output_vars('case_7'(A,B,C,D,E,F,G,H,I,J,K,L,M),[A,B,C,D,E,F,G,H,I,J],[K,L,M]).
input_output_vars('case_8'(A,B,C,D,E,F,G,H),[A,B,C,D,E,F,G],[H]).
input_output_vars('case_9'(A,B,C,D,E,F,G,H,I,J),[A,B,C,D,E,F,G,H,I],[J]).
input_output_vars('eq'(A,B,C),[A,B],[C]).
input_output_vars('firstline'(A,B,C,D),[A,B],[C,D]).
input_output_vars('geq'(A,B,C),[A,B],[C]).
input_output_vars('gt'(A,B,C),[A,B],[C]).
input_output_vars('head_or_zero'(A,B,C),[A,B],[C]).
input_output_vars('lcs'(A,B,C,D,E),[A,B,C,D],[E]).
input_output_vars('lcstable'(A,B,C,D,E,F,G),[A,B,C,D],[E,F,G]).
input_output_vars('leq'(A,B,C),[A,B],[C]).
input_output_vars('lt'(A,B,C),[A,B],[C]).
input_output_vars('maxNorm'(A,B,C),[A,B],[C]).
input_output_vars('max_raml'(A,B,C),[A,B],[C]).
input_output_vars('neg'(A,B),[A],[B]).
input_output_vars('neq'(A,B,C),[A,B],[C]).
input_output_vars('newline'(A,B,C,D,E,F,G),[A,B,C,D,E],[F,G]).
input_output_vars('or'(A,B,C),[A,B],[C]).
eq('eq',[A,B,C],0,[],[A=B,C=1,A>=0,B>=0,C>=0]).
eq('eq',[A,B,C],0,[],[A>=B+1,C=0,A>=0,B>=0,C>=0]).
eq('eq',[A,B,C],0,[],[B>=A+1,C=0,A>=0,B>=0,C>=0]).
eq('neq',[A,B,C],0,[],[A=B,C=0,A>=0,B>=0,C>=0]).
eq('neq',[A,B,C],0,[],[A>=B+1,C=1,A>=0,B>=0,C>=0]).
eq('neq',[A,B,C],0,[],[B>=A+1,C=1,A>=0,B>=0,C>=0]).
eq('lt',[A,B,C],0,[],[B-A>=1,C=1,A>=0,B>=0,C>=0]).
eq('lt',[A,B,C],0,[],[B=<A,C=0,A>=0,B>=0,C>=0]).
eq('leq',[A,B,C],0,[],[A=<B,C=1,A>=0,B>=0,C>=0]).
eq('leq',[A,B,C],0,[],[A-B>=1,C=0,A>=0,B>=0,C>=0]).
eq('gt',[A,B,C],0,[],[A-B>=1,C=1,A>=0,B>=0,C>=0]).
eq('gt',[A,B,C],0,[],[A=<B,C=0,A>=0,B>=0,C>=0]).
eq('geq',[A,B,C],0,[],[B=<A,C=1,A>=0,B>=0,C>=0]).
eq('geq',[A,B,C],0,[],[B-A>=1,C=0,A>=0,B>=0,C>=0]).
eq('neg',[A,B],0,[],[A=0,B=1,A>=0,B>=0]).
eq('neg',[A,B],0,[],[A=1,B=0,A>=0,B>=0]).
eq('and_op',[A,B,C],0,[],[A=0,C=0,A>=0,B>=0,C>=0]).
eq('and_op',[A,B,C],0,[],[A=1,C=B,A>=0,B>=0,C>=0]).
eq('or',[A,B,C],0,[],[A=1,C=1,A>=0,B>=0,C>=0]).
eq('or',[A,B,C],0,[],[A=0,C=B,A>=0,B>=0,C>=0]).
eq('maxNorm',[A,B,A],0,[],[A>=1+B,A>=0,B>=0,A>=0]).
eq('maxNorm',[A,B,B],0,[],[A=<B,A>=0,B>=0,B>=0]).
eq('case_0',[A,B,C,D],2,[],[A=1,C=1,A>=0,B>=0,C>=0,D>=0]).
eq('case_0',[A,B,C,D],5,['firstline'(E,F,G,H)],[B=I+F,A=E+1,E>=1,J=0,D=J+H,C=G+1,G>=1,A>=0,B>=0,C>=0,D>=0]).
eq('firstline',[A,B,C,D],1,['case_0'(A,B,C,D)],[A>=0,B>=0,C>=0,D>=0]).
eq('case_1',[A,B,A],1,[],[A>=B+1,A>=0,B>=0,A>=0]).
eq('case_1',[A,B,B],1,[],[B>=A,A>=0,B>=0,B>=0]).
eq('max_raml',[A,B,C],1,['case_1'(A,B,C)],[A>=0,B>=0,C>=0]).
eq('case_2',[A,B,C],1,[],[B=C+D,A=E+1,E>=1,A>=0,B>=0,C>=0]).
eq('case_2',[A,B,C],3,[],[A=1,C=0,A>=0,B>=0,C>=0]).
eq('head_or_zero',[A,B,C],1,['case_2'(A,B,C)],[A>=0,B>=0,C>=0]).
eq('case_3',[A,B,C,D,E,F,G],2,[],[D=1,F=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0]).
eq('case_4',[A,B,C,D,E,F,G,H,I,J],2,[],[B=1,I=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0]).
eq('case_5',[A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P],3,[],[J=E,Q=1,P=A+Q,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0,M>=0,N>=0,O>=0,P>=0]).
eq('case_5',[A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P],2,['max_raml'(M,B,P)],[J>=E+1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0,M>=0,N>=0,O>=0,P>=0]).
eq('case_4',[A,B,C,D,E,F,G,H,I,J],15,['newline'(A,K,L,G,H,M,N),'head_or_zero'(O,P,Q),'head_or_zero'(K,L,R),'case_5'(S,T,O,P,A,B,C,D,E,F,G,H,U,K,L,V)],[C=U+L,B=K+1,K>=1,P=N,O=M,M>=1,T=Q,S=R,W=V,X=W+P,Y=O+1,O>=1,Z=X,A1=Y,Y>=1,B1=Z,C1=A1,A1>=1,D1=B1,E1=C1,C1>=1,J=D1,I=E1,E1>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0]).
eq('case_3',[A,B,C,D,E,F,G],3,['case_4'(A,B,C,D,E,H,I,J,F,G)],[E=H+J,D=I+1,I>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0]).
eq('newline',[A,B,C,D,E,F,G],1,['case_3'(A,B,C,D,E,F,G)],[A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0]).
eq('case_6',[A,B,C,D,E,F,G],4,['firstline'(C,D,H,I)],[A=1,J=0,K=1,G=I+L,F=H+J,E=K+1,K>=1,H>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0]).
eq('case_7',[A,B,C,D,E,F,G,H,I,J,K,L,M],2,[],[B=0,A=1,L=0,K=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0,M>=0]).
eq('case_7',[A,B,C,D,E,F,G,H,I,J,K,L,M],5,['newline'(H,N,O,F,G,P,Q)],[C=O+R,B=N+S,A=T+1,T>=1,N>=1,U=O+R,V=N+S,W=T+1,T>=1,N>=1,M=Q+U,L=P+V,K=W+1,W>=1,P>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0,M>=0]).
eq('case_6',[A,B,C,D,E,F,G],6,['lcstable'(H,I,C,D,J,K,L),'case_7'(M,N,O,A,B,C,D,P,H,I,Q,R,S)],[B=P+I,A=H+1,H>=1,O=L,N=K,M=J,J>=1,G=S,F=R,E=Q,Q>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0]).
eq('lcstable',[A,B,C,D,E,F,G],1,['case_6'(A,B,C,D,E,F,G)],[A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0]).
eq('case_8',[A,B,C,D,E,F,G,H],2,[],[B=0,A=1,H=0,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0]).
eq('case_9',[A,B,C,D,E,F,G,D,E,H],2,[],[D=1,H=0,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,D>=0,E>=0,H>=0]).
eq('case_9',[A,B,C,D,E,F,G,D,E,H],2,[],[E=H+I,D=J+1,J>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,D>=0,E>=0,H>=0]).
eq('case_8',[A,B,C,D,E,F,G,H],3,['case_9'(A,B,C,D,E,F,G,D,E,H)],[C=E+I,B=D+J,J>=1,A=K+1,K>=1,D>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0]).
eq('lcs',[A,B,C,D,E],4,['lcstable'(A,B,C,D,F,G,H),'case_8'(I,J,K,A,B,C,D,L)],[K=H,J=G,I=F,F>=1,E=L,A>=0,B>=0,C>=0,D>=0,E>=0]).

Preprocessing Cost Relations
=====================================

#### Computed strongly connected components 
0. recursive  : [case_0/4,firstline/4]
1. non_recursive  : [case_9/10]
2. non_recursive  : [case_8/8]
3. non_recursive  : [case_1/3]
4. non_recursive  : [max_raml/3]
5. non_recursive  : [case_5/16]
6. non_recursive  : [case_2/3]
7. non_recursive  : [head_or_zero/3]
8. recursive [non_tail] : [case_3/7,case_4/10,newline/7]
9. non_recursive  : [case_7/13]
10. recursive [non_tail] : [case_6/7,lcstable/7]
11. non_recursive  : [lcs/5]
Warning: the following predicates are never called:[and_op/3,eq/3,geq/3,gt/3,leq/3,lt/3,maxNorm/3,neg/2,neq/3,or/3]

#### Obtained direct recursion through partial evaluation 
0. SCC is partially evaluated into firstline/4
1. SCC is partially evaluated into case_9/10
2. SCC is partially evaluated into case_8/8
3. SCC is partially evaluated into case_1/3
4. SCC is completely evaluated into other SCCs
5. SCC is partially evaluated into case_5/16
6. SCC is partially evaluated into case_2/3
7. SCC is completely evaluated into other SCCs
8. SCC is partially evaluated into newline/7
9. SCC is partially evaluated into case_7/13
10. SCC is partially evaluated into lcstable/7
11. SCC is partially evaluated into lcs/5

Control-Flow Refinement of Cost Relations
=====================================

### Specialization of cost equations firstline/4 
* CE 2 is refined into CE [21] 
* CE 1 is refined into CE [22] 


#### Refined cost equations firstline/4 
* CE 21: firstline(A,B,C,D) = 3
     [D>=0,B>=0,C=1,A=1] 
* CE 22: firstline(A,B,C,D) = 6+ firstline(E,F,G,D)
     [G>=1,E>=1,D>=0,B>=0,G+1=C,E+1=A] 

### Cost equations --> "Loop" of firstline/4 
* CEs [22] --> Loop 21 
* CEs [21] --> Loop 22 

#### Loops of firstline/4 
* Loop 21: firstline(A,B,C,D)->  firstline(A',B',C',D)
                  [C'>=1,A'>=1,D>=0,B>=0,C'+1=C,A'+1=A] 
* Loop 22: firstline(A,B,C,D) [D>=0,B>=0,C=1,A=1] 

### Ranking functions of CR firstline(A,B,C,D) 
* RF of phase [21]: [A-1]

#### Partial ranking functions of CR firstline(A,B,C,D) 
* Partial RF of phase [21]:
  - RF of loop [21:1]:
    A-1

Discarded unfeasible chain [[21]]...(Non-terminating chain proved terminating)

### Resulting Chains:firstline(A,B,C,D) 
* [[21],22]
* [22]


### Merging Chains  firstline/4 into  External patterns of execution 
* [[22]] --> 1 
* [[22,[21]]] --> 2 


### Specialization of cost equations case_9/10 
* CE 20 is refined into CE [23] 
* CE 19 is refined into CE [24] 


#### Refined cost equations case_9/10 
* CE 23: case_9(A,B,C,D,E,F,G,D,E,H) = 2
     [B>=D+1,H>=0,G>=0,F>=0,E>=0,D>=2,C>=0,A>=2] 
* CE 24: case_9(A,B,C,D,E,F,G,H,E,I) = 2
     [G>=0,F>=0,E>=0,C>=0,B>=2,A>=2,I=0,H=1,D=1] 

### Cost equations --> "Loop" of case_9/10 
* CEs [23] --> Loop 23 
* CEs [24] --> Loop 24 

#### Loops of case_9/10 
* Loop 23: case_9(A,B,C,D,E,F,G,D,E,H) [B>=D+1,H>=0,G>=0,F>=0,E>=0,D>=2,C>=0,A>=2] 
* Loop 24: case_9(A,B,C,D,E,F,G,H,E,I) [G>=0,F>=0,E>=0,C>=0,B>=2,A>=2,I=0,H=1,D=1] 

### Ranking functions of CR case_9(A,B,C,D,E,F,G,H,I,J) 

#### Partial ranking functions of CR case_9(A,B,C,D,E,F,G,H,I,J) 


### Resulting Chains:case_9(A,B,C,D,E,F,G,H,I,J) 
* [24]
* [23]


### Merging Chains  case_9/10 into  External patterns of execution 
* [[24]] --> 1 
* [[23]] --> 2 


### Specialization of cost equations case_8/8 
* CE 16 is refined into CE [25,26] 
* CE 15 is refined into CE [27] 


#### Refined cost equations case_8/8 
* CE 25: case_8(A,B,C,D,E,F,G,H) = 3+ case_9(A,B,C,I,E,F,G,J,E,K):1
     [E>=0,G>=0,F>=0,C>=0,B>=2,A>=2,K=0,J=1,I=1,H=0,D=1] 
* CE 26: case_8(A,B,C,D,E,F,G,H) = 3+ case_9(A,B,C,D,E,F,G,D,E,H):2
     [B>=D+1,H>=0,E>=0,D>=2,G>=0,F>=0,C>=0,A>=2] 
* CE 27: case_8(A,B,C,D,E,F,G,H) = 2
     [G>=0,F>=0,E>=0,D>=0,C>=0,H=0,B=0,A=1] 

### Cost equations --> "Loop" of case_8/8 
* CEs [26] --> Loop 25 
* CEs [25] --> Loop 26 
* CEs [27] --> Loop 27 

#### Loops of case_8/8 
* Loop 25: case_8(A,B,C,D,E,F,G,H) [B>=D+1,H>=0,G>=0,F>=0,E>=0,D>=2,C>=0,A>=2] 
* Loop 26: case_8(A,B,C,D,E,F,G,H) [G>=0,F>=0,E>=0,C>=0,B>=2,A>=2,H=0,D=1] 
* Loop 27: case_8(A,B,C,D,E,F,G,H) [G>=0,F>=0,E>=0,D>=0,C>=0,H=0,B=0,A=1] 

### Ranking functions of CR case_8(A,B,C,D,E,F,G,H) 

#### Partial ranking functions of CR case_8(A,B,C,D,E,F,G,H) 


### Resulting Chains:case_8(A,B,C,D,E,F,G,H) 
* [27]
* [26]
* [25]


### Merging Chains  case_8/8 into  External patterns of execution 
* [[27]] --> 1 
* [[26]] --> 2 
* [[25]] --> 3 


### Specialization of cost equations case_1/3 
* CE 18 is refined into CE [28] 
* CE 17 is refined into CE [29] 


#### Refined cost equations case_1/3 
* CE 28: case_1(A,B,B) = 1
     [B>=A,A>=0] 
* CE 29: case_1(A,B,A) = 1
     [A>=B+1,B>=0] 

### Cost equations --> "Loop" of case_1/3 
* CEs [28] --> Loop 28 
* CEs [29] --> Loop 29 

#### Loops of case_1/3 
* Loop 28: case_1(A,B,B) [B>=A,A>=0] 
* Loop 29: case_1(A,B,A) [A>=B+1,B>=0] 

### Ranking functions of CR case_1(A,B,C) 

#### Partial ranking functions of CR case_1(A,B,C) 


### Resulting Chains:case_1(A,B,C) 
* [29]
* [28]


### Merging Chains  case_1/3 into  External patterns of execution 
* [[29]] --> 1 
* [[28]] --> 2 


### Specialization of cost equations case_5/16 
* CE 12 is refined into CE [30,31] 
* CE 11 is refined into CE [32] 


#### Refined cost equations case_5/16 
* CE 30: case_5(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,M) = 3+ case_1(M,B,M):1
     [M>=B+1,J>=E+1,B>=0,O>=0,N>=1,L>=0,K>=1,E>=0,D>=0,C>=1,A>=0,J+L=I,M+O=G,K+1=H,N+1=F] 
* CE 31: case_5(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,B) = 3+ case_1(M,B,B):2
     [B>=M,J>=E+1,M>=0,O>=0,N>=1,L>=0,K>=1,E>=0,D>=0,C>=1,A>=0,J+L=I,M+O=G,K+1=H,N+1=F] 
* CE 32: case_5(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P) = 3
     [I>=L,O>=0,N>=1,M>=0,L>=0,K>=1,D>=0,C>=1,B>=0,A>=0,J+L=I,E+L=I,M+O=G,A+1=P,K+1=H,N+1=F] 

### Cost equations --> "Loop" of case_5/16 
* CEs [30] --> Loop 30 
* CEs [31] --> Loop 31 
* CEs [32] --> Loop 32 

#### Loops of case_5/16 
* Loop 30: case_5(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,M) [G>=M,I>=J,J>=E+1,M>=B+1,H>=2,F>=2,E>=0,D>=0,C>=1,B>=0,A>=0,G=M+O,I=J+L,F=N+1,H=K+1] 
* Loop 31: case_5(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,B) [G>=M,B>=M,I>=J,J>=E+1,M>=0,H>=2,F>=2,E>=0,D>=0,C>=1,A>=0,I=J+L,M+O=G,F=N+1,H=K+1] 
* Loop 32: case_5(A,B,C,D,E,F,G,H,I,E,J,K,L,M,N,O) [G>=L,I>=E,L>=0,H>=2,F>=2,E>=0,D>=0,C>=1,B>=0,A>=0,E+K=I,L+N=G,A+1=O,F=M+1,H=J+1] 

### Ranking functions of CR case_5(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P) 

#### Partial ranking functions of CR case_5(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P) 


### Resulting Chains:case_5(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P) 
* [32]
* [31]
* [30]


### Merging Chains  case_5/16 into  External patterns of execution 
* [[32]] --> 1 
* [[31]] --> 2 
* [[30]] --> 3 


### Specialization of cost equations case_2/3 
* CE 9 is refined into CE [33] 
* CE 10 is refined into CE [34] 


#### Refined cost equations case_2/3 
* CE 33: case_2(A,B,C) = 1
     [C>=0,B>=0,A>=2] 
* CE 34: case_2(A,B,C) = 3
     [B>=0,C=0,A=1] 

### Cost equations --> "Loop" of case_2/3 
* CEs [33] --> Loop 33 
* CEs [34] --> Loop 34 

#### Loops of case_2/3 
* Loop 33: case_2(A,B,C) [C>=0,B>=0,A>=2] 
* Loop 34: case_2(A,B,C) [B>=0,C=0,A=1] 

### Ranking functions of CR case_2(A,B,C) 

#### Partial ranking functions of CR case_2(A,B,C) 


### Resulting Chains:case_2(A,B,C) 
* [34]
* [33]


### Merging Chains  case_2/3 into  External patterns of execution 
* [[34]] --> 1 
* [[33]] --> 2 


### Specialization of cost equations newline/7 
* CE 5 is refined into CE [35,36,37,38,39,40,41,42,43,44,45,46] 
* CE 3 is refined into CE [47] 
* CE 4 is refined into CE [48] 


#### Refined cost equations newline/7 
* CE 35: newline(A,B,C,D,E,F,G) = 21+ newline(A,H,I,J,K,L,M)+ case_2(N,M,O):1+ case_2(P,I,Q):1+ case_5(R,S,T,M,A,U,V,W,E,A,J,X,Y,Z,I,A1):1
     [E>=A,I>=0,Y>=0,J>=1,A>=0,M>=0,A+K=E,A+X=E,I+Y=V,I+Y=C,J+1=W,M+1=G,J+1=D,L=1,H=1,A1=1,Z=1,U=2,T=1,S=0,R=0,Q=0,P=1,O=0,N=1,F=2,B=2] 
* CE 36: newline(A,B,C,D,E,F,G) = 21+ newline(A,H,C,I,J,K,G)+ case_2(L,G,M):1+ case_2(N,C,O):1+ case_5(P,Q,R,G,A,S,C,T,U,V,I,J,W,X,C,Y):2
     [V>=A+1,J>=0,I>=1,C>=0,A>=0,G>=0,V+J=U,V+J=E,I+1=T,I+1=D,K=1,H=1,Y=0,X=1,W=0,S=2,R=1,Q=0,P=0,O=0,N=1,M=0,L=1,F=2,B=2] 
* CE 37: newline(A,B,C,D,E,F,G) = 21+ newline(A,H,I,J,K,L,M)+ case_2(N,M,O):1+ case_2(P,I,Q):1+ case_5(R,S,T,M,A,U,V,W,X,Y,J,K,Z,A1,I,Z):3
     [Y>=A+1,Z>=1,I>=0,K>=0,J>=1,A>=0,M>=0,Y+K=X,I+Z=V,M+Z=G,Y+K=E,I+Z=C,J+1=W,J+1=D,L=1,H=1,A1=1,U=2,T=1,S=0,R=0,Q=0,P=1,O=0,N=1,F=2,B=2] 
* CE 38: newline(A,B,C,D,E,F,G) = 21+ newline(A,H,I,J,K,L,M)+ case_2(N,M,O):1+ case_2(H,I,P):2+ case_5(Q,R,S,M,A,T,U,V,E,A,J,W,X,H,I,Y):1
     [E>=A,Y>=1,I>=0,H>=2,X>=0,J>=1,A>=0,M>=0,A+K=E,A+W=E,I+X=U,M+Y=G,I+X=C,J+1=V,H+1=T,Y=Q+1,Y=P+1,J+1=D,H+1=B,L=1,S=1,R=0,O=0,N=1,F=2] 
* CE 39: newline(A,B,C,D,E,F,G) = 21+ newline(A,H,C,I,J,K,G)+ case_2(L,G,M):1+ case_2(H,C,N):2+ case_5(N,O,P,G,A,Q,C,R,S,T,I,J,U,H,C,V):2
     [T>=A+1,H>=2,J>=0,I>=1,C>=0,A>=0,G>=0,N>=0,T+J=S,T+J=E,I+1=R,H+1=Q,I+1=D,H+1=B,K=1,V=0,U=0,P=1,O=0,M=0,L=1,F=2] 
* CE 40: newline(A,B,C,D,E,F,G) = 21+ newline(A,H,I,J,K,L,M)+ case_2(N,M,O):1+ case_2(H,I,P):2+ case_5(P,Q,R,M,A,S,T,U,V,W,J,K,X,H,I,X):3
     [W>=A+1,X>=1,I>=0,H>=2,K>=0,J>=1,A>=0,M>=0,P>=0,W+K=V,I+X=T,M+X=G,W+K=E,I+X=C,J+1=U,H+1=S,J+1=D,H+1=B,L=1,R=1,Q=0,O=0,N=1,F=2] 
* CE 41: newline(A,B,C,D,E,F,G) = 21+ newline(A,H,I,J,K,L,M)+ case_2(L,M,N):2+ case_2(O,I,P):1+ case_5(Q,N,L,M,A,R,S,T,E,A,J,U,V,W,I,X):1
     [E>=A,I>=0,V>=0,J>=1,A>=0,M>=0,L>=2,N>=0,A+K=E,A+U=E,I+V=S,I+V=C,J+1=T,M+1=G,L+1=F,J+1=D,H=1,X=1,W=1,R=2,Q=0,P=0,O=1,B=2] 
* CE 42: newline(A,B,C,D,E,F,G) = 21+ newline(A,H,I,J,K,L,M)+ case_2(L,M,N):2+ case_2(O,P,Q):1+ case_5(R,N,L,M,A,S,C,T,U,V,J,K,W,X,Y,N):2
     [N>=W,C>=W,V>=A+1,W>=0,K>=0,J>=1,A>=0,M>=0,L>=2,C=W+I,C=W+Y,V+K=U,C=P+W,M+N=G,V+K=E,J+1=T,L+1=F,J+1=D,H=1,X=1,S=2,R=0,Q=0,O=1,B=2] 
* CE 43: newline(A,B,C,D,E,F,G) = 21+ newline(A,H,I,J,K,L,M)+ case_2(L,M,N):2+ case_2(O,I,P):1+ case_5(Q,N,L,M,A,R,S,T,U,V,J,K,W,X,I,W):3
     [V>=A+1,W>=N+1,I>=0,K>=0,J>=1,A>=0,M>=0,L>=2,N>=0,V+K=U,I+W=S,M+W=G,V+K=E,I+W=C,J+1=T,L+1=F,J+1=D,H=1,X=1,R=2,Q=0,P=0,O=1,B=2] 
* CE 44: newline(A,B,C,D,E,F,G) = 21+ newline(A,H,I,J,K,L,M)+ case_2(L,M,N):2+ case_2(H,I,O):2+ case_5(P,N,L,M,A,Q,R,S,E,A,J,T,U,H,I,V):1
     [E>=A,V>=1,I>=0,H>=2,U>=0,J>=1,A>=0,M>=0,L>=2,N>=0,A+K=E,A+T=E,I+U=R,M+V=G,I+U=C,J+1=S,H+1=Q,V=P+1,V=O+1,L+1=F,J+1=D,H+1=B] 
* CE 45: newline(A,B,C,D,E,F,G) = 21+ newline(A,H,I,J,K,L,M)+ case_2(L,M,N):2+ case_2(H,O,P):2+ case_5(P,N,L,M,A,Q,C,R,S,T,J,K,U,H,V,N):2
     [N>=U,C>=U,T>=A+1,H>=2,U>=0,K>=0,J>=1,A>=0,M>=0,L>=2,P>=0,C=U+I,C=U+V,T+K=S,C=O+U,M+N=G,T+K=E,J+1=R,H+1=Q,L+1=F,J+1=D,H+1=B] 
* CE 46: newline(A,B,C,D,E,F,G) = 21+ newline(A,H,I,J,K,L,M)+ case_2(L,M,N):2+ case_2(H,I,O):2+ case_5(O,N,L,M,A,P,Q,R,S,T,J,K,U,H,I,U):3
     [T>=A+1,U>=N+1,I>=0,H>=2,K>=0,J>=1,A>=0,M>=0,L>=2,N>=0,O>=0,T+K=S,I+U=Q,M+U=G,T+K=E,I+U=C,J+1=R,H+1=P,L+1=F,J+1=D,H+1=B] 
* CE 47: newline(A,B,C,D,E,F,G) = 3
     [G>=0,E>=0,C>=0,B>=0,A>=0,F=1,D=1] 
* CE 48: newline(A,B,C,D,E,F,G) = 6
     [G>=0,E>=0,D>=2,C>=0,A>=0,F=1,B=1] 

### Cost equations --> "Loop" of newline/7 
* CEs [47] --> Loop 35 
* CEs [48] --> Loop 36 
* CEs [45,46] --> Loop 37 
* CEs [44] --> Loop 38 
* CEs [40] --> Loop 39 
* CEs [38] --> Loop 40 
* CEs [39] --> Loop 41 
* CEs [42,43] --> Loop 42 
* CEs [41] --> Loop 43 
* CEs [37] --> Loop 44 
* CEs [36] --> Loop 45 
* CEs [35] --> Loop 46 

#### Loops of newline/7 
* Loop 35: newline(A,B,C,D,E,F,G) [G>=0,E>=0,C>=0,B>=0,A>=0,F=1,D=1] 
* Loop 36: newline(A,B,C,D,E,F,G) [G>=0,E>=0,D>=2,C>=0,A>=0,F=1,B=1] 
* Loop 37: newline(A,B,C,D,E,F,G)->  newline(A,A',B',C',D',E',F')
                  [G+B'>=C+F',E>=A+D'+1,C>=B',F'>=0,D'>=0,B'>=0,F>=3,D>=2,B>=3,A>=0,F=E'+1,D=C'+1,B=A'+1] 
* Loop 38: newline(A,B,C,D,E,F,G)->  newline(A,A',B',C',D',E',F')
                  [G>=F'+1,C>=B',E>=A,F'>=0,B'>=0,F>=3,D>=2,B>=3,A>=0,A+D'=E,F=E'+1,D=C'+1,B=A'+1] 
* Loop 39: newline(A,B,C,D,E,F,G)->  newline(A,A',B',C',D',E',F')
                  [G+B'>=C,E>=A+D'+1,C>=B'+1,D'>=0,B'>=0,D>=2,B>=3,A>=0,C+F'=G+B',D=C'+1,B=A'+1,E'=1,F=2] 
* Loop 40: newline(A,B,C,D,E,F,G)->  newline(A,A',B',C',D',E',F')
                  [G>=F'+1,C>=B',E>=A,F'>=0,B'>=0,D>=2,B>=3,A>=0,A+D'=E,D=C'+1,B=A'+1,E'=1,F=2] 
* Loop 41: newline(A,B,C,D,E,F,G)->  newline(A,A',C,B',C',D',G)
                  [E>=A+C'+1,C'>=0,G>=0,D>=2,C>=0,B>=3,A>=0,D=B'+1,B=A'+1,D'=1,F=2] 
* Loop 42: newline(A,B,C,D,E,F,G)->  newline(A,A',B',C',D',E',F')
                  [G+B'>=C+F',E>=A+D'+1,C>=B',F'>=0,D'>=0,B'>=0,F>=3,D>=2,A>=0,F=E'+1,D=C'+1,A'=1,B=2] 
* Loop 43: newline(A,B,C,D,E,F,G)->  newline(A,A',B',C',D',E',F')
                  [C>=B',E>=A,B'>=0,G>=1,F>=3,D>=2,A>=0,A+D'=E,G=F'+1,F=E'+1,D=C'+1,A'=1,B=2] 
* Loop 44: newline(A,B,C,D,E,F,G)->  newline(A,A',B',C',D',E',F')
                  [G+B'>=C,E>=A+D'+1,C>=B'+1,D'>=0,B'>=0,D>=2,A>=0,C+F'=G+B',D=C'+1,E'=1,A'=1,F=2,B=2] 
* Loop 45: newline(A,B,C,D,E,F,G)->  newline(A,A',C,B',C',D',G)
                  [E>=A+C'+1,C'>=0,G>=0,D>=2,C>=0,A>=0,D=B'+1,D'=1,A'=1,F=2,B=2] 
* Loop 46: newline(A,B,C,D,E,F,G)->  newline(A,A',B',C',D',E',F')
                  [C>=B',E>=A,B'>=0,G>=1,D>=2,A>=0,A+D'=E,G=F'+1,D=C'+1,E'=1,A'=1,F=2,B=2] 

### Ranking functions of CR newline(A,B,C,D,E,F,G) 
* RF of phase [37,38]: [B-2,D-1]

#### Partial ranking functions of CR newline(A,B,C,D,E,F,G) 
* Partial RF of phase [37,38]:
  - RF of loop [37:1]:
    -A+E
    E
  - RF of loop [37:1,38:1]:
    B-2
    D-1

Discarded unfeasible chain [[37,38]]...(Non-terminating chain proved terminating)

### Resulting Chains:newline(A,B,C,D,E,F,G) 
* [[37,38],46,36]
* [[37,38],46,35]
* [[37,38],45,36]
* [[37,38],45,35]
* [[37,38],44,36]
* [[37,38],44,35]
* [[37,38],41,35]
* [[37,38],40,35]
* [[37,38],39,35]
* [46,36]
* [46,35]
* [45,36]
* [45,35]
* [44,36]
* [44,35]
* [41,35]
* [40,35]
* [39,35]
* [36]
* [35]


### Merging Chains  newline/7 into  External patterns of execution 
* [[36]] --> 1 
* [[35,44],[35,45]] --> 2 
* [[35,46]] --> 3 
* [[36,44],[36,45]] --> 4 
* [[36,46]] --> 5 
* [[35]] --> 6 
* [[35,39],[35,41]] --> 7 
* [[35,40]] --> 8 
* [[35,44,[37,38]],[35,45,[37,38]]] --> 9 
* [[35,46,[37,38]]] --> 10 
* [[36,44,[37,38]],[36,45,[37,38]]] --> 11 
* [[36,46,[37,38]]] --> 12 
* [[35,39,[37,38]],[35,41,[37,38]]] --> 13 
* [[35,40,[37,38]]] --> 14 


### Specialization of cost equations case_7/13 
* CE 14 is refined into CE [49,50,51,52,53,54,55,56,57,58,59,60,61,62] 
* CE 13 is refined into CE [63] 


#### Refined cost equations case_7/13 
* CE 49: case_7(A,B,C,D,E,F,G,H,I,J,K,L,M) = 5+ newline(H,N,O,F,G,P,Q):1
     [M>=Q,Q>=0,G>=0,F>=2,O>=0,H>=0,L>=1,J>=0,I>=1,A>=2,C+Q=M,H+J=E,A+1=K,I+1=D,L=B+1,P=1,N=1] 
* CE 50: case_7(A,B,C,D,E,F,G,H,I,J,K,L,M) = 5+ newline(H,N,O,P,G,Q,R):2
     [M>=R,G>=H+1,R>=0,O>=0,H>=0,L>=2,J>=0,I>=1,A>=2,C+R=M,H+J=E,A+1=K,I+1=D,L=B+2,Q=2,P=2,N=2,F=2] 
* CE 51: case_7(A,B,C,D,E,F,G,H,I,J,K,L,M) = 5+ newline(H,N,O,P,G,Q,R):3
     [M>=R,G>=H,R>=1,O>=0,H>=0,L>=2,J>=0,I>=1,A>=2,C+R=M,H+J=E,A+1=K,I+1=D,L=B+2,Q=2,P=2,N=2,F=2] 
* CE 52: case_7(A,B,C,D,E,F,G,H,I,J,K,L,M) = 5+ newline(H,N,O,F,G,P,Q):4
     [M>=Q,G>=H+1,Q>=0,F>=3,O>=0,H>=0,L>=2,J>=0,I>=1,A>=2,C+Q=M,H+J=E,A+1=K,I+1=D,L=B+2,P=2,N=2] 
* CE 53: case_7(A,B,C,D,E,F,G,H,I,J,K,L,M) = 5+ newline(H,N,O,F,G,P,Q):5
     [M>=Q,G>=H,Q>=1,F>=3,O>=0,H>=0,L>=2,J>=0,I>=1,A>=2,C+Q=M,H+J=E,A+1=K,I+1=D,L=B+2,P=2,N=2] 
* CE 54: case_7(A,B,C,D,E,F,G,H,I,J,K,L,M) = 5+ newline(H,N,O,P,G,Q,R):6
     [M>=R,R>=0,G>=0,O>=0,N>=1,H>=0,L>=1,J>=0,I>=1,A>=2,C+R=M,H+J=E,A+1=K,I+1=D,L=B+1,Q=1,P=1,F=1] 
* CE 55: case_7(A,B,C,D,E,F,G,H,I,J,K,L,M) = 5+ newline(H,N,O,P,G,Q,R):7
     [M>=R,G>=H+1,R>=0,O>=0,N>=3,H>=0,L>=2,J>=0,I>=1,A>=2,C+R=M,H+J=E,A+1=K,I+1=D,L=B+2,Q=2,P=2,F=2] 
* CE 56: case_7(A,B,C,D,E,F,G,H,I,J,K,L,M) = 5+ newline(H,N,O,P,G,Q,R):8
     [M>=R,G>=H,R>=1,O>=0,N>=3,H>=0,L>=2,J>=0,I>=1,A>=2,C+R=M,H+J=E,A+1=K,I+1=D,L=B+2,Q=2,P=2,F=2] 
* CE 57: case_7(A,B,C,D,E,F,G,H,I,J,K,L,M) = 5+ newline(H,F,N,F,G,F,O):9
     [G+O+1>=2*H+F,M>=O,L>=F,G>=2*H+1,O>=0,F>=3,N>=0,H>=0,J>=0,I>=1,A>=2,C+O=M,B+F=L,H+J=E,A+1=K,I+1=D] 
* CE 58: case_7(A,B,C,D,E,F,G,H,I,J,K,L,M) = 5+ newline(H,F,N,F,G,F,O):10
     [G+O+1>=2*H+F,M>=O,L>=F,G>=2*H,O>=1,F>=3,N>=0,H>=0,J>=0,I>=1,A>=2,C+O=M,B+F=L,H+J=E,A+1=K,I+1=D] 
* CE 59: case_7(A,B,C,D,E,F,G,H,I,J,K,L,M) = 5+ newline(H,N,O,F,G,N,P):11
     [G+P+1>=2*H+N,M>=P,F>=N+1,L>=N,G>=2*H+1,P>=0,N>=3,O>=0,H>=0,J>=0,I>=1,A>=2,C+P=M,B+N=L,H+J=E,A+1=K,I+1=D] 
* CE 60: case_7(A,B,C,D,E,F,G,H,I,J,K,L,M) = 5+ newline(H,N,O,F,G,N,P):12
     [G+P+1>=2*H+N,M>=P,F>=N+1,L>=N,G>=2*H,P>=1,N>=3,O>=0,H>=0,J>=0,I>=1,A>=2,C+P=M,B+N=L,H+J=E,A+1=K,I+1=D] 
* CE 61: case_7(A,B,C,D,E,F,G,H,I,J,K,L,M) = 5+ newline(H,N,O,F,G,F,P):13
     [G+P+1>=2*H+F,M>=P,N>=F+1,L>=F,G>=2*H+1,P>=0,F>=3,O>=0,H>=0,J>=0,I>=1,A>=2,C+P=M,B+F=L,H+J=E,A+1=K,I+1=D] 
* CE 62: case_7(A,B,C,D,E,F,G,H,I,J,K,L,M) = 5+ newline(H,N,O,F,G,F,P):14
     [G+P+1>=2*H+F,M>=P,N>=F+1,L>=F,G>=2*H,P>=1,F>=3,O>=0,H>=0,J>=0,I>=1,A>=2,C+P=M,B+F=L,H+J=E,A+1=K,I+1=D] 
* CE 63: case_7(A,B,C,D,E,F,G,H,I,J,K,L,M) = 2
     [M>=0,J>=0,I>=1,H>=0,G>=0,F>=0,C>=0,H+J=E,I+1=D,L=0,K=1,B=0,A=1] 

### Cost equations --> "Loop" of case_7/13 
* CEs [59] --> Loop 47 
* CEs [60] --> Loop 48 
* CEs [57,61] --> Loop 49 
* CEs [58,62] --> Loop 50 
* CEs [53] --> Loop 51 
* CEs [52] --> Loop 52 
* CEs [49] --> Loop 53 
* CEs [51,56] --> Loop 54 
* CEs [50,55] --> Loop 55 
* CEs [54] --> Loop 56 
* CEs [63] --> Loop 57 

#### Loops of case_7/13 
* Loop 47: case_7(A,B,C,D,E,F,G,H,I,J,K,L,M) [B+G+M+1>=2*H+C+L,B+F>=L+1,E>=H,M>=C,L>=B+3,G>=2*H+1,H>=0,D>=2,C>=0,B>=0,A>=2,H+J=E,A+1=K,D=I+1] 
* Loop 48: case_7(A,B,C,D,E,F,G,H,I,J,K,L,M) [B+G+M+1>=2*H+C+L,B+F>=L+1,E>=H,M>=C+1,L>=B+3,G>=2*H,H>=0,D>=2,C>=0,B>=0,A>=2,H+J=E,A+1=K,D=I+1] 
* Loop 49: case_7(A,B,C,D,E,F,G,H,I,J,K,L,M) [G+M+1>=2*H+C+F,E>=H,M>=C,G>=2*H+1,H>=0,F>=3,D>=2,C>=0,B>=0,A>=2,B+F=L,E=H+J,A+1=K,D=I+1] 
* Loop 50: case_7(A,B,C,D,E,F,G,H,I,J,K,L,M) [G+M+1>=2*H+C+F,E>=H,M>=C+1,G>=2*H,H>=0,F>=3,D>=2,C>=0,B>=0,A>=2,B+F=L,E=H+J,A+1=K,D=I+1] 
* Loop 51: case_7(A,B,C,D,E,F,G,H,I,J,K,L,M) [G>=H,E>=H,M>=C+1,H>=0,F>=3,D>=2,C>=0,B>=0,A>=2,H+J=E,B+2=L,A+1=K,D=I+1] 
* Loop 52: case_7(A,B,C,D,E,F,G,H,I,J,K,L,M) [G>=H+1,E>=H,M>=C,H>=0,F>=3,D>=2,C>=0,B>=0,A>=2,H+J=E,B+2=L,A+1=K,D=I+1] 
* Loop 53: case_7(A,B,C,D,E,F,G,H,I,J,K,L,M) [E>=H,M>=C,H>=0,G>=0,F>=2,D>=2,C>=0,B>=0,A>=2,H+J=E,B+1=L,A+1=K,D=I+1] 
* Loop 54: case_7(A,B,C,D,E,F,G,H,I,J,K,L,M) [G>=H,E>=H,M>=C+1,H>=0,D>=2,C>=0,B>=0,A>=2,H+J=E,B+2=L,A+1=K,D=I+1,F=2] 
* Loop 55: case_7(A,B,C,D,E,F,G,H,I,J,K,L,M) [G>=H+1,E>=H,M>=C,H>=0,D>=2,C>=0,B>=0,A>=2,H+J=E,B+2=L,A+1=K,D=I+1,F=2] 
* Loop 56: case_7(A,B,C,D,E,F,G,H,I,J,K,L,M) [E>=H,M>=C,H>=0,G>=0,D>=2,C>=0,B>=0,A>=2,H+J=E,B+1=L,A+1=K,D=I+1,F=1] 
* Loop 57: case_7(A,B,C,D,E,F,G,H,I,J,K,L,M) [E>=H,M>=0,H>=0,G>=0,F>=0,D>=2,C>=0,H+J=E,D=I+1,L=0,K=1,B=0,A=1] 

### Ranking functions of CR case_7(A,B,C,D,E,F,G,H,I,J,K,L,M) 

#### Partial ranking functions of CR case_7(A,B,C,D,E,F,G,H,I,J,K,L,M) 


### Resulting Chains:case_7(A,B,C,D,E,F,G,H,I,J,K,L,M) 
* [57]
* [56]
* [55]
* [54]
* [53]
* [52]
* [51]
* [50]
* [49]
* [48]
* [47]


### Merging Chains  case_7/13 into  External patterns of execution 
* [[57]] --> 1 
* [[56]] --> 2 
* [[55]] --> 3 
* [[54]] --> 4 
* [[53]] --> 5 
* [[52]] --> 6 
* [[51]] --> 7 
* [[50]] --> 8 
* [[49]] --> 9 
* [[48]] --> 10 
* [[47]] --> 11 


### Specialization of cost equations lcstable/7 
* CE 7 is refined into CE [64,65] 
* CE 6 is refined into CE [66,67,68,69,70,71,72,73,74,75,76] 


#### Refined cost equations lcstable/7 
* CE 64: lcstable(A,B,C,D,E,F,G) = 5+ firstline(H,D,I,J):1
     [J>=0,D>=0,G>=0,B>=0,I=1,H=1,F=1,E=2,C=1,A=1] 
* CE 65: lcstable(A,B,C,D,E,C,F) = 5+ firstline(C,D,C,G):2
     [G>=0,C>=2,D>=0,F>=0,B>=0,E=2,A=1] 
* CE 66: lcstable(A,B,C,D,E,F,G) = 7+ lcstable(H,I,C,D,J,K,L)+ case_7(M,N,L,O,P,C,D,Q,H,I,R,S,G):1
     [G>=0,I>=0,H>=1,Q>=0,D>=0,C>=0,L>=0,Q+I=P,Q+I=B,H+1=O,H+1=A,K=0,J=1,S=0,R=1,N=0,M=1,F=0,E=1] 
* CE 67: lcstable(A,B,C,D,E,F,G) = 7+ lcstable(H,I,J,D,K,L,M)+ case_7(N,O,M,P,Q,R,D,S,H,I,E,F,G):2
     [G>=M,F>=1,E>=3,I>=0,H>=1,S>=0,D>=0,M>=0,S+I=Q,S+I=B,F=L+1,E=K+1,H+1=P,F=O+1,E=N+1,H+1=A,J=1,R=1,C=1] 
* CE 68: lcstable(A,B,C,D,E,F,G) = 7+ lcstable(H,I,J,D,K,L,M)+ case_7(N,O,M,P,Q,R,D,S,H,I,E,F,G):3
     [D>=S+1,G>=M,F>=2,E>=3,I>=0,H>=1,S>=0,M>=0,S+I=Q,S+I=B,F=L+2,E=K+1,H+1=P,F=O+2,E=N+1,H+1=A,J=2,R=2,C=2] 
* CE 69: lcstable(A,B,C,D,E,F,G) = 7+ lcstable(H,I,J,D,K,L,M)+ case_7(N,O,M,P,Q,R,D,S,H,I,E,F,G):4
     [D>=S,G>=M+1,F>=2,E>=3,I>=0,H>=1,S>=0,M>=0,S+I=Q,S+I=B,F=L+2,E=K+1,H+1=P,F=O+2,E=N+1,H+1=A,J=2,R=2,C=2] 
* CE 70: lcstable(A,B,C,D,E,F,G) = 7+ lcstable(H,I,C,D,J,K,L)+ case_7(M,N,L,O,P,C,D,Q,H,I,E,F,G):5
     [G>=L,F>=1,E>=3,I>=0,H>=1,Q>=0,D>=0,C>=2,L>=0,Q+I=P,Q+I=B,F=K+1,E=J+1,H+1=O,F=N+1,E=M+1,H+1=A] 
* CE 71: lcstable(A,B,C,D,E,F,G) = 7+ lcstable(H,I,C,D,J,K,L)+ case_7(M,N,L,O,P,C,D,Q,H,I,E,F,G):6
     [D>=Q+1,G>=L,F>=2,E>=3,I>=0,H>=1,Q>=0,C>=3,L>=0,Q+I=P,Q+I=B,F=K+2,E=J+1,H+1=O,F=N+2,E=M+1,H+1=A] 
* CE 72: lcstable(A,B,C,D,E,F,G) = 7+ lcstable(H,I,C,D,J,K,L)+ case_7(M,N,L,O,P,C,D,Q,H,I,E,F,G):7
     [D>=Q,G>=L+1,F>=2,E>=3,I>=0,H>=1,Q>=0,C>=3,L>=0,Q+I=P,Q+I=B,F=K+2,E=J+1,H+1=O,F=N+2,E=M+1,H+1=A] 
* CE 73: lcstable(A,B,C,D,E,F,G) = 7+ lcstable(H,I,J,D,K,L,M)+ case_7(N,L,M,O,B,P,D,Q,H,R,E,F,G):8
     [D+G+L+1>=2*Q+F+M,B>=Q,G>=M+1,F>=L+3,D>=2*Q,E>=3,H>=1,Q>=0,M>=0,L>=0,B=Q+I,B=Q+R,F=L+J,F=L+P,F=C+L,E=K+1,H+1=O,E=N+1,H+1=A] 
* CE 74: lcstable(A,B,C,D,E,F,G) = 7+ lcstable(H,I,J,D,K,L,M)+ case_7(N,L,M,O,B,P,D,Q,H,R,E,F,G):9
     [D+G+L+1>=2*Q+F+M,B>=Q,G>=M,F>=L+3,D>=2*Q+1,E>=3,H>=1,Q>=0,M>=0,L>=0,B=Q+I,B=Q+R,F=L+J,F=L+P,F=C+L,E=K+1,H+1=O,E=N+1,H+1=A] 
* CE 75: lcstable(A,B,C,D,E,F,G) = 7+ lcstable(H,I,C,D,J,K,L)+ case_7(M,K,L,N,B,C,D,O,H,P,E,F,G):10
     [D+G+K+1>=2*O+F+L,C+K>=F+1,B>=O,G>=L+1,F>=K+3,D>=2*O,E>=3,H>=1,O>=0,L>=0,K>=0,B=O+I,B=O+P,E=J+1,H+1=N,E=M+1,H+1=A] 
* CE 76: lcstable(A,B,C,D,E,F,G) = 7+ lcstable(H,I,C,D,J,K,L)+ case_7(M,K,L,N,B,C,D,O,H,P,E,F,G):11
     [D+G+K+1>=2*O+F+L,C+K>=F+1,B>=O,G>=L,F>=K+3,D>=2*O+1,E>=3,H>=1,O>=0,L>=0,K>=0,B=O+I,B=O+P,E=J+1,H+1=N,E=M+1,H+1=A] 

### Cost equations --> "Loop" of lcstable/7 
* CEs [75] --> Loop 58 
* CEs [76] --> Loop 59 
* CEs [73] --> Loop 60 
* CEs [74] --> Loop 61 
* CEs [72] --> Loop 62 
* CEs [71] --> Loop 63 
* CEs [70] --> Loop 64 
* CEs [66] --> Loop 65 
* CEs [69] --> Loop 66 
* CEs [68] --> Loop 67 
* CEs [67] --> Loop 68 
* CEs [65] --> Loop 69 
* CEs [64] --> Loop 70 

#### Loops of lcstable/7 
* Loop 58: lcstable(A,B,C,D,E,F,G)->  lcstable(A',B',C,D,C',D',E')
                  [D+G+D'+2*B'+1>=2*B+F+E',C+D'>=F+1,D+2*B'>=2*B,G>=E'+1,F>=D'+3,B>=B',E'>=0,D'>=0,B'>=0,E>=3,A>=2,E=C'+1,A=A'+1] 
* Loop 59: lcstable(A,B,C,D,E,F,G)->  lcstable(A',B',C,D,C',D',E')
                  [D+G+D'+2*B'+1>=2*B+F+E',C+D'>=F+1,D+2*B'>=2*B+1,G>=E',F>=D'+3,B>=B',E'>=0,D'>=0,B'>=0,E>=3,A>=2,E=C'+1,A=A'+1] 
* Loop 60: lcstable(A,B,C,D,E,F,G)->  lcstable(A',B',C,D,C',D',E')
                  [D+G+2*B'+1>=2*B+C+E',D+2*B'>=2*B,G>=E'+1,B>=B',F>=C,E'>=0,B'>=0,E>=3,C>=3,A>=2,C+D'=F,E=C'+1,A=A'+1] 
* Loop 61: lcstable(A,B,C,D,E,F,G)->  lcstable(A',B',C,D,C',D',E')
                  [D+G+2*B'+1>=2*B+C+E',D+2*B'>=2*B+1,G>=E',B>=B',F>=C,E'>=0,B'>=0,E>=3,C>=3,A>=2,C+D'=F,E=C'+1,A=A'+1] 
* Loop 62: lcstable(A,B,C,D,E,F,G)->  lcstable(A',B',C,D,C',D',E')
                  [D+B'>=B,G>=E'+1,B>=B',E'>=0,B'>=0,F>=2,E>=3,C>=3,A>=2,F=D'+2,E=C'+1,A=A'+1] 
* Loop 63: lcstable(A,B,C,D,E,F,G)->  lcstable(A',B',C,D,C',D',E')
                  [D+B'>=B+1,G>=E',B>=B',E'>=0,B'>=0,F>=2,E>=3,C>=3,A>=2,F=D'+2,E=C'+1,A=A'+1] 
* Loop 64: lcstable(A,B,C,D,E,F,G)->  lcstable(A',B',C,D,C',D',E')
                  [G>=E',B>=B',E'>=0,B'>=0,F>=1,E>=3,D>=0,C>=2,A>=2,F=D'+1,E=C'+1,A=A'+1] 
* Loop 65: lcstable(A,B,C,D,E,F,G)->  lcstable(A',B',C,D,C',D',E')
                  [B>=B',E'>=0,B'>=0,G>=0,D>=0,C>=0,A>=2,A=A'+1,D'=0,C'=1,F=0,E=1] 
* Loop 66: lcstable(A,B,C,D,E,F,G)->  lcstable(A',B',C',D,D',E',F')
                  [D+B'>=B,G>=F'+1,B>=B',F'>=0,B'>=0,F>=2,E>=3,A>=2,F=E'+2,E=D'+1,A=A'+1,C'=2,C=2] 
* Loop 67: lcstable(A,B,C,D,E,F,G)->  lcstable(A',B',C',D,D',E',F')
                  [D+B'>=B+1,G>=F',B>=B',F'>=0,B'>=0,F>=2,E>=3,A>=2,F=E'+2,E=D'+1,A=A'+1,C'=2,C=2] 
* Loop 68: lcstable(A,B,C,D,E,F,G)->  lcstable(A',B',C',D,D',E',F')
                  [G>=F',B>=B',F'>=0,B'>=0,F>=1,E>=3,D>=0,A>=2,F=E'+1,E=D'+1,A=A'+1,C'=1,C=1] 
* Loop 69: lcstable(A,B,C,D,E,C,F) [F>=0,D>=0,C>=2,B>=0,E=2,A=1] 
* Loop 70: lcstable(A,B,C,D,E,F,G) [G>=0,D>=0,B>=0,F=1,E=2,C=1,A=1] 

### Ranking functions of CR lcstable(A,B,C,D,E,F,G) 
* RF of phase [58,59,60,61,62,63,64,66,67]: [A-1]
* RF of phase [65]: [A-1]
* RF of phase [68]: [A-1]

#### Partial ranking functions of CR lcstable(A,B,C,D,E,F,G) 
* Partial RF of phase [58,59,60,61,62,63,64,66,67]:
  - RF of loop [58:1,59:1,60:1,61:1,62:1,63:1,64:1,66:1,67:1]:
    A-1
* Partial RF of phase [65]:
  - RF of loop [65:1]:
    A-1
* Partial RF of phase [68]:
  - RF of loop [68:1]:
    A-1

Discarded unfeasible chain [[68]]...(Non-terminating chain proved terminating)
Discarded unfeasible chain [[65]](Non-terminating chain proved terminating)
Discarded unfeasible chain [[58,59,60,61,62,63,64,66,67]](Non-terminating chain proved terminating)

### Resulting Chains:lcstable(A,B,C,D,E,F,G) 
* [[68],70]
* [[58,59,60,61,62,63,64,66,67],69]
* [70]
* [69]


### Merging Chains  lcstable/7 into  External patterns of execution 
* [[70]] --> 1 
* [[69]] --> 2 
* [[70,[68]]] --> 3 
* [[69,[58,59,60,61,62,63,64,66,67]]] --> 4 


### Specialization of cost equations lcs/5 
* CE 8 is refined into CE [77,78] 


#### Refined cost equations lcs/5 
* CE 77: lcs(A,B,C,D,E) = 4+ lcstable(F,B,C,D,G,C,H):2+ case_8(I,C,H,J,B,C,D,K):2
     [D>=0,B>=0,H>=0,C>=2,K=0,J=1,I=2,G=2,F=1,E=0,A=1] 
* CE 78: lcs(A,B,C,D,E) = 4+ lcstable(F,B,C,D,G,H,I):4+ case_8(G,H,I,J,B,C,D,E):3
     [H+2>=C+G,E>=0,D>=0,C>=2,B>=0,I>=0,G>=3,G=J+1,G=F+1,G=A+1] 

### Cost equations --> "Loop" of lcs/5 
* CEs [78] --> Loop 71 
* CEs [77] --> Loop 72 

#### Loops of lcs/5 
* Loop 71: lcs(A,B,C,D,E) [E>=0,D>=0,C>=2,B>=0,A>=2] 
* Loop 72: lcs(A,B,C,D,E) [D>=0,C>=2,B>=0,E=0,A=1] 

### Ranking functions of CR lcs(A,B,C,D,E) 

#### Partial ranking functions of CR lcs(A,B,C,D,E) 


### Resulting Chains:lcs(A,B,C,D,E) 
* [72]
* [71]


### Merging Chains  lcs/5 into  External patterns of execution 
* [[72]] --> 1 
* [[71]] --> 2 


Computing Bounds
=====================================

#### Simplifying cost structure of CE 21 

#### Computing cost of phase [21] 

#### Simplifying cost structure of CE 22 

#### Cost of loops [21] 

 * loop 21:firstline(A,B,C,D) -> [firstline(A',B',C',D')] 
6
##### Pending set firstline(A,B,C,D)
* Psum in Loop 21: [it(21)=<1]

###### Computing sum for it(21)=<1  in Loop 21 
   - Applying inductive sum strategy 
     - head Candidate: A-1 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(21)=<A-1,it(21)=<A-1,it(21)=<A-A',it(21)=<A-A'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [21] 

#### Simplifying cost structure of phase [21] 

#### Cost of phase [21]:firstline(A,B,C,D) -> [firstline(A',B',C',D')] 
6*it(21)+0
  Such that:it(21) =< A
it(21) =< A-A'

#### Simplifying cost structure of chain [[21],22] 

#### Cost of chains of firstline(A,B,C,D):
* Chain [[21],22]: 6*it(21)+3
  Such that:it(21) =< C

  with precondition: [A=C,A>=2,B>=0,D>=0] 

* Chain [22]: 3
  with precondition: [A=1,C=1,B>=0,D>=0] 


#### Simplifying cost structure of CE 24 

#### Simplifying cost structure of CE 23 

#### Cost of chains of case_9(A,B,C,D,E,F,G,H,I,J):
* Chain [24]: 2
  with precondition: [D=1,H=1,J=0,I=E,A>=2,B>=2,C>=0,F>=0,G>=0,I>=0] 

* Chain [23]: 2
  with precondition: [H=D,I=E,A>=2,C>=0,F>=0,G>=0,H>=2,I>=0,J>=0,B>=H+1] 


#### Simplifying cost structure of CE 27 

#### Simplifying cost structure of CE 25 

#### Simplifying cost structure of CE 26 

#### Cost of chains of case_8(A,B,C,D,E,F,G,H):
* Chain [27]: 2
  with precondition: [A=1,B=0,H=0,C>=0,D>=0,E>=0,F>=0,G>=0] 

* Chain [26]: 5
  with precondition: [D=1,H=0,A>=2,B>=2,C>=0,E>=0,F>=0,G>=0] 

* Chain [25]: 5
  with precondition: [A>=2,C>=0,D>=2,E>=0,F>=0,G>=0,H>=0,B>=D+1] 


#### Simplifying cost structure of CE 29 

#### Simplifying cost structure of CE 28 

#### Cost of chains of case_1(A,B,C):
* Chain [29]: 1
  with precondition: [A=C,B>=0,A>=B+1] 

* Chain [28]: 1
  with precondition: [B=C,A>=0,B>=A] 


#### Simplifying cost structure of CE 32 

#### Simplifying cost structure of CE 31 

#### Simplifying cost structure of CE 30 

#### Cost of chains of case_5(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P):
* Chain [32]: 3
  with precondition: [J=E,N+1=F,K+1=H,A+1=P,J+L=I,G=M+O,A>=0,B>=0,C>=1,D>=0,J>=0,K>=1,M>=0,N>=1,I>=J,G>=M] 

* Chain [31]: 4
  with precondition: [N+1=F,K+1=H,B=P,J+L=I,G=M+O,A>=0,C>=1,D>=0,E>=0,K>=1,L>=0,M>=0,N>=1,J>=E+1,B>=M,G>=M] 

* Chain [30]: 4
  with precondition: [N+1=F,K+1=H,M=P,M+O=G,J+L=I,A>=0,B>=0,C>=1,D>=0,E>=0,K>=1,L>=0,N>=1,O>=0,M>=B+1,J>=E+1] 


#### Simplifying cost structure of CE 34 

#### Simplifying cost structure of CE 33 

#### Cost of chains of case_2(A,B,C):
* Chain [34]: 3
  with precondition: [A=1,C=0,B>=0] 

* Chain [33]: 1
  with precondition: [A>=2,B>=0,C>=0] 


#### Simplifying cost structure of CE 48 

#### Simplifying cost structure of CE 35 

#### Simplifying cost structure of chain [46,36] 

#### Computing cost of phase [37,38] 

#### Simplifying cost structure of CE 45 

#### Simplifying cost structure of CE 46 

#### Simplifying cost structure of CE 44 

#### Cost of loops [37,38] 

 * loop 37:newline(A,B,C,D,E,F,G) -> [newline(A',B',C',D',E',F',G')] 
27
 * loop 38:newline(A,B,C,D,E,F,G) -> [newline(A',B',C',D',E',F',G')] 
26
##### Pending set newline(A,B,C,D,E,F,G)
* Psum in Loop 37: [it(37)=<1]
* Psum in Loop 38: [it(38)=<1]

###### Computing sum for it(37)=<1  in Loop 37 
   - Applying inductive sum strategy 
     - head Candidate: B-2 
       - Loop 38 is collaborative and bounds [it(38)] 
     - head Candidate: D-1 
       - Loop 38 is collaborative and bounds [it(38)] 
     - head Candidate: B-2 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: D-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: E 
       - Loop 38 is collaborative
     - head Candidate: -A+E 
       - Loop 38 is collaborative
     - tail Candidate: B-2 
       - Loop 38 is collaborative and bounds [it(38)] 
     - tail Candidate: D-1 
       - Loop 38 is collaborative and bounds [it(38)] 
     - tail Candidate: B-2 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: D-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: E 
       - Loop 38 is collaborative
     - tail Candidate: -A+E 
       - Loop 38 is collaborative
 * Adding constraints: [it(37)+it(38)=<B-2,it(37)+it(38)=<D-1,it(37)+it(38)=<B-2,it(37)+it(38)=<D-1,it(37)=<E,it(37)=< -A+E,it(37)+it(38)=<B-B',it(37)+it(38)=<D-D',it(37)+it(38)=<B-B',it(37)+it(38)=<D-D',it(37)=<E-E',it(37)=< -A+E+A'-E'] 

##### Pending set A
* Psum in Loop 38: [it(38)=<1]

###### Computing sum for it(38)=<1  in Loop 38 
   - Applying inductive sum strategy 
     - head Candidate: B-2 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: D-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: B-2 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: D-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B-2 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: D-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B-2 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: D-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(37)+it(38)=<B-2,it(37)+it(38)=<D-1,it(37)+it(38)=<B-2,it(37)+it(38)=<D-1,it(37)+it(38)=<B-B',it(37)+it(38)=<D-D',it(37)+it(38)=<B-B',it(37)+it(38)=<D-D'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [37,38] 

#### Simplifying cost structure of phase [37,38] 

#### Cost of phase [37,38]:newline(A,B,C,D,E,F,G) -> [newline(A',B',C',D',E',F',G')] 
27*it(37)+26*it(38)+0
  Such that:it(37) =< -A+E
it(37) =< -A+E+A'-E'
it(37) =< E
it(37) =< E-E'
aux(1) =< B
aux(2) =< B-B'
aux(3) =< D
aux(4) =< D-D'
it(37) =< aux(1)
it(38) =< aux(1)
it(37) =< aux(2)
it(38) =< aux(2)
it(37) =< aux(3)
it(38) =< aux(3)
it(37) =< aux(4)
it(38) =< aux(4)

#### Simplifying cost structure of chain [[37,38],46,36] 
 * Joined equivalent variables [aux(5),aux(1),aux(2),aux(4)] into aux(5)

#### Simplifying cost structure of CE 47 

#### Simplifying cost structure of chain [46,35] 

#### Found solution for phase  [37,38] in the cache 

#### Cost of phase [37,38]:newline(A,B,C,D,E,F,G) -> [newline(A',B',C',D',E',F',G')] 
27*it(37)+26*it(38)+0
  Such that:it(37) =< -A+E
it(37) =< -A+E+A'-E'
it(37) =< E
it(37) =< E-E'
aux(1) =< B
aux(2) =< B-B'
aux(3) =< D
aux(4) =< D-D'
it(37) =< aux(1)
it(38) =< aux(1)
it(37) =< aux(2)
it(38) =< aux(2)
it(37) =< aux(3)
it(38) =< aux(3)
it(37) =< aux(4)
it(38) =< aux(4)

#### Simplifying cost structure of chain [[37,38],46,35] 
 * Joined equivalent variables [aux(6),aux(1),aux(2),aux(3),aux(4)] into aux(6)

#### Simplifying cost structure of CE 36 

#### Simplifying cost structure of chain [45,36] 

#### Found solution for phase  [37,38] in the cache 

#### Cost of phase [37,38]:newline(A,B,C,D,E,F,G) -> [newline(A',B',C',D',E',F',G')] 
27*it(37)+26*it(38)+0
  Such that:it(37) =< -A+E
it(37) =< -A+E+A'-E'
it(37) =< E
it(37) =< E-E'
aux(1) =< B
aux(2) =< B-B'
aux(3) =< D
aux(4) =< D-D'
it(37) =< aux(1)
it(38) =< aux(1)
it(37) =< aux(2)
it(38) =< aux(2)
it(37) =< aux(3)
it(38) =< aux(3)
it(37) =< aux(4)
it(38) =< aux(4)

#### Simplifying cost structure of chain [[37,38],45,36] 
 * Joined equivalent variables [aux(7),aux(1),aux(2),aux(4)] into aux(7)

#### Simplifying cost structure of chain [45,35] 

#### Found solution for phase  [37,38] in the cache 

#### Cost of phase [37,38]:newline(A,B,C,D,E,F,G) -> [newline(A',B',C',D',E',F',G')] 
27*it(37)+26*it(38)+0
  Such that:it(37) =< -A+E
it(37) =< -A+E+A'-E'
it(37) =< E
it(37) =< E-E'
aux(1) =< B
aux(2) =< B-B'
aux(3) =< D
aux(4) =< D-D'
it(37) =< aux(1)
it(38) =< aux(1)
it(37) =< aux(2)
it(38) =< aux(2)
it(37) =< aux(3)
it(38) =< aux(3)
it(37) =< aux(4)
it(38) =< aux(4)

#### Simplifying cost structure of chain [[37,38],45,35] 
 * Joined equivalent variables [aux(8),aux(1),aux(2),aux(3),aux(4)] into aux(8)

#### Simplifying cost structure of CE 37 

#### Simplifying cost structure of chain [44,36] 

#### Found solution for phase  [37,38] in the cache 

#### Cost of phase [37,38]:newline(A,B,C,D,E,F,G) -> [newline(A',B',C',D',E',F',G')] 
27*it(37)+26*it(38)+0
  Such that:it(37) =< -A+E
it(37) =< -A+E+A'-E'
it(37) =< E
it(37) =< E-E'
aux(1) =< B
aux(2) =< B-B'
aux(3) =< D
aux(4) =< D-D'
it(37) =< aux(1)
it(38) =< aux(1)
it(37) =< aux(2)
it(38) =< aux(2)
it(37) =< aux(3)
it(38) =< aux(3)
it(37) =< aux(4)
it(38) =< aux(4)

#### Simplifying cost structure of chain [[37,38],44,36] 
 * Joined equivalent variables [aux(9),aux(1),aux(2),aux(4)] into aux(9)

#### Simplifying cost structure of chain [44,35] 

#### Found solution for phase  [37,38] in the cache 

#### Cost of phase [37,38]:newline(A,B,C,D,E,F,G) -> [newline(A',B',C',D',E',F',G')] 
27*it(37)+26*it(38)+0
  Such that:it(37) =< -A+E
it(37) =< -A+E+A'-E'
it(37) =< E
it(37) =< E-E'
aux(1) =< B
aux(2) =< B-B'
aux(3) =< D
aux(4) =< D-D'
it(37) =< aux(1)
it(38) =< aux(1)
it(37) =< aux(2)
it(38) =< aux(2)
it(37) =< aux(3)
it(38) =< aux(3)
it(37) =< aux(4)
it(38) =< aux(4)

#### Simplifying cost structure of chain [[37,38],44,35] 
 * Joined equivalent variables [aux(10),aux(1),aux(2),aux(3),aux(4)] into aux(10)

#### Simplifying cost structure of CE 39 

#### Simplifying cost structure of chain [41,35] 

#### Found solution for phase  [37,38] in the cache 

#### Cost of phase [37,38]:newline(A,B,C,D,E,F,G) -> [newline(A',B',C',D',E',F',G')] 
27*it(37)+26*it(38)+0
  Such that:it(37) =< -A+E
it(37) =< -A+E+A'-E'
it(37) =< E
it(37) =< E-E'
aux(1) =< B
aux(2) =< B-B'
aux(3) =< D
aux(4) =< D-D'
it(37) =< aux(1)
it(38) =< aux(1)
it(37) =< aux(2)
it(38) =< aux(2)
it(37) =< aux(3)
it(38) =< aux(3)
it(37) =< aux(4)
it(38) =< aux(4)

#### Simplifying cost structure of chain [[37,38],41,35] 
 * Joined equivalent variables [aux(11),aux(2),aux(3),aux(4)] into aux(11)

#### Simplifying cost structure of CE 38 

#### Simplifying cost structure of chain [40,35] 

#### Found solution for phase  [37,38] in the cache 

#### Cost of phase [37,38]:newline(A,B,C,D,E,F,G) -> [newline(A',B',C',D',E',F',G')] 
27*it(37)+26*it(38)+0
  Such that:it(37) =< -A+E
it(37) =< -A+E+A'-E'
it(37) =< E
it(37) =< E-E'
aux(1) =< B
aux(2) =< B-B'
aux(3) =< D
aux(4) =< D-D'
it(37) =< aux(1)
it(38) =< aux(1)
it(37) =< aux(2)
it(38) =< aux(2)
it(37) =< aux(3)
it(38) =< aux(3)
it(37) =< aux(4)
it(38) =< aux(4)

#### Simplifying cost structure of chain [[37,38],40,35] 
 * Joined equivalent variables [aux(12),aux(2),aux(3),aux(4)] into aux(12)

#### Simplifying cost structure of CE 40 

#### Simplifying cost structure of chain [39,35] 

#### Found solution for phase  [37,38] in the cache 

#### Cost of phase [37,38]:newline(A,B,C,D,E,F,G) -> [newline(A',B',C',D',E',F',G')] 
27*it(37)+26*it(38)+0
  Such that:it(37) =< -A+E
it(37) =< -A+E+A'-E'
it(37) =< E
it(37) =< E-E'
aux(1) =< B
aux(2) =< B-B'
aux(3) =< D
aux(4) =< D-D'
it(37) =< aux(1)
it(38) =< aux(1)
it(37) =< aux(2)
it(38) =< aux(2)
it(37) =< aux(3)
it(38) =< aux(3)
it(37) =< aux(4)
it(38) =< aux(4)

#### Simplifying cost structure of chain [[37,38],39,35] 
 * Joined equivalent variables [aux(13),aux(2),aux(3),aux(4)] into aux(13)
 * Renamed intermediate variables: 
[ (ch([[37,38],44,35]),it(37))>>s(1), (ch([[37,38],44,35]),aux(10))>>s(2), (ch([[37,38],44,35]),it(38))>>s(3)]
 * Renamed intermediate variables: 
[ (ch([[37,38],45,35]),it(37))>>s(4), (ch([[37,38],45,35]),aux(8))>>s(5), (ch([[37,38],45,35]),it(38))>>s(6)]
 * Joined equivalent variables [aux(15),s(2),s(5)] into aux(15)
 * Joined equivalent variables [s(1),s(4)] into s(1)
 * Joined equivalent variables [s(3),s(6)] into s(3)
 * Renamed intermediate variables: 
[ (ch([[37,38],44,36]),it(37))>>s(7), (ch([[37,38],44,36]),aux(3))>>s(8), (ch([[37,38],44,36]),aux(9))>>s(9), (ch([[37,38],44,36]),it(38))>>s(10)]
 * Renamed intermediate variables: 
[ (ch([[37,38],45,36]),it(37))>>s(11), (ch([[37,38],45,36]),aux(3))>>s(12), (ch([[37,38],45,36]),aux(7))>>s(13), (ch([[37,38],45,36]),it(38))>>s(14)]
 * Joined equivalent variables [aux(17),s(9),s(13)] into aux(17)
 * Joined equivalent variables [aux(18),s(8),s(12)] into aux(18)
 * Joined equivalent variables [s(7),s(11)] into s(7)
 * Joined equivalent variables [s(10),s(14)] into s(10)
 * Renamed intermediate variables: 
[ (ch([[37,38],39,35]),it(37))>>s(15), (ch([[37,38],39,35]),aux(1))>>s(16), (ch([[37,38],39,35]),aux(13))>>s(17), (ch([[37,38],39,35]),it(38))>>s(18)]
 * Renamed intermediate variables: 
[ (ch([[37,38],41,35]),it(37))>>s(19), (ch([[37,38],41,35]),aux(1))>>s(20), (ch([[37,38],41,35]),aux(11))>>s(21), (ch([[37,38],41,35]),it(38))>>s(22)]
 * Joined equivalent variables [aux(20),s(16),s(20)] into aux(20)
 * Joined equivalent variables [aux(21),s(17),s(21)] into aux(21)
 * Joined equivalent variables [s(15),s(19)] into s(15)
 * Joined equivalent variables [s(18),s(22)] into s(18)

#### Cost of chains of newline(A,B,C,D,E,F,G):
* Chain [[37,38],46,36]: 27*it(37)+26*it(38)+36
  Such that:it(37) =< -A+E
aux(3) =< D
aux(5) =< B
it(37) =< aux(5)
it(38) =< aux(5)
it(37) =< aux(3)
it(38) =< aux(3)

  with precondition: [B=F,A>=0,B>=3,C>=0,G>=1,E>=2*A,D>=B+1,E+G+1>=2*A+B] 

* Chain [[37,38],46,35]: 27*it(37)+26*it(38)+33
  Such that:it(37) =< -A+E
aux(6) =< B
it(37) =< aux(6)
it(38) =< aux(6)

  with precondition: [B=D,B=F,A>=0,B>=3,C>=0,G>=1,E>=2*A,E+G+1>=2*A+B] 

* Chain [[37,38],45,36]: 27*it(37)+26*it(38)+37
  Such that:it(37) =< -A+E
aux(3) =< D
aux(7) =< B
it(37) =< aux(7)
it(38) =< aux(7)
it(37) =< aux(3)
it(38) =< aux(3)

  with precondition: [B=F,A>=0,B>=3,C>=0,G>=0,E>=2*A+1,D>=B+1,E+G+1>=2*A+B] 

* Chain [[37,38],45,35]: 27*it(37)+26*it(38)+34
  Such that:it(37) =< -A+E
aux(8) =< B
it(37) =< aux(8)
it(38) =< aux(8)

  with precondition: [B=D,B=F,A>=0,B>=3,C>=0,G>=0,E>=2*A+1,E+G+1>=2*A+B] 

* Chain [[37,38],44,36]: 27*it(37)+26*it(38)+37
  Such that:it(37) =< -A+E
aux(3) =< D
aux(9) =< B
it(37) =< aux(9)
it(38) =< aux(9)
it(37) =< aux(3)
it(38) =< aux(3)

  with precondition: [B=F,A>=0,B>=3,C>=1,G>=1,E>=2*A+1,D>=B+1,E+G>=2*A+B] 

* Chain [[37,38],44,35]: 27*it(37)+26*it(38)+34
  Such that:it(37) =< -A+E
aux(10) =< B
it(37) =< aux(10)
it(38) =< aux(10)

  with precondition: [B=D,B=F,A>=0,B>=3,C>=1,G>=1,E>=2*A+1,E+G>=2*A+B] 

* Chain [[37,38],41,35]: 27*it(37)+26*it(38)+32
  Such that:it(37) =< -A+E
aux(1) =< B
aux(11) =< D
it(37) =< aux(1)
it(38) =< aux(1)
it(37) =< aux(11)
it(38) =< aux(11)

  with precondition: [D=F,A>=0,C>=0,D>=3,G>=0,E>=2*A+1,B>=D+1,E+G+1>=2*A+D] 

* Chain [[37,38],40,35]: 27*it(37)+26*it(38)+31
  Such that:it(37) =< -A+E
aux(1) =< B
aux(12) =< D
it(37) =< aux(1)
it(38) =< aux(1)
it(37) =< aux(12)
it(38) =< aux(12)

  with precondition: [D=F,A>=0,C>=0,D>=3,G>=1,E>=2*A,B>=D+1,E+G+1>=2*A+D] 

* Chain [[37,38],39,35]: 27*it(37)+26*it(38)+32
  Such that:it(37) =< -A+E
aux(1) =< B
aux(13) =< D
it(37) =< aux(1)
it(38) =< aux(1)
it(37) =< aux(13)
it(38) =< aux(13)

  with precondition: [D=F,A>=0,C>=1,D>=3,G>=1,E>=2*A+1,B>=D+1,E+G>=2*A+D] 

* Chain [46,36]: 36
  with precondition: [B=2,F=2,A>=0,C>=0,D>=3,G>=1,E>=A] 

* Chain [46,35]: 33
  with precondition: [B=2,D=2,F=2,A>=0,C>=0,G>=1,E>=A] 

* Chain [45,36]: 37
  with precondition: [B=2,F=2,A>=0,C>=0,D>=3,G>=0,E>=A+1] 

* Chain [45,35]: 34
  with precondition: [B=2,D=2,F=2,A>=0,C>=0,G>=0,E>=A+1] 

* Chain [44,36]: 37
  with precondition: [B=2,F=2,A>=0,C>=1,D>=3,G>=1,E>=A+1] 

* Chain [44,35]: 34
  with precondition: [B=2,D=2,F=2,A>=0,C>=1,G>=1,E>=A+1] 

* Chain [41,35]: 32
  with precondition: [D=2,F=2,A>=0,B>=3,C>=0,G>=0,E>=A+1] 

* Chain [40,35]: 31
  with precondition: [D=2,F=2,A>=0,B>=3,C>=0,G>=1,E>=A] 

* Chain [39,35]: 32
  with precondition: [D=2,F=2,A>=0,B>=3,C>=1,G>=1,E>=A+1] 

* Chain [36]: 6
  with precondition: [B=1,F=1,A>=0,C>=0,D>=2,E>=0,G>=0] 

* Chain [35]: 3
  with precondition: [D=1,F=1,A>=0,B>=0,C>=0,E>=0,G>=0] 


#### Simplifying cost structure of CE 63 

#### Simplifying cost structure of CE 54 

#### Simplifying cost structure of CE 50 

#### Simplifying cost structure of CE 55 

#### Simplifying cost structure of CE 51 

#### Simplifying cost structure of CE 56 

#### Simplifying cost structure of CE 49 

#### Simplifying cost structure of CE 52 

#### Simplifying cost structure of CE 53 
 * Renamed intermediate variables: 
[ (eq(58,1),it(37))>>s(23), (eq(58,1),aux(6))>>s(24), (eq(58,1),it(38))>>s(25)]

#### Simplifying cost structure of CE 58 
 * Renamed intermediate variables: 
[ (eq(62,1),it(37))>>s(26), (eq(62,1),aux(1))>>s(27), (eq(62,1),aux(12))>>s(28), (eq(62,1),it(38))>>s(29)]

#### Simplifying cost structure of CE 62 
 * Joined equivalent variables [aux(23),s(24),s(28)] into aux(23)
 * Joined equivalent variables [s(23),s(26)] into s(23)
 * Joined equivalent variables [s(25),s(29)] into s(25)
 * Renamed intermediate variables: 
[ (eq(57,1),aux(14))>>s(30), (eq(57,1),aux(15))>>s(31), (eq(57,1),s(1))>>s(32), (eq(57,1),s(3))>>s(33)]

#### Simplifying cost structure of CE 57 
 * Renamed intermediate variables: 
[ (eq(61,1),aux(19))>>s(34), (eq(61,1),aux(20))>>s(35), (eq(61,1),aux(21))>>s(36), (eq(61,1),s(15))>>s(37), (eq(61,1),s(18))>>s(38)]

#### Simplifying cost structure of CE 61 
 * Joined equivalent variables [aux(24),s(31),s(36)] into aux(24)
 * Joined equivalent variables [s(33),s(38)] into s(33)
 * Renamed intermediate variables: 
[ (eq(60,1),it(37))>>s(39), (eq(60,1),aux(3))>>s(40), (eq(60,1),aux(5))>>s(41), (eq(60,1),it(38))>>s(42)]

#### Simplifying cost structure of CE 60 
 * Joined equivalent variables [aux(25),s(40),s(41)] into aux(25)
 * Renamed intermediate variables: 
[ (eq(59,1),aux(16))>>s(43), (eq(59,1),aux(17))>>s(44), (eq(59,1),aux(18))>>s(45), (eq(59,1),s(7))>>s(46), (eq(59,1),s(10))>>s(47)]

#### Simplifying cost structure of CE 59 
 * Joined equivalent variables [aux(26),s(44),s(45)] into aux(26)

#### Cost of chains of case_7(A,B,C,D,E,F,G,H,I,J,K,L,M):
* Chain [57]: 2
  with precondition: [A=1,B=0,K=1,L=0,I+1=D,E=H+J,C>=0,F>=0,G>=0,H>=0,I>=1,M>=0,E>=H] 

* Chain [56]: 8
  with precondition: [F=1,L=B+1,I+1=D,A+1=K,E=H+J,A>=2,C>=0,G>=0,H>=0,I>=1,L>=1,M>=C,E>=H] 

* Chain [55]: 39
  with precondition: [F=2,L=B+2,I+1=D,A+1=K,E=H+J,A>=2,C>=0,H>=0,I>=1,L>=2,M>=C,E>=H,G>=H+1] 

* Chain [54]: 38
  with precondition: [F=2,L=B+2,I+1=D,A+1=K,E=H+J,A>=2,C>=0,H>=0,I>=1,L>=2,M>=C+1,E>=H,G>=H] 

* Chain [53]: 11
  with precondition: [L=B+1,I+1=D,A+1=K,E=H+J,A>=2,C>=0,F>=2,G>=0,H>=0,I>=1,L>=1,M>=C,E>=H] 

* Chain [52]: 42
  with precondition: [L=B+2,I+1=D,A+1=K,E=H+J,A>=2,C>=0,F>=3,H>=0,I>=1,L>=2,M>=C,E>=H,G>=H+1] 

* Chain [51]: 41
  with precondition: [L=B+2,I+1=D,A+1=K,E=H+J,A>=2,C>=0,F>=3,H>=0,I>=1,L>=2,M>=C+1,E>=H,G>=H] 

* Chain [50]: 54*s(23)+52*s(25)+38
  Such that:aux(22) =< -E+G+J
aux(23) =< F
s(23) =< aux(22)
s(23) =< aux(23)
s(25) =< aux(23)

  with precondition: [I+1=D,A+1=K,H+J=E,B+F=L,A>=2,C>=0,F>=3,H>=0,I>=1,J>=0,G>=2*H,M>=C+1,L>=F,G+M+1>=2*H+C+F] 

* Chain [49]: 54*s(32)+104*s(33)+54*s(37)+39
  Such that:s(34) =< -E+G+J
s(30) =< G-H
aux(24) =< F
s(37) =< s(34)
s(37) =< aux(24)
s(33) =< aux(24)
s(32) =< s(30)
s(32) =< aux(24)

  with precondition: [I+1=D,A+1=K,H+J=E,B+F=L,A>=2,C>=0,F>=3,H>=0,I>=1,J>=0,G>=2*H+1,M>=C,L>=F,G+M+1>=2*H+C+F] 

* Chain [48]: 27*s(39)+26*s(42)+41
  Such that:s(39) =< -E+G+J
aux(25) =< F
s(39) =< aux(25)
s(42) =< aux(25)

  with precondition: [I+1=D,A+1=K,E=H+J,A>=2,B>=0,C>=0,H>=0,I>=1,G>=2*H,L>=B+3,M>=C+1,E>=H,B+F>=L+1,B+G+M+1>=2*H+C+L] 

* Chain [47]: 54*s(46)+52*s(47)+42
  Such that:s(43) =< -E+G+J
aux(26) =< F
s(46) =< s(43)
s(46) =< aux(26)
s(47) =< aux(26)

  with precondition: [I+1=D,A+1=K,E=H+J,A>=2,B>=0,C>=0,H>=0,I>=1,G>=2*H+1,L>=B+3,M>=C,E>=H,B+F>=L+1,B+G+M+1>=2*H+C+L] 


#### Simplifying cost structure of CE 64 

#### Computing cost of phase [68] 

#### Simplifying cost structure of CE 67 

#### Cost of loops [68] 

 * loop 68:lcstable(A,B,C,D,E,F,G) -> [lcstable(A',B',C',D',E',F',G')] 
15
##### Pending set lcstable(A,B,C,D,E,F,G)
* Psum in Loop 68: [it(68)=<1]

###### Computing sum for it(68)=<1  in Loop 68 
   - Applying inductive sum strategy 
     - head Candidate: A-1 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(68)=<A-1,it(68)=<A-1,it(68)=<A-A',it(68)=<A-A'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [68] 

#### Simplifying cost structure of phase [68] 

#### Cost of phase [68]:lcstable(A,B,C,D,E,F,G) -> [lcstable(A',B',C',D',E',F',G')] 
15*it(68)+0
  Such that:it(68) =< A
it(68) =< A-A'

#### Simplifying cost structure of chain [[68],70] 
 * Renamed intermediate variables: 
[ (eq(65,1),it(21))>>s(48)]

#### Simplifying cost structure of CE 65 

#### Computing cost of phase [58,59,60,61,62,63,64,66,67] 
 * Renamed intermediate variables: 
[ (eq(75,1),s(39))>>s(49), (eq(75,1),aux(25))>>s(50), (eq(75,1),s(42))>>s(51)]

#### Simplifying cost structure of CE 75 
 * Renamed intermediate variables: 
[ (it(58),s(49))>>s(52), (it(58),s(50))>>s(53), (it(58),s(51))>>s(54)]
 * Renamed intermediate variables: 
[ (eq(76,1),s(43))>>s(55), (eq(76,1),aux(26))>>s(56), (eq(76,1),s(46))>>s(57), (eq(76,1),s(47))>>s(58)]

#### Simplifying cost structure of CE 76 
 * Renamed intermediate variables: 
[ (it(59),s(55))>>s(59), (it(59),s(56))>>s(60), (it(59),s(57))>>s(61), (it(59),s(58))>>s(62)]
 * Renamed intermediate variables: 
[ (eq(73,1),aux(22))>>s(63), (eq(73,1),aux(23))>>s(64), (eq(73,1),s(23))>>s(65), (eq(73,1),s(25))>>s(66)]

#### Simplifying cost structure of CE 73 
 * Renamed intermediate variables: 
[ (it(60),s(63))>>s(67), (it(60),s(64))>>s(68), (it(60),s(65))>>s(69), (it(60),s(66))>>s(70)]
 * Renamed intermediate variables: 
[ (eq(74,1),s(34))>>s(71), (eq(74,1),s(30))>>s(72), (eq(74,1),aux(24))>>s(73), (eq(74,1),s(37))>>s(74), (eq(74,1),s(33))>>s(75), (eq(74,1),s(32))>>s(76)]

#### Simplifying cost structure of CE 74 
 * Joined equivalent variables [aux(27),s(71),s(72)] into aux(27)
 * Joined equivalent variables [s(74),s(76)] into s(74)
 * Renamed intermediate variables: 
[ (it(61),s(73))>>s(77), (it(61),aux(27))>>s(78), (it(61),s(74))>>s(79), (it(61),s(75))>>s(80)]

#### Simplifying cost structure of CE 72 

#### Simplifying cost structure of CE 71 

#### Simplifying cost structure of CE 70 

#### Simplifying cost structure of CE 69 

#### Simplifying cost structure of CE 68 

#### Cost of loops [58,59,60,61,62,63,64,66,67] 

 * loop 58:lcstable(A,B,C,D,E,F,G) -> [lcstable(A',B',C',D',E',F',G')] 
27*s(52)+26*s(54)+48
  Such that:s(52) =< -B+B'+D'
s(53) =< C'
s(52) =< s(53)
s(54) =< s(53)

 * loop 59:lcstable(A,B,C,D,E,F,G) -> [lcstable(A',B',C',D',E',F',G')] 
54*s(61)+52*s(62)+49
  Such that:s(59) =< -B+B'+D'
s(60) =< C'
s(61) =< s(59)
s(61) =< s(60)
s(62) =< s(60)

 * loop 60:lcstable(A,B,C,D,E,F,G) -> [lcstable(A',B',C',D',E',F',G')] 
54*s(69)+52*s(70)+45
  Such that:s(67) =< -B+B'+D'
s(68) =< C'
s(69) =< s(67)
s(69) =< s(68)
s(70) =< s(68)

 * loop 61:lcstable(A,B,C,D,E,F,G) -> [lcstable(A',B',C',D',E',F',G')] 
108*s(79)+104*s(80)+46
  Such that:s(77) =< C'
s(78) =< -B+B'+D'
s(79) =< s(78)
s(79) =< s(77)
s(80) =< s(77)

 * loop 62:lcstable(A,B,C,D,E,F,G) -> [lcstable(A',B',C',D',E',F',G')] 
48
 * loop 63:lcstable(A,B,C,D,E,F,G) -> [lcstable(A',B',C',D',E',F',G')] 
49
 * loop 64:lcstable(A,B,C,D,E,F,G) -> [lcstable(A',B',C',D',E',F',G')] 
18
 * loop 66:lcstable(A,B,C,D,E,F,G) -> [lcstable(A',B',C',D',E',F',G')] 
45
 * loop 67:lcstable(A,B,C,D,E,F,G) -> [lcstable(A',B',C',D',E',F',G')] 
46
##### Pending set lcstable(A,B,C,D,E,F,G)
* Psum in Loop 58: [it(58)=<1,s(81)=< -B+B'+D',s(83)=<C']
* Psum in Loop 59: [it(59)=<1,s(87)=< -B+B'+D',s(86)=<C']
* Psum in Loop 60: [it(60)=<1,s(91)=< -B+B'+D',s(90)=<C']
* Psum in Loop 61: [it(61)=<1,s(95)=< -B+B'+D',s(94)=<C']
* Psum in Loop 62: [it(62)=<1]
* Psum in Loop 63: [it(63)=<1]
* Psum in Loop 64: [it(64)=<1]
* Psum in Loop 66: [it(66)=<1]
* Psum in Loop 67: [it(67)=<1]

###### Computing sum for it(58)=<1  in Loop 58 
   - Applying inductive sum strategy 
     - head Candidate: A-1 
       - Loop 59 is collaborative and bounds [it(59)] 
       - Loop 60 is collaborative and bounds [it(60)] 
       - Loop 61 is collaborative and bounds [it(61)] 
       - Loop 62 is collaborative and bounds [it(62)] 
       - Loop 63 is collaborative and bounds [it(63)] 
       - Loop 64 is collaborative and bounds [it(64)] 
       - Loop 66 is collaborative and bounds [it(66)] 
       - Loop 67 is collaborative and bounds [it(67)] 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
       - Loop 59 is collaborative and bounds [it(59)] 
       - Loop 60 is collaborative and bounds [it(60)] 
       - Loop 61 is collaborative and bounds [it(61)] 
       - Loop 62 is collaborative and bounds [it(62)] 
       - Loop 63 is collaborative and bounds [it(63)] 
       - Loop 64 is collaborative and bounds [it(64)] 
       - Loop 66 is collaborative and bounds [it(66)] 
       - Loop 67 is collaborative and bounds [it(67)] 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(58)+it(59)+it(60)+it(61)+it(62)+it(63)+it(64)+it(66)+it(67)=<A-1,it(58)+it(59)+it(60)+it(61)+it(62)+it(63)+it(64)+it(66)+it(67)=<A-1,it(58)+it(59)+it(60)+it(61)+it(62)+it(63)+it(64)+it(66)+it(67)=<A-A',it(58)+it(59)+it(60)+it(61)+it(62)+it(63)+it(64)+it(66)+it(67)=<A-A'] 

##### Pending set A
* Psum in Loop 58: [s(81)=< -B+B'+D',s(83)=<C']
* Psum in Loop 59: [it(59)=<1,s(87)=< -B+B'+D',s(86)=<C']
* Psum in Loop 60: [it(60)=<1,s(91)=< -B+B'+D',s(90)=<C']
* Psum in Loop 61: [it(61)=<1,s(95)=< -B+B'+D',s(94)=<C']
* Psum in Loop 62: [it(62)=<1]
* Psum in Loop 63: [it(63)=<1]
* Psum in Loop 64: [it(64)=<1]
* Psum in Loop 66: [it(66)=<1]
* Psum in Loop 67: [it(67)=<1]

###### Computing sum for s(81)=< -B+B'+D'  in Loop 58 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(28)=<D] 
 * Adding constraints: [s(81)=<it(58)*aux(28)] 

##### Pending set lcstable(A,B,C,D,E,F,G)
* Pmax/min: [aux(28)=<D]
* Psum in Loop 58: [s(83)=<C']
* Psum in Loop 59: [it(59)=<1,s(87)=< -B+B'+D',s(86)=<C']
* Psum in Loop 60: [it(60)=<1,s(91)=< -B+B'+D',s(90)=<C']
* Psum in Loop 61: [it(61)=<1,s(95)=< -B+B'+D',s(94)=<C']
* Psum in Loop 62: [it(62)=<1]
* Psum in Loop 63: [it(63)=<1]
* Psum in Loop 64: [it(64)=<1]
* Psum in Loop 66: [it(66)=<1]
* Psum in Loop 67: [it(67)=<1]

###### Computing max_min for aux(28)=<D  
   - Found a solution using transitive invariants 
 * Adding constraints:[aux(28)=<D] 

##### Pending set lcstable(A,B,C,D,E,F,G)
* Psum in Loop 58: [s(83)=<C']
* Psum in Loop 59: [it(59)=<1,s(87)=< -B+B'+D',s(86)=<C']
* Psum in Loop 60: [it(60)=<1,s(91)=< -B+B'+D',s(90)=<C']
* Psum in Loop 61: [it(61)=<1,s(95)=< -B+B'+D',s(94)=<C']
* Psum in Loop 62: [it(62)=<1]
* Psum in Loop 63: [it(63)=<1]
* Psum in Loop 64: [it(64)=<1]
* Psum in Loop 66: [it(66)=<1]
* Psum in Loop 67: [it(67)=<1]

###### Computing sum for s(83)=<C'  in Loop 58 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(29)=<C] 
 * Adding constraints: [s(83)=<it(58)*aux(29)] 

##### Pending set lcstable(A,B,C,D,E,F,G)
* Pmax/min: [aux(29)=<C]
* Psum in Loop 59: [it(59)=<1,s(87)=< -B+B'+D',s(86)=<C']
* Psum in Loop 60: [it(60)=<1,s(91)=< -B+B'+D',s(90)=<C']
* Psum in Loop 61: [it(61)=<1,s(95)=< -B+B'+D',s(94)=<C']
* Psum in Loop 62: [it(62)=<1]
* Psum in Loop 63: [it(63)=<1]
* Psum in Loop 64: [it(64)=<1]
* Psum in Loop 66: [it(66)=<1]
* Psum in Loop 67: [it(67)=<1]

###### Computing max_min for aux(29)=<C  
   - Found a solution using transitive invariants 
 * Adding constraints:[aux(29)=<C] 

##### Pending set lcstable(A,B,C,D,E,F,G)
* Psum in Loop 59: [it(59)=<1,s(87)=< -B+B'+D',s(86)=<C']
* Psum in Loop 60: [it(60)=<1,s(91)=< -B+B'+D',s(90)=<C']
* Psum in Loop 61: [it(61)=<1,s(95)=< -B+B'+D',s(94)=<C']
* Psum in Loop 62: [it(62)=<1]
* Psum in Loop 63: [it(63)=<1]
* Psum in Loop 64: [it(64)=<1]
* Psum in Loop 66: [it(66)=<1]
* Psum in Loop 67: [it(67)=<1]

###### Computing sum for it(59)=<1  in Loop 59 
   - Applying inductive sum strategy 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(58)+it(59)+it(60)+it(61)+it(62)+it(63)+it(64)+it(66)+it(67)=<A-1,it(58)+it(59)+it(60)+it(61)+it(62)+it(63)+it(64)+it(66)+it(67)=<A-1,it(58)+it(59)+it(60)+it(61)+it(62)+it(63)+it(64)+it(66)+it(67)=<A-A',it(58)+it(59)+it(60)+it(61)+it(62)+it(63)+it(64)+it(66)+it(67)=<A-A'] 

##### Pending set lcstable(A,B,C,D,E,F,G)
* Psum in Loop 59: [s(87)=< -B+B'+D',s(86)=<C']
* Psum in Loop 60: [it(60)=<1,s(91)=< -B+B'+D',s(90)=<C']
* Psum in Loop 61: [it(61)=<1,s(95)=< -B+B'+D',s(94)=<C']
* Psum in Loop 62: [it(62)=<1]
* Psum in Loop 63: [it(63)=<1]
* Psum in Loop 64: [it(64)=<1]
* Psum in Loop 66: [it(66)=<1]
* Psum in Loop 67: [it(67)=<1]

###### Computing sum for s(87)=< -B+B'+D'  in Loop 59 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(30)=<D] 
 * Adding constraints: [s(87)=<it(59)*aux(30)] 

##### Pending set lcstable(A,B,C,D,E,F,G)
* Pmax/min: [aux(30)=<D]
* Psum in Loop 59: [s(86)=<C']
* Psum in Loop 60: [it(60)=<1,s(91)=< -B+B'+D',s(90)=<C']
* Psum in Loop 61: [it(61)=<1,s(95)=< -B+B'+D',s(94)=<C']
* Psum in Loop 62: [it(62)=<1]
* Psum in Loop 63: [it(63)=<1]
* Psum in Loop 64: [it(64)=<1]
* Psum in Loop 66: [it(66)=<1]
* Psum in Loop 67: [it(67)=<1]

###### Computing max_min for aux(30)=<D  
   - Found a solution using cacheing 
 * Adding constraints:[aux(30)=<aux(28)] 

##### Pending set lcstable(A,B,C,D,E,F,G)
* Psum in Loop 59: [s(86)=<C']
* Psum in Loop 60: [it(60)=<1,s(91)=< -B+B'+D',s(90)=<C']
* Psum in Loop 61: [it(61)=<1,s(95)=< -B+B'+D',s(94)=<C']
* Psum in Loop 62: [it(62)=<1]
* Psum in Loop 63: [it(63)=<1]
* Psum in Loop 64: [it(64)=<1]
* Psum in Loop 66: [it(66)=<1]
* Psum in Loop 67: [it(67)=<1]

###### Computing sum for s(86)=<C'  in Loop 59 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(31)=<C] 
 * Adding constraints: [s(86)=<it(59)*aux(31)] 

##### Pending set lcstable(A,B,C,D,E,F,G)
* Pmax/min: [aux(31)=<C]
* Psum in Loop 60: [it(60)=<1,s(91)=< -B+B'+D',s(90)=<C']
* Psum in Loop 61: [it(61)=<1,s(95)=< -B+B'+D',s(94)=<C']
* Psum in Loop 62: [it(62)=<1]
* Psum in Loop 63: [it(63)=<1]
* Psum in Loop 64: [it(64)=<1]
* Psum in Loop 66: [it(66)=<1]
* Psum in Loop 67: [it(67)=<1]

###### Computing max_min for aux(31)=<C  
   - Found a solution using cacheing 
 * Adding constraints:[aux(31)=<aux(29)] 

##### Pending set lcstable(A,B,C,D,E,F,G)
* Psum in Loop 60: [it(60)=<1,s(91)=< -B+B'+D',s(90)=<C']
* Psum in Loop 61: [it(61)=<1,s(95)=< -B+B'+D',s(94)=<C']
* Psum in Loop 62: [it(62)=<1]
* Psum in Loop 63: [it(63)=<1]
* Psum in Loop 64: [it(64)=<1]
* Psum in Loop 66: [it(66)=<1]
* Psum in Loop 67: [it(67)=<1]

###### Computing sum for it(60)=<1  in Loop 60 
   - Applying inductive sum strategy 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(58)+it(59)+it(60)+it(61)+it(62)+it(63)+it(64)+it(66)+it(67)=<A-1,it(58)+it(59)+it(60)+it(61)+it(62)+it(63)+it(64)+it(66)+it(67)=<A-1,it(58)+it(59)+it(60)+it(61)+it(62)+it(63)+it(64)+it(66)+it(67)=<A-A',it(58)+it(59)+it(60)+it(61)+it(62)+it(63)+it(64)+it(66)+it(67)=<A-A'] 

##### Pending set lcstable(A,B,C,D,E,F,G)
* Psum in Loop 60: [s(91)=< -B+B'+D',s(90)=<C']
* Psum in Loop 61: [it(61)=<1,s(95)=< -B+B'+D',s(94)=<C']
* Psum in Loop 62: [it(62)=<1]
* Psum in Loop 63: [it(63)=<1]
* Psum in Loop 64: [it(64)=<1]
* Psum in Loop 66: [it(66)=<1]
* Psum in Loop 67: [it(67)=<1]

###### Computing sum for s(91)=< -B+B'+D'  in Loop 60 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(32)=<D] 
 * Adding constraints: [s(91)=<it(60)*aux(32)] 

##### Pending set lcstable(A,B,C,D,E,F,G)
* Pmax/min: [aux(32)=<D]
* Psum in Loop 60: [s(90)=<C']
* Psum in Loop 61: [it(61)=<1,s(95)=< -B+B'+D',s(94)=<C']
* Psum in Loop 62: [it(62)=<1]
* Psum in Loop 63: [it(63)=<1]
* Psum in Loop 64: [it(64)=<1]
* Psum in Loop 66: [it(66)=<1]
* Psum in Loop 67: [it(67)=<1]

###### Computing max_min for aux(32)=<D  
   - Found a solution using cacheing 
 * Adding constraints:[aux(32)=<aux(28)] 

##### Pending set lcstable(A,B,C,D,E,F,G)
* Psum in Loop 60: [s(90)=<C']
* Psum in Loop 61: [it(61)=<1,s(95)=< -B+B'+D',s(94)=<C']
* Psum in Loop 62: [it(62)=<1]
* Psum in Loop 63: [it(63)=<1]
* Psum in Loop 64: [it(64)=<1]
* Psum in Loop 66: [it(66)=<1]
* Psum in Loop 67: [it(67)=<1]

###### Computing sum for s(90)=<C'  in Loop 60 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(33)=<C] 
 * Adding constraints: [s(90)=<it(60)*aux(33)] 

##### Pending set lcstable(A,B,C,D,E,F,G)
* Pmax/min: [aux(33)=<C]
* Psum in Loop 61: [it(61)=<1,s(95)=< -B+B'+D',s(94)=<C']
* Psum in Loop 62: [it(62)=<1]
* Psum in Loop 63: [it(63)=<1]
* Psum in Loop 64: [it(64)=<1]
* Psum in Loop 66: [it(66)=<1]
* Psum in Loop 67: [it(67)=<1]

###### Computing max_min for aux(33)=<C  
   - Found a solution using cacheing 
 * Adding constraints:[aux(33)=<aux(29)] 

##### Pending set lcstable(A,B,C,D,E,F,G)
* Psum in Loop 61: [it(61)=<1,s(95)=< -B+B'+D',s(94)=<C']
* Psum in Loop 62: [it(62)=<1]
* Psum in Loop 63: [it(63)=<1]
* Psum in Loop 64: [it(64)=<1]
* Psum in Loop 66: [it(66)=<1]
* Psum in Loop 67: [it(67)=<1]

###### Computing sum for it(61)=<1  in Loop 61 
   - Applying inductive sum strategy 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(58)+it(59)+it(60)+it(61)+it(62)+it(63)+it(64)+it(66)+it(67)=<A-1,it(58)+it(59)+it(60)+it(61)+it(62)+it(63)+it(64)+it(66)+it(67)=<A-1,it(58)+it(59)+it(60)+it(61)+it(62)+it(63)+it(64)+it(66)+it(67)=<A-A',it(58)+it(59)+it(60)+it(61)+it(62)+it(63)+it(64)+it(66)+it(67)=<A-A'] 

##### Pending set lcstable(A,B,C,D,E,F,G)
* Psum in Loop 61: [s(95)=< -B+B'+D',s(94)=<C']
* Psum in Loop 62: [it(62)=<1]
* Psum in Loop 63: [it(63)=<1]
* Psum in Loop 64: [it(64)=<1]
* Psum in Loop 66: [it(66)=<1]
* Psum in Loop 67: [it(67)=<1]

###### Computing sum for s(95)=< -B+B'+D'  in Loop 61 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(34)=<D] 
 * Adding constraints: [s(95)=<it(61)*aux(34)] 

##### Pending set lcstable(A,B,C,D,E,F,G)
* Pmax/min: [aux(34)=<D]
* Psum in Loop 61: [s(94)=<C']
* Psum in Loop 62: [it(62)=<1]
* Psum in Loop 63: [it(63)=<1]
* Psum in Loop 64: [it(64)=<1]
* Psum in Loop 66: [it(66)=<1]
* Psum in Loop 67: [it(67)=<1]

###### Computing max_min for aux(34)=<D  
   - Found a solution using cacheing 
 * Adding constraints:[aux(34)=<aux(28)] 

##### Pending set lcstable(A,B,C,D,E,F,G)
* Psum in Loop 61: [s(94)=<C']
* Psum in Loop 62: [it(62)=<1]
* Psum in Loop 63: [it(63)=<1]
* Psum in Loop 64: [it(64)=<1]
* Psum in Loop 66: [it(66)=<1]
* Psum in Loop 67: [it(67)=<1]

###### Computing sum for s(94)=<C'  in Loop 61 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(35)=<C] 
 * Adding constraints: [s(94)=<it(61)*aux(35)] 

##### Pending set lcstable(A,B,C,D,E,F,G)
* Pmax/min: [aux(35)=<C]
* Psum in Loop 62: [it(62)=<1]
* Psum in Loop 63: [it(63)=<1]
* Psum in Loop 64: [it(64)=<1]
* Psum in Loop 66: [it(66)=<1]
* Psum in Loop 67: [it(67)=<1]

###### Computing max_min for aux(35)=<C  
   - Found a solution using cacheing 
 * Adding constraints:[aux(35)=<aux(29)] 

##### Pending set lcstable(A,B,C,D,E,F,G)
* Psum in Loop 62: [it(62)=<1]
* Psum in Loop 63: [it(63)=<1]
* Psum in Loop 64: [it(64)=<1]
* Psum in Loop 66: [it(66)=<1]
* Psum in Loop 67: [it(67)=<1]

###### Computing sum for it(62)=<1  in Loop 62 
   - Applying inductive sum strategy 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(58)+it(59)+it(60)+it(61)+it(62)+it(63)+it(64)+it(66)+it(67)=<A-1,it(58)+it(59)+it(60)+it(61)+it(62)+it(63)+it(64)+it(66)+it(67)=<A-1,it(58)+it(59)+it(60)+it(61)+it(62)+it(63)+it(64)+it(66)+it(67)=<A-A',it(58)+it(59)+it(60)+it(61)+it(62)+it(63)+it(64)+it(66)+it(67)=<A-A'] 

##### Pending set lcstable(A,B,C,D,E,F,G)
* Psum in Loop 63: [it(63)=<1]
* Psum in Loop 64: [it(64)=<1]
* Psum in Loop 66: [it(66)=<1]
* Psum in Loop 67: [it(67)=<1]

###### Computing sum for it(63)=<1  in Loop 63 
   - Applying inductive sum strategy 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(58)+it(59)+it(60)+it(61)+it(62)+it(63)+it(64)+it(66)+it(67)=<A-1,it(58)+it(59)+it(60)+it(61)+it(62)+it(63)+it(64)+it(66)+it(67)=<A-1,it(58)+it(59)+it(60)+it(61)+it(62)+it(63)+it(64)+it(66)+it(67)=<A-A',it(58)+it(59)+it(60)+it(61)+it(62)+it(63)+it(64)+it(66)+it(67)=<A-A'] 

##### Pending set lcstable(A,B,C,D,E,F,G)
* Psum in Loop 64: [it(64)=<1]
* Psum in Loop 66: [it(66)=<1]
* Psum in Loop 67: [it(67)=<1]

###### Computing sum for it(64)=<1  in Loop 64 
   - Applying inductive sum strategy 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(58)+it(59)+it(60)+it(61)+it(62)+it(63)+it(64)+it(66)+it(67)=<A-1,it(58)+it(59)+it(60)+it(61)+it(62)+it(63)+it(64)+it(66)+it(67)=<A-1,it(58)+it(59)+it(60)+it(61)+it(62)+it(63)+it(64)+it(66)+it(67)=<A-A',it(58)+it(59)+it(60)+it(61)+it(62)+it(63)+it(64)+it(66)+it(67)=<A-A'] 

##### Pending set lcstable(A,B,C,D,E,F,G)
* Psum in Loop 66: [it(66)=<1]
* Psum in Loop 67: [it(67)=<1]

###### Computing sum for it(66)=<1  in Loop 66 
   - Applying inductive sum strategy 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(58)+it(59)+it(60)+it(61)+it(62)+it(63)+it(64)+it(66)+it(67)=<A-1,it(58)+it(59)+it(60)+it(61)+it(62)+it(63)+it(64)+it(66)+it(67)=<A-1,it(58)+it(59)+it(60)+it(61)+it(62)+it(63)+it(64)+it(66)+it(67)=<A-A',it(58)+it(59)+it(60)+it(61)+it(62)+it(63)+it(64)+it(66)+it(67)=<A-A'] 

##### Pending set lcstable(A,B,C,D,E,F,G)
* Psum in Loop 67: [it(67)=<1]

###### Computing sum for it(67)=<1  in Loop 67 
   - Applying inductive sum strategy 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(58)+it(59)+it(60)+it(61)+it(62)+it(63)+it(64)+it(66)+it(67)=<A-1,it(58)+it(59)+it(60)+it(61)+it(62)+it(63)+it(64)+it(66)+it(67)=<A-1,it(58)+it(59)+it(60)+it(61)+it(62)+it(63)+it(64)+it(66)+it(67)=<A-A',it(58)+it(59)+it(60)+it(61)+it(62)+it(63)+it(64)+it(66)+it(67)=<A-A'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [58,59,60,61,62,63,64,66,67] 

#### Simplifying cost structure of phase [58,59,60,61,62,63,64,66,67] 
 * Joined equivalent variables [aux(31),aux(33),aux(35)] into aux(31)
 * Joined equivalent variables [aux(30),aux(32),aux(34)] into aux(30)
 * Joined equivalent variables [it(58),it(59),it(60),it(61),it(62),it(63),it(64),it(66),it(67)] into it(58)
 * Joined equivalent variables [s(86),s(90),s(94)] into s(86)
 * Joined equivalent variables [s(87),s(91),s(95)] into s(87)
 * Joined equivalent variables [s(85),s(89),s(93)] into s(85)
 * Joined equivalent variables [s(84),s(88),s(92)] into s(84)

#### Cost of phase [58,59,60,61,62,63,64,66,67]:lcstable(A,B,C,D,E,F,G) -> [lcstable(A',B',C',D',E',F',G')] 
394*it(58)+27*s(81)+26*s(82)+216*s(84)+208*s(85)+0
  Such that:aux(29) =< C
aux(28) =< D
aux(36) =< A
aux(37) =< A-A'
it(58) =< aux(36)
it(58) =< aux(37)
aux(31) =< aux(29)
aux(30) =< aux(28)
s(83) =< it(58)*aux(29)
s(81) =< it(58)*aux(28)
s(86) =< it(58)*aux(31)
s(87) =< it(58)*aux(30)
s(84) =< s(87)
s(84) =< s(86)
s(85) =< s(86)
s(81) =< s(83)
s(82) =< s(83)

#### Simplifying cost structure of chain [[58,59,60,61,62,63,64,66,67],69] 
 * Joined equivalent variables [aux(38),aux(36),aux(37)] into aux(38)
 * Joined equivalent variables [aux(39),aux(29)] into aux(39)

#### Cost of chains of lcstable(A,B,C,D,E,F,G):
* Chain [[68],70]: 15*it(68)+8
  Such that:it(68) =< F

  with precondition: [C=1,A+1=E,A=F,A>=2,B>=0,D>=0,G>=0] 

* Chain [[58,59,60,61,62,63,64,66,67],69]: 394*it(58)+6*s(48)+27*s(81)+26*s(82)+216*s(84)+208*s(85)+8
  Such that:aux(28) =< D
aux(38) =< A
aux(39) =< C
s(48) =< aux(39)
it(58) =< aux(38)
aux(31) =< aux(39)
aux(30) =< aux(28)
s(83) =< it(58)*aux(39)
s(81) =< it(58)*aux(28)
s(86) =< it(58)*aux(31)
s(87) =< it(58)*aux(30)
s(84) =< s(87)
s(84) =< s(86)
s(85) =< s(86)
s(81) =< s(83)
s(82) =< s(83)

  with precondition: [A+1=E,A>=2,B>=0,C>=2,D>=0,G>=0,F+1>=A+C] 

* Chain [70]: 8
  with precondition: [A=1,C=1,E=2,F=1,B>=0,D>=0,G>=0] 

* Chain [69]: 6*s(48)+8
  Such that:s(48) =< C

  with precondition: [A=1,E=2,C=F,B>=0,C>=2,D>=0,G>=0] 

 * Renamed intermediate variables: 
[ (eq(77,1),s(48))>>s(96)]

#### Simplifying cost structure of CE 77 
 * Renamed intermediate variables: 
[ (eq(78,1),aux(28))>>s(97), (eq(78,1),aux(38))>>s(98), (eq(78,1),aux(39))>>s(99), (eq(78,1),s(48))>>s(100), (eq(78,1),it(58))>>s(101), (eq(78,1),aux(31))>>s(102), (eq(78,1),aux(30))>>s(103), (eq(78,1),s(83))>>s(104), (eq(78,1),s(81))>>s(105), (eq(78,1),s(86))>>s(106), (eq(78,1),s(87))>>s(107), (eq(78,1),s(84))>>s(108), (eq(78,1),s(85))>>s(109), (eq(78,1),s(82))>>s(110)]

#### Simplifying cost structure of CE 78 

#### Cost of chains of lcs(A,B,C,D,E):
* Chain [72]: 6*s(96)+17
  Such that:s(96) =< C

  with precondition: [A=1,E=0,B>=0,C>=2,D>=0] 

* Chain [71]: 6*s(100)+394*s(101)+27*s(105)+216*s(108)+208*s(109)+26*s(110)+17
  Such that:s(98) =< A
s(99) =< C
s(97) =< D
s(100) =< s(99)
s(101) =< s(98)
s(102) =< s(99)
s(103) =< s(97)
s(104) =< s(101)*s(99)
s(105) =< s(101)*s(97)
s(106) =< s(101)*s(102)
s(107) =< s(101)*s(103)
s(108) =< s(107)
s(108) =< s(106)
s(109) =< s(106)
s(105) =< s(104)
s(110) =< s(104)

  with precondition: [A>=2,B>=0,C>=2,D>=0,E>=0] 


Closed-form bounds of firstline(A,B,C,D): 
-------------------------------------
* Chain [[21],22] with precondition: [A=C,A>=2,B>=0,D>=0] 
    - Upper bound: 6*A+3 
    - Complexity: n 
* Chain [22] with precondition: [A=1,C=1,B>=0,D>=0] 
    - Upper bound: 3 
    - Complexity: constant 

### Maximum cost of firstline(A,B,C,D): 6*A+3 
Asymptotic class: n 

Closed-form bounds of newline(A,B,C,D,E,F,G): 
-------------------------------------
* Chain [[37,38],46,36] with precondition: [B=F,A>=0,B>=3,C>=0,G>=1,E>=2*A,D>=B+1,E+G+1>=2*A+B] 
    - Upper bound: -27*A+26*B+27*E+36 
    - Complexity: n 
* Chain [[37,38],46,35] with precondition: [B=D,B=F,A>=0,B>=3,C>=0,G>=1,E>=2*A,E+G+1>=2*A+B] 
    - Upper bound: -27*A+26*B+27*E+33 
    - Complexity: n 
* Chain [[37,38],45,36] with precondition: [B=F,A>=0,B>=3,C>=0,G>=0,E>=2*A+1,D>=B+1,E+G+1>=2*A+B] 
    - Upper bound: -27*A+26*B+27*E+37 
    - Complexity: n 
* Chain [[37,38],45,35] with precondition: [B=D,B=F,A>=0,B>=3,C>=0,G>=0,E>=2*A+1,E+G+1>=2*A+B] 
    - Upper bound: -27*A+26*B+27*E+34 
    - Complexity: n 
* Chain [[37,38],44,36] with precondition: [B=F,A>=0,B>=3,C>=1,G>=1,E>=2*A+1,D>=B+1,E+G>=2*A+B] 
    - Upper bound: -27*A+26*B+27*E+37 
    - Complexity: n 
* Chain [[37,38],44,35] with precondition: [B=D,B=F,A>=0,B>=3,C>=1,G>=1,E>=2*A+1,E+G>=2*A+B] 
    - Upper bound: -27*A+26*B+27*E+34 
    - Complexity: n 
* Chain [[37,38],41,35] with precondition: [D=F,A>=0,C>=0,D>=3,G>=0,E>=2*A+1,B>=D+1,E+G+1>=2*A+D] 
    - Upper bound: -27*A+26*B+27*E+32 
    - Complexity: n 
* Chain [[37,38],40,35] with precondition: [D=F,A>=0,C>=0,D>=3,G>=1,E>=2*A,B>=D+1,E+G+1>=2*A+D] 
    - Upper bound: -27*A+26*B+27*E+31 
    - Complexity: n 
* Chain [[37,38],39,35] with precondition: [D=F,A>=0,C>=1,D>=3,G>=1,E>=2*A+1,B>=D+1,E+G>=2*A+D] 
    - Upper bound: -27*A+26*B+27*E+32 
    - Complexity: n 
* Chain [46,36] with precondition: [B=2,F=2,A>=0,C>=0,D>=3,G>=1,E>=A] 
    - Upper bound: 36 
    - Complexity: constant 
* Chain [46,35] with precondition: [B=2,D=2,F=2,A>=0,C>=0,G>=1,E>=A] 
    - Upper bound: 33 
    - Complexity: constant 
* Chain [45,36] with precondition: [B=2,F=2,A>=0,C>=0,D>=3,G>=0,E>=A+1] 
    - Upper bound: 37 
    - Complexity: constant 
* Chain [45,35] with precondition: [B=2,D=2,F=2,A>=0,C>=0,G>=0,E>=A+1] 
    - Upper bound: 34 
    - Complexity: constant 
* Chain [44,36] with precondition: [B=2,F=2,A>=0,C>=1,D>=3,G>=1,E>=A+1] 
    - Upper bound: 37 
    - Complexity: constant 
* Chain [44,35] with precondition: [B=2,D=2,F=2,A>=0,C>=1,G>=1,E>=A+1] 
    - Upper bound: 34 
    - Complexity: constant 
* Chain [41,35] with precondition: [D=2,F=2,A>=0,B>=3,C>=0,G>=0,E>=A+1] 
    - Upper bound: 32 
    - Complexity: constant 
* Chain [40,35] with precondition: [D=2,F=2,A>=0,B>=3,C>=0,G>=1,E>=A] 
    - Upper bound: 31 
    - Complexity: constant 
* Chain [39,35] with precondition: [D=2,F=2,A>=0,B>=3,C>=1,G>=1,E>=A+1] 
    - Upper bound: 32 
    - Complexity: constant 
* Chain [36] with precondition: [B=1,F=1,A>=0,C>=0,D>=2,E>=0,G>=0] 
    - Upper bound: 6 
    - Complexity: constant 
* Chain [35] with precondition: [D=1,F=1,A>=0,B>=0,C>=0,E>=0,G>=0] 
    - Upper bound: 3 
    - Complexity: constant 

### Maximum cost of newline(A,B,C,D,E,F,G): max([34,26*B+28+nat(-A+E)*27+6])+3 
Asymptotic class: n 

Closed-form bounds of lcstable(A,B,C,D,E,F,G): 
-------------------------------------
* Chain [[68],70] with precondition: [C=1,A+1=E,A=F,A>=2,B>=0,D>=0,G>=0] 
    - Upper bound: 15*A+8 
    - Complexity: n 
* Chain [[58,59,60,61,62,63,64,66,67],69] with precondition: [A+1=E,A>=2,B>=0,C>=2,D>=0,G>=0,F+1>=A+C] 
    - Upper bound: 394*A+6*C+8+234*C*A+243*D*A 
    - Complexity: n^2 
* Chain [70] with precondition: [A=1,C=1,E=2,F=1,B>=0,D>=0,G>=0] 
    - Upper bound: 8 
    - Complexity: constant 
* Chain [69] with precondition: [A=1,E=2,C=F,B>=0,C>=2,D>=0,G>=0] 
    - Upper bound: 6*C+8 
    - Complexity: n 

### Maximum cost of lcstable(A,B,C,D,E,F,G): max([6*C,379*A+6*C+234*C*A+243*D*A+15*A])+8 
Asymptotic class: n^2 

Closed-form bounds of lcs(A,B,C,D,E): 
-------------------------------------
* Chain [72] with precondition: [A=1,E=0,B>=0,C>=2,D>=0] 
    - Upper bound: 6*C+17 
    - Complexity: n 
* Chain [71] with precondition: [A>=2,B>=0,C>=2,D>=0,E>=0] 
    - Upper bound: 394*A+6*C+17+234*C*A+243*D*A 
    - Complexity: n^2 

### Maximum cost of lcs(A,B,C,D,E): 234*C*A+394*A+243*D*A+ (6*C+17) 
Asymptotic class: n^2 
* Total analysis performed in 4375 ms.


Cost relation system solved by CoFloCo in 4378 ms.

Method firstline terminates?: YES

 - l_1: size of l wrt. List<Rat>
 - l_2: size of l wrt. Rat
UB for firstline(l_1,l_2) = 6*l_1+3

Method newline terminates?: YES

 - y_1: size of y wrt. Rat
 - lastline_1: size of lastline wrt. List<Rat>
 - lastline_2: size of lastline wrt. Rat
 - l_1: size of l wrt. List<Rat>
 - l_2: size of l wrt. Rat
UB for newline(y_1,lastline_1,lastline_2,l_1,l_2) = max([34,26*lastline_1+28+nat(-y_1+l_2)*27+6])+3

Method lcstable terminates?: YES

 - l1_1: size of l1 wrt. List<Rat>
 - l1_2: size of l1 wrt. Rat
 - l2_1: size of l2 wrt. List<Rat>
 - l2_2: size of l2 wrt. Rat
UB for lcstable(l1_1,l1_2,l2_1,l2_2) = max([6*l2_1,379*l1_1+6*l2_1+234*l2_1*l1_1+243*l2_2*l1_1+15*l1_1])+8

Method lcs terminates?: YES

 - l1_1: size of l1 wrt. List<Rat>
 - l1_2: size of l1 wrt. Rat
 - l2_1: size of l2 wrt. List<Rat>
 - l2_2: size of l2 wrt. Rat
UB for lcs(l1_1,l1_2,l2_1,l2_2) = 234*l2_1*l1_1+394*l1_1+243*l2_2*l1_1+ (6*l2_1+17)
