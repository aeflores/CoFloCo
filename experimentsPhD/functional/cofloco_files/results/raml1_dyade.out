
Abs program loaded in 22 ms.

Rule based representation generated in 2 ms.

Rule based representation stored in /tmp/costabs/rbr.rbr

RBR properties stored in /tmp/costabs/rbr.properties

Class invariants generated and loaded in 0 ms.

Abstract compilation performed in 14 ms.

Cost relation system stored in /tmp/costabs/crs.crs

Generated 28 equations 
entry('mult'(A,B,C,D,E):[]).
entry('dyade'(A,B,C,D,E,F,G):[]).
input_output_vars('and_op'(A,B,C),[A,B],[C]).
input_output_vars('case_0'(A,B,C,D,E),[A,B,C],[D,E]).
input_output_vars('case_1'(A,B,C,D,E,F,G),[A,B,C,D],[E,F,G]).
input_output_vars('dyade'(A,B,C,D,E,F,G),[A,B,C,D],[E,F,G]).
input_output_vars('eq'(A,B,C),[A,B],[C]).
input_output_vars('geq'(A,B,C),[A,B],[C]).
input_output_vars('gt'(A,B,C),[A,B],[C]).
input_output_vars('leq'(A,B,C),[A,B],[C]).
input_output_vars('lt'(A,B,C),[A,B],[C]).
input_output_vars('maxNorm'(A,B,C),[A,B],[C]).
input_output_vars('mult'(A,B,C,D,E),[A,B,C],[D,E]).
input_output_vars('neg'(A,B),[A],[B]).
input_output_vars('neq'(A,B,C),[A,B],[C]).
input_output_vars('or'(A,B,C),[A,B],[C]).
eq('eq',[A,B,C],0,[],[A=B,C=1,A>=0,B>=0,C>=0]).
eq('eq',[A,B,C],0,[],[A>=B+1,C=0,A>=0,B>=0,C>=0]).
eq('eq',[A,B,C],0,[],[B>=A+1,C=0,A>=0,B>=0,C>=0]).
eq('neq',[A,B,C],0,[],[A=B,C=0,A>=0,B>=0,C>=0]).
eq('neq',[A,B,C],0,[],[A>=B+1,C=1,A>=0,B>=0,C>=0]).
eq('neq',[A,B,C],0,[],[B>=A+1,C=1,A>=0,B>=0,C>=0]).
eq('lt',[A,B,C],0,[],[B-A>=1,C=1,A>=0,B>=0,C>=0]).
eq('lt',[A,B,C],0,[],[B=<A,C=0,A>=0,B>=0,C>=0]).
eq('leq',[A,B,C],0,[],[A=<B,C=1,A>=0,B>=0,C>=0]).
eq('leq',[A,B,C],0,[],[A-B>=1,C=0,A>=0,B>=0,C>=0]).
eq('gt',[A,B,C],0,[],[A-B>=1,C=1,A>=0,B>=0,C>=0]).
eq('gt',[A,B,C],0,[],[A=<B,C=0,A>=0,B>=0,C>=0]).
eq('geq',[A,B,C],0,[],[B=<A,C=1,A>=0,B>=0,C>=0]).
eq('geq',[A,B,C],0,[],[B-A>=1,C=0,A>=0,B>=0,C>=0]).
eq('neg',[A,B],0,[],[A=0,B=1,A>=0,B>=0]).
eq('neg',[A,B],0,[],[A=1,B=0,A>=0,B>=0]).
eq('and_op',[A,B,C],0,[],[A=0,C=0,A>=0,B>=0,C>=0]).
eq('and_op',[A,B,C],0,[],[A=1,C=B,A>=0,B>=0,C>=0]).
eq('or',[A,B,C],0,[],[A=1,C=1,A>=0,B>=0,C>=0]).
eq('or',[A,B,C],0,[],[A=0,C=B,A>=0,B>=0,C>=0]).
eq('maxNorm',[A,B,A],0,[],[A>=1+B,A>=0,B>=0,A>=0]).
eq('maxNorm',[A,B,B],0,[],[A=<B,A>=0,B>=0,B>=0]).
eq('case_0',[A,B,C,D,E],2,[],[B=1,D=1,A>=0,B>=0,C>=0,D>=0,E>=0]).
eq('case_0',[A,B,C,D,E],5,['mult'(A,F,G,H,I)],[C=J+G,B=F+1,F>=1,K=L,E=K+I,D=H+1,H>=1,A>=0,B>=0,C>=0,D>=0,E>=0]).
eq('mult',[A,B,C,D,E],1,['case_0'(A,B,C,D,E)],[A>=0,B>=0,C>=0,D>=0,E>=0]).
eq('case_1',[A,B,C,D,E,F,G],2,[],[A=1,F=0,E=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0]).
eq('case_1',[A,B,C,D,E,F,G],5,['mult'(H,C,D,I,J),'dyade'(K,L,C,D,M,N,O)],[B=H+L,A=K+1,K>=1,G=J+O,F=I+N,E=M+1,M>=1,I>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0]).
eq('dyade',[A,B,C,D,E,F,G],1,['case_1'(A,B,C,D,E,F,G)],[A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0]).

Preprocessing Cost Relations
=====================================

#### Computed strongly connected components 
0. recursive  : [case_0/5,mult/5]
1. recursive  : [case_1/7,dyade/7]
Warning: the following predicates are never called:[and_op/3,eq/3,geq/3,gt/3,leq/3,lt/3,maxNorm/3,neg/2,neq/3,or/3]

#### Obtained direct recursion through partial evaluation 
0. SCC is partially evaluated into mult/5
1. SCC is partially evaluated into dyade/7

Control-Flow Refinement of Cost Relations
=====================================

### Specialization of cost equations mult/5 
* CE 2 is refined into CE [5] 
* CE 1 is refined into CE [6] 


#### Refined cost equations mult/5 
* CE 5: mult(A,B,C,D,E) = 3
     [E>=0,C>=0,A>=0,D=1,B=1] 
* CE 6: mult(A,B,C,D,E) = 6+ mult(A,F,G,H,I)
     [H>=1,F>=1,E>=0,C>=0,A>=0,H+1=D,F+1=B] 

### Cost equations --> "Loop" of mult/5 
* CEs [6] --> Loop 5 
* CEs [5] --> Loop 6 

#### Loops of mult/5 
* Loop 5: mult(A,B,C,D,E)->  mult(A,A',B',C',D')
                  [C'>=1,A'>=1,E>=0,C>=0,A>=0,C'+1=D,A'+1=B] 
* Loop 6: mult(A,B,C,D,E) [E>=0,C>=0,A>=0,D=1,B=1] 

### Ranking functions of CR mult(A,B,C,D,E) 
* RF of phase [5]: [B-1]

#### Partial ranking functions of CR mult(A,B,C,D,E) 
* Partial RF of phase [5]:
  - RF of loop [5:1]:
    B-1

Discarded unfeasible chain [[5]]...(Non-terminating chain proved terminating)

### Resulting Chains:mult(A,B,C,D,E) 
* [[5],6]
* [6]


### Merging Chains  mult/5 into  External patterns of execution 
* [[6]] --> 1 
* [[6,[5]]] --> 2 


### Specialization of cost equations dyade/7 
* CE 4 is refined into CE [7] 
* CE 3 is refined into CE [8,9] 


#### Refined cost equations dyade/7 
* CE 7: dyade(A,B,C,D,E,F,G) = 3
     [G>=0,D>=0,C>=0,B>=0,F=0,E=1,A=1] 
* CE 8: dyade(A,B,C,D,E,F,G) = 6+ mult(H,I,D,J,K):1+ dyade(L,M,N,D,O,P,Q)
     [K+Q>=0,H+M>=0,P+1>=0,O>=1,L>=1,K>=0,D>=0,H>=0,K+Q=G,H+M=B,P+1=F,O+1=E,L+1=A,N=1,J=1,I=1,C=1] 
* CE 9: dyade(A,B,C,D,E,F,G) = 6+ mult(H,C,D,C,I):2+ dyade(J,K,C,D,L,M,N)
     [I+N>=0,C+M>=0,H+K>=0,L>=1,J>=1,I>=0,C>=2,D>=0,H>=0,I+N=G,C+M=F,H+K=B,L+1=E,J+1=A] 

### Cost equations --> "Loop" of dyade/7 
* CEs [9] --> Loop 7 
* CEs [8] --> Loop 8 
* CEs [7] --> Loop 9 

#### Loops of dyade/7 
* Loop 7: dyade(A,B,C,D,E,F,G)->  dyade(A',B',C,D,C',D',E')
                  [G>=E',B>=B',G>=0,F>=0,E>=2,D>=0,C>=2,B>=0,A>=2,F=C+D',E=C'+1,A=A'+1] 
* Loop 8: dyade(A,B,C,D,E,F,G)->  dyade(A',B',C',D,D',E',F')
                  [G>=F',B>=B',G>=0,F>=0,E>=2,D>=0,B>=0,A>=2,F=E'+1,E=D'+1,A=A'+1,C'=1,C=1] 
* Loop 9: dyade(A,B,C,D,E,F,G) [G>=0,D>=0,C>=0,B>=0,F=0,E=1,A=1] 

### Ranking functions of CR dyade(A,B,C,D,E,F,G) 
* RF of phase [7]: [A-1]
* RF of phase [8]: [A-1]

#### Partial ranking functions of CR dyade(A,B,C,D,E,F,G) 
* Partial RF of phase [7]:
  - RF of loop [7:1]:
    A-1
* Partial RF of phase [8]:
  - RF of loop [8:1]:
    A-1

Discarded unfeasible chain [[8]]...(Non-terminating chain proved terminating)
Discarded unfeasible chain [[7]](Non-terminating chain proved terminating)

### Resulting Chains:dyade(A,B,C,D,E,F,G) 
* [[8],9]
* [[7],9]
* [9]


### Merging Chains  dyade/7 into  External patterns of execution 
* [[9]] --> 1 
* [[9,[8]]] --> 2 
* [[9,[7]]] --> 3 


Computing Bounds
=====================================

#### Simplifying cost structure of CE 5 

#### Computing cost of phase [5] 

#### Simplifying cost structure of CE 6 

#### Cost of loops [5] 

 * loop 5:mult(A,B,C,D,E) -> [mult(A',B',C',D',E')] 
6
##### Pending set mult(A,B,C,D,E)
* Psum in Loop 5: [it(5)=<1]

###### Computing sum for it(5)=<1  in Loop 5 
   - Applying inductive sum strategy 
     - head Candidate: B-1 
     - head Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B-1 
     - tail Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(5)=<B-1,it(5)=<B-1,it(5)=<B-B',it(5)=<B-B'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [5] 

#### Simplifying cost structure of phase [5] 

#### Cost of phase [5]:mult(A,B,C,D,E) -> [mult(A',B',C',D',E')] 
6*it(5)+0
  Such that:it(5) =< B
it(5) =< B-B'

#### Simplifying cost structure of chain [[5],6] 

#### Cost of chains of mult(A,B,C,D,E):
* Chain [[5],6]: 6*it(5)+3
  Such that:it(5) =< D

  with precondition: [B=D,A>=0,B>=2,C>=0,E>=0] 

* Chain [6]: 3
  with precondition: [B=1,D=1,A>=0,C>=0,E>=0] 


#### Simplifying cost structure of CE 7 

#### Computing cost of phase [8] 

#### Simplifying cost structure of CE 8 

#### Cost of loops [8] 

 * loop 8:dyade(A,B,C,D,E,F,G) -> [dyade(A',B',C',D',E',F',G')] 
9
##### Pending set dyade(A,B,C,D,E,F,G)
* Psum in Loop 8: [it(8)=<1]

###### Computing sum for it(8)=<1  in Loop 8 
   - Applying inductive sum strategy 
     - head Candidate: A-1 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(8)=<A-1,it(8)=<A-1,it(8)=<A-A',it(8)=<A-A'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [8] 

#### Simplifying cost structure of phase [8] 

#### Cost of phase [8]:dyade(A,B,C,D,E,F,G) -> [dyade(A',B',C',D',E',F',G')] 
9*it(8)+0
  Such that:it(8) =< A
it(8) =< A-A'

#### Simplifying cost structure of chain [[8],9] 

#### Computing cost of phase [7] 
 * Renamed intermediate variables: 
[ (eq(9,1),it(5))>>s(1)]

#### Simplifying cost structure of CE 9 
 * Renamed intermediate variables: 
[ (it(7),s(1))>>s(2)]

#### Cost of loops [7] 

 * loop 7:dyade(A,B,C,D,E,F,G) -> [dyade(A',B',C',D',E',F',G')] 
6*s(2)+9
  Such that:s(2) =< C'

##### Pending set dyade(A,B,C,D,E,F,G)
* Psum in Loop 7: [it(7)=<1,s(3)=<C']

###### Computing sum for it(7)=<1  in Loop 7 
   - Applying inductive sum strategy 
     - head Candidate: A-1 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(7)=<A-1,it(7)=<A-1,it(7)=<A-A',it(7)=<A-A'] 

##### Pending set A
* Psum in Loop 7: [s(3)=<C']

###### Computing sum for s(3)=<C'  in Loop 7 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(1)=<C] 
 * Adding constraints: [s(3)=<it(7)*aux(1)] 

##### Pending set dyade(A,B,C,D,E,F,G)
* Pmax/min: [aux(1)=<C]

###### Computing max_min for aux(1)=<C  
   - Found a solution using transitive invariants 
 * Adding constraints:[aux(1)=<C] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [7] 

#### Simplifying cost structure of phase [7] 

#### Cost of phase [7]:dyade(A,B,C,D,E,F,G) -> [dyade(A',B',C',D',E',F',G')] 
9*it(7)+6*s(3)+0
  Such that:it(7) =< A
it(7) =< A-A'
aux(1) =< C
s(3) =< it(7)*aux(1)

#### Simplifying cost structure of chain [[7],9] 

#### Cost of chains of dyade(A,B,C,D,E,F,G):
* Chain [[8],9]: 9*it(8)+3
  Such that:it(8) =< F

  with precondition: [C=1,A=E,A=F+1,A>=2,B>=0,D>=0,G>=0] 

* Chain [[7],9]: 9*it(7)+6*s(3)+3
  Such that:aux(1) =< C
it(7) =< E
s(3) =< it(7)*aux(1)

  with precondition: [A=E,A>=2,B>=0,C>=2,D>=0,G>=0,F+4>=2*A+C] 

* Chain [9]: 3
  with precondition: [A=1,E=1,F=0,B>=0,C>=0,D>=0,G>=0] 


Closed-form bounds of mult(A,B,C,D,E): 
-------------------------------------
* Chain [[5],6] with precondition: [B=D,A>=0,B>=2,C>=0,E>=0] 
    - Upper bound: 6*B+3 
    - Complexity: n 
* Chain [6] with precondition: [B=1,D=1,A>=0,C>=0,E>=0] 
    - Upper bound: 3 
    - Complexity: constant 

### Maximum cost of mult(A,B,C,D,E): 6*B+3 
Asymptotic class: n 

Closed-form bounds of dyade(A,B,C,D,E,F,G): 
-------------------------------------
* Chain [[8],9] with precondition: [C=1,A=E,A=F+1,A>=2,B>=0,D>=0,G>=0] 
    - Upper bound: 9*A+3 
    - Complexity: n 
* Chain [[7],9] with precondition: [A=E,A>=2,B>=0,C>=2,D>=0,G>=0,F+4>=2*A+C] 
    - Upper bound: 9*A+3+6*A*C 
    - Complexity: n^2 
* Chain [9] with precondition: [A=1,E=1,F=0,B>=0,C>=0,D>=0,G>=0] 
    - Upper bound: 3 
    - Complexity: constant 

### Maximum cost of dyade(A,B,C,D,E,F,G): 6*A*C+9*A+3 
Asymptotic class: n^2 
* Total analysis performed in 644 ms.


Cost relation system solved by CoFloCo in 650 ms.

Method mult terminates?: YES

 - n_1: size of n wrt. Rat
 - l_1: size of l wrt. List<Rat>
 - l_2: size of l wrt. Rat
UB for mult(n_1,l_1,l_2) = 6*l_1+3

Method dyade terminates?: YES

 - l1_1: size of l1 wrt. List<Rat>
 - l1_2: size of l1 wrt. Rat
 - l2_1: size of l2 wrt. List<Rat>
 - l2_2: size of l2 wrt. Rat
UB for dyade(l1_1,l1_2,l2_1,l2_2) = 6*l1_1*l2_1+9*l1_1+3
