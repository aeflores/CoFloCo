
Abs program loaded in 13 ms.

Rule based representation generated in 1 ms.

Rule based representation stored in /tmp/costabs/rbr.rbr

RBR properties stored in /tmp/costabs/rbr.properties

Class invariants generated and loaded in 0 ms.

Abstract compilation performed in 8 ms.

Cost relation system stored in /tmp/costabs/crs.crs

Generated 36 equations 
entry('zip3'(A,B,C,D,E,F,G,H,I):[]).
entry('group3'(A,B,C,D,E):[]).
input_output_vars('and_op'(A,B,C),[A,B],[C]).
input_output_vars('case_0'(A,B,C,D,E,F,G,H,I),[A,B,C,D,E,F],[G,H,I]).
input_output_vars('case_1'(A,B,C,D,E,F,G,H,I,J,K,L),[A,B,C,D,E,F,G,H,I],[J,K,L]).
input_output_vars('case_2'(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O),[A,B,C,D,E,F,G,H,I,J,K,L],[M,N,O]).
input_output_vars('case_3'(A,B,C,D,E),[A,B],[C,D,E]).
input_output_vars('case_4'(A,B,C,D,E,F,G,H),[A,B,C,D,E],[F,G,H]).
input_output_vars('case_5'(A,B,C,D,E,F,G,H,I,J,K),[A,B,C,D,E,F,G,H],[I,J,K]).
input_output_vars('eq'(A,B,C),[A,B],[C]).
input_output_vars('geq'(A,B,C),[A,B],[C]).
input_output_vars('group3'(A,B,C,D,E),[A,B],[C,D,E]).
input_output_vars('gt'(A,B,C),[A,B],[C]).
input_output_vars('leq'(A,B,C),[A,B],[C]).
input_output_vars('lt'(A,B,C),[A,B],[C]).
input_output_vars('maxNorm'(A,B,C),[A,B],[C]).
input_output_vars('neg'(A,B),[A],[B]).
input_output_vars('neq'(A,B,C),[A,B],[C]).
input_output_vars('or'(A,B,C),[A,B],[C]).
input_output_vars('zip3'(A,B,C,D,E,F,G,H,I),[A,B,C,D,E,F],[G,H,I]).
eq('eq',[A,B,C],0,[],[A=B,C=1,A>=0,B>=0,C>=0]).
eq('eq',[A,B,C],0,[],[A>=B+1,C=0,A>=0,B>=0,C>=0]).
eq('eq',[A,B,C],0,[],[B>=A+1,C=0,A>=0,B>=0,C>=0]).
eq('neq',[A,B,C],0,[],[A=B,C=0,A>=0,B>=0,C>=0]).
eq('neq',[A,B,C],0,[],[A>=B+1,C=1,A>=0,B>=0,C>=0]).
eq('neq',[A,B,C],0,[],[B>=A+1,C=1,A>=0,B>=0,C>=0]).
eq('lt',[A,B,C],0,[],[B-A>=1,C=1,A>=0,B>=0,C>=0]).
eq('lt',[A,B,C],0,[],[B=<A,C=0,A>=0,B>=0,C>=0]).
eq('leq',[A,B,C],0,[],[A=<B,C=1,A>=0,B>=0,C>=0]).
eq('leq',[A,B,C],0,[],[A-B>=1,C=0,A>=0,B>=0,C>=0]).
eq('gt',[A,B,C],0,[],[A-B>=1,C=1,A>=0,B>=0,C>=0]).
eq('gt',[A,B,C],0,[],[A=<B,C=0,A>=0,B>=0,C>=0]).
eq('geq',[A,B,C],0,[],[B=<A,C=1,A>=0,B>=0,C>=0]).
eq('geq',[A,B,C],0,[],[B-A>=1,C=0,A>=0,B>=0,C>=0]).
eq('neg',[A,B],0,[],[A=0,B=1,A>=0,B>=0]).
eq('neg',[A,B],0,[],[A=1,B=0,A>=0,B>=0]).
eq('and_op',[A,B,C],0,[],[A=0,C=0,A>=0,B>=0,C>=0]).
eq('and_op',[A,B,C],0,[],[A=1,C=B,A>=0,B>=0,C>=0]).
eq('or',[A,B,C],0,[],[A=1,C=1,A>=0,B>=0,C>=0]).
eq('or',[A,B,C],0,[],[A=0,C=B,A>=0,B>=0,C>=0]).
eq('maxNorm',[A,B,A],0,[],[A>=1+B,A>=0,B>=0,A>=0]).
eq('maxNorm',[A,B,B],0,[],[A=<B,A>=0,B>=0,B>=0]).
eq('case_0',[A,B,C,D,E,F,G,H,I],2,[],[B=0,A=1,I=0,H=1,G=0,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0]).
eq('case_1',[A,B,C,D,E,F,G,H,I,J,K,L],2,[],[D=0,C=1,L=0,K=1,J=0,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0]).
eq('case_2',[A,B,C,D,E,F,G,H,I,J,K,L,M,N,O],2,[],[F=0,E=1,O=0,N=1,M=0,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0,M>=0,N>=0,O>=0]).
eq('case_2',[A,B,C,D,E,F,G,H,I,J,K,L,M,N,O],5,['zip3'(H,I,K,L,P,Q,R,S,T)],[F=U+Q,E=P+1,P>=1,U>=1,V=G+J+U,W=1,U>=1,J>=1,G>=1,O=V+T,N=S+1,M=W+R,S>=1,W>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0,M>=0,N>=0,O>=0]).
eq('case_1',[A,B,C,D,E,F,G,H,I,J,K,L],3,['case_2'(A,B,C,D,E,F,G,H,I,M,N,O,J,K,L)],[D=M+O,C=N+1,N>=1,M>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0]).
eq('case_0',[A,B,C,D,E,F,G,H,I],3,['case_1'(A,B,C,D,E,F,J,K,L,G,H,I)],[B=J+L,A=K+1,K>=1,J>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0]).
eq('zip3',[A,B,C,D,E,F,G,H,I],1,['case_0'(A,B,C,D,E,F,G,H,I)],[A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0]).
eq('case_3',[A,B,C,D,E],2,[],[B=0,A=1,E=0,D=1,C=0,A>=0,B>=0,C>=0,D>=0,E>=0]).
eq('case_4',[A,B,C,D,E,F,G,H],2,[],[E=0,D=1,H=0,G=1,F=0,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0]).
eq('case_5',[A,B,C,D,E,F,G,H,I,J,K],2,[],[H=0,G=1,K=0,J=1,I=0,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0]).
eq('case_5',[A,B,C,D,E,F,G,H,I,J,K],5,['group3'(L,M,N,O,P)],[H=Q+M,G=L+1,L>=1,Q>=1,R=C+F+Q,S=1,Q>=1,F>=1,C>=1,K=R+P,J=O+1,I=S+N,O>=1,S>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0]).
eq('case_4',[A,B,C,D,E,F,G,H],3,['case_5'(A,B,C,D,E,I,J,K,F,G,H)],[E=I+K,D=J+1,J>=1,I>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0]).
eq('case_3',[A,B,C,D,E],3,['case_4'(A,B,F,G,H,C,D,E)],[B=F+H,A=G+1,G>=1,F>=1,A>=0,B>=0,C>=0,D>=0,E>=0]).
eq('group3',[A,B,C,D,E],1,['case_3'(A,B,C,D,E)],[A>=0,B>=0,C>=0,D>=0,E>=0]).

Preprocessing Cost Relations
=====================================

#### Computed strongly connected components 
0. recursive  : [case_3/5,case_4/8,case_5/11,group3/5]
1. recursive  : [case_0/9,case_1/12,case_2/15,zip3/9]
Warning: the following predicates are never called:[and_op/3,eq/3,geq/3,gt/3,leq/3,lt/3,maxNorm/3,neg/2,neq/3,or/3]

#### Obtained direct recursion through partial evaluation 
0. SCC is partially evaluated into group3/5
1. SCC is partially evaluated into zip3/9

Control-Flow Refinement of Cost Relations
=====================================

### Specialization of cost equations group3/5 
* CE 6 is refined into CE [9] 
* CE 5 is refined into CE [10] 
* CE 8 is refined into CE [11] 
* CE 7 is refined into CE [12] 


#### Refined cost equations group3/5 
* CE 9: group3(A,B,C,D,E) = 9
     [B>=2,E=0,D=1,C=0,A=3] 
* CE 10: group3(A,B,C,D,E) = 6
     [B>=1,E=0,D=1,C=0,A=2] 
* CE 11: group3(A,B,C,D,E) = 3
     [E=0,D=1,C=0,B=0,A=1] 
* CE 12: group3(A,B,C,D,E) = 12+ group3(F,G,H,I,J)
     [B>=G+3,I>=1,H+1>=0,E>=0,B>=2,A>=4,E+G=B+J,A=F+3,I+1=D,H+1=C] 

### Cost equations --> "Loop" of group3/5 
* CEs [12] --> Loop 9 
* CEs [9] --> Loop 10 
* CEs [10] --> Loop 11 
* CEs [11] --> Loop 12 

#### Loops of group3/5 
* Loop 9: group3(A,B,C,D,E)->  group3(A',B',C',D',E')
                  [B>=B'+3,D'>=1,C'+1>=0,E>=0,B>=2,A>=4,B+E'=E+B',A=A'+3,D'+1=D,C'+1=C] 
* Loop 10: group3(A,B,C,D,E) [B>=2,E=0,D=1,C=0,A=3] 
* Loop 11: group3(A,B,C,D,E) [B>=1,E=0,D=1,C=0,A=2] 
* Loop 12: group3(A,B,C,D,E) [E=0,D=1,C=0,B=0,A=1] 

### Ranking functions of CR group3(A,B,C,D,E) 
* RF of phase [9]: [A/3-1,B/3-1/3]

#### Partial ranking functions of CR group3(A,B,C,D,E) 
* Partial RF of phase [9]:
  - RF of loop [9:1]:
    A/3-1
    B/3-1/3

Discarded unfeasible chain [[9]]...(Non-terminating chain proved terminating)

### Resulting Chains:group3(A,B,C,D,E) 
* [[9],12]
* [[9],11]
* [[9],10]
* [12]
* [11]
* [10]


### Merging Chains  group3/5 into  External patterns of execution 
* [[12]] --> 1 
* [[11]] --> 2 
* [[10]] --> 3 
* [[12,[9]]] --> 4 
* [[11,[9]]] --> 5 
* [[10,[9]]] --> 6 


### Specialization of cost equations zip3/9 
* CE 2 is refined into CE [13] 
* CE 1 is refined into CE [14] 
* CE 4 is refined into CE [15] 
* CE 3 is refined into CE [16] 


#### Refined cost equations zip3/9 
* CE 13: zip3(A,B,C,D,E,F,G,H,I) = 9
     [D>=1,C>=2,B>=1,A>=2,I=0,H=1,G=0,F=0,E=1] 
* CE 14: zip3(A,B,C,D,E,F,G,H,I) = 6
     [F>=0,E>=0,B>=1,A>=2,I=0,H=1,G=0,D=0,C=1] 
* CE 15: zip3(A,B,C,D,E,F,G,H,I) = 3
     [F>=0,E>=0,D>=0,C>=0,I=0,H=1,G=0,B=0,A=1] 
* CE 16: zip3(A,B,C,D,E,F,G,H,I) = 12+ zip3(J,K,L,M,N,O,P,Q,R)
     [B+D+F+R>=I+M+O,I+M+O>=D+F+R+1,F>=O+1,D>=M+1,Q>=1,P+1>=0,N>=1,M>=0,L>=1,J>=1,I>=0,F>=0,I+K+M+O=B+D+F+R,Q+1=H,P+1=G,N+1=E,L+1=C,J+1=A] 

### Cost equations --> "Loop" of zip3/9 
* CEs [16] --> Loop 13 
* CEs [13] --> Loop 14 
* CEs [14] --> Loop 15 
* CEs [15] --> Loop 16 

#### Loops of zip3/9 
* Loop 13: zip3(A,B,C,D,E,F,G,H,I)->  zip3(A',B',C',D',E',F',G',H',I')
                  [B+D+F+I'>=I+D'+F',I+D'+F'>=D+F+I'+1,F>=F'+1,D>=D'+1,H'>=1,G'+1>=0,E'>=1,D'>=0,C'>=1,A'>=1,I>=0,F>=0,B+D+F+I'=I+B'+D'+F',H'+1=H,G'+1=G,E'+1=E,C'+1=C,A'+1=A] 
* Loop 14: zip3(A,B,C,D,E,F,G,H,I) [D>=1,C>=2,B>=1,A>=2,I=0,H=1,G=0,F=0,E=1] 
* Loop 15: zip3(A,B,C,D,E,F,G,H,I) [F>=0,E>=0,B>=1,A>=2,I=0,H=1,G=0,D=0,C=1] 
* Loop 16: zip3(A,B,C,D,E,F,G,H,I) [F>=0,E>=0,D>=0,C>=0,I=0,H=1,G=0,B=0,A=1] 

### Ranking functions of CR zip3(A,B,C,D,E,F,G,H,I) 
* RF of phase [13]: [A-1,B,C-1,D,E-1,F+1]

#### Partial ranking functions of CR zip3(A,B,C,D,E,F,G,H,I) 
* Partial RF of phase [13]:
  - RF of loop [13:1]:
    A-1
    B
    C-1
    D
    E-1
    F+1

Discarded unfeasible chain [[13]]...(Non-terminating chain proved terminating)

### Resulting Chains:zip3(A,B,C,D,E,F,G,H,I) 
* [[13],16]
* [[13],15]
* [[13],14]
* [16]
* [15]
* [14]


### Merging Chains  zip3/9 into  External patterns of execution 
* [[16]] --> 1 
* [[15]] --> 2 
* [[14]] --> 3 
* [[16,[13]]] --> 4 
* [[15,[13]]] --> 5 
* [[14,[13]]] --> 6 


Computing Bounds
=====================================

#### Simplifying cost structure of CE 11 

#### Computing cost of phase [9] 

#### Simplifying cost structure of CE 12 

#### Cost of loops [9] 

 * loop 9:group3(A,B,C,D,E) -> [group3(A',B',C',D',E')] 
12
##### Pending set group3(A,B,C,D,E)
* Psum in Loop 9: [it(9)=<1]

###### Computing sum for it(9)=<1  in Loop 9 
   - Applying inductive sum strategy 
     - head Candidate: A/3-1 
     - head Candidate: B/3-1/3 
     - head Candidate: A/3-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: B/3-1/3 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A/3-1 
     - tail Candidate: B/3-1/3 
     - tail Candidate: A/3-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B/3-1/3 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(9)=<A/3-1,it(9)=<B/3-1/3,it(9)=<A/3-1,it(9)=<B/3-1/3,it(9)=<A/3-A'/3,it(9)=<B/3-B'/3,it(9)=<A/3-A'/3,it(9)=<B/3-B'/3] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [9] 

#### Simplifying cost structure of phase [9] 

#### Cost of phase [9]:group3(A,B,C,D,E) -> [group3(A',B',C',D',E')] 
12*it(9)+0
  Such that:it(9) =< A/3
it(9) =< A/3-A'/3
it(9) =< B/3
it(9) =< B/3-B'/3

#### Simplifying cost structure of chain [[9],12] 

#### Simplifying cost structure of CE 10 

#### Found solution for phase  [9] in the cache 

#### Cost of phase [9]:group3(A,B,C,D,E) -> [group3(A',B',C',D',E')] 
12*it(9)+0
  Such that:it(9) =< A/3
it(9) =< A/3-A'/3
it(9) =< B/3
it(9) =< B/3-B'/3

#### Simplifying cost structure of chain [[9],11] 

#### Simplifying cost structure of CE 9 

#### Found solution for phase  [9] in the cache 

#### Cost of phase [9]:group3(A,B,C,D,E) -> [group3(A',B',C',D',E')] 
12*it(9)+0
  Such that:it(9) =< A/3
it(9) =< A/3-A'/3
it(9) =< B/3
it(9) =< B/3-B'/3

#### Simplifying cost structure of chain [[9],10] 

#### Cost of chains of group3(A,B,C,D,E):
* Chain [[9],12]: 12*it(9)+3
  Such that:it(9) =< D

  with precondition: [A=3*C+1,A+2=3*D,E=B,A>=4,E+1>=A] 

* Chain [[9],11]: 12*it(9)+6
  Such that:it(9) =< C

  with precondition: [A=3*C+2,A+1=3*D,A>=5,E+2>=A,B>=E+1] 

* Chain [[9],10]: 12*it(9)+9
  Such that:it(9) =< C

  with precondition: [A=3*C+3,A=3*D,A>=6,E+3>=A,B>=E+2] 

* Chain [12]: 3
  with precondition: [A=1,B=0,C=0,D=1,E=0] 

* Chain [11]: 6
  with precondition: [A=2,C=0,D=1,E=0,B>=1] 

* Chain [10]: 9
  with precondition: [A=3,C=0,D=1,E=0,B>=2] 


#### Simplifying cost structure of CE 15 

#### Computing cost of phase [13] 

#### Simplifying cost structure of CE 16 

#### Cost of loops [13] 

 * loop 13:zip3(A,B,C,D,E,F,G,H,I) -> [zip3(A',B',C',D',E',F',G',H',I')] 
12
##### Pending set zip3(A,B,C,D,E,F,G,H,I)
* Psum in Loop 13: [it(13)=<1]

###### Computing sum for it(13)=<1  in Loop 13 
   - Applying inductive sum strategy 
     - head Candidate: E-1 
     - head Candidate: D 
     - head Candidate: F+1 
     - head Candidate: C-1 
     - head Candidate: B 
     - head Candidate: A-1 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: B 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: D 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: E-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: F+1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: E-1 
     - tail Candidate: D 
     - tail Candidate: F+1 
     - tail Candidate: C-1 
     - tail Candidate: B 
     - tail Candidate: A-1 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: D 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: E-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: F+1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(13)=<E-1,it(13)=<D,it(13)=<F+1,it(13)=<C-1,it(13)=<B,it(13)=<A-1,it(13)=<A-1,it(13)=<B,it(13)=<C-1,it(13)=<D,it(13)=<E-1,it(13)=<F+1,it(13)=<E-E',it(13)=<D-D',it(13)=<F-F',it(13)=<C-C',it(13)=<B-B',it(13)=<A-A',it(13)=<A-A',it(13)=<B-B',it(13)=<C-C',it(13)=<D-D',it(13)=<E-E',it(13)=<F-F'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [13] 

#### Simplifying cost structure of phase [13] 

#### Cost of phase [13]:zip3(A,B,C,D,E,F,G,H,I) -> [zip3(A',B',C',D',E',F',G',H',I')] 
12*it(13)+0
  Such that:it(13) =< A
it(13) =< A-A'
it(13) =< B
it(13) =< B-B'
it(13) =< C
it(13) =< C-C'
it(13) =< D
it(13) =< D-D'
it(13) =< E
it(13) =< E-E'
it(13) =< F+1
it(13) =< F-F'

#### Simplifying cost structure of chain [[13],16] 

#### Simplifying cost structure of CE 14 

#### Found solution for phase  [13] in the cache 

#### Cost of phase [13]:zip3(A,B,C,D,E,F,G,H,I) -> [zip3(A',B',C',D',E',F',G',H',I')] 
12*it(13)+0
  Such that:it(13) =< A
it(13) =< A-A'
it(13) =< B
it(13) =< B-B'
it(13) =< C
it(13) =< C-C'
it(13) =< D
it(13) =< D-D'
it(13) =< E
it(13) =< E-E'
it(13) =< F+1
it(13) =< F-F'

#### Simplifying cost structure of chain [[13],15] 

#### Simplifying cost structure of CE 13 

#### Found solution for phase  [13] in the cache 

#### Cost of phase [13]:zip3(A,B,C,D,E,F,G,H,I) -> [zip3(A',B',C',D',E',F',G',H',I')] 
12*it(13)+0
  Such that:it(13) =< A
it(13) =< A-A'
it(13) =< B
it(13) =< B-B'
it(13) =< C
it(13) =< C-C'
it(13) =< D
it(13) =< D-D'
it(13) =< E
it(13) =< E-E'
it(13) =< F+1
it(13) =< F-F'

#### Simplifying cost structure of chain [[13],14] 

#### Cost of chains of zip3(A,B,C,D,E,F,G,H,I):
* Chain [[13],16]: 12*it(13)+3
  Such that:it(13) =< G

  with precondition: [A=G+1,A=H,A>=2,B+1>=A,C>=A,D+1>=A,E>=A,F+1>=A,I+2>=2*A+B,B+D+F>=I] 

* Chain [[13],15]: 12*it(13)+6
  Such that:it(13) =< G

  with precondition: [C=G+1,C=H,C>=2,A>=C+1,B>=C,D+1>=C,E>=C,F+1>=C,I+2>=2*C+D,B+D+F>=I+1] 

* Chain [[13],14]: 12*it(13)+9
  Such that:it(13) =< H

  with precondition: [E=G+1,E=H,E>=2,A>=E+1,B>=E,C>=E+1,D>=E,F+1>=E,I+2>=2*E+F,B+D+F>=I+2] 

* Chain [16]: 3
  with precondition: [A=1,B=0,G=0,H=1,I=0,C>=0,D>=0,E>=0,F>=0] 

* Chain [15]: 6
  with precondition: [C=1,D=0,G=0,H=1,I=0,A>=2,B>=1,E>=0,F>=0] 

* Chain [14]: 9
  with precondition: [E=1,F=0,G=0,H=1,I=0,A>=2,B>=1,C>=2,D>=1] 


Closed-form bounds of zip3(A,B,C,D,E,F,G,H,I): 
-------------------------------------
* Chain [[13],16] with precondition: [A=G+1,A=H,A>=2,B+1>=A,C>=A,D+1>=A,E>=A,F+1>=A,I+2>=2*A+B,B+D+F>=I] 
    - Upper bound: 12*B+3 
    - Complexity: n 
* Chain [[13],15] with precondition: [C=G+1,C=H,C>=2,A>=C+1,B>=C,D+1>=C,E>=C,F+1>=C,I+2>=2*C+D,B+D+F>=I+1] 
    - Upper bound: 12*D+6 
    - Complexity: n 
* Chain [[13],14] with precondition: [E=G+1,E=H,E>=2,A>=E+1,B>=E,C>=E+1,D>=E,F+1>=E,I+2>=2*E+F,B+D+F>=I+2] 
    - Upper bound: 12*B+9 
    - Complexity: n 
* Chain [16] with precondition: [A=1,B=0,G=0,H=1,I=0,C>=0,D>=0,E>=0,F>=0] 
    - Upper bound: 3 
    - Complexity: constant 
* Chain [15] with precondition: [C=1,D=0,G=0,H=1,I=0,A>=2,B>=1,E>=0,F>=0] 
    - Upper bound: 6 
    - Complexity: constant 
* Chain [14] with precondition: [E=1,F=0,G=0,H=1,I=0,A>=2,B>=1,C>=2,D>=1] 
    - Upper bound: 9 
    - Complexity: constant 

### Maximum cost of zip3(A,B,C,D,E,F,G,H,I): max([12*B+6,max([12*D+3,6])])+3 
Asymptotic class: n 

Closed-form bounds of group3(A,B,C,D,E): 
-------------------------------------
* Chain [[9],12] with precondition: [A=3*C+1,A+2=3*D,E=B,A>=4,E+1>=A] 
    - Upper bound: 4*A+11 
    - Complexity: n 
* Chain [[9],11] with precondition: [A=3*C+2,A+1=3*D,A>=5,E+2>=A,B>=E+1] 
    - Upper bound: 4*A+6 
    - Complexity: n 
* Chain [[9],10] with precondition: [A=3*C+3,A=3*D,A>=6,E+3>=A,B>=E+2] 
    - Upper bound: 4*A+9 
    - Complexity: n 
* Chain [12] with precondition: [A=1,B=0,C=0,D=1,E=0] 
    - Upper bound: 3 
    - Complexity: constant 
* Chain [11] with precondition: [A=2,C=0,D=1,E=0,B>=1] 
    - Upper bound: 6 
    - Complexity: constant 
* Chain [10] with precondition: [A=3,C=0,D=1,E=0,B>=2] 
    - Upper bound: 9 
    - Complexity: constant 

### Maximum cost of group3(A,B,C,D,E): 4*A+11 
Asymptotic class: n 
* Total analysis performed in 389 ms.


Cost relation system solved by CoFloCo in 391 ms.

Method zip3 terminates?: YES

 - l1_1: size of l1 wrt. List<A>
 - l1_2: size of l1 wrt. A
 - l2_1: size of l2 wrt. List<A>
 - l2_2: size of l2 wrt. A
 - l3_1: size of l3 wrt. List<A>
 - l3_2: size of l3 wrt. A
UB for zip3(l1_1,l1_2,l2_1,l2_2,l3_1,l3_2) = max([12*l1_2+6,max([12*l2_2+3,6])])+3

Method group3 terminates?: YES

 - l_1: size of l wrt. List<A>
 - l_2: size of l wrt. A
UB for group3(l_1,l_2) = 4*l_1+11
