
Abs program loaded in 9 ms.

Rule based representation generated in 3 ms.

Rule based representation stored in /tmp/costabs/rbr.rbr

RBR properties stored in /tmp/costabs/rbr.properties

Class invariants generated and loaded in 0 ms.

Abstract compilation performed in 7 ms.

Cost relation system stored in /tmp/costabs/crs.crs

Generated 37 equations 
entry('appendL'(A,B,C,D,E,F):[]).
entry('flatten'(A,B,C,D,E):[]).
entry('insertL'(A,B,C,D,E):[]).
entry('insertionsort'(A,B,C,D):[]).
entry('flattensort'(A,B,C,D,E):[]).
input_output_vars('and_op'(A,B,C),[A,B],[C]).
input_output_vars('appendL'(A,B,C,D,E,F),[A,B,C,D],[E,F]).
input_output_vars('case_0'(A,B,C,D,E,F),[A,B,C,D],[E,F]).
input_output_vars('case_1'(A,B,C,D,E),[A,B,C],[D,E]).
input_output_vars('case_2'(A,B,C,D,E),[A,B,C],[D,E]).
input_output_vars('case_3'(A,B,C,D,E,F,G,H),[A,B,C,D,E,F],[G,H]).
input_output_vars('case_4'(A,B,C,D),[A,B],[C,D]).
input_output_vars('eq'(A,B,C),[A,B],[C]).
input_output_vars('flatten'(A,B,C,D,E),[A,B,C],[D,E]).
input_output_vars('flattensort'(A,B,C,D,E),[A,B,C],[D,E]).
input_output_vars('geq'(A,B,C),[A,B],[C]).
input_output_vars('gt'(A,B,C),[A,B],[C]).
input_output_vars('insertL'(A,B,C,D,E),[A,B,C],[D,E]).
input_output_vars('insertionsort'(A,B,C,D),[A,B],[C,D]).
input_output_vars('leq'(A,B,C),[A,B],[C]).
input_output_vars('lt'(A,B,C),[A,B],[C]).
input_output_vars('maxNorm'(A,B,C),[A,B],[C]).
input_output_vars('neg'(A,B),[A],[B]).
input_output_vars('neq'(A,B,C),[A,B],[C]).
input_output_vars('or'(A,B,C),[A,B],[C]).
eq('eq',[A,B,C],0,[],[A=B,C=1,A>=0,B>=0,C>=0]).
eq('eq',[A,B,C],0,[],[A>=B+1,C=0,A>=0,B>=0,C>=0]).
eq('eq',[A,B,C],0,[],[B>=A+1,C=0,A>=0,B>=0,C>=0]).
eq('neq',[A,B,C],0,[],[A=B,C=0,A>=0,B>=0,C>=0]).
eq('neq',[A,B,C],0,[],[A>=B+1,C=1,A>=0,B>=0,C>=0]).
eq('neq',[A,B,C],0,[],[B>=A+1,C=1,A>=0,B>=0,C>=0]).
eq('lt',[A,B,C],0,[],[B-A>=1,C=1,A>=0,B>=0,C>=0]).
eq('lt',[A,B,C],0,[],[B=<A,C=0,A>=0,B>=0,C>=0]).
eq('leq',[A,B,C],0,[],[A=<B,C=1,A>=0,B>=0,C>=0]).
eq('leq',[A,B,C],0,[],[A-B>=1,C=0,A>=0,B>=0,C>=0]).
eq('gt',[A,B,C],0,[],[A-B>=1,C=1,A>=0,B>=0,C>=0]).
eq('gt',[A,B,C],0,[],[A=<B,C=0,A>=0,B>=0,C>=0]).
eq('geq',[A,B,C],0,[],[B=<A,C=1,A>=0,B>=0,C>=0]).
eq('geq',[A,B,C],0,[],[B-A>=1,C=0,A>=0,B>=0,C>=0]).
eq('neg',[A,B],0,[],[A=0,B=1,A>=0,B>=0]).
eq('neg',[A,B],0,[],[A=1,B=0,A>=0,B>=0]).
eq('and_op',[A,B,C],0,[],[A=0,C=0,A>=0,B>=0,C>=0]).
eq('and_op',[A,B,C],0,[],[A=1,C=B,A>=0,B>=0,C>=0]).
eq('or',[A,B,C],0,[],[A=1,C=1,A>=0,B>=0,C>=0]).
eq('or',[A,B,C],0,[],[A=0,C=B,A>=0,B>=0,C>=0]).
eq('maxNorm',[A,B,A],0,[],[A>=1+B,A>=0,B>=0,A>=0]).
eq('maxNorm',[A,B,B],0,[],[A=<B,A>=0,B>=0,B>=0]).
eq('case_0',[A,B,C,D,C,D],1,[],[A=1,A>=0,B>=0,C>=0,D>=0,C>=0,D>=0]).
eq('case_0',[A,B,C,D,E,F],4,['appendL'(G,H,C,D,I,J)],[B=K+H,A=G+1,G>=1,F=K+J,E=I+1,I>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0]).
eq('appendL',[A,B,C,D,E,F],1,['case_0'(A,B,C,D,E,F)],[A>=0,B>=0,C>=0,D>=0,E>=0,F>=0]).
eq('case_1',[A,B,C,D,E],2,[],[C=1,A=0,D=1,A>=0,B>=0,C>=0,D>=0,E>=0]).
eq('case_1',[A,B,C,D,E],6,['flatten'(F,G,H,I,J),'flatten'(K,L,M,N,O),'appendL'(I,J,N,O,P,Q),'appendL'(R,S,P,Q,D,E)],[C=M+H+1,B=S+G+L,A=R+F+K,M>=1,H>=1,R>=1,A>=0,B>=0,C>=0,D>=0,E>=0]).
eq('flatten',[A,B,C,D,E],1,['case_1'(A,B,C,D,E)],[A>=0,B>=0,C>=0,D>=0,E>=0]).
eq('case_2',[A,B,C,D,E],3,[],[B=1,F=1,E=A+G,D=F+1,F>=1,A>=0,B>=0,C>=0,D>=0,E>=0]).
eq('case_3',[A,B,C,D,E,F,G,H],3,['insertL'(A,E,F,I,J)],[A>=D+1,H=D+J,G=I+1,I>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0]).
eq('case_3',[A,B,C,D,E,F,G,H],3,[],[D>=A,I=D+F,J=E+1,E>=1,H=A+I,G=J+1,J>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0]).
eq('case_2',[A,B,C,D,E],3,['case_3'(A,B,C,F,G,H,D,E)],[C=F+H,B=G+1,G>=1,A>=0,B>=0,C>=0,D>=0,E>=0]).
eq('insertL',[A,B,C,D,E],1,['case_2'(A,B,C,D,E)],[A>=0,B>=0,C>=0,D>=0,E>=0]).
eq('case_4',[A,B,C,D],2,[],[A=1,C=1,A>=0,B>=0,C>=0,D>=0]).
eq('case_4',[A,B,C,D],4,['insertionsort'(E,F,G,H),'insertL'(I,G,H,C,D)],[B=I+F,A=E+1,E>=1,A>=0,B>=0,C>=0,D>=0]).
eq('insertionsort',[A,B,C,D],1,['case_4'(A,B,C,D)],[A>=0,B>=0,C>=0,D>=0]).
eq('flattensort',[A,B,C,D,E],2,['flatten'(A,B,C,F,G),'insertionsort'(F,G,D,E)],[A>=0,B>=0,C>=0,D>=0,E>=0]).

Preprocessing Cost Relations
=====================================

#### Computed strongly connected components 
0. recursive  : [appendL/6,case_0/6]
1. recursive [non_tail,multiple] : [case_1/5,flatten/5]
2. recursive  : [case_2/5,case_3/8,insertL/5]
3. recursive [non_tail] : [case_4/4,insertionsort/4]
4. non_recursive  : [flattensort/5]
Warning: the following predicates are never called:[and_op/3,eq/3,geq/3,gt/3,leq/3,lt/3,maxNorm/3,neg/2,neq/3,or/3]

#### Obtained direct recursion through partial evaluation 
0. SCC is partially evaluated into appendL/6
1. SCC is partially evaluated into flatten/5
2. SCC is partially evaluated into insertL/5
3. SCC is partially evaluated into insertionsort/4
4. SCC is partially evaluated into flattensort/5

Control-Flow Refinement of Cost Relations
=====================================

### Specialization of cost equations appendL/6 
* CE 2 is refined into CE [11] 
* CE 1 is refined into CE [12] 


#### Refined cost equations appendL/6 
* CE 11: appendL(A,B,C,D,C,D) = 2
     [D>=0,C>=0,B>=0,A=1] 
* CE 12: appendL(A,B,C,D,E,F) = 5+ appendL(G,H,C,D,I,J)
     [F+H>=J,I>=1,G>=1,F>=0,D>=0,C>=0,B+J=F+H,I+1=E,G+1=A] 

### Cost equations --> "Loop" of appendL/6 
* CEs [12] --> Loop 11 
* CEs [11] --> Loop 12 

#### Loops of appendL/6 
* Loop 11: appendL(A,B,C,D,E,F)->  appendL(A',B',C,D,C',D')
                  [F+B'>=D',C'>=1,A'>=1,F>=0,D>=0,C>=0,F+B'=B+D',C'+1=E,A'+1=A] 
* Loop 12: appendL(A,B,C,D,C,D) [D>=0,C>=0,B>=0,A=1] 

### Ranking functions of CR appendL(A,B,C,D,E,F) 
* RF of phase [11]: [A-1]

#### Partial ranking functions of CR appendL(A,B,C,D,E,F) 
* Partial RF of phase [11]:
  - RF of loop [11:1]:
    A-1

Discarded unfeasible chain [[11]]...(Non-terminating chain proved terminating)

### Resulting Chains:appendL(A,B,C,D,E,F) 
* [[11],12]
* [12]


### Merging Chains  appendL/6 into  External patterns of execution 
* [[12]] --> 1 
* [[12,[11]]] --> 2 


### Specialization of cost equations flatten/5 
* CE 4 is refined into CE [13] 
* CE 3 is refined into CE [14,15,16,17] 


#### Refined cost equations flatten/5 
* CE 13: flatten(A,B,C,D,E) = 3
     [E>=0,B>=0,D=1,C=1,A=0] 
* CE 14: flatten(A,B,C,D,E) = 7+ flatten(F,G,H,I,J)+ flatten(K,L,M,D,E)+ appendL(N,J,D,E,D,E):1+ appendL(O,P,D,E,D,E):1
     [P+G+L>=0,F+K+1>=0,M>=1,H>=1,E>=0,D>=0,P>=0,J>=0,P+G+L=B,H+M+1=C,F+K+1=A,I=1,O=1,N=1] 
* CE 15: flatten(A,B,C,D,E) = 7+ flatten(F,G,H,I,J)+ flatten(K,L,M,N,O)+ appendL(P,J,Q,O,R,O):1+ appendL(S,T,U,O,D,E):2
     [T+G+L>=0,S+F+K>=0,O+T>=E,D>=S,M>=1,H>=1,E>=0,O>=0,T>=0,S>=2,J>=0,T+G+L=B,S+F+K=A,D+1=S+N,D+1=S+U,D+1=R+S,D+1=Q+S,H+M+1=C,I=1,P=1] 
* CE 16: flatten(A,B,C,D,E) = 7+ flatten(F,G,H,I,J)+ flatten(K,L,M,N,O)+ appendL(I,J,P,O,D,E):2+ appendL(Q,R,D,E,D,E):1
     [R+G+L>=0,J+O>=E,F+K+1>=0,D>=I,M>=1,H>=1,E>=0,R>=0,O>=0,J>=0,I>=2,R+G+L=B,D+1=I+N,D+1=I+P,H+M+1=C,F+K+1=A,Q=1] 
* CE 17: flatten(A,B,C,D,E) = 7+ flatten(F,G,H,I,J)+ flatten(K,L,M,N,O)+ appendL(I,J,P,O,Q,R):2+ appendL(S,T,U,R,D,E):2
     [T+G+L>=0,S+F+K>=0,R+T>=E,J+O>=R,D+1>=I+S,M>=1,H>=1,E>=0,R>=0,T>=0,S>=2,O>=0,J>=0,I>=2,D+2=I+S+N,D+2=I+P+S,T+G+L=B,S+F+K=A,D+1=S+U,D+1=Q+S,H+M+1=C] 

### Cost equations --> "Loop" of flatten/5 
* CEs [17] --> Loop 13 
* CEs [16] --> Loop 14 
* CEs [15] --> Loop 15 
* CEs [14] --> Loop 16 
* CEs [13] --> Loop 17 

#### Loops of flatten/5 
* Loop 13: flatten(A,B,C,D,E)->  flatten(A',B',C',D',E')  flatten(A'2,B'2,C'2,D'2,E'2)
                  [B+E'+E'2>=E+B'+B'2,D+A'+A'2+1>=A+D',B>=B'+B'2,A>=A'+A'2+2,C>=C'+2,E'2>=0,E'>=0,D'>=2,C'>=1,E>=0,B>=0,A>=0,A+D'+D'2=D+A'+A'2+2,C'+C'2+1=C] 
* Loop 14: flatten(A,B,C,D,E)->  flatten(A',B',C',D',E')  flatten(A'2,B'2,C'2,D'2,E'2)
                  [B>=B'+B'2,E'+E'2>=E,D>=D',C>=C'+2,E'2>=0,E'>=0,D'>=2,C'>=1,E>=0,B>=0,A>=0,A=A'+A'2+1,D'+D'2=D+1,C'+C'2+1=C] 
* Loop 15: flatten(A,B,C,D,E)->  flatten(A',B',C',D',E')  flatten(A'2,B'2,C'2,D'2,E'2)
                  [B+E'2>=E+B'+B'2,D+A'+A'2>=A,B>=B'+B'2,A>=A'+A'2+2,C>=C'+2,E'2>=0,E'>=0,C'>=1,E>=0,B>=0,A>=0,A+D'2=D+A'+A'2+1,C'+C'2+1=C,D'=1] 
* Loop 16: flatten(A,B,C,D,E)->  flatten(A',B',C',D',E')  flatten(A'2,B'2,C'2,D,E)
                  [B>=B'+B'2,C>=C'+2,E'>=0,C'>=1,E>=0,D>=0,B>=0,A>=0,A=A'+A'2+1,C'+C'2+1=C,D'=1] 
* Loop 17: flatten(A,B,C,D,E) [E>=0,B>=0,D=1,C=1,A=0] 

### Ranking functions of CR flatten(A,B,C,D,E) 
* RF of phase [13,14,15,16]: [C/2-1]

#### Partial ranking functions of CR flatten(A,B,C,D,E) 
* Partial RF of phase [13,14,15,16]:
  - RF of loop [13:1,13:2,14:1,14:2,15:1,15:2,16:1,16:2]:
    C/2-1

Discarded unfeasible chain [multiple([13,14,15,16],[[],[17]])]...(Non-terminating chain proved terminating)
Remaining chain: [multiple([13,14,15,16],[[17]])]

### Resulting Chains:flatten(A,B,C,D,E) 
* [17]
* [multiple([13,14,15,16],[[17]])]


### Merging Chains  flatten/5 into  External patterns of execution 
* [[17]] --> 1 
* [[multiple([13,14,15,16],[[17]])]] --> 2 


### Specialization of cost equations insertL/5 
* CE 7 is refined into CE [18] 
* CE 5 is refined into CE [19] 
* CE 6 is refined into CE [20] 


#### Refined cost equations insertL/5 
* CE 18: insertL(A,B,C,D,E) = 7
     [2*C>=E,E>=C,D>=3,E=A+C,D=B+1] 
* CE 19: insertL(A,B,C,D,E) = 4
     [E>=0,C>=0,A>=0,D=2,B=1] 
* CE 20: insertL(A,B,C,D,E) = 7+ insertL(A,F,G,H,I)
     [A+G>=C+1,C>=G,H>=1,G>=0,F>=1,E>=0,E+G=C+I,H+1=D,F+1=B] 

### Cost equations --> "Loop" of insertL/5 
* CEs [20] --> Loop 18 
* CEs [18] --> Loop 19 
* CEs [19] --> Loop 20 

#### Loops of insertL/5 
* Loop 18: insertL(A,B,C,D,E)->  insertL(A,A',B',C',D')
                  [A+B'>=C+1,C>=B',C'>=1,B'>=0,A'>=1,E>=0,C+D'=E+B',C'+1=D,A'+1=B] 
* Loop 19: insertL(A,B,C,D,E) [C>=A,B>=2,A>=0,A+C=E,B+1=D] 
* Loop 20: insertL(A,B,C,D,E) [E>=0,C>=0,A>=0,D=2,B=1] 

### Ranking functions of CR insertL(A,B,C,D,E) 
* RF of phase [18]: [B-1]

#### Partial ranking functions of CR insertL(A,B,C,D,E) 
* Partial RF of phase [18]:
  - RF of loop [18:1]:
    B-1

Discarded unfeasible chain [[18]]...(Non-terminating chain proved terminating)

### Resulting Chains:insertL(A,B,C,D,E) 
* [[18],20]
* [[18],19]
* [20]
* [19]


### Merging Chains  insertL/5 into  External patterns of execution 
* [[20]] --> 1 
* [[19],[19,[18]]] --> 2 
* [[20,[18]]] --> 3 


### Specialization of cost equations insertionsort/4 
* CE 9 is refined into CE [21] 
* CE 8 is refined into CE [22,23,24] 


#### Refined cost equations insertionsort/4 
* CE 21: insertionsort(A,B,C,D) = 3
     [D>=0,B>=0,C=1,A=1] 
* CE 22: insertionsort(A,B,C,D) = 5+ insertionsort(E,F,G,H)+ insertL(I,J,H,K,D):1
     [I+F>=0,E>=1,D>=0,H>=0,I>=0,I+F=B,E+1=A,G=1,K=2,J=1,C=2] 
* CE 23: insertionsort(A,B,C,D) = 5+ insertionsort(E,F,G,H)+ insertL(I,J,K,C,D):2
     [I+F>=0,D>=2*I,E>=1,C>=3,I>=0,D=I+H,D=I+K,I+F=B,C=G+1,C=J+1,E+1=A] 
* CE 24: insertionsort(A,B,C,D) = 5+ insertionsort(E,F,G,H)+ insertL(I,J,H,C,D):3
     [I+F>=0,E>=1,D>=0,C>=3,H>=0,I>=1,I+F=B,C=G+1,C=J+1,E+1=A] 

### Cost equations --> "Loop" of insertionsort/4 
* CEs [24] --> Loop 21 
* CEs [23] --> Loop 22 
* CEs [22] --> Loop 23 
* CEs [21] --> Loop 24 

#### Loops of insertionsort/4 
* Loop 21: insertionsort(A,B,C,D)->  insertionsort(A',B',C',D')
                  [B>=B'+1,D'>=0,D>=0,C>=3,B>=0,A>=2,C=C'+1,A=A'+1] 
* Loop 22: insertionsort(A,B,C,D)->  insertionsort(A',B',C',D')
                  [D+2*B'>=2*B,B>=B',C>=3,B>=0,A>=2,B+D'=D+B',C=C'+1,A=A'+1] 
* Loop 23: insertionsort(A,B,C,D)->  insertionsort(A',B',C',D')
                  [B>=B',D'>=0,D>=0,B>=0,A>=2,A=A'+1,C'=1,C=2] 
* Loop 24: insertionsort(A,B,C,D) [D>=0,B>=0,C=1,A=1] 

### Ranking functions of CR insertionsort(A,B,C,D) 
* RF of phase [21,22]: [A-1]

#### Partial ranking functions of CR insertionsort(A,B,C,D) 
* Partial RF of phase [21,22]:
  - RF of loop [21:1]:
    B+1
  - RF of loop [21:1,22:1]:
    A-1

Discarded unfeasible chain [[21,22]]...(Non-terminating chain proved terminating)

### Resulting Chains:insertionsort(A,B,C,D) 
* [[21,22],23,24]
* [24]
* [23,24]


### Merging Chains  insertionsort/4 into  External patterns of execution 
* [[24]] --> 1 
* [[24,23]] --> 2 
* [[24,23,[21,22]]] --> 3 


### Specialization of cost equations flattensort/5 
* CE 10 is refined into CE [25,26,27,28] 


#### Refined cost equations flattensort/5 
* CE 25: flattensort(A,B,C,D,E) = 2+ flatten(F,B,G,H,I):1+ insertionsort(J,I,K,E):1
     [E>=0,I>=0,B>=0,K=1,J=1,H=1,G=1,F=0,D=1,C=1,A=0] 
* CE 26: flattensort(A,B,C,D,E) = 2+ flatten(F,B,C,G,H):2+ insertionsort(I,H,J,E):1
     [E>=0,H>=0,C>=3,B>=0,C=2*F+1,C=2*A+1,J=1,I=1,G=1,D=1] 
* CE 27: flattensort(A,B,C,D,E) = 2+ flatten(F,B,C,G,H):2+ insertionsort(I,H,J,E):2
     [E>=0,H>=0,C>=3,B>=0,C+1=2*F,C+1=2*A,J=2,I=2,G=2,D=2] 
* CE 28: flattensort(A,B,C,D,E) = 2+ flatten(F,B,C,D,G):2+ insertionsort(D,G,D,E):3
     [E>=0,D>=3,G>=0,C>=3,B>=0,C+2*D=2*F+3,C+2*D=2*A+3] 

### Cost equations --> "Loop" of flattensort/5 
* CEs [28] --> Loop 25 
* CEs [27] --> Loop 26 
* CEs [26] --> Loop 27 
* CEs [25] --> Loop 28 

#### Loops of flattensort/5 
* Loop 25: flattensort(A,B,C,D,E) [2*A>=C+3,E>=0,C>=3,B>=0,C+2*D=2*A+3] 
* Loop 26: flattensort(A,B,C,D,E) [E>=0,B>=0,A>=2,2*A=C+1,D=2] 
* Loop 27: flattensort(A,B,C,D,E) [E>=0,B>=0,A>=1,2*A+1=C,D=1] 
* Loop 28: flattensort(A,B,C,D,E) [E>=0,B>=0,D=1,C=1,A=0] 

### Ranking functions of CR flattensort(A,B,C,D,E) 

#### Partial ranking functions of CR flattensort(A,B,C,D,E) 


### Resulting Chains:flattensort(A,B,C,D,E) 
* [28]
* [27]
* [26]
* [25]


### Merging Chains  flattensort/5 into  External patterns of execution 
* [[28]] --> 1 
* [[27]] --> 2 
* [[26]] --> 3 
* [[25]] --> 4 


Computing Bounds
=====================================

#### Simplifying cost structure of CE 11 

#### Computing cost of phase [11] 

#### Simplifying cost structure of CE 12 

#### Cost of loops [11] 

 * loop 11:appendL(A,B,C,D,E,F) -> [appendL(A',B',C',D',E',F')] 
5
##### Pending set appendL(A,B,C,D,E,F)
* Psum in Loop 11: [it(11)=<1]

###### Computing sum for it(11)=<1  in Loop 11 
   - Applying inductive sum strategy 
     - head Candidate: A-1 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(11)=<A-1,it(11)=<A-1,it(11)=<A-A',it(11)=<A-A'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [11] 

#### Simplifying cost structure of phase [11] 

#### Cost of phase [11]:appendL(A,B,C,D,E,F) -> [appendL(A',B',C',D',E',F')] 
5*it(11)+0
  Such that:it(11) =< A
it(11) =< A-A'

#### Simplifying cost structure of chain [[11],12] 

#### Cost of chains of appendL(A,B,C,D,E,F):
* Chain [[11],12]: 5*it(11)+2
  Such that:it(11) =< -C+E

  with precondition: [A+C=E+1,A>=2,B>=0,C>=1,D>=0,F>=0,B+D>=F] 

* Chain [12]: 2
  with precondition: [A=1,C=E,D=F,B>=0,C>=0,D>=0] 


#### Simplifying cost structure of CE 13 

#### Computing cost of chain [multiple([13,14,15,16],[[17]])] with multiple recursion
 * Renamed intermediate variables: 
[ (eq(17,1),it(11))>>s(1)]
 * Renamed intermediate variables: 
[ (eq(17,2),it(11))>>s(2)]

#### Simplifying cost structure of CE 17 
 * Renamed intermediate variables: 
[ (it(13),s(2))>>s(3), (it(13),s(1))>>s(4)]
 * Renamed intermediate variables: 
[ (eq(16,1),it(11))>>s(5)]

#### Simplifying cost structure of CE 16 
 * Renamed intermediate variables: 
[ (it(14),s(5))>>s(6)]
 * Renamed intermediate variables: 
[ (eq(15,2),it(11))>>s(7)]

#### Simplifying cost structure of CE 15 
 * Renamed intermediate variables: 
[ (it(15),s(7))>>s(8)]

#### Simplifying cost structure of CE 14 

#### Cost of loops [13,14,15,16] 

 * loop 13:flatten(A,B,C,D,E) -> [flatten(A',B',C',D',E'),flatten(A'2,B'2,C'2,D'2,E'2)] 
5*s(4)+5*s(3)+11
  Such that:s(3) =< A-A'-A'2
s(4) =< -C/2+A'+C'2/2+1

 * loop 14:flatten(A,B,C,D,E) -> [flatten(A',B',C',D',E'),flatten(A'2,B'2,C'2,D'2,E'2)] 
5*s(6)+11
  Such that:s(6) =< -C/2+A'+C'2/2+1

 * loop 15:flatten(A,B,C,D,E) -> [flatten(A',B',C',D',E'),flatten(A'2,B'2,C'2,D'2,E'2)] 
5*s(8)+11
  Such that:s(8) =< A-A'-A'2

 * loop 16:flatten(A,B,C,D,E) -> [flatten(A',B',C',D',E'),flatten(A'2,B'2,C'2,D'2,E'2)] 
11
##### Pending set flatten(A,B,C,D,E)
* Psum in Loop 13: [it(13)=<1,s(10)=<A-A'-A'2,s(9)=< -C/2+A'+C'2/2+1]
* Psum in Loop 14: [it(14)=<1,s(11)=< -C/2+A'+C'2/2+1]
* Psum in Loop 15: [it(15)=<1,s(12)=<A-A'-A'2]
* Psum in Loop 16: [it(16)=<1]
* Psum in Chain-Tail [17]: [it([17])=<1]

###### Computing sum for it(13)=<1  in Loop 13 
   - Applying inductive sum strategy 
     - head Candidate: 2/3*A-C/3 
       - Loop 14 is collaborative
       - Loop 15 is collaborative
       - Loop 16 is collaborative
       - Chain [17] is ignored
     - head Candidate: 2/5*A-1/5 
       - Loop 14 is collaborative
       - Loop 15 is collaborative
       - Loop 16 is collaborative
       - Chain [17] is ignored
     - tail Candidate: 2/3*A-C/3 
       - Loop 14 is collaborative
       - Loop 15 is collaborative and bounds [it(15)] 
       - Loop 16 is collaborative
       - Chain-Tail [17] adds a constant 1/3 
     - tail Candidate: 2/5*A-1/5 
       - Loop 14 is collaborative
       - Loop 15 is collaborative and bounds [it(15)] 
       - Loop 16 is collaborative
       - Chain-Tail [17] adds a constant 1/5 
 * Adding constraints: [it(13)+it(15)=<it([17])* (1/3)+aux(1),it(13)+it(15)=<it([17])* (1/5)+aux(2),it(13)=<2/3*A-C/3,it(13)=<2/5*A-1/5,aux(1)=<2/3*A-C/3,aux(2)=<2/5*A-1/5] 

##### Pending set A
* Psum in Loop 13: [s(10)=<A-A'-A'2,s(9)=< -C/2+A'+C'2/2+1]
* Psum in Loop 14: [it(14)=<1,s(11)=< -C/2+A'+C'2/2+1]
* Psum in Loop 15: [it(15)=<1,s(12)=<A-A'-A'2]
* Psum in Loop 16: [it(16)=<1]
* Psum in Chain-Tail [17]: [it([17])=<1]

###### Computing sum for s(10)=<A-A'-A'2  in Loop 13 
   - Applying inductive sum strategy 
     - head Candidate: 4/3*A-2/3*C 
       - Loop 14 is collaborative
       - Loop 15 is collaborative
       - Loop 16 is collaborative
       - Chain [17] is ignored
     - head Candidate: A 
       - Loop 14 is collaborative and bounds [it(14)] 
       - Loop 15 is collaborative and bounds [it(15)] 
       - Loop 16 is collaborative and bounds [it(16)] 
       - Chain-Tail [17] is collaborative
     - tail Candidate: 4/3*A-2/3*C 
       - Loop 14 is collaborative
       - Loop 15 is collaborative and bounds [it(15)] 
       - Loop 16 is collaborative
       - Chain-Tail [17] adds a constant 2/3 
     - tail Candidate: A 
       - Loop 14 is collaborative and bounds [it(14)] 
       - Loop 15 is collaborative and bounds [it(15)] 
       - Loop 16 is collaborative and bounds [it(16)] 
       - Chain-Tail [17] is collaborative
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(4)=<A-C/2+1/2] 
 * Adding constraints: [s(10)=<it(13)*aux(4),it(15)+s(10)=<it([17])* (2/3)+aux(3),s(10)=<4/3*A-2/3*C,it(14)+it(15)+it(16)+s(10)=<A,aux(3)=<4/3*A-2/3*C,it(14)+it(15)+it(16)+s(10)=<A] 

##### Pending set flatten(A,B,C,D,E)
* Pmax/min: [aux(4)=<A-C/2+1/2]
* Psum in Loop 13: [s(9)=< -C/2+A'+C'2/2+1]
* Psum in Loop 14: [it(14)=<1,s(11)=< -C/2+A'+C'2/2+1]
* Psum in Loop 15: [it(15)=<1,s(12)=<A-A'-A'2]
* Psum in Loop 16: [it(16)=<1]
* Psum in Chain-Tail [17]: [it([17])=<1]

###### Computing max_min for aux(4)=<A-C/2+1/2  
   - Applying max/min strategy 
     - Loop 13 does not increase the expression
     - Loop 14 does not increase the expression
     - Loop 15 does not increase the expression
     - Loop 16 does not increase the expression
 * Adding constraints:[aux(4)=<aux(5),aux(5)=<A-C/2+1/2] 

##### Pending set flatten(A,B,C,D,E)
* Psum in Loop 13: [s(9)=< -C/2+A'+C'2/2+1]
* Psum in Loop 14: [it(14)=<1,s(11)=< -C/2+A'+C'2/2+1]
* Psum in Loop 15: [it(15)=<1,s(12)=<A-A'-A'2]
* Psum in Loop 16: [it(16)=<1]
* Psum in Chain-Tail [17]: [it([17])=<1]

###### Computing sum for s(9)=< -C/2+A'+C'2/2+1  in Loop 13 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(6)=<A-C/2-1/2] 
 * Adding constraints: [s(9)=<it(13)*aux(6)] 

##### Pending set flatten(A,B,C,D,E)
* Pmax/min: [aux(6)=<A-C/2-1/2]
* Psum in Loop 14: [it(14)=<1,s(11)=< -C/2+A'+C'2/2+1]
* Psum in Loop 15: [it(15)=<1,s(12)=<A-A'-A'2]
* Psum in Loop 16: [it(16)=<1]
* Psum in Chain-Tail [17]: [it([17])=<1]

###### Computing max_min for aux(6)=<A-C/2-1/2  
   - Found a solution using cacheing 
 * Adding constraints:[aux(6)=<aux(4)-1] 

##### Pending set flatten(A,B,C,D,E)
* Psum in Loop 14: [it(14)=<1,s(11)=< -C/2+A'+C'2/2+1]
* Psum in Loop 15: [it(15)=<1,s(12)=<A-A'-A'2]
* Psum in Loop 16: [it(16)=<1]
* Psum in Chain-Tail [17]: [it([17])=<1]

###### Computing sum for it(14)=<1  in Loop 14 
   - Applying inductive sum strategy 
     - head Candidate: 2/3*A-1/3 
       - Loop 13 is collaborative
       - Loop 15 is collaborative and bounds [it(15)] 
       - Loop 16 is collaborative
       - Chain [17] is ignored
     - head Candidate: C/2-1/2 
       - Loop 13 is collaborative
       - Loop 15 is collaborative and bounds [it(15)] 
       - Loop 16 is collaborative and bounds [it(16)] 
       - Chain-Tail [17] is collaborative
     - tail Candidate: 2/3*A-1/3 
       - Loop 13 is collaborative
       - Loop 15 is collaborative and bounds [it(15)] 
       - Loop 16 is collaborative and bounds [it(16)] 
       - Chain-Tail [17] adds a constant 1/3 
     - tail Candidate: C/2-1/2 
       - Loop 13 is collaborative
       - Loop 15 is collaborative and bounds [it(15)] 
       - Loop 16 is collaborative and bounds [it(16)] 
       - Chain-Tail [17] is collaborative
 * Adding constraints: [it(14)+it(15)+it(16)=<it([17])* (1/3)+aux(7),it(14)+it(15)=<2/3*A-1/3,it(14)+it(15)+it(16)=<C/2-1/2,aux(7)=<2/3*A-1/3,it(14)+it(15)+it(16)=<C/2-1/2] 

##### Pending set flatten(A,B,C,D,E)
* Psum in Loop 14: [s(11)=< -C/2+A'+C'2/2+1]
* Psum in Loop 15: [it(15)=<1,s(12)=<A-A'-A'2]
* Psum in Loop 16: [it(16)=<1]
* Psum in Chain-Tail [17]: [it([17])=<1]

###### Computing sum for s(11)=< -C/2+A'+C'2/2+1  in Loop 14 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(8)=<A-C/2+1/2] 
 * Adding constraints: [s(11)=<it(14)*aux(8)] 

##### Pending set flatten(A,B,C,D,E)
* Pmax/min: [aux(8)=<A-C/2+1/2]
* Psum in Loop 15: [it(15)=<1,s(12)=<A-A'-A'2]
* Psum in Loop 16: [it(16)=<1]
* Psum in Chain-Tail [17]: [it([17])=<1]

###### Computing max_min for aux(8)=<A-C/2+1/2  
   - Found a solution using cacheing 
 * Adding constraints:[aux(8)=<aux(4)] 

##### Pending set flatten(A,B,C,D,E)
* Psum in Loop 15: [it(15)=<1,s(12)=<A-A'-A'2]
* Psum in Loop 16: [it(16)=<1]
* Psum in Chain-Tail [17]: [it([17])=<1]

###### Computing sum for it(15)=<1  in Loop 15 
   - Applying inductive sum strategy 
     - head Candidate: A/2 
       - Loop 13 is collaborative
       - Loop 14 is collaborative
       - Loop 16 is collaborative
       - Chain-Tail [17] is collaborative
     - head Candidate: C/2-1/2 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A/2 
       - Loop 13 is collaborative
       - Loop 14 is collaborative
       - Loop 16 is collaborative
       - Chain-Tail [17] is collaborative
     - tail Candidate: C/2-1/2 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(15)=<A/2,it(14)+it(15)+it(16)=<C/2-1/2,it(15)=<A/2,it(14)+it(15)+it(16)=<C/2-1/2] 

##### Pending set flatten(A,B,C,D,E)
* Psum in Loop 15: [s(12)=<A-A'-A'2]
* Psum in Loop 16: [it(16)=<1]
* Psum in Chain-Tail [17]: [it([17])=<1]

###### Computing sum for s(12)=<A-A'-A'2  in Loop 15 
   - Applying inductive sum strategy 
     - head Candidate: 2*A-C+1 
       - Loop 13 is collaborative
       - Loop 14 is collaborative
       - Loop 16 is collaborative
       - Chain-Tail [17] is collaborative
     - head Candidate: A 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: 2*A-C+1 
       - Loop 13 is collaborative
       - Loop 14 is collaborative
       - Loop 16 is collaborative
       - Chain-Tail [17] is collaborative
     - tail Candidate: A 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [s(12)=<2*A-C+1,it(14)+it(16)+s(10)+s(12)=<A,s(12)=<2*A-C+1,it(14)+it(16)+s(10)+s(12)=<A] 

##### Pending set flatten(A,B,C,D,E)
* Psum in Loop 16: [it(16)=<1]
* Psum in Chain-Tail [17]: [it([17])=<1]

###### Computing sum for it(16)=<1  in Loop 16 
   - Applying inductive sum strategy 
     - head Candidate: A 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: C/2-1/2 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C/2-1/2 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(14)+it(15)+it(16)+s(10)=<A,it(14)+it(15)+it(16)=<C/2-1/2,it(14)+it(15)+it(16)+s(10)=<A,it(14)+it(15)+it(16)=<C/2-1/2] 

##### Pending set flatten(A,B,C,D,E)
* Psum in Chain-Tail [17]: [it([17])=<1]

###### Computing sum for it([17])=<1  in Chain-Tail [17] 
   - Applying inductive sum strategy 
     - head Candidate: C/2+1/2 
       - Loop 13 is collaborative
       - Loop 14 is collaborative
       - Loop 15 is collaborative
       - Loop 16 is collaborative
     - head Candidate: A/2+1 
       - Loop 13 is collaborative
       - Loop 14 adds a constant 1/2 
       - Loop 15 is collaborative
       - Loop 16 adds a constant 1/2 
     - tail Candidate: C/2+1/2 
       - Loop 13 is collaborative
       - Loop 14 is collaborative
       - Loop 15 is collaborative
       - Loop 16 is collaborative
     - tail Candidate: A/2+1 
       - Loop 13 is collaborative
       - Loop 14 adds a constant 1/2 
       - Loop 15 is collaborative
       - Loop 16 adds a constant 1/2 
 * Adding constraints: [it([17])=<it(16)* (1/2)+it(14)* (1/2)+aux(9),it([17])=<it(16)* (1/2)+it(14)* (1/2)+aux(10),it([17])=<C/2+1/2,aux(9)=<A/2+1,it([17])=<C/2+1/2,aux(10)=<A/2+1] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [13,14,15,16,[17]] 
Found a cycle in the non-final constraints
 Removed possibly redundant constraints to solve a cycle in the cost structure 
it(13)+it(15)=<it([17])* (1/3)+aux(1)
it(13)+it(15)=<it([17])* (1/5)+aux(2)
s(10)=<it(13)*aux(4)
it(15)+s(10)=<it([17])* (2/3)+aux(3)
it(14)+it(15)+it(16)=<it([17])* (1/3)+aux(7)
it([17])=<it(16)* (1/2)+it(14)* (1/2)+aux(9)
it([17])=<it(16)* (1/2)+it(14)* (1/2)+aux(10)

#### Simplifying cost structure of phase [13,14,15,16,[17]] 
 * Joined equivalent variables [aux(5),aux(4)] into aux(5)
 * Joined equivalent variables [aux(12),aux(9),aux(10)] into aux(12)
 * Joined equivalent variables [aux(13),aux(7)] into aux(13)
 * Joined equivalent variables [aux(14),aux(1)] into aux(14)
 * Joined equivalent variables [aux(15),aux(2)] into aux(15)
 * Joined equivalent variables [aux(16),aux(3)] into aux(16)

#### Cost of phase [13,14,15,16]:flatten(A,B,C,D,E) -> [] 
11*it(13)+11*it(14)+11*it(15)+11*it(16)+3*it([17])+5*s(9)+5*s(10)+5*s(11)+5*s(12)+0
  Such that:aux(5) =< A-C/2+1/2
s(12) =< 2*A-C+1
it(15) =< A/2
it([17]) =< C/2+1/2
aux(11) =< A
aux(13) =< 2/3*A
aux(14) =< 2/3*A-C/3
aux(15) =< 2/5*A
aux(16) =< 4/3*A-2/3*C
aux(17) =< C/2
it(14) =< aux(11)
it(15) =< aux(11)
it(16) =< aux(11)
s(10) =< aux(11)
s(12) =< aux(11)
it(14) =< aux(13)
it(15) =< aux(13)
it(13) =< aux(14)
it(13) =< aux(15)
s(10) =< aux(16)
it(14) =< aux(17)
it(15) =< aux(17)
it(16) =< aux(17)
aux(8) =< aux(5)
aux(6) =< aux(5)-1
s(11) =< it(14)*aux(8)
s(9) =< it(13)*aux(6)

#### Cost of chains of flatten(A,B,C,D,E):
* Chain [17]: 3
  with precondition: [A=0,C=1,D=1,B>=0,E>=0] 

* Chain [multiple([13,14,15,16],[[17]])]: 11*it(13)+11*it(14)+11*it(15)+11*it(16)+3*it([17])+5*s(9)+5*s(10)+5*s(11)+5*s(12)+0
  Such that:aux(5) =< A-C/2+1/2
s(12) =< 2*A-C+1
it(15) =< A/2
it([17]) =< C/2+1/2
aux(11) =< A
aux(13) =< 2/3*A
aux(14) =< 2/3*A-C/3
aux(15) =< 2/5*A
aux(16) =< 4/3*A-2/3*C
aux(17) =< C/2
it(14) =< aux(11)
it(15) =< aux(11)
it(16) =< aux(11)
s(10) =< aux(11)
s(12) =< aux(11)
it(14) =< aux(13)
it(15) =< aux(13)
it(13) =< aux(14)
it(13) =< aux(15)
s(10) =< aux(16)
it(14) =< aux(17)
it(15) =< aux(17)
it(16) =< aux(17)
aux(8) =< aux(5)
aux(6) =< aux(5)-1
s(11) =< it(14)*aux(8)
s(9) =< it(13)*aux(6)

  with precondition: [2*A+3=2*D+C,B>=0,C>=3,E>=0,2*A+1>=C] 


#### Simplifying cost structure of CE 19 

#### Computing cost of phase [18] 

#### Simplifying cost structure of CE 20 

#### Cost of loops [18] 

 * loop 18:insertL(A,B,C,D,E) -> [insertL(A',B',C',D',E')] 
7
##### Pending set insertL(A,B,C,D,E)
* Psum in Loop 18: [it(18)=<1]

###### Computing sum for it(18)=<1  in Loop 18 
   - Applying inductive sum strategy 
     - head Candidate: B-1 
     - head Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B-1 
     - tail Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(18)=<B-1,it(18)=<B-1,it(18)=<B-B',it(18)=<B-B'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [18] 

#### Simplifying cost structure of phase [18] 

#### Cost of phase [18]:insertL(A,B,C,D,E) -> [insertL(A',B',C',D',E')] 
7*it(18)+0
  Such that:it(18) =< B
it(18) =< B-B'

#### Simplifying cost structure of chain [[18],20] 

#### Simplifying cost structure of CE 18 

#### Found solution for phase  [18] in the cache 

#### Cost of phase [18]:insertL(A,B,C,D,E) -> [insertL(A',B',C',D',E')] 
7*it(18)+0
  Such that:it(18) =< B
it(18) =< B-B'

#### Simplifying cost structure of chain [[18],19] 
 * Renamed intermediate variables: 
[ (ch([[18],19]),it(18))>>s(13)]

#### Cost of chains of insertL(A,B,C,D,E):
* Chain [[18],20]: 7*it(18)+4
  Such that:it(18) =< D

  with precondition: [B+1=D,A>=1,B>=2,C>=0,E>=0] 

* Chain [[18],19]: 7*it(18)+7
  Such that:it(18) =< D

  with precondition: [B+1=D,A+C=E,A>=1,B>=3,C>=A] 

* Chain [20]: 4
  with precondition: [B=1,D=2,A>=0,C>=0,E>=0] 

* Chain [19]: 7
  with precondition: [B+1=D,A+C=E,A>=0,B>=2,C>=A] 


#### Simplifying cost structure of CE 21 

#### Simplifying cost structure of CE 22 

#### Simplifying cost structure of chain [23,24] 

#### Computing cost of phase [21,22] 
 * Renamed intermediate variables: 
[ (eq(24,1),it(18))>>s(14)]

#### Simplifying cost structure of CE 24 
 * Renamed intermediate variables: 
[ (it(21),s(14))>>s(15)]
 * Renamed intermediate variables: 
[ (eq(23,1),s(13))>>s(16)]

#### Simplifying cost structure of CE 23 
 * Renamed intermediate variables: 
[ (it(22),s(16))>>s(17)]

#### Cost of loops [21,22] 

 * loop 21:insertionsort(A,B,C,D) -> [insertionsort(A',B',C',D')] 
7*s(15)+9
  Such that:s(15) =< A'+1

 * loop 22:insertionsort(A,B,C,D) -> [insertionsort(A',B',C',D')] 
7*s(17)+12
  Such that:s(17) =< A'+1

##### Pending set insertionsort(A,B,C,D)
* Psum in Loop 21: [it(21)=<1,s(18)=<A'+1]
* Psum in Loop 22: [it(22)=<1,s(19)=<A'+1]

###### Computing sum for it(21)=<1  in Loop 21 
   - Applying inductive sum strategy 
     - head Candidate: A-1 
       - Loop 22 is collaborative and bounds [it(22)] 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: B+1 
       - Loop 22 is collaborative
     - tail Candidate: A-1 
       - Loop 22 is collaborative and bounds [it(22)] 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B+1 
       - Loop 22 is collaborative
 * Adding constraints: [it(21)+it(22)=<A-1,it(21)+it(22)=<A-1,it(21)=<B+1,it(21)+it(22)=<A-A',it(21)+it(22)=<A-A',it(21)=<B-B'] 

##### Pending set A
* Psum in Loop 21: [s(18)=<A'+1]
* Psum in Loop 22: [it(22)=<1,s(19)=<A'+1]

###### Computing sum for s(18)=<A'+1  in Loop 21 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(18)=<A] 
 * Adding constraints: [s(18)=<it(21)*aux(18)] 

##### Pending set insertionsort(A,B,C,D)
* Pmax/min: [aux(18)=<A]
* Psum in Loop 22: [it(22)=<1,s(19)=<A'+1]

###### Computing max_min for aux(18)=<A  
   - Found a solution using transitive invariants 
 * Adding constraints:[aux(18)=<A] 

##### Pending set insertionsort(A,B,C,D)
* Psum in Loop 22: [it(22)=<1,s(19)=<A'+1]

###### Computing sum for it(22)=<1  in Loop 22 
   - Applying inductive sum strategy 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(21)+it(22)=<A-1,it(21)+it(22)=<A-1,it(21)+it(22)=<A-A',it(21)+it(22)=<A-A'] 

##### Pending set insertionsort(A,B,C,D)
* Psum in Loop 22: [s(19)=<A'+1]

###### Computing sum for s(19)=<A'+1  in Loop 22 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(19)=<A] 
 * Adding constraints: [s(19)=<it(22)*aux(19)] 

##### Pending set insertionsort(A,B,C,D)
* Pmax/min: [aux(19)=<A]

###### Computing max_min for aux(19)=<A  
   - Found a solution using cacheing 
 * Adding constraints:[aux(19)=<aux(18)] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [21,22] 

#### Simplifying cost structure of phase [21,22] 
 * Joined equivalent variables [aux(20),aux(18)] into aux(20)

#### Cost of phase [21,22]:insertionsort(A,B,C,D) -> [insertionsort(A',B',C',D')] 
9*it(21)+12*it(22)+7*s(18)+7*s(19)+0
  Such that:it(21) =< B+1
it(21) =< B-B'
aux(20) =< A
aux(21) =< A-A'
it(21) =< aux(20)
it(22) =< aux(20)
it(21) =< aux(21)
it(22) =< aux(21)
aux(19) =< aux(20)
s(18) =< it(21)*aux(20)
s(19) =< it(22)*aux(19)

#### Simplifying cost structure of chain [[21,22],23,24] 
 * Joined equivalent variables [aux(22),aux(20),aux(21)] into aux(22)

#### Cost of chains of insertionsort(A,B,C,D):
* Chain [[21,22],23,24]: 9*it(21)+12*it(22)+7*s(18)+7*s(19)+12
  Such that:it(21) =< B
aux(22) =< A
it(21) =< aux(22)
it(22) =< aux(22)
aux(19) =< aux(22)
s(18) =< it(21)*aux(22)
s(19) =< it(22)*aux(19)

  with precondition: [A=C,A>=3,B>=0,D>=0] 

* Chain [24]: 3
  with precondition: [A=1,C=1,B>=0,D>=0] 

* Chain [23,24]: 12
  with precondition: [A=2,C=2,B>=0,D>=0] 


#### Simplifying cost structure of CE 25 
 * Renamed intermediate variables: 
[ (eq(26,1),aux(5))>>s(20), (eq(26,1),s(12))>>s(21), (eq(26,1),it(15))>>s(22), (eq(26,1),it([17]))>>s(23), (eq(26,1),aux(11))>>s(24), (eq(26,1),aux(13))>>s(25), (eq(26,1),aux(14))>>s(26), (eq(26,1),aux(15))>>s(27), (eq(26,1),aux(16))>>s(28), (eq(26,1),aux(17))>>s(29), (eq(26,1),it(14))>>s(30), (eq(26,1),it(16))>>s(31), (eq(26,1),s(10))>>s(32), (eq(26,1),it(13))>>s(33), (eq(26,1),aux(8))>>s(34), (eq(26,1),aux(6))>>s(35), (eq(26,1),s(11))>>s(36), (eq(26,1),s(9))>>s(37)]

#### Simplifying cost structure of CE 26 
 * Joined equivalent variables [aux(23),s(20),s(26),s(28)] into aux(23)
 * Joined equivalent variables [s(21),s(32)] into s(21)
 * Renamed intermediate variables: 
[ (eq(27,1),aux(5))>>s(38), (eq(27,1),s(12))>>s(39), (eq(27,1),it(15))>>s(40), (eq(27,1),it([17]))>>s(41), (eq(27,1),aux(11))>>s(42), (eq(27,1),aux(13))>>s(43), (eq(27,1),aux(14))>>s(44), (eq(27,1),aux(15))>>s(45), (eq(27,1),aux(16))>>s(46), (eq(27,1),aux(17))>>s(47), (eq(27,1),it(14))>>s(48), (eq(27,1),it(16))>>s(49), (eq(27,1),s(10))>>s(50), (eq(27,1),it(13))>>s(51), (eq(27,1),aux(8))>>s(52), (eq(27,1),aux(6))>>s(53), (eq(27,1),s(11))>>s(54), (eq(27,1),s(9))>>s(55)]

#### Simplifying cost structure of CE 27 
 * Joined equivalent variables [aux(24),s(42)] into aux(24)
 * Renamed intermediate variables: 
[ (eq(28,1),aux(5))>>s(56), (eq(28,1),s(12))>>s(57), (eq(28,1),it(15))>>s(58), (eq(28,1),it([17]))>>s(59), (eq(28,1),aux(11))>>s(60), (eq(28,1),aux(13))>>s(61), (eq(28,1),aux(14))>>s(62), (eq(28,1),aux(15))>>s(63), (eq(28,1),aux(16))>>s(64), (eq(28,1),aux(17))>>s(65), (eq(28,1),it(14))>>s(66), (eq(28,1),it(16))>>s(67), (eq(28,1),s(10))>>s(68), (eq(28,1),it(13))>>s(69), (eq(28,1),aux(8))>>s(70), (eq(28,1),aux(6))>>s(71), (eq(28,1),s(11))>>s(72), (eq(28,1),s(9))>>s(73)]
 * Renamed intermediate variables: 
[ (eq(28,2),it(21))>>s(74), (eq(28,2),aux(22))>>s(75), (eq(28,2),it(22))>>s(76), (eq(28,2),aux(19))>>s(77), (eq(28,2),s(18))>>s(78), (eq(28,2),s(19))>>s(79)]

#### Simplifying cost structure of CE 28 
 * Joined equivalent variables [s(74),s(76)] into s(74)

#### Cost of chains of flattensort(A,B,C,D,E):
* Chain [28]: 8
  with precondition: [A=0,C=1,D=1,B>=0,E>=0] 

* Chain [27]: 11*s(22)+3*s(23)+11*s(30)+11*s(31)+5
  Such that:s(24) =< A
s(23) =< A+1
s(29) =< A+1/2
s(22) =< A/2
s(25) =< 2/3*A
s(30) =< s(24)
s(22) =< s(24)
s(31) =< s(24)
s(30) =< s(25)
s(22) =< s(25)
s(30) =< s(29)
s(22) =< s(29)
s(31) =< s(29)

  with precondition: [D=1,2*A+1=C,A>=1,B>=0,E>=0] 

* Chain [26]: 5*s(39)+11*s(40)+3*s(41)+11*s(48)+11*s(49)+5*s(50)+11*s(51)+5*s(54)+5*s(55)+14
  Such that:s(38) =< 1
s(39) =< 2
s(44) =< 1/3
s(46) =< 2/3
s(47) =< C/2
s(43) =< C/3+1/3
s(40) =< C/4+1/4
s(45) =< C/5+1/5
aux(24) =< C/2+1/2
s(41) =< aux(24)
s(48) =< aux(24)
s(40) =< aux(24)
s(49) =< aux(24)
s(50) =< aux(24)
s(39) =< aux(24)
s(48) =< s(43)
s(40) =< s(43)
s(51) =< s(44)
s(51) =< s(45)
s(50) =< s(46)
s(48) =< s(47)
s(40) =< s(47)
s(49) =< s(47)
s(52) =< s(38)
s(53) =< s(38)-1
s(54) =< s(48)*s(52)
s(55) =< s(51)*s(53)

  with precondition: [D=2,2*A=C+1,A>=2,B>=0,E>=0] 

* Chain [25]: 5*s(57)+11*s(58)+3*s(59)+11*s(66)+11*s(67)+5*s(68)+11*s(69)+5*s(72)+5*s(73)+21*s(74)+7*s(78)+7*s(79)+14
  Such that:s(60) =< A
s(56) =< A-C/2+1/2
s(75) =< A-C/2+3/2
s(57) =< 2*A-C+1
s(58) =< A/2
s(61) =< 2/3*A
s(62) =< 2/3*A-C/3
s(63) =< 2/5*A
s(64) =< 4/3*A-2/3*C
s(65) =< C/2
s(59) =< C/2+1/2
s(74) =< s(75)
s(77) =< s(75)
s(78) =< s(74)*s(75)
s(79) =< s(74)*s(77)
s(66) =< s(60)
s(58) =< s(60)
s(67) =< s(60)
s(68) =< s(60)
s(57) =< s(60)
s(66) =< s(61)
s(58) =< s(61)
s(69) =< s(62)
s(69) =< s(63)
s(68) =< s(64)
s(66) =< s(65)
s(58) =< s(65)
s(67) =< s(65)
s(70) =< s(56)
s(71) =< s(56)-1
s(72) =< s(66)*s(70)
s(73) =< s(69)*s(71)

  with precondition: [2*A+3=2*D+C,B>=0,C>=3,E>=0,2*A>=C+3] 


Closed-form bounds of appendL(A,B,C,D,E,F): 
-------------------------------------
* Chain [[11],12] with precondition: [A+C=E+1,A>=2,B>=0,C>=1,D>=0,F>=0,B+D>=F] 
    - Upper bound: 5*A+2 
    - Complexity: n 
* Chain [12] with precondition: [A=1,C=E,D=F,B>=0,C>=0,D>=0] 
    - Upper bound: 2 
    - Complexity: constant 

### Maximum cost of appendL(A,B,C,D,E,F): 5*A+2 
Asymptotic class: n 

Closed-form bounds of flatten(A,B,C,D,E): 
-------------------------------------
* Chain [17] with precondition: [A=0,C=1,D=1,B>=0,E>=0] 
    - Upper bound: 3 
    - Complexity: constant 
* Chain [multiple([13,14,15,16],[[17]])] with precondition: [2*A+3=2*D+C,B>=0,C>=3,E>=0,2*A+1>=C] 
    - Upper bound: 10*A-5*C+5+ (nat(A-C/2-1/2)*5*nat(2/3*A-C/3)+27*A+ (5*A-5/2*C+5/2)*A)+ (3/2*C+3/2)+nat(2/3*A-C/3)*11+11/2*A 
    - Complexity: n^2 

### Maximum cost of flatten(A,B,C,D,E): max([3,10*A-5*C+5+ (nat(A-C/2-1/2)*5*nat(2/3*A-C/3)+27*A+ (5*A-5/2*C+5/2)*A)+ (3/2*C+3/2)+nat(2/3*A-C/3)*11+11/2*A]) 
Asymptotic class: n^2 

Closed-form bounds of insertL(A,B,C,D,E): 
-------------------------------------
* Chain [[18],20] with precondition: [B+1=D,A>=1,B>=2,C>=0,E>=0] 
    - Upper bound: 7*B+11 
    - Complexity: n 
* Chain [[18],19] with precondition: [B+1=D,A+C=E,A>=1,B>=3,C>=A] 
    - Upper bound: 7*B+14 
    - Complexity: n 
* Chain [20] with precondition: [B=1,D=2,A>=0,C>=0,E>=0] 
    - Upper bound: 4 
    - Complexity: constant 
* Chain [19] with precondition: [B+1=D,A+C=E,A>=0,B>=2,C>=A] 
    - Upper bound: 7 
    - Complexity: constant 

### Maximum cost of insertL(A,B,C,D,E): 7*B+14 
Asymptotic class: n 

Closed-form bounds of insertionsort(A,B,C,D): 
-------------------------------------
* Chain [[21,22],23,24] with precondition: [A=C,A>=3,B>=0,D>=0] 
    - Upper bound: 12*A+12+7*A*A+7*A*B+9*B 
    - Complexity: n^2 
* Chain [24] with precondition: [A=1,C=1,B>=0,D>=0] 
    - Upper bound: 3 
    - Complexity: constant 
* Chain [23,24] with precondition: [A=2,C=2,B>=0,D>=0] 
    - Upper bound: 12 
    - Complexity: constant 

### Maximum cost of insertionsort(A,B,C,D): max([9,12*A+9+7*A*A+7*A*B+9*B])+3 
Asymptotic class: n^2 

Closed-form bounds of flattensort(A,B,C,D,E): 
-------------------------------------
* Chain [28] with precondition: [A=0,C=1,D=1,B>=0,E>=0] 
    - Upper bound: 8 
    - Complexity: constant 
* Chain [27] with precondition: [D=1,2*A+1=C,A>=1,B>=0,E>=0] 
    - Upper bound: 61/2*A+8 
    - Complexity: n 
* Chain [26] with precondition: [D=2,2*A=C+1,A>=2,B>=0,E>=0] 
    - Upper bound: 71/4*C+195/4 
    - Complexity: n 
* Chain [25] with precondition: [2*A+3=2*D+C,B>=0,C>=3,E>=0,2*A>=C+3] 
    - Upper bound: 22/3*A-11/3*C+ (10*A-5*C+5+ (21*A-21/2*C+63/2+ (27*A+14+ (5*A-5/2*C-5/2)* (2/3*A-C/3)+ (5*A-5/2*C+5/2)*A)+ (14*A-7*C+21)* (A-C/2+3/2))+ (3/2*C+3/2))+11/2*A 
    - Complexity: n^2 

### Maximum cost of flattensort(A,B,C,D,E): max([71/4*C+175/4,55/2*A+max([3*A+3,10*A-5*C+5+ (21*A-21/2*C+63/2+ (5*A+9+nat(A-C/2-1/2)*5*nat(2/3*A-C/3)+ (5*A-5/2*C+5/2)*A)+ (14*A-7*C+21)* (A-C/2+3/2))+ (3/2*C+3/2)+nat(2/3*A-C/3)*11])])+5 
Asymptotic class: n^2 
* Total analysis performed in 2574 ms.


Cost relation system solved by CoFloCo in 2577 ms.

Method appendL terminates?: YES

 - l1_1: size of l1 wrt. List<Rat>
 - l1_2: size of l1 wrt. Rat
 - l2_1: size of l2 wrt. List<Rat>
 - l2_2: size of l2 wrt. Rat
UB for appendL(l1_1,l1_2,l2_1,l2_2) = 5*l1_1+2

Method flatten terminates?: YES

 - t_1: size of t wrt. List<Rat>
 - t_2: size of t wrt. Rat
 - t_3: size of t wrt. Tree
UB for flatten(t_1,t_2,t_3) = max([3,10*t_1-5*t_3+5+ (nat(t_1-t_3/2-1/2)*5*nat(2/3*t_1-t_3/3)+27*t_1+ (5*t_1-5/2*t_3+5/2)*t_1)+ (3/2*t_3+3/2)+nat(2/3*t_1-t_3/3)*11+11/2*t_1])

Method insertL terminates?: YES

 - x_1: size of x wrt. Rat
 - l_1: size of l wrt. List<Rat>
 - l_2: size of l wrt. Rat
UB for insertL(x_1,l_1,l_2) = 7*l_1+14

Method insertionsort terminates?: YES

 - l_1: size of l wrt. List<Rat>
 - l_2: size of l wrt. Rat
UB for insertionsort(l_1,l_2) = max([9,12*l_1+9+7*l_1*l_1+7*l_1*l_2+9*l_2])+3

Method flattensort terminates?: YES

 - t_1: size of t wrt. List<Rat>
 - t_2: size of t wrt. Rat
 - t_3: size of t wrt. Tree
UB for flattensort(t_1,t_2,t_3) = max([71/4*t_3+175/4,55/2*t_1+max([3*t_1+3,10*t_1-5*t_3+5+ (21*t_1-21/2*t_3+63/2+ (5*t_1+9+nat(t_1-t_3/2-1/2)*5*nat(2/3*t_1-t_3/3)+ (5*t_1-5/2*t_3+5/2)*t_1)+ (14*t_1-7*t_3+21)* (t_1-t_3/2+3/2))+ (3/2*t_3+3/2)+nat(2/3*t_1-t_3/3)*11])])+5
