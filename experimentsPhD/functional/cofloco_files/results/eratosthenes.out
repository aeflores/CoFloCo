
Abs program loaded in 9 ms.

Rule based representation generated in 2 ms.

Rule based representation stored in /tmp/costabs/rbr.rbr

RBR properties stored in /tmp/costabs/rbr.properties

Class invariants generated and loaded in 0 ms.

Abstract compilation performed in 3 ms.

Cost relation system stored in /tmp/costabs/crs.crs

Generated 30 equations 
entry('filter'(A,B,C,D,E):[]).
entry('eratos'(A,B,C,D):[]).
input_output_vars('and_op'(A,B,C),[A,B],[C]).
input_output_vars('case_0'(A,B,C,D,E),[A,B,C],[D,E]).
input_output_vars('case_1'(A,B,C,D,E,F,G,H,I,J,K,L),[A,B,C,D,E,F,G,H,I,J],[K,L]).
input_output_vars('case_2'(A,B,C,D),[A,B],[C,D]).
input_output_vars('eq'(A,B,C),[A,B],[C]).
input_output_vars('eratos'(A,B,C,D),[A,B],[C,D]).
input_output_vars('filter'(A,B,C,D,E),[A,B,C],[D,E]).
input_output_vars('geq'(A,B,C),[A,B],[C]).
input_output_vars('gt'(A,B,C),[A,B],[C]).
input_output_vars('leq'(A,B,C),[A,B],[C]).
input_output_vars('lt'(A,B,C),[A,B],[C]).
input_output_vars('maxNorm'(A,B,C),[A,B],[C]).
input_output_vars('neg'(A,B),[A],[B]).
input_output_vars('neq'(A,B,C),[A,B],[C]).
input_output_vars('or'(A,B,C),[A,B],[C]).
eq('eq',[A,B,C],0,[],[A=B,C=1,A>=0,B>=0,C>=0]).
eq('eq',[A,B,C],0,[],[A>=B+1,C=0,A>=0,B>=0,C>=0]).
eq('eq',[A,B,C],0,[],[B>=A+1,C=0,A>=0,B>=0,C>=0]).
eq('neq',[A,B,C],0,[],[A=B,C=0,A>=0,B>=0,C>=0]).
eq('neq',[A,B,C],0,[],[A>=B+1,C=1,A>=0,B>=0,C>=0]).
eq('neq',[A,B,C],0,[],[B>=A+1,C=1,A>=0,B>=0,C>=0]).
eq('lt',[A,B,C],0,[],[B-A>=1,C=1,A>=0,B>=0,C>=0]).
eq('lt',[A,B,C],0,[],[B=<A,C=0,A>=0,B>=0,C>=0]).
eq('leq',[A,B,C],0,[],[A=<B,C=1,A>=0,B>=0,C>=0]).
eq('leq',[A,B,C],0,[],[A-B>=1,C=0,A>=0,B>=0,C>=0]).
eq('gt',[A,B,C],0,[],[A-B>=1,C=1,A>=0,B>=0,C>=0]).
eq('gt',[A,B,C],0,[],[A=<B,C=0,A>=0,B>=0,C>=0]).
eq('geq',[A,B,C],0,[],[B=<A,C=1,A>=0,B>=0,C>=0]).
eq('geq',[A,B,C],0,[],[B-A>=1,C=0,A>=0,B>=0,C>=0]).
eq('neg',[A,B],0,[],[A=0,B=1,A>=0,B>=0]).
eq('neg',[A,B],0,[],[A=1,B=0,A>=0,B>=0]).
eq('and_op',[A,B,C],0,[],[A=0,C=0,A>=0,B>=0,C>=0]).
eq('and_op',[A,B,C],0,[],[A=1,C=B,A>=0,B>=0,C>=0]).
eq('or',[A,B,C],0,[],[A=1,C=1,A>=0,B>=0,C>=0]).
eq('or',[A,B,C],0,[],[A=0,C=B,A>=0,B>=0,C>=0]).
eq('maxNorm',[A,B,A],0,[],[A>=1+B,A>=0,B>=0,A>=0]).
eq('maxNorm',[A,B,B],0,[],[A=<B,A>=0,B>=0,B>=0]).
eq('case_0',[A,B,C,D,E],2,[],[B=1,D=1,A>=0,B>=0,C>=0,D>=0,E>=0]).
eq('case_1',[A,B,C,D,E,F,G,H,I,J,C,D],1,[],[A=B,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,C>=0,D>=0]).
eq('case_1',[A,B,C,D,E,F,G,H,I,J,K,L],2,[],[A>=B+1,L=H+D,K=C+1,C>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0]).
eq('case_0',[A,B,C,D,E],8,['filter'(A,F,G,H,I),'case_1'(J,K,L,M,A,B,C,N,F,G,O,P)],[C=N+G,B=F+1,F>=1,M=I,L=H,H>=1,J=Q,K=0,E=P,D=O,O>=1,A>=0,B>=0,C>=0,D>=0,E>=0]).
eq('filter',[A,B,C,D,E],1,['case_0'(A,B,C,D,E)],[A>=0,B>=0,C>=0,D>=0,E>=0]).
eq('case_2',[A,B,C,D],2,[],[A=1,C=1,A>=0,B>=0,C>=0,D>=0]).
eq('case_2',[A,B,C,D],5,['filter'(E,F,G,H,I),'eratos'(H,I,J,K)],[B=E+G,A=F+1,F>=1,D=E+K,C=J+1,J>=1,A>=0,B>=0,C>=0,D>=0]).
eq('eratos',[A,B,C,D],1,['case_2'(A,B,C,D)],[A>=0,B>=0,C>=0,D>=0]).

Preprocessing Cost Relations
=====================================

#### Computed strongly connected components 
0. non_recursive  : [case_1/12]
1. recursive [non_tail] : [case_0/5,filter/5]
2. recursive  : [case_2/4,eratos/4]
Warning: the following predicates are never called:[and_op/3,eq/3,geq/3,gt/3,leq/3,lt/3,maxNorm/3,neg/2,neq/3,or/3]

#### Obtained direct recursion through partial evaluation 
0. SCC is partially evaluated into case_1/12
1. SCC is partially evaluated into filter/5
2. SCC is partially evaluated into eratos/4

Control-Flow Refinement of Cost Relations
=====================================

### Specialization of cost equations case_1/12 
* CE 6 is refined into CE [7] 
* CE 5 is refined into CE [8] 


#### Refined cost equations case_1/12 
* CE 7: case_1(A,B,C,D,E,F,G,H,I,J,K,L) = 2
     [J>=0,I>=1,H>=0,E>=0,D>=0,C>=1,A>=1,D+H=L,H+J=G,C+1=K,I+1=F,B=0] 
* CE 8: case_1(A,B,C,D,E,F,G,H,I,J,C,D) = 1
     [J>=0,I>=1,H>=0,E>=0,D>=0,C>=1,H+J=G,I+1=F,B=0,A=0] 

### Cost equations --> "Loop" of case_1/12 
* CEs [7] --> Loop 7 
* CEs [8] --> Loop 8 

#### Loops of case_1/12 
* Loop 7: case_1(A,B,C,D,E,F,G,H,I,J,K,L) [G>=H,H>=0,F>=2,E>=0,D>=0,C>=1,A>=1,D+H=L,H+J=G,C+1=K,F=I+1,B=0] 
* Loop 8: case_1(A,B,C,D,E,F,G,H,I,J,C,D) [G>=H,H>=0,F>=2,E>=0,D>=0,C>=1,H+J=G,F=I+1,B=0,A=0] 

### Ranking functions of CR case_1(A,B,C,D,E,F,G,H,I,J,K,L) 

#### Partial ranking functions of CR case_1(A,B,C,D,E,F,G,H,I,J,K,L) 


### Resulting Chains:case_1(A,B,C,D,E,F,G,H,I,J,K,L) 
* [8]
* [7]


### Merging Chains  case_1/12 into  External patterns of execution 
* [[8]] --> 1 
* [[7]] --> 2 


### Specialization of cost equations filter/5 
* CE 2 is refined into CE [9] 
* CE 1 is refined into CE [10,11] 


#### Refined cost equations filter/5 
* CE 9: filter(A,B,C,D,E) = 3
     [E>=0,C>=0,A>=0,D=1,B=1] 
* CE 10: filter(A,B,C,D,E) = 9+ filter(A,F,G,D,E)+ case_1(H,I,D,E,A,J,K,L,F,G,D,E):1
     [E>=0,D>=1,G>=0,F>=1,L>=0,A>=0,L+G=K,L+G=C,F+1=J,F+1=B,I=0,H=0] 
* CE 11: filter(A,B,C,D,E) = 9+ filter(A,F,G,H,I)+ case_1(J,K,L,M,A,N,O,P,F,G,D,E):2
     [E>=P,D>=2,G>=0,F>=1,P>=0,A>=0,J>=1,P+I=E,M+P=E,P+G=O,P+G=C,D=H+1,F+1=N,D=L+1,F+1=B,K=0] 

### Cost equations --> "Loop" of filter/5 
* CEs [11] --> Loop 9 
* CEs [10] --> Loop 10 
* CEs [9] --> Loop 11 

#### Loops of filter/5 
* Loop 9: filter(A,B,C,D,E)->  filter(A,A',B',C',D')
                  [E+B'>=C,C>=B',B'>=0,D>=2,B>=2,A>=0,C+D'=E+B',D=C'+1,B=A'+1] 
* Loop 10: filter(A,B,C,D,E)->  filter(A,A',B',D,E)
                  [C>=B',B'>=0,E>=0,D>=1,B>=2,A>=0,B=A'+1] 
* Loop 11: filter(A,B,C,D,E) [E>=0,C>=0,A>=0,D=1,B=1] 

### Ranking functions of CR filter(A,B,C,D,E) 
* RF of phase [9,10]: [B-1]

#### Partial ranking functions of CR filter(A,B,C,D,E) 
* Partial RF of phase [9,10]:
  - RF of loop [9:1,10:1]:
    B-1

Discarded unfeasible chain [[9,10]]...(Non-terminating chain proved terminating)

### Resulting Chains:filter(A,B,C,D,E) 
* [[9,10],11]
* [11]


### Merging Chains  filter/5 into  External patterns of execution 
* [[11]] --> 1 
* [[11,[9,10]]] --> 2 


### Specialization of cost equations eratos/4 
* CE 4 is refined into CE [12] 
* CE 3 is refined into CE [13,14] 


#### Refined cost equations eratos/4 
* CE 12: eratos(A,B,C,D) = 3
     [D>=0,B>=0,C=1,A=1] 
* CE 13: eratos(A,B,C,D) = 6+ filter(E,F,G,H,I):1+ eratos(J,I,K,L)
     [E+L>=0,K>=1,I>=0,G>=0,E>=0,E+L=D,E+G=B,K+1=C,J=1,H=1,F=1,A=2] 
* CE 14: eratos(A,B,C,D) = 6+ filter(E,F,G,H,I):2+ eratos(H,I,J,K)
     [E+K>=0,F>=H,J>=1,I>=0,H>=1,G>=0,F>=2,E>=0,E+K=D,E+G=B,J+1=C,F+1=A] 

### Cost equations --> "Loop" of eratos/4 
* CEs [14] --> Loop 12 
* CEs [13] --> Loop 13 
* CEs [12] --> Loop 14 

#### Loops of eratos/4 
* Loop 12: eratos(A,B,C,D)->  eratos(A',B',C',D')
                  [B+D'>=D,D>=D',A>=A'+1,B'>=0,A'>=1,D>=0,C>=2,A>=3,C=C'+1] 
* Loop 13: eratos(A,B,C,D)->  eratos(A',B',C',D')
                  [B+D'>=D,D>=D',B'>=0,D>=0,C>=2,C=C'+1,A'=1,A=2] 
* Loop 14: eratos(A,B,C,D) [D>=0,B>=0,C=1,A=1] 

### Ranking functions of CR eratos(A,B,C,D) 
* RF of phase [12]: [A-2]

#### Partial ranking functions of CR eratos(A,B,C,D) 
* Partial RF of phase [12]:
  - RF of loop [12:1]:
    A-2

Discarded unfeasible chain [[12]]...(Non-terminating chain proved terminating)

### Resulting Chains:eratos(A,B,C,D) 
* [[12],14]
* [[12],13,14]
* [14]
* [13,14]


### Merging Chains  eratos/4 into  External patterns of execution 
* [[14]] --> 1 
* [[14,13]] --> 2 
* [[14,[12]]] --> 3 
* [[14,13,[12]]] --> 4 


Computing Bounds
=====================================

#### Simplifying cost structure of CE 8 

#### Simplifying cost structure of CE 7 

#### Cost of chains of case_1(A,B,C,D,E,F,G,H,I,J,K,L):
* Chain [8]: 1
  with precondition: [A=0,B=0,L=D,I+1=F,C=K,G=H+J,C>=1,E>=0,H>=0,I>=1,L>=0,G>=H] 

* Chain [7]: 2
  with precondition: [B=0,I+1=F,C+1=K,G=H+J,D+H=L,A>=1,C>=1,E>=0,H>=0,I>=1,G>=H,L>=H] 


#### Simplifying cost structure of CE 9 

#### Computing cost of phase [9,10] 

#### Simplifying cost structure of CE 11 

#### Simplifying cost structure of CE 10 

#### Cost of loops [9,10] 

 * loop 9:filter(A,B,C,D,E) -> [filter(A',B',C',D',E')] 
11
 * loop 10:filter(A,B,C,D,E) -> [filter(A',B',C',D',E')] 
10
##### Pending set filter(A,B,C,D,E)
* Psum in Loop 9: [it(9)=<1]
* Psum in Loop 10: [it(10)=<1]

###### Computing sum for it(9)=<1  in Loop 9 
   - Applying inductive sum strategy 
     - head Candidate: B-1 
       - Loop 10 is collaborative and bounds [it(10)] 
     - head Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B-1 
       - Loop 10 is collaborative and bounds [it(10)] 
     - tail Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(9)+it(10)=<B-1,it(9)+it(10)=<B-1,it(9)+it(10)=<B-B',it(9)+it(10)=<B-B'] 

##### Pending set A
* Psum in Loop 10: [it(10)=<1]

###### Computing sum for it(10)=<1  in Loop 10 
   - Applying inductive sum strategy 
     - head Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(9)+it(10)=<B-1,it(9)+it(10)=<B-1,it(9)+it(10)=<B-B',it(9)+it(10)=<B-B'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [9,10] 

#### Simplifying cost structure of phase [9,10] 
 * Joined equivalent variables [it(9),it(10)] into it(9)

#### Cost of phase [9,10]:filter(A,B,C,D,E) -> [filter(A',B',C',D',E')] 
21*it(9)+0
  Such that:aux(1) =< B
aux(2) =< B-B'
it(9) =< aux(1)
it(9) =< aux(2)

#### Simplifying cost structure of chain [[9,10],11] 
 * Joined equivalent variables [aux(3),aux(1),aux(2)] into aux(3)

#### Cost of chains of filter(A,B,C,D,E):
* Chain [[9,10],11]: 21*it(9)+3
  Such that:aux(3) =< B
it(9) =< aux(3)

  with precondition: [A>=0,B>=2,C>=0,D>=1,E>=0,B>=D] 

* Chain [11]: 3
  with precondition: [B=1,D=1,A>=0,C>=0,E>=0] 


#### Simplifying cost structure of CE 12 

#### Computing cost of phase [12] 
 * Renamed intermediate variables: 
[ (eq(14,1),aux(3))>>s(1), (eq(14,1),it(9))>>s(2)]

#### Simplifying cost structure of CE 14 
 * Renamed intermediate variables: 
[ (it(12),s(1))>>s(3), (it(12),s(2))>>s(4)]

#### Cost of loops [12] 

 * loop 12:eratos(A,B,C,D) -> [eratos(A',B',C',D')] 
21*s(4)+9
  Such that:s(3) =< A
s(4) =< s(3)

##### Pending set eratos(A,B,C,D)
* Psum in Loop 12: [it(12)=<1,s(6)=<A]

###### Computing sum for it(12)=<1  in Loop 12 
   - Applying inductive sum strategy 
     - head Candidate: A-2 
     - head Candidate: A-2 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-2 
     - tail Candidate: A-2 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(12)=<A-2,it(12)=<A-2,it(12)=<A-A',it(12)=<A-A'] 

##### Pending set A
* Psum in Loop 12: [s(6)=<A]

###### Computing sum for s(6)=<A  in Loop 12 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(4)=<A] 
 * Adding constraints: [s(6)=<it(12)*aux(4)] 

##### Pending set eratos(A,B,C,D)
* Pmax/min: [aux(4)=<A]

###### Computing max_min for aux(4)=<A  
   - Found a solution using transitive invariants 
 * Adding constraints:[aux(4)=<A] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [12] 

#### Simplifying cost structure of phase [12] 
 * Joined equivalent variables [aux(5),aux(4)] into aux(5)

#### Cost of phase [12]:eratos(A,B,C,D) -> [eratos(A',B',C',D')] 
9*it(12)+21*s(5)+0
  Such that:it(12) =< A-A'
aux(5) =< A
it(12) =< aux(5)
s(6) =< it(12)*aux(5)
s(5) =< s(6)

#### Simplifying cost structure of chain [[12],14] 
 * Joined equivalent variables [aux(6),aux(5)] into aux(6)

#### Simplifying cost structure of CE 13 

#### Simplifying cost structure of chain [13,14] 

#### Found solution for phase  [12] in the cache 

#### Cost of phase [12]:eratos(A,B,C,D) -> [eratos(A',B',C',D')] 
9*it(12)+21*s(5)+0
  Such that:it(12) =< A-A'
aux(5) =< A
it(12) =< aux(5)
s(6) =< it(12)*aux(5)
s(5) =< s(6)

#### Simplifying cost structure of chain [[12],13,14] 
 * Joined equivalent variables [aux(7),aux(5)] into aux(7)

#### Cost of chains of eratos(A,B,C,D):
* Chain [[12],14]: 9*it(12)+21*s(5)+3
  Such that:aux(6) =< A
it(12) =< aux(6)
s(6) =< it(12)*aux(6)
s(5) =< s(6)

  with precondition: [B>=0,C>=2,D>=0,A>=C+1] 

* Chain [[12],13,14]: 9*it(12)+21*s(5)+12
  Such that:aux(7) =< A
it(12) =< aux(7)
s(6) =< it(12)*aux(7)
s(5) =< s(6)

  with precondition: [B>=0,C>=3,D>=0,A>=C] 

* Chain [14]: 3
  with precondition: [A=1,C=1,B>=0,D>=0] 

* Chain [13,14]: 12
  with precondition: [A=2,C=2,B>=0,D>=0] 


Closed-form bounds of filter(A,B,C,D,E): 
-------------------------------------
* Chain [[9,10],11] with precondition: [A>=0,B>=2,C>=0,D>=1,E>=0,B>=D] 
    - Upper bound: 21*B+3 
    - Complexity: n 
* Chain [11] with precondition: [B=1,D=1,A>=0,C>=0,E>=0] 
    - Upper bound: 3 
    - Complexity: constant 

### Maximum cost of filter(A,B,C,D,E): 21*B+3 
Asymptotic class: n 

Closed-form bounds of eratos(A,B,C,D): 
-------------------------------------
* Chain [[12],14] with precondition: [B>=0,C>=2,D>=0,A>=C+1] 
    - Upper bound: 9*A+3+21*A*A 
    - Complexity: n^2 
* Chain [[12],13,14] with precondition: [B>=0,C>=3,D>=0,A>=C] 
    - Upper bound: 9*A+12+21*A*A 
    - Complexity: n^2 
* Chain [14] with precondition: [A=1,C=1,B>=0,D>=0] 
    - Upper bound: 3 
    - Complexity: constant 
* Chain [13,14] with precondition: [A=2,C=2,B>=0,D>=0] 
    - Upper bound: 12 
    - Complexity: constant 

### Maximum cost of eratos(A,B,C,D): 21*A*A+9*A+12 
Asymptotic class: n^2 
* Total analysis performed in 188 ms.


Cost relation system solved by CoFloCo in 189 ms.

Method filter terminates?: YES

 - p_1: size of p wrt. Rat
 - l_1: size of l wrt. List<Rat>
 - l_2: size of l wrt. Rat
UB for filter(p_1,l_1,l_2) = 21*l_1+3

Method eratos terminates?: YES

 - l_1: size of l wrt. List<Rat>
 - l_2: size of l wrt. Rat
UB for eratos(l_1,l_2) = 21*l_1*l_1+9*l_1+12
