
Abs program loaded in 11 ms.

Rule based representation generated in 8 ms.

Rule based representation stored in /tmp/costabs/rbr.rbr

RBR properties stored in /tmp/costabs/rbr.properties

Class invariants generated and loaded in 0 ms.

Abstract compilation performed in 68 ms.

Cost relation system stored in /tmp/costabs/crs.crs

Generated 152 equations 
entry('last'(A,B,C,D):[]).
entry('last_two'(A,B,C,D,E):[]).
entry('at'(A,B,C,D,E):[]).
entry('lengthL'(A,B,C,D,E,F):[]).
entry('rev'(A,B,C,D,E,F,G,H):[]).
entry('eq_lists'(A,B,C,D,E):[]).
entry('is_palindrome'(A,B,C):[]).
entry('compress'(A,B,C,D):[]).
entry('pack'(A,B,C,D,E):[]).
entry('encode'(A,B,C,D,E):[]).
entry('duplicate'(A,B,C,D):[]).
entry('replicate'(A,B,C,D,E):[]).
entry('drop'(A,B,C,D,E):[]).
entry('split'(A,B,C,D,E,F):[]).
entry('slice'(A,B,C,D,E,F):[]).
entry('concat'(A,B,C,D,E,F,G,H,I,J,K,L):[]).
entry('rotate'(A,B,C,D,E):[]).
entry('removeAt'(A,B,C,D,E):[]).
entry('insertAt'(A,B,C,D,E,F):[]).
entry('minusminus'(A,B,C,D):[]).
entry('randomL'(A,B):[]).
entry('minL'(A,B,C):[]).
entry('rand_select'(A,B,C,D,E):[]).
entry('lotto_select'(A,B,C,D):[]).
input_output_vars('and_op'(A,B,C),[A,B],[C]).
input_output_vars('at'(A,B,C,D,E),[A,B,C],[D,E]).
input_output_vars('aux_length'(A,B,C,D,E,F,G,H),[A,B,C,D,E,F],[G,H]).
input_output_vars('aux_rev'(A,B,C,D,E,F,G,H,I,J,K,L),[A,B,C,D,E,F,G,H],[I,J,K,L]).
input_output_vars('case_0'(A,B,C,D),[A,B],[C,D]).
input_output_vars('case_1'(A,B,C,D,E,F,G),[A,B,C,D,E],[F,G]).
input_output_vars('case_10'(A,B,C,D,E),[A,B,C,D],[E]).
input_output_vars('case_11'(A,B,C,D,E,F,G,H),[A,B,C,D,E,F,G],[H]).
input_output_vars('case_12'(A,B,C,D),[A,B],[C,D]).
input_output_vars('case_13'(A,B,C,D,E,F,G),[A,B,C,D,E],[F,G]).
input_output_vars('case_14'(A,B,C,D,E,F,G,H,I,J),[A,B,C,D,E,F,G,H],[I,J]).
input_output_vars('case_15'(A,B,C,D,E,F,G,H,I,J),[A,B,C,D,E,F,G],[H,I,J]).
input_output_vars('case_16'(A,B,C,D,E,F,G,H,I,J,K,L,M),[A,B,C,D,E,F,G,H,I,J],[K,L,M]).
input_output_vars('case_17'(A,B,C,D,E,F,G,H,I,J,K,L,M,N),[A,B,C,D,E,F,G,H,I,J,K],[L,M,N]).
input_output_vars('case_18'(A,B,C,D,E,F,G,H,I),[A,B,C,D,E,F],[G,H,I]).
input_output_vars('case_19'(A,B,C,D,E,F,G,H,I,J,K,L),[A,B,C,D,E,F,G,H,I],[J,K,L]).
input_output_vars('case_2'(A,B,C,D,E),[A,B],[C,D,E]).
input_output_vars('case_20'(A,B,C,D,E,F,G,H,I,J,K,L,M),[A,B,C,D,E,F,G,H,I,J],[K,L,M]).
input_output_vars('case_21'(A,B,C,D),[A,B],[C,D]).
input_output_vars('case_22'(A,B,C,D,E,F,G),[A,B,C,D,E],[F,G]).
input_output_vars('case_23'(A,B,C,D,E,F,G),[A,B,C,D,E],[F,G]).
input_output_vars('case_24'(A,B,C,D,E,F),[A,B,C,D],[E,F]).
input_output_vars('case_25'(A,B,C,D,E,F,G,H,I),[A,B,C,D,E,F,G],[H,I]).
input_output_vars('case_26'(A,B,C,D,E,F,G,H),[A,B,C,D,E],[F,G,H]).
input_output_vars('case_27'(A,B,C,D,E,F,G,H,I,J,K,L),[A,B,C,D,E,F,G,H,I],[J,K,L]).
input_output_vars('case_28'(A,B,C,D,E),[A,B,C],[D,E]).
input_output_vars('case_29'(A,B,C,D,E,F,G,H,I),[A,B,C,D,E,F,G],[H,I]).
input_output_vars('case_3'(A,B,C,D,E,F,G,H),[A,B,C,D,E],[F,G,H]).
input_output_vars('case_30'(A,B,C,D,E),[A,B,C],[D,E]).
input_output_vars('case_31'(A,B,C,D,E,F,G,H,I),[A,B,C,D,E,F,G],[H,I]).
input_output_vars('case_32'(A,B,C,D,E,F,G,H,I,J,K,L),[A,B,C,D,E,F,G,H],[I,J,K,L]).
input_output_vars('case_33'(A,B,C,D,E,F),[A,B,C,D,E],[F]).
input_output_vars('case_34'(A,B,C,D,E,F,G,H),[A,B,C,D,E,F],[G,H]).
input_output_vars('case_35'(A,B,C,D,E,F,G,H,I,J,K),[A,B,C,D,E,F,G,H,I],[J,K]).
input_output_vars('case_36'(A,B,C,D,E),[A,B,C],[D,E]).
input_output_vars('case_37'(A,B,C,D,E,F,G,H,I),[A,B,C,D,E,F,G],[H,I]).
input_output_vars('case_38'(A,B,C,D,E,F),[A,B,C,D],[E,F]).
input_output_vars('case_39'(A,B,C,D,E,F,G,H,I,J),[A,B,C,D,E,F,G,H],[I,J]).
input_output_vars('case_4'(A,B,C,D,E,F,G,H,I,J,K),[A,B,C,D,E,F,G,H],[I,J,K]).
input_output_vars('case_40'(A,B,C,D),[A,B],[C,D]).
input_output_vars('case_41'(A,B,C,D),[A,B],[C,D]).
input_output_vars('case_42'(A,B,C),[A,B],[C]).
input_output_vars('case_43'(A,B,C,D,E,F,G,H),[A,B,C,D,E],[F,G,H]).
input_output_vars('case_44'(A,B,C,D,E,F,G,H,I,J,K,L),[A,B,C,D,E,F,G,H,I],[J,K,L]).
input_output_vars('case_45'(A,B,C,D,E,F,G,H,I),[A,B,C,D,E,F,G],[H,I]).
input_output_vars('case_46'(A,B,C,D,E,F,G,H,I,J,K,L),[A,B,C,D,E,F,G,H,I,J],[K,L]).
input_output_vars('case_5'(A,B,C,D,E),[A,B,C],[D,E]).
input_output_vars('case_6'(A,B,C,D,E,F,G,H,I),[A,B,C,D,E,F,G],[H,I]).
input_output_vars('case_7'(A,B,C,D,E,F,G,H),[A,B,C,D,E,F],[G,H]).
input_output_vars('case_8'(A,B,C,D,E,F,G,H,I,J,K,L),[A,B,C,D,E,F,G,H],[I,J,K,L]).
input_output_vars('case_9'(A,B,C,D,E),[A,B,C,D],[E]).
input_output_vars('compress'(A,B,C,D),[A,B],[C,D]).
input_output_vars('concat'(A,B,C,D,E,F,G,H,I,J,K,L),[A,B,C,D,E,F,G,H],[I,J,K,L]).
input_output_vars('drop'(A,B,C,D,E),[A,B,C],[D,E]).
input_output_vars('drop_aux'(A,B,C,D,E,F),[A,B,C,D],[E,F]).
input_output_vars('drop_slice'(A,B,C,D,E),[A,B,C],[D,E]).
input_output_vars('duplicate'(A,B,C,D),[A,B],[C,D]).
input_output_vars('encode'(A,B,C,D,E),[A,B],[C,D,E]).
input_output_vars('encode_aux'(A,B,C,D,E,F,G,H,I),[A,B,C,D,E,F],[G,H,I]).
input_output_vars('eq'(A,B,C),[A,B],[C]).
input_output_vars('eq_lists'(A,B,C,D,E),[A,B,C,D],[E]).
input_output_vars('geq'(A,B,C),[A,B],[C]).
input_output_vars('gt'(A,B,C),[A,B],[C]).
input_output_vars('insertAt'(A,B,C,D,E,F),[A,B,C,D],[E,F]).
input_output_vars('is_palindrome'(A,B,C),[A,B],[C]).
input_output_vars('last'(A,B,C,D),[A,B],[C,D]).
input_output_vars('last_two'(A,B,C,D,E),[A,B],[C,D,E]).
input_output_vars('lengthL'(A,B,C,D,E,F),[A,B,C,D],[E,F]).
input_output_vars('leq'(A,B,C),[A,B],[C]).
input_output_vars('lotto_select'(A,B,C,D),[A,B],[C,D]).
input_output_vars('lt'(A,B,C),[A,B],[C]).
input_output_vars('maxNorm'(A,B,C),[A,B],[C]).
input_output_vars('minL'(A,B,C),[A,B],[C]).
input_output_vars('minusminus'(A,B,C,D),[A,B],[C,D]).
input_output_vars('minusminus_aux'(A,B,C,D),[A,B],[C,D]).
input_output_vars('neg'(A,B),[A],[B]).
input_output_vars('neq'(A,B,C),[A,B],[C]).
input_output_vars('or'(A,B,C),[A,B],[C]).
input_output_vars('pack'(A,B,C,D,E),[A,B],[C,D,E]).
input_output_vars('pack_aux'(A,B,C,D,E,F,G,H,I,J),[A,B,C,D,E,F,G],[H,I,J]).
input_output_vars('prepend'(A,B,C,D,E,F),[A,B,C,D],[E,F]).
input_output_vars('rand_select'(A,B,C,D,E),[A,B,C],[D,E]).
input_output_vars('rand_select_aux'(A,B,C,D,E,F,G,H),[A,B,C,D,E,F],[G,H]).
input_output_vars('rand_select_extract'(A,B,C,D,E,F,G,H),[A,B,C,D,E],[F,G,H]).
input_output_vars('rand_select_extract_rand'(A,B,C,D,E,F),[A,B,C],[D,E,F]).
input_output_vars('randomL'(A,B),[A],[B]).
input_output_vars('removeAt'(A,B,C,D,E),[A,B,C],[D,E]).
input_output_vars('replicate'(A,B,C,D,E),[A,B,C],[D,E]).
input_output_vars('replicate_aux'(A,B,C,D,E,F,G),[A,B,C,D,E],[F,G]).
input_output_vars('rev'(A,B,C,D,E,F,G,H),[A,B,C,D],[E,F,G,H]).
input_output_vars('rotate'(A,B,C,D,E),[A,B,C],[D,E]).
input_output_vars('slice'(A,B,C,D,E,F),[A,B,C,D],[E,F]).
input_output_vars('split'(A,B,C,D,E,F),[A,B,C],[D,E,F]).
input_output_vars('split_aux'(A,B,C,D,E,F,G,H),[A,B,C,D,E],[F,G,H]).
input_output_vars('take_slice'(A,B,C,D,E),[A,B,C],[D,E]).
eq('eq',[A,B,C],0,[],[A=B,C=1,A>=0,B>=0,C>=0]).
eq('eq',[A,B,C],0,[],[A>=B+1,C=0,A>=0,B>=0,C>=0]).
eq('eq',[A,B,C],0,[],[B>=A+1,C=0,A>=0,B>=0,C>=0]).
eq('neq',[A,B,C],0,[],[A=B,C=0,A>=0,B>=0,C>=0]).
eq('neq',[A,B,C],0,[],[A>=B+1,C=1,A>=0,B>=0,C>=0]).
eq('neq',[A,B,C],0,[],[B>=A+1,C=1,A>=0,B>=0,C>=0]).
eq('lt',[A,B,C],0,[],[B-A>=1,C=1,A>=0,B>=0,C>=0]).
eq('lt',[A,B,C],0,[],[B=<A,C=0,A>=0,B>=0,C>=0]).
eq('leq',[A,B,C],0,[],[A=<B,C=1,A>=0,B>=0,C>=0]).
eq('leq',[A,B,C],0,[],[A-B>=1,C=0,A>=0,B>=0,C>=0]).
eq('gt',[A,B,C],0,[],[A-B>=1,C=1,A>=0,B>=0,C>=0]).
eq('gt',[A,B,C],0,[],[A=<B,C=0,A>=0,B>=0,C>=0]).
eq('geq',[A,B,C],0,[],[B=<A,C=1,A>=0,B>=0,C>=0]).
eq('geq',[A,B,C],0,[],[B-A>=1,C=0,A>=0,B>=0,C>=0]).
eq('neg',[A,B],0,[],[A=0,B=1,A>=0,B>=0]).
eq('neg',[A,B],0,[],[A=1,B=0,A>=0,B>=0]).
eq('and_op',[A,B,C],0,[],[A=0,C=0,A>=0,B>=0,C>=0]).
eq('and_op',[A,B,C],0,[],[A=1,C=B,A>=0,B>=0,C>=0]).
eq('or',[A,B,C],0,[],[A=1,C=1,A>=0,B>=0,C>=0]).
eq('or',[A,B,C],0,[],[A=0,C=B,A>=0,B>=0,C>=0]).
eq('maxNorm',[A,B,A],0,[],[A>=1+B,A>=0,B>=0,A>=0]).
eq('maxNorm',[A,B,B],0,[],[A=<B,A>=0,B>=0,B>=0]).
eq('case_0',[A,B,C,D],2,[],[B=0,A=1,D=0,C=1,A>=0,B>=0,C>=0,D>=0]).
eq('case_1',[A,B,C,D,E,F,G],2,[],[E=0,D=1,G=C,F=1,C>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0]).
eq('case_1',[A,B,C,D,E,F,G],3,['last'(D,E,F,G)],[E=H+H,H>=1,D=I+1,I>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0]).
eq('case_0',[A,B,C,D],3,['case_1'(A,B,E,F,G,C,D)],[B=E+G,A=F+1,F>=1,E>=1,A>=0,B>=0,C>=0,D>=0]).
eq('last',[A,B,C,D],1,['case_0'(A,B,C,D)],[A>=0,B>=0,C>=0,D>=0]).
eq('case_2',[A,B,C,D,E],2,[],[B=0,A=1,E=0,D=1,C=0,A>=0,B>=0,C>=0,D>=0,E>=0]).
eq('case_3',[A,B,C,D,E,F,G,H],2,[],[E=0,D=1,H=0,G=1,F=0,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0]).
eq('case_4',[A,B,C,D,E,F,G,H,I,J,K],3,[],[H=0,G=1,L=C+F,M=1,F>=1,C>=1,K=L,J=1,I=M,M>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0]).
eq('case_4',[A,B,C,D,E,F,G,H,I,J,K],3,['last_two'(D,E,I,J,K)],[H=L+L,L>=1,G=M+1,M>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0]).
eq('case_3',[A,B,C,D,E,F,G,H],3,['case_4'(A,B,C,D,E,I,J,K,F,G,H)],[E=I+K,D=J+1,J>=1,I>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0]).
eq('case_2',[A,B,C,D,E],3,['case_3'(A,B,F,G,H,C,D,E)],[B=F+H,A=G+1,G>=1,F>=1,A>=0,B>=0,C>=0,D>=0,E>=0]).
eq('last_two',[A,B,C,D,E],1,['case_2'(A,B,C,D,E)],[A>=0,B>=0,C>=0,D>=0,E>=0]).
eq('case_5',[A,B,C,D,E],2,[],[C=0,B=1,E=0,D=1,A>=0,B>=0,C>=0,D>=0,E>=0]).
eq('case_6',[A,B,C,D,E,F,G,H,I],2,[],[B=A,I=E,H=1,E>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0]).
eq('case_6',[A,B,C,D,E,F,G,H,I],4,['at'(J,F,G,H,I)],[B>=A+1,K=1,J=B-K,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0]).
eq('case_5',[A,B,C,D,E],4,['case_6'(F,A,B,C,G,H,I,D,E)],[C=G+I,B=H+1,H>=1,G>=1,F=0,A>=0,B>=0,C>=0,D>=0,E>=0]).
eq('at',[A,B,C,D,E],1,['case_5'(A,B,C,D,E)],[A>=0,B>=0,C>=0,D>=0,E>=0]).
eq('case_7',[A,B,C,D,E,F,E,F],1,[],[D=0,C=1,A=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,E>=0,F>=0]).
eq('case_7',[A,B,C,D,E,F,G,H],5,['aux_length'(I,J,K,L,M,N,G,H)],[D=O+L,O>=1,C=K+1,B=P+J,A=I+1,K>=1,I>=1,Q=1,R=1,N=F+Q,M=E+R,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0]).
eq('aux_length',[A,B,C,D,E,F,G,H],1,['case_7'(A,B,C,D,E,F,G,H)],[A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0]).
eq('lengthL',[A,B,C,D,E,F],2,['aux_length'(A,B,C,D,G,H,E,F)],[H=0,G=0,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0]).
eq('case_8',[A,B,C,D,E,F,G,H,A,B,C,D],1,[],[H=0,G=1,E=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,A>=0,B>=0,C>=0,D>=0]).
eq('case_8',[A,B,C,D,E,F,G,H,I,J,K,L],4,['aux_rev'(M,N,O,P,Q,R,S,T,I,J,K,L)],[H=U+T,G=S+1,F=V+R,E=Q+1,S>=1,Q>=1,U>=1,P=U+D,O=C+1,N=V+B,M=A+1,C>=1,A>=1,U>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0]).
eq('aux_rev',[A,B,C,D,E,F,G,H,I,J,K,L],1,['case_8'(A,B,C,D,E,F,G,H,I,J,K,L)],[A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0]).
eq('rev',[A,B,C,D,E,F,G,H],2,['aux_rev'(I,J,K,L,A,B,C,D,E,F,G,H)],[L=0,K=1,I=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0]).
eq('case_10',[A,B,C,D,E],2,[],[C=1,E=1,A>=0,B>=0,C>=0,D>=0,E>=0]).
eq('case_10',[A,B,C,D,E],3,[],[D=F+F,C=G+1,G>=1,E=0,A>=0,B>=0,C>=0,D>=0,E>=0]).
eq('case_9',[A,B,C,D,E],2,['case_10'(A,B,C,D,E)],[A=1,A>=0,B>=0,C>=0,D>=0,E>=0]).
eq('case_11',[A,B,C,D,E,F,G,H],2,[],[C=1,H=0,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0]).
eq('case_11',[A,B,C,D,E,F,G,H],5,['eq'(E,I,J),'eq_lists'(F,G,K,L,M),'and_op'(J,M,H)],[D=I+L,C=K+1,K>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0]).
eq('case_9',[A,B,C,D,E],3,['case_11'(A,B,C,D,F,G,H,E)],[B=F+H,A=G+1,G>=1,A>=0,B>=0,C>=0,D>=0,E>=0]).
eq('eq_lists',[A,B,C,D,E],1,['case_9'(A,B,C,D,E)],[A>=0,B>=0,C>=0,D>=0,E>=0]).
eq('is_palindrome',[A,B,C],2,['rev'(A,B,D,E,F,G,H,I),'eq_lists'(A,B,F,G,C)],[A>=0,B>=0,C>=0]).
eq('case_12',[A,B,C,D],2,[],[A=1,C=1,A>=0,B>=0,C>=0,D>=0]).
eq('case_13',[A,B,C,D,E,F,G],3,[],[D=1,H=1,G=C+I,F=H+1,H>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0]).
eq('case_14',[A,B,C,D,E,F,G,H,I,J],3,['compress'(K,L,I,J)],[C=F,L=F+H,K=G+1,G>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0]).
eq('case_14',[A,B,C,D,E,F,G,H,I,J],4,['compress'(K,L,M,N)],[C>=F+1,L=F+H,K=G+1,G>=1,J=C+N,I=M+1,M>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0]).
eq('case_13',[A,B,C,D,E,F,G],3,['case_14'(A,B,C,D,E,H,I,J,F,G)],[E=H+J,D=I+1,I>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0]).
eq('case_12',[A,B,C,D],3,['case_13'(A,B,E,F,G,C,D)],[B=E+G,A=F+1,F>=1,A>=0,B>=0,C>=0,D>=0]).
eq('compress',[A,B,C,D],1,['case_12'(A,B,C,D)],[A>=0,B>=0,C>=0,D>=0]).
eq('case_15',[A,B,C,D,E,F,G,H,I,J],2,[],[F=1,I=0,H=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0]).
eq('case_16',[A,B,C,D,E,F,G,H,I,J,K,L,M],3,[],[I=1,N=H+B,O=A+1,A>=1,M=N+E,L=O+D,K=C+1,C>=1,O>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0,M>=0]).
eq('case_17',[A,B,C,D,E,F,G,H,I,J,K,L,M,N],3,['pack_aux'(O,P,C,D,E,I,J,L,M,N)],[H=K,P=H+B,O=A+1,A>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0,M>=0,N>=0]).
eq('case_17',[A,B,C,D,E,F,G,H,I,J,K,L,M,N],5,['pack_aux'(O,P,Q,R,S,I,J,L,M,N)],[H>=K+1,O=1,T=H+B,U=A+1,A>=1,S=T+E,R=U+D,Q=C+1,C>=1,U>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0,M>=0,N>=0]).
eq('case_16',[A,B,C,D,E,F,G,H,I,J,K,L,M],3,['case_17'(A,B,C,D,E,F,G,H,I,J,N,K,L,M)],[J=N+O,I=P+1,P>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0,M>=0]).
eq('case_15',[A,B,C,D,E,F,G,H,I,J],3,['case_16'(A,B,C,D,E,F,G,K,L,M,H,I,J)],[G=K+M,F=L+1,L>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0]).
eq('pack_aux',[A,B,C,D,E,F,G,H,I,J],1,['case_15'(A,B,C,D,E,F,G,H,I,J)],[A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0]).
eq('pack',[A,B,C,D,E],3,['pack_aux'(F,G,H,I,J,A,B,C,D,E)],[F=1,I=0,H=1,A>=0,B>=0,C>=0,D>=0,E>=0]).
eq('case_18',[A,B,C,D,E,F,G,H,I],2,[],[E=1,H=1,G=0,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0]).
eq('case_19',[A,B,C,D,E,F,G,H,I,J,K,L],5,[],[H=1,M=1,N=A+M,O=N+G,P=1,L=O+D,K=C+1,J=P+B,C>=1,P>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0]).
eq('case_20',[A,B,C,D,E,F,G,H,I,J,K,L,M],4,['encode_aux'(N,B,C,D,H,I,K,L,M)],[G=J,O=1,N=A+O,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0,M>=0]).
eq('case_20',[A,B,C,D,E,F,G,H,I,J,K,L,M],7,['encode_aux'(N,O,P,Q,H,I,K,L,M)],[G>=J+1,N=0,R=1,S=A+R,T=S+G,U=1,Q=T+D,P=C+1,O=U+B,C>=1,U>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0,M>=0]).
eq('case_19',[A,B,C,D,E,F,G,H,I,J,K,L],3,['case_20'(A,B,C,D,E,F,G,H,I,M,J,K,L)],[I=M+N,H=O+1,O>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0]).
eq('case_18',[A,B,C,D,E,F,G,H,I],3,['case_19'(A,B,C,D,E,F,J,K,L,G,H,I)],[F=J+L,E=K+1,K>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0]).
eq('encode_aux',[A,B,C,D,E,F,G,H,I],1,['case_18'(A,B,C,D,E,F,G,H,I)],[A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0]).
eq('encode',[A,B,C,D,E],3,['encode_aux'(F,G,H,I,A,B,C,D,E)],[F=0,H=1,G=0,A>=0,B>=0,C>=0,D>=0,E>=0]).
eq('case_21',[A,B,C,D],2,[],[B=0,A=1,D=0,C=1,A>=0,B>=0,C>=0,D>=0]).
eq('case_21',[A,B,C,D],5,['duplicate'(E,F,G,H)],[B=I+F,A=E+1,E>=1,I>=1,J=I+H,K=G+1,G>=1,I>=1,D=I+J,C=K+1,K>=1,I>=1,A>=0,B>=0,C>=0,D>=0]).
eq('duplicate',[A,B,C,D],1,['case_21'(A,B,C,D)],[A>=0,B>=0,C>=0,D>=0]).
eq('case_22',[A,B,C,D,E,C,D],1,[],[B=A,A>=0,B>=0,C>=0,D>=0,E>=0,C>=0,D>=0]).
eq('case_22',[A,B,C,D,E,F,G],5,['prepend'(H,I,J,E,F,G)],[B>=A+1,K=1,H=B-K,J=E+D,I=C+1,C>=1,E>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0]).
eq('prepend',[A,B,C,D,E,F],2,['case_22'(G,A,B,C,D,E,F)],[G=0,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0]).
eq('case_23',[A,B,C,D,E,A,B],1,[],[D=0,C=1,A>=0,B>=0,C>=0,D>=0,E>=0,A>=0,B>=0]).
eq('case_23',[A,B,C,D,E,F,G],4,['prepend'(E,A,B,H,I,J),'replicate_aux'(I,J,K,L,E,F,G)],[D=H+L,C=K+1,K>=1,H>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0]).
eq('replicate_aux',[A,B,C,D,E,F,G],1,['case_23'(A,B,C,D,E,F,G)],[A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0]).
eq('replicate',[A,B,C,D,E],3,['rev'(F,G,A,B,H,I,J,K),'replicate_aux'(L,M,J,K,C,D,E)],[M=0,L=1,A>=0,B>=0,C>=0,D>=0,E>=0]).
eq('case_24',[A,B,C,D,E,F],2,[],[D=0,C=1,F=0,E=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0]).
eq('case_25',[A,B,C,D,E,F,G,H,I],3,['drop_aux'(A,J,F,G,H,I)],[B=A,J=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0]).
eq('case_25',[A,B,C,D,E,F,G,H,I],5,['drop_aux'(A,J,F,G,K,L)],[B>=A+1,M=1,J=B+M,I=E+L,H=K+1,K>=1,E>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0]).
eq('case_24',[A,B,C,D,E,F],3,['case_25'(A,B,C,D,G,H,I,E,F)],[D=G+I,C=H+1,H>=1,G>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0]).
eq('drop_aux',[A,B,C,D,E,F],1,['case_24'(A,B,C,D,E,F)],[A>=0,B>=0,C>=0,D>=0,E>=0,F>=0]).
eq('drop',[A,B,C,D,E],2,['drop_aux'(C,F,A,B,D,E)],[F=1,A>=0,B>=0,C>=0,D>=0,E>=0]).
eq('case_26',[A,B,C,D,E,F,G,H],4,['rev'(I,J,B,C,K,L,M,N)],[E=0,D=1,O=0,P=1,H=N+O,G=M+P,F=1,P>=1,M>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0]).
eq('case_27',[A,B,C,D,E,F,G,H,I,J,K,L],3,['rev'(M,N,C,D,O,P,Q,R)],[B=A,L=R+F,K=Q+E,J=1,E>=1,Q>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0]).
eq('case_27',[A,B,C,D,E,F,G,H,I,J,K,L],5,['split_aux'(M,N,O,H,I,J,K,L)],[B>=A+1,P=1,M=B-P,O=G+D,N=C+1,C>=1,G>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0]).
eq('case_26',[A,B,C,D,E,F,G,H],4,['case_27'(I,A,B,C,D,E,J,K,L,F,G,H)],[E=J+L,D=K+1,K>=1,J>=1,I=0,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0]).
eq('split_aux',[A,B,C,D,E,F,G,H],1,['case_26'(A,B,C,D,E,F,G,H)],[A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0]).
eq('split',[A,B,C,D,E,F],2,['split_aux'(C,G,H,A,B,D,E,F)],[H=0,G=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0]).
eq('case_28',[A,B,C,D,E],2,[],[C=0,B=1,E=0,D=1,A>=0,B>=0,C>=0,D>=0,E>=0]).
eq('case_29',[A,B,C,D,E,F,G,H,I],2,[],[B=A,I=0,H=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0]).
eq('case_29',[A,B,C,D,E,F,G,H,I],5,['take_slice'(J,F,G,K,L)],[B>=A+1,M=1,J=B-M,I=E+L,H=K+1,K>=1,E>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0]).
eq('case_28',[A,B,C,D,E],4,['case_29'(F,A,B,C,G,H,I,D,E)],[C=G+I,B=H+1,H>=1,G>=1,F=0,A>=0,B>=0,C>=0,D>=0,E>=0]).
eq('take_slice',[A,B,C,D,E],1,['case_28'(A,B,C,D,E)],[A>=0,B>=0,C>=0,D>=0,E>=0]).
eq('case_30',[A,B,C,D,E],2,[],[C=0,B=1,E=0,D=1,A>=0,B>=0,C>=0,D>=0,E>=0]).
eq('case_31',[A,B,C,D,E,F,G,C,D],1,[],[B=A,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,C>=0,D>=0]).
eq('case_31',[A,B,C,D,E,F,G,H,I],4,['drop_slice'(J,F,G,H,I)],[B>=A+1,K=1,J=B-K,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0]).
eq('case_30',[A,B,C,D,E],4,['case_31'(F,A,B,C,G,H,I,D,E)],[C=G+I,B=H+1,H>=1,G>=1,F=0,A>=0,B>=0,C>=0,D>=0,E>=0]).
eq('drop_slice',[A,B,C,D,E],1,['case_30'(A,B,C,D,E)],[A>=0,B>=0,C>=0,D>=0,E>=0]).
eq('slice',[A,B,C,D,E,F],7,['drop_slice'(G,A,B,H,I),'take_slice'(J,H,I,E,F)],[K=D-C,L=1,J=K+L,M=1,G=C-M,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0]).
eq('case_32',[A,B,C,D,E,F,G,H,E,F,G,H],1,[],[D=0,C=1,A=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,E>=0,F>=0,G>=0,H>=0]).
eq('case_32',[A,B,C,D,E,F,G,H,I,J,K,L],4,['concat'(M,N,O,P,E,F,G,H,Q,R,S,T)],[D=U+P,C=O+1,B=V+N,A=M+1,O>=1,M>=1,U>=1,L=U+T,K=S+1,J=V+R,I=Q+1,S>=1,Q>=1,U>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0]).
eq('concat',[A,B,C,D,E,F,G,H,I,J,K,L],1,['case_32'(A,B,C,D,E,F,G,H,I,J,K,L)],[A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0]).
eq('case_33',[A,B,C,D,E,F],2,[],[B=A,F=0,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0]).
eq('case_33',[A,B,C,D,E,F],4,[],[B>=A+1,G=H,I=G+B,F=J,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0]).
eq('case_34',[A,B,C,D,E,F,D,E],1,[],[B=A,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,D>=0,E>=0]).
eq('case_35',[A,B,C,D,E,F,G,H,I,J,K],2,['concat'(L,M,N,O,P,Q,R,S,T,U,J,K)],[C=S+O,B=R+N,A=1,N>=1,R>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0]).
eq('case_34',[A,B,C,D,E,F,G,H],5,['split'(D,E,F,I,J,K),'case_35'(L,M,N,A,B,C,D,E,F,O,P)],[B>=A+1,N=K,M=J,L=I,I>=1,H=P,G=O,O>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0]).
eq('rotate',[A,B,C,D,E],9,['lengthL'(F,G,A,B,H,I),'case_33'(J,K,A,B,C,L),'case_34'(M,N,K,A,B,C,O,P)],[K=I,J=0,N=L,M=0,Q=P,R=O,O>=1,E=Q,D=R,R>=1,A>=0,B>=0,C>=0,D>=0,E>=0]).
eq('case_36',[A,B,C,D,E],2,[],[C=0,B=1,E=0,D=1,A>=0,B>=0,C>=0,D>=0,E>=0]).
eq('case_37',[A,B,C,D,E,F,G,F,G],1,[],[B=A,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,F>=0,G>=0]).
eq('case_37',[A,B,C,D,E,F,G,H,I],5,['removeAt'(J,F,G,K,L)],[B>=A+1,M=1,J=B-M,I=E+L,H=K+1,K>=1,E>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0]).
eq('case_36',[A,B,C,D,E],4,['case_37'(F,A,B,C,G,H,I,D,E)],[C=G+I,B=H+1,H>=1,G>=1,F=1,A>=0,B>=0,C>=0,D>=0,E>=0]).
eq('removeAt',[A,B,C,D,E],1,['case_36'(A,B,C,D,E)],[A>=0,B>=0,C>=0,D>=0,E>=0]).
eq('case_38',[A,B,C,D,E,F],2,[],[D=0,C=1,F=0,E=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0]).
eq('case_39',[A,B,C,D,E,F,G,H,I,J],3,[],[C=A,K=F+H,L=G+1,G>=1,F>=1,J=B+K,I=L+1,L>=1,B>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0]).
eq('case_39',[A,B,C,D,E,F,G,H,I,J],5,['insertAt'(B,K,G,H,L,M)],[C>=A+1,N=1,K=C-N,J=F+M,I=L+1,L>=1,F>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0]).
eq('case_38',[A,B,C,D,E,F],4,['case_39'(G,A,B,C,D,H,I,J,E,F)],[D=H+J,C=I+1,I>=1,H>=1,G=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0]).
eq('insertAt',[A,B,C,D,E,F],1,['case_38'(A,B,C,D,E,F)],[A>=0,B>=0,C>=0,D>=0,E>=0,F>=0]).
eq('case_40',[A,B,C,D],2,[],[A>=B+1,C=1,A>=0,B>=0,C>=0,D>=0]).
eq('case_40',[A,B,C,D],5,['minusminus_aux'(E,B,F,G)],[B>=A,H=1,E=A+H,D=A+G,C=F+1,F>=1,A>=0,B>=0,C>=0,D>=0]).
eq('minusminus_aux',[A,B,C,D],1,['case_40'(A,B,C,D)],[A>=0,B>=0,C>=0,D>=0]).
eq('case_41',[A,B,C,D],3,['minusminus_aux'(B,A,E,F),'rev'(E,F,G,H,C,D,I,J)],[A>=B+1,A>=0,B>=0,C>=0,D>=0]).
eq('case_41',[A,B,C,D],2,['minusminus_aux'(A,B,C,D)],[B>=A,A>=0,B>=0,C>=0,D>=0]).
eq('minusminus',[A,B,C,D],1,['case_41'(A,B,C,D)],[A>=0,B>=0,C>=0,D>=0]).
eq('randomL',[A,B],2,[],[C=1337,B=D,A>=0,B>=0]).
eq('case_42',[A,B,A],1,[],[B>=A+1,A>=0,B>=0,A>=0]).
eq('case_42',[A,B,B],1,[],[A>=B,A>=0,B>=0,B>=0]).
eq('minL',[A,B,C],1,['case_42'(A,B,C)],[A>=0,B>=0,C>=0]).
eq('case_43',[A,B,C,D,E,F,G,H],4,[],[D=1,I=0,J=1,H=I+K,G=J,F=1,J>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0]).
eq('case_44',[A,B,C,D,E,F,G,H,I,J,K,L],3,['concat'(B,C,M,N,H,I,O,P,Q,R,S,T)],[D=A,L=G+R,K=Q,J=1,Q>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0]).
eq('case_44',[A,B,C,D,E,F,G,H,I,J,K,L],5,['rand_select_extract'(M,N,O,H,I,J,K,L)],[D>=A+1,N=G+C,M=B+1,B>=1,P=1,O=D-P,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0]).
eq('case_43',[A,B,C,D,E,F,G,H],4,['case_44'(I,A,B,C,D,E,J,K,L,F,G,H)],[E=J+L,D=K+1,K>=1,I=0,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0]).
eq('rand_select_extract',[A,B,C,D,E,F,G,H],1,['case_43'(A,B,C,D,E,F,G,H)],[A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0]).
eq('rand_select_extract_rand',[A,B,C,D,E,F],3,['randomL'(C,G),'rand_select_extract'(H,I,G,A,B,D,E,F)],[H=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0]).
eq('case_45',[A,B,C,D,E,F,G,C,D],1,[],[B=A,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,C>=0,D>=0]).
eq('case_46',[A,B,C,D,E,F,G,H,I,J,K,L],7,['rand_select_aux'(M,N,O,P,Q,R,K,L)],[C=S+Q,B=P,A=1,P>=1,T=1,M=E-T,O=S+G,N=F+1,F>=1,U=1,R=J-U,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0]).
eq('case_45',[A,B,C,D,E,F,G,H,I],5,['rand_select_extract_rand'(E,F,G,J,K,L),'case_46'(M,N,O,A,B,C,D,E,F,G,P,Q)],[B>=A+1,O=L,N=K,M=J,J>=1,I=Q,H=P,P>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0]).
eq('rand_select_aux',[A,B,C,D,E,F,G,H],2,['case_45'(I,A,B,C,D,E,F,G,H)],[I=0,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0]).
eq('rand_select',[A,B,C,D,E],6,['lengthL'(A,B,F,G,H,I),'minL'(C,J,K),'rand_select_aux'(K,L,M,A,B,J,N,O)],[J=I,L=1,E=O,D=N,N>=1,A>=0,B>=0,C>=0,D>=0,E>=0]).
eq('lotto_select',[A,B,C,D],3,['minusminus'(E,B,F,G),'rand_select'(F,G,A,C,D)],[E=1,A>=0,B>=0,C>=0,D>=0]).

Preprocessing Cost Relations
=====================================

#### Computed strongly connected components 
0. recursive  : [at/5,case_5/5,case_6/9]
1. recursive  : [case_12/4,case_13/7,case_14/10,compress/4]
2. recursive  : [case_32/12,concat/12]
3. recursive  : [case_24/6,case_25/9,drop_aux/6]
4. non_recursive  : [drop/5]
5. recursive  : [case_21/4,duplicate/4]
6. recursive  : [case_18/9,case_19/12,case_20/13,encode_aux/9]
7. non_recursive  : [encode/5]
8. non_recursive  : [case_10/5]
9. non_recursive  : [and_op/3]
10. non_recursive  : [eq/3]
11. recursive [non_tail] : [case_11/8,case_9/5,eq_lists/5]
12. recursive  : [case_38/6,case_39/10,insertAt/6]
13. recursive  : [aux_rev/12,case_8/12]
14. non_recursive  : [rev/8]
15. non_recursive  : [is_palindrome/3]
16. recursive  : [case_0/4,case_1/7,last/4]
17. recursive  : [case_2/5,case_3/8,case_4/11,last_two/5]
18. recursive  : [aux_length/8,case_7/8]
19. non_recursive  : [lengthL/6]
20. recursive  : [case_40/4,minusminus_aux/4]
21. non_recursive  : [case_41/4]
22. non_recursive  : [minusminus/4]
23. non_recursive  : [case_42/3]
24. non_recursive  : [minL/3]
25. recursive  : [case_43/8,case_44/12,rand_select_extract/8]
26. non_recursive  : [randomL/2]
27. non_recursive  : [rand_select_extract_rand/6]
28. recursive  : [case_45/9,case_46/12,rand_select_aux/8]
29. non_recursive  : [rand_select/5]
30. non_recursive  : [lotto_select/4]
31. recursive  : [case_15/10,case_16/13,case_17/14,pack_aux/10]
32. non_recursive  : [pack/5]
33. recursive  : [case_36/5,case_37/9,removeAt/5]
34. recursive  : [case_22/7,prepend/6]
35. recursive  : [case_23/7,replicate_aux/7]
36. non_recursive  : [replicate/5]
37. non_recursive  : [case_33/6]
38. non_recursive  : [case_35/11]
39. recursive  : [case_26/8,case_27/12,split_aux/8]
40. non_recursive  : [split/6]
41. non_recursive  : [case_34/8]
42. non_recursive  : [rotate/5]
43. recursive  : [case_30/5,case_31/9,drop_slice/5]
44. recursive  : [case_28/5,case_29/9,take_slice/5]
45. non_recursive  : [slice/6]
Warning: the following predicates are never called:[geq/3,gt/3,leq/3,lt/3,maxNorm/3,neg/2,neq/3,or/3]

#### Obtained direct recursion through partial evaluation 
0. SCC is partially evaluated into at/5
1. SCC is partially evaluated into compress/4
2. SCC is partially evaluated into concat/12
3. SCC is partially evaluated into drop_aux/6
4. SCC is partially evaluated into drop/5
5. SCC is partially evaluated into duplicate/4
6. SCC is partially evaluated into encode_aux/9
7. SCC is partially evaluated into encode/5
8. SCC is partially evaluated into case_10/5
9. SCC is partially evaluated into and_op/3
10. SCC is partially evaluated into eq/3
11. SCC is partially evaluated into eq_lists/5
12. SCC is partially evaluated into insertAt/6
13. SCC is partially evaluated into aux_rev/12
14. SCC is partially evaluated into rev/8
15. SCC is partially evaluated into is_palindrome/3
16. SCC is partially evaluated into last/4
17. SCC is partially evaluated into last_two/5
18. SCC is partially evaluated into aux_length/8
19. SCC is partially evaluated into lengthL/6
20. SCC is partially evaluated into minusminus_aux/4
21. SCC is partially evaluated into case_41/4
22. SCC is partially evaluated into minusminus/4
23. SCC is partially evaluated into case_42/3
24. SCC is partially evaluated into minL/3
25. SCC is partially evaluated into rand_select_extract/8
26. SCC is partially evaluated into randomL/2
27. SCC is partially evaluated into rand_select_extract_rand/6
28. SCC is partially evaluated into rand_select_aux/8
29. SCC is partially evaluated into rand_select/5
30. SCC is partially evaluated into lotto_select/4
31. SCC is partially evaluated into pack_aux/10
32. SCC is partially evaluated into pack/5
33. SCC is partially evaluated into removeAt/5
34. SCC is partially evaluated into prepend/6
35. SCC is partially evaluated into replicate_aux/7
36. SCC is partially evaluated into replicate/5
37. SCC is partially evaluated into case_33/6
38. SCC is completely evaluated into other SCCs
39. SCC is partially evaluated into split_aux/8
40. SCC is partially evaluated into split/6
41. SCC is partially evaluated into case_34/8
42. SCC is partially evaluated into rotate/5
43. SCC is partially evaluated into drop_slice/5
44. SCC is partially evaluated into take_slice/5
45. SCC is partially evaluated into slice/6

Control-Flow Refinement of Cost Relations
=====================================

### Specialization of cost equations at/5 
* CE 10 is refined into CE [94] 
* CE 8 is refined into CE [95] 
* CE 9 is refined into CE [96] 


#### Refined cost equations at/5 
* CE 94: at(A,B,C,D,E) = 9+ at(F,G,H,D,E)
     [C>=H+1,H>=0,G>=1,F>=0,E>=0,D>=0,G+1=B,F+1=A] 
* CE 95: at(A,B,C,D,E) = 3
     [A>=0,E=0,D=1,C=0,B=1] 
* CE 96: at(A,B,C,D,E) = 7
     [C>=E,E>=1,B>=2,D=1,A=0] 

### Cost equations --> "Loop" of at/5 
* CEs [95] --> Loop 94 
* CEs [96] --> Loop 95 
* CEs [94] --> Loop 96 

#### Loops of at/5 
* Loop 94: at(A,B,C,D,E) [A>=0,E=0,D=1,C=0,B=1] 
* Loop 95: at(A,B,C,D,E) [C>=E,E>=1,B>=2,D=1,A=0] 
* Loop 96: at(A,B,C,D,E)->  at(A',B',C',D,E)
                  [C>=C'+1,C'>=0,B'>=1,A'>=0,E>=0,D>=0,B'+1=B,A'+1=A] 

### Ranking functions of CR at(A,B,C,D,E) 
* RF of phase [96]: [A,B-1,C]

#### Partial ranking functions of CR at(A,B,C,D,E) 
* Partial RF of phase [96]:
  - RF of loop [96:1]:
    A
    B-1
    C

Discarded unfeasible chain [[96]]...(Non-terminating chain proved terminating)

### Resulting Chains:at(A,B,C,D,E) 
* [[96],95]
* [[96],94]
* [95]
* [94]


### Merging Chains  at/5 into  External patterns of execution 
* [[95]] --> 1 
* [[94]] --> 2 
* [[94,[96]]] --> 3 
* [[95,[96]]] --> 4 


### Specialization of cost equations compress/4 
* CE 17 is refined into CE [97] 
* CE 20 is refined into CE [98] 
* CE 18 is refined into CE [99] 
* CE 19 is refined into CE [100] 


#### Refined cost equations compress/4 
* CE 97: compress(A,B,C,D) = 7
     [D>=0,B>=0,C=2,A=2] 
* CE 98: compress(A,B,C,D) = 3
     [D>=0,B>=0,C=1,A=1] 
* CE 99: compress(A,B,C,D) = 10+ compress(E,F,C,D)
     [B>=F,2*F>=B,E>=2,D>=0,C>=0,E+1=A] 
* CE 100: compress(A,B,C,D) = 11+ compress(E,F,G,H)
     [B+H>=D,D>=H+1,G>=1,E>=2,D>=0,D+F=B+H,G+1=C,E+1=A] 

### Cost equations --> "Loop" of compress/4 
* CEs [99] --> Loop 97 
* CEs [100] --> Loop 98 
* CEs [97] --> Loop 99 
* CEs [98] --> Loop 100 

#### Loops of compress/4 
* Loop 97: compress(A,B,C,D)->  compress(A',B',C,D)
                  [B>=B',2*B'>=B,D>=0,C>=0,A>=3,A=A'+1] 
* Loop 98: compress(A,B,C,D)->  compress(A',B',C',D')
                  [B>=B'+1,B'>=0,D>=0,C>=2,A>=3,D+B'=B+D',C=C'+1,A=A'+1] 
* Loop 99: compress(A,B,C,D) [D>=0,B>=0,C=2,A=2] 
* Loop 100: compress(A,B,C,D) [D>=0,B>=0,C=1,A=1] 

### Ranking functions of CR compress(A,B,C,D) 
* RF of phase [97,98]: [A-2]

#### Partial ranking functions of CR compress(A,B,C,D) 
* Partial RF of phase [97,98]:
  - RF of loop [97:1,98:1]:
    A-2
  - RF of loop [98:1]:
    B

Discarded unfeasible chain [[97,98]]...(Non-terminating chain proved terminating)

### Resulting Chains:compress(A,B,C,D) 
* [[97,98],99]
* [100]
* [99]


### Merging Chains  compress/4 into  External patterns of execution 
* [[100]] --> 1 
* [[99]] --> 2 
* [[99,[97,98]]] --> 3 


### Specialization of cost equations concat/12 
* CE 30 is refined into CE [101] 
* CE 29 is refined into CE [102] 


#### Refined cost equations concat/12 
* CE 101: concat(A,B,C,D,E,F,G,H,E,F,G,H) = 2
     [H>=0,G>=0,F>=0,E>=0,B>=0,D=0,C=1,A=1] 
* CE 102: concat(A,B,C,D,E,F,G,H,I,J,K,L) = 5+ concat(M,N,O,P,E,F,G,H,Q,R,S,T)
     [L+P>=T,J+N>=R,L>=T+1,S>=1,Q>=1,O>=1,M>=1,L>=0,J>=0,H>=0,G>=0,F>=0,E>=0,D+T=L+P,B+R=J+N,S+1=K,Q+1=I,O+1=C,M+1=A] 

### Cost equations --> "Loop" of concat/12 
* CEs [102] --> Loop 101 
* CEs [101] --> Loop 102 

#### Loops of concat/12 
* Loop 101: concat(A,B,C,D,E,F,G,H,I,J,K,L)->  concat(A',B',C',D',E,F,G,H,E',F',G',H')
                  [L+D'>=H',J+B'>=F',L>=H'+1,G'>=1,E'>=1,C'>=1,A'>=1,L>=0,J>=0,H>=0,G>=0,F>=0,E>=0,L+D'=D+H',J+B'=B+F',G'+1=K,E'+1=I,C'+1=C,A'+1=A] 
* Loop 102: concat(A,B,C,D,E,F,G,H,E,F,G,H) [H>=0,G>=0,F>=0,E>=0,B>=0,D=0,C=1,A=1] 

### Ranking functions of CR concat(A,B,C,D,E,F,G,H,I,J,K,L) 
* RF of phase [101]: [A-1,C-1,D+1]

#### Partial ranking functions of CR concat(A,B,C,D,E,F,G,H,I,J,K,L) 
* Partial RF of phase [101]:
  - RF of loop [101:1]:
    A-1
    C-1
    D+1

Discarded unfeasible chain [[101]]...(Non-terminating chain proved terminating)

### Resulting Chains:concat(A,B,C,D,E,F,G,H,I,J,K,L) 
* [[101],102]
* [102]


### Merging Chains  concat/12 into  External patterns of execution 
* [[102]] --> 1 
* [[102,[101]]] --> 2 


### Specialization of cost equations drop_aux/6 
* CE 66 is refined into CE [103] 
* CE 65 is refined into CE [104] 
* CE 64 is refined into CE [105] 


#### Refined cost equations drop_aux/6 
* CE 103: drop_aux(A,B,C,D,E,F) = 9+ drop_aux(A,G,H,I,J,K)
     [D+K>=F,F>=K+1,B>=A+1,J>=1,H>=1,F>=0,A>=0,D+K=F+I,B+1=G,J+1=E,H+1=C] 
* CE 104: drop_aux(A,B,C,D,E,F) = 7+ drop_aux(G,H,I,J,E,F)
     [D>=J+1,J>=0,I>=1,F>=0,E>=0,I+1=C,H=1,G=1,B=1,A=1] 
* CE 105: drop_aux(A,B,C,D,E,F) = 3
     [B>=1,A>=0,F=0,E=1,D=0,C=1] 

### Cost equations --> "Loop" of drop_aux/6 
* CEs [105] --> Loop 103 
* CEs [103] --> Loop 104 
* CEs [104] --> Loop 105 

#### Loops of drop_aux/6 
* Loop 103: drop_aux(A,B,C,D,E,F) [B>=1,A>=0,F=0,E=1,D=0,C=1] 
* Loop 104: drop_aux(A,B,C,D,E,F)->  drop_aux(A,A',B',C',D',E')
                  [D>=C'+1,B>=A+1,C'>=0,F>=0,E>=2,C>=2,A>=0,F+C'=D+E',E=D'+1,C=B'+1,B+1=A'] 
* Loop 105: drop_aux(A,B,C,D,E,F)->  drop_aux(A',B',C',D',E,F)
                  [D>=D'+1,D'>=0,F>=0,E>=0,C>=2,C=C'+1,B'=1,A'=1,B=1,A=1] 

### Ranking functions of CR drop_aux(A,B,C,D,E,F) 
* RF of phase [104]: [C-1,D]
* RF of phase [105]: [C-1,D]

#### Partial ranking functions of CR drop_aux(A,B,C,D,E,F) 
* Partial RF of phase [104]:
  - RF of loop [104:1]:
    C-1
    D
* Partial RF of phase [105]:
  - RF of loop [105:1]:
    C-1
    D

Discarded unfeasible chain [[105]]...(Non-terminating chain proved terminating)
Discarded unfeasible chain [[104]](Non-terminating chain proved terminating)

### Resulting Chains:drop_aux(A,B,C,D,E,F) 
* [[105],103]
* [[104],103]
* [103]


### Merging Chains  drop_aux/6 into  External patterns of execution 
* [[103,[105]]] --> 1 
* [[103]] --> 2 
* [[103,[104]]] --> 3 


### Specialization of cost equations drop/5 
* CE 26 is refined into CE [106,107,108] 


#### Refined cost equations drop/5 
* CE 106: drop(A,B,C,D,E) = 2+ drop_aux(F,G,A,B,H,I):1
     [B+1>=A,A>=2,I=0,H=1,G=1,F=1,E=0,D=1,C=1] 
* CE 107: drop(A,B,C,D,E) = 2+ drop_aux(C,F,G,H,I,J):2
     [C>=0,J=0,I=1,H=0,G=1,F=1,E=0,D=1,B=0,A=1] 
* CE 108: drop(A,B,C,A,B) = 2+ drop_aux(D,E,A,B,A,B):3
     [B+1>=A,A>=2,E=1,D=0,C=0] 

### Cost equations --> "Loop" of drop/5 
* CEs [106] --> Loop 106 
* CEs [108] --> Loop 107 
* CEs [107] --> Loop 108 

#### Loops of drop/5 
* Loop 106: drop(A,B,C,D,E) [B+1>=A,A>=2,E=0,D=1,C=1] 
* Loop 107: drop(A,B,C,A,B) [B+1>=A,A>=2,C=0] 
* Loop 108: drop(A,B,C,D,E) [C>=0,E=0,D=1,B=0,A=1] 

### Ranking functions of CR drop(A,B,C,D,E) 

#### Partial ranking functions of CR drop(A,B,C,D,E) 


### Resulting Chains:drop(A,B,C,D,E) 
* [108]
* [107]
* [106]


### Merging Chains  drop/5 into  External patterns of execution 
* [[108]] --> 1 
* [[107]] --> 2 
* [[106]] --> 3 


### Specialization of cost equations duplicate/4 
* CE 24 is refined into CE [109] 
* CE 23 is refined into CE [110] 


#### Refined cost equations duplicate/4 
* CE 109: duplicate(A,B,C,D) = 3
     [D=0,C=1,B=0,A=1] 
* CE 110: duplicate(A,B,C,D) = 6+ duplicate(E,F,G,H)
     [D+2*F>=H,D>=H+2,E>=1,D>=0,C>=3,H+2*B=2*F+D,C=G+2,E+1=A] 

### Cost equations --> "Loop" of duplicate/4 
* CEs [110] --> Loop 109 
* CEs [109] --> Loop 110 

#### Loops of duplicate/4 
* Loop 109: duplicate(A,B,C,D)->  duplicate(A',B',C',D')
                  [D+2*B'>=D',D>=D'+2,A'>=1,D>=0,C>=3,D+2*B'=2*B+D',C=C'+2,A'+1=A] 
* Loop 110: duplicate(A,B,C,D) [D=0,C=1,B=0,A=1] 

### Ranking functions of CR duplicate(A,B,C,D) 
* RF of phase [109]: [A-1,B+1]

#### Partial ranking functions of CR duplicate(A,B,C,D) 
* Partial RF of phase [109]:
  - RF of loop [109:1]:
    A-1
    B+1

Discarded unfeasible chain [[109]]...(Non-terminating chain proved terminating)

### Resulting Chains:duplicate(A,B,C,D) 
* [[109],110]
* [110]


### Merging Chains  duplicate/4 into  External patterns of execution 
* [[110]] --> 1 
* [[110,[109]]] --> 2 


### Specialization of cost equations encode_aux/9 
* CE 58 is refined into CE [111] 
* CE 61 is refined into CE [112] 
* CE 59 is refined into CE [113] 
* CE 60 is refined into CE [114] 


#### Refined cost equations encode_aux/9 
* CE 111: encode_aux(A,B,C,D,E,F,G,H,I) = 9
     [A+D+F+1>=I,I>=A+D+1,H>=2,D>=0,A>=0,H=G+1,H=C+1,H=B+2,E=2] 
* CE 112: encode_aux(A,B,C,D,E,F,G,H,I) = 3
     [I>=0,F>=0,D>=0,H=1,G=0,E=1,C=1,B=0,A=0] 
* CE 113: encode_aux(A,B,C,D,E,F,G,H,I) = 11+ encode_aux(J,K,C,D,L,M,G,H,I)
     [F>=M,M>=0,L>=2,I>=0,H>=0,G>=0,D>=0,C>=1,A>=0,C=K+1,A+1=J,L+1=E,C=B+1] 
* CE 114: encode_aux(A,B,C,D,E,F,G,H,I) = 14+ encode_aux(J,C,K,L,M,N,G,H,I)
     [L+N>=D+F+1,F>=N+1,N>=0,M>=2,I>=0,H>=0,G>=0,D>=0,C>=1,A+D+F+1=L+N,C+1=K,M+1=E,C=B+1,J=0] 

### Cost equations --> "Loop" of encode_aux/9 
* CEs [113] --> Loop 111 
* CEs [114] --> Loop 112 
* CEs [111] --> Loop 113 
* CEs [112] --> Loop 114 

#### Loops of encode_aux/9 
* Loop 111: encode_aux(A,B,C,D,E,F,G,H,I)->  encode_aux(A',B,B',D,C',D',G,H,I)
                  [F>=D',D'>=0,I>=0,H>=0,G>=0,E>=3,D>=0,B>=0,A>=0,E=C'+1,B+1=B',A+1=A',B+1=C] 
* Loop 112: encode_aux(A,B,C,D,E,F,G,H,I)->  encode_aux(A',B',C',D',E',F',G,H,I)
                  [A+D+F+1>=D',D'>=A+D+2,I>=0,H>=0,G>=0,E>=3,D>=0,B>=0,A>=0,A+D+F+1=D'+F',E=E'+1,B+2=C',B+1=B',B+1=C,A'=0] 
* Loop 113: encode_aux(A,B,C,D,E,F,G,H,I) [A+D+F+1>=I,I>=A+D+1,D>=0,B>=0,A>=0,B+2=H,B+1=G,B+1=C,E=2] 
* Loop 114: encode_aux(A,B,C,D,E,F,G,H,I) [I>=0,F>=0,D>=0,H=1,G=0,E=1,C=1,B=0,A=0] 

### Ranking functions of CR encode_aux(A,B,C,D,E,F,G,H,I) 
* RF of phase [111,112]: [E-2]

#### Partial ranking functions of CR encode_aux(A,B,C,D,E,F,G,H,I) 
* Partial RF of phase [111,112]:
  - RF of loop [111:1,112:1]:
    E-2
  - RF of loop [112:1]:
    F

Discarded unfeasible chain [[111,112]]...(Non-terminating chain proved terminating)

### Resulting Chains:encode_aux(A,B,C,D,E,F,G,H,I) 
* [[111,112],113]
* [114]
* [113]


### Merging Chains  encode_aux/9 into  External patterns of execution 
* [[114]] --> 1 
* [[113]] --> 2 
* [[113,[111,112]]] --> 3 


### Specialization of cost equations encode/5 
* CE 22 is refined into CE [115,116,117] 


#### Refined cost equations encode/5 
* CE 115: encode(A,B,C,D,E) = 3+ encode_aux(F,G,H,I,J,B,K,L,E):1
     [E>=0,B>=0,I>=0,L=1,K=0,J=1,H=1,G=0,F=0,D=1,C=0,A=1] 
* CE 116: encode(A,B,C,D,E) = 3+ encode_aux(F,G,H,I,J,B,K,L,E):2
     [B+I+1>=E,E>=I+1,I>=0,L=2,K=1,J=2,H=1,G=0,F=0,D=2,C=1,A=2] 
* CE 117: encode(A,B,C,D,E) = 3+ encode_aux(F,G,H,I,A,B,J,D,E):3
     [A+B+I>=E+1,E+3>=A+D+I,A>=D,D>=2,A>=3,I>=0,D=J+1,D=C+1,H=1,G=0,F=0] 

### Cost equations --> "Loop" of encode/5 
* CEs [117] --> Loop 115 
* CEs [116] --> Loop 116 
* CEs [115] --> Loop 117 

#### Loops of encode/5 
* Loop 115: encode(A,B,C,D,E) [E+2>=A+C,B+1>=C,A>=C+1,C>=1,A>=3,C+1=D] 
* Loop 116: encode(A,B,C,D,E) [E>=1,B>=0,D=2,C=1,A=2] 
* Loop 117: encode(A,B,C,D,E) [E>=0,B>=0,D=1,C=0,A=1] 

### Ranking functions of CR encode(A,B,C,D,E) 

#### Partial ranking functions of CR encode(A,B,C,D,E) 


### Resulting Chains:encode(A,B,C,D,E) 
* [117]
* [116]
* [115]


### Merging Chains  encode/5 into  External patterns of execution 
* [[117]] --> 1 
* [[116]] --> 2 
* [[115]] --> 3 


### Specialization of cost equations case_10/5 
* CE 53 is refined into CE [118] 
* CE 52 is refined into CE [119] 


#### Refined cost equations case_10/5 
* CE 118: case_10(A,B,C,D,E) = 3
     [D>=0,C>=2,B>=0,E=0,A=1] 
* CE 119: case_10(A,B,C,D,E) = 2
     [D>=0,B>=0,E=1,C=1,A=1] 

### Cost equations --> "Loop" of case_10/5 
* CEs [118] --> Loop 118 
* CEs [119] --> Loop 119 

#### Loops of case_10/5 
* Loop 118: case_10(A,B,C,D,E) [D>=0,C>=2,B>=0,E=0,A=1] 
* Loop 119: case_10(A,B,C,D,E) [D>=0,B>=0,E=1,C=1,A=1] 

### Ranking functions of CR case_10(A,B,C,D,E) 

#### Partial ranking functions of CR case_10(A,B,C,D,E) 


### Resulting Chains:case_10(A,B,C,D,E) 
* [119]
* [118]


### Merging Chains  case_10/5 into  External patterns of execution 
* [[119]] --> 1 
* [[118]] --> 2 


### Specialization of cost equations and_op/3 
* CE 51 is refined into CE [120] 
* CE 50 is refined into CE [121] 


#### Refined cost equations and_op/3 
* CE 120: and_op(A,B,B) = 0
     [B>=0,A=1] 
* CE 121: and_op(A,B,C) = 0
     [B>=0,C=0,A=0] 

### Cost equations --> "Loop" of and_op/3 
* CEs [120] --> Loop 120 
* CEs [121] --> Loop 121 

#### Loops of and_op/3 
* Loop 120: and_op(A,B,B) [B>=0,A=1] 
* Loop 121: and_op(A,B,C) [B>=0,C=0,A=0] 

### Ranking functions of CR and_op(A,B,C) 

#### Partial ranking functions of CR and_op(A,B,C) 


### Resulting Chains:and_op(A,B,C) 
* [121]
* [120]


### Merging Chains  and_op/3 into  External patterns of execution 
* [[121]] --> 1 
* [[120]] --> 2 


### Specialization of cost equations eq/3 
* CE 47 is refined into CE [122] 
* CE 48 is refined into CE [123] 
* CE 49 is refined into CE [124] 


#### Refined cost equations eq/3 
* CE 122: eq(A,A,B) = 0
     [A>=0,B=1] 
* CE 123: eq(A,B,C) = 0
     [A>=B+1,B>=0,C=0] 
* CE 124: eq(A,B,C) = 0
     [B>=A+1,A>=0,C=0] 

### Cost equations --> "Loop" of eq/3 
* CEs [122] --> Loop 122 
* CEs [123] --> Loop 123 
* CEs [124] --> Loop 124 

#### Loops of eq/3 
* Loop 122: eq(A,A,B) [A>=0,B=1] 
* Loop 123: eq(A,B,C) [A>=B+1,B>=0,C=0] 
* Loop 124: eq(A,B,C) [B>=A+1,A>=0,C=0] 

### Ranking functions of CR eq(A,B,C) 

#### Partial ranking functions of CR eq(A,B,C) 


### Resulting Chains:eq(A,B,C) 
* [124]
* [123]
* [122]


### Merging Chains  eq/3 into  External patterns of execution 
* [[124]] --> 1 
* [[123]] --> 2 
* [[122]] --> 3 


### Specialization of cost equations eq_lists/5 
* CE 14 is refined into CE [125] 
* CE 15 is refined into CE [126,127] 
* CE 13 is refined into CE [128,129,130] 


#### Refined cost equations eq_lists/5 
* CE 125: eq_lists(A,B,C,D,E) = 6
     [D>=0,B>=0,A>=2,E=0,C=1] 
* CE 126: eq_lists(A,B,C,D,E) = 3+ case_10(F,B,G,D,H):1
     [D>=0,B>=0,H=1,G=1,F=1,E=1,C=1,A=1] 
* CE 127: eq_lists(A,B,C,D,E) = 3+ case_10(F,B,C,D,G):2
     [D>=0,C>=2,B>=0,G=0,F=1,E=0,A=1] 
* CE 128: eq_lists(A,B,C,D,E) = 9+ eq(F,G,H):1+ eq_lists(I,J,K,L,M)+ and_op(N,M,O):1
     [G+L>=0,G>=F+1,K>=1,J>=0,I>=1,M>=0,F>=0,G+L=D,F+J=B,K+1=C,I+1=A,O=0,N=0,H=0,E=0] 
* CE 129: eq_lists(A,B,C,D,E) = 9+ eq(F,G,H):2+ eq_lists(I,J,K,L,M)+ and_op(N,M,O):1
     [G+L>=0,F>=G+1,K>=1,J>=0,I>=1,M>=0,G>=0,G+L=D,F+J=B,K+1=C,I+1=A,O=0,N=0,H=0,E=0] 
* CE 130: eq_lists(A,B,C,D,E) = 9+ eq(F,F,G):3+ eq_lists(H,I,J,K,E)+ and_op(L,E,E):2
     [F+K>=0,J>=1,I>=0,H>=1,E>=0,F>=0,F+K=D,F+I=B,J+1=C,H+1=A,L=1,G=1] 

### Cost equations --> "Loop" of eq_lists/5 
* CEs [130] --> Loop 125 
* CEs [129] --> Loop 126 
* CEs [128] --> Loop 127 
* CEs [125] --> Loop 128 
* CEs [127] --> Loop 129 
* CEs [126] --> Loop 130 

#### Loops of eq_lists/5 
* Loop 125: eq_lists(A,B,C,D,E)->  eq_lists(A',B',C',D',E)
                  [B>=B',B'>=0,E>=0,D>=0,C>=2,A>=2,D+B'=B+D',C=C'+1,A=A'+1] 
* Loop 126: eq_lists(A,B,C,D,E)->  eq_lists(A',B',C',D',E')
                  [B+D'>=D+B'+1,D>=D',E'>=0,B'>=0,D>=0,C>=2,A>=2,C=C'+1,A=A'+1,E=0] 
* Loop 127: eq_lists(A,B,C,D,E)->  eq_lists(A',B',C',D',E')
                  [D+B'>=B+D'+1,B>=B',E'>=0,B'>=0,D>=0,C>=2,A>=2,C=C'+1,A=A'+1,E=0] 
* Loop 128: eq_lists(A,B,C,D,E) [D>=0,B>=0,A>=2,E=0,C=1] 
* Loop 129: eq_lists(A,B,C,D,E) [D>=0,C>=2,B>=0,E=0,A=1] 
* Loop 130: eq_lists(A,B,C,D,E) [D>=0,B>=0,E=1,C=1,A=1] 

### Ranking functions of CR eq_lists(A,B,C,D,E) 
* RF of phase [125,126,127]: [A-1,C-1]

#### Partial ranking functions of CR eq_lists(A,B,C,D,E) 
* Partial RF of phase [125,126,127]:
  - RF of loop [125:1,126:1,127:1]:
    A-1
    C-1
  - RF of loop [126:1]:
    B
  - RF of loop [127:1]:
    D+1

Discarded unfeasible chain [[125,126,127]]...(Non-terminating chain proved terminating)

### Resulting Chains:eq_lists(A,B,C,D,E) 
* [[125,126,127],130]
* [[125,126,127],129]
* [[125,126,127],128]
* [130]
* [129]
* [128]


### Merging Chains  eq_lists/5 into  External patterns of execution 
* [[130]] --> 1 
* [[129]] --> 2 
* [[128]] --> 3 
* [[129,[125,126,127]]] --> 4 
* [[128,[125,126,127]]] --> 5 
* [[130,[125,126,127]]] --> 6 


### Specialization of cost equations insertAt/6 
* CE 37 is refined into CE [131] 
* CE 35 is refined into CE [132] 
* CE 36 is refined into CE [133] 


#### Refined cost equations insertAt/6 
* CE 131: insertAt(A,B,C,D,E,F) = 10+ insertAt(A,G,H,I,J,K)
     [D+K>=F,F>=K+1,J>=1,H>=1,F>=0,B>=2,A>=0,F+I=D+K,B=G+1,J+1=E,H+1=C] 
* CE 132: insertAt(A,B,C,D,E,F) = 3
     [B>=0,A>=0,F=0,E=1,D=0,C=1] 
* CE 133: insertAt(A,B,C,D,E,F) = 8
     [F>=D+1,E>=3,D>=1,A+D=F,E=C+1,B=1] 

### Cost equations --> "Loop" of insertAt/6 
* CEs [132] --> Loop 131 
* CEs [133] --> Loop 132 
* CEs [131] --> Loop 133 

#### Loops of insertAt/6 
* Loop 131: insertAt(A,B,C,D,E,F) [B>=0,A>=0,F=0,E=1,D=0,C=1] 
* Loop 132: insertAt(A,B,C,D,E,F) [D>=1,C>=2,A>=1,A+D=F,C+1=E,B=1] 
* Loop 133: insertAt(A,B,C,D,E,F)->  insertAt(A,A',B',C',D',E')
                  [D+E'>=F,F>=E'+1,D'>=1,B'>=1,F>=0,B>=2,A>=0,D+E'=F+C',B=A'+1,D'+1=E,B'+1=C] 

### Ranking functions of CR insertAt(A,B,C,D,E,F) 
* RF of phase [133]: [B-1,C-1,D]

#### Partial ranking functions of CR insertAt(A,B,C,D,E,F) 
* Partial RF of phase [133]:
  - RF of loop [133:1]:
    B-1
    C-1
    D

Discarded unfeasible chain [[133]]...(Non-terminating chain proved terminating)

### Resulting Chains:insertAt(A,B,C,D,E,F) 
* [[133],132]
* [[133],131]
* [132]
* [131]


### Merging Chains  insertAt/6 into  External patterns of execution 
* [[132]] --> 1 
* [[131]] --> 2 
* [[131,[133]]] --> 3 
* [[132,[133]]] --> 4 


### Specialization of cost equations aux_rev/12 
* CE 46 is refined into CE [134] 
* CE 45 is refined into CE [135] 


#### Refined cost equations aux_rev/12 
* CE 134: aux_rev(A,B,A,C,D,E,F,G,A,B,A,C) = 2
     [C+1>=A,E>=0,A>=1,B>=0,G=0,F=1,D=1] 
* CE 135: aux_rev(A,B,A,C,D,E,F,G,H,I,J,K) = 5+ aux_rev(L,M,N,O,P,Q,R,S,H,I,J,K)
     [O+S+1>=A+G,M+Q>=E,G>=S+1,R>=1,P>=1,K>=0,J>=0,I>=0,H>=0,G>=0,E>=0,A>=1,C+G=O+S,M+Q=B+E,A+1=N,A+1=L,R+1=F,P+1=D] 

### Cost equations --> "Loop" of aux_rev/12 
* CEs [135] --> Loop 134 
* CEs [134] --> Loop 135 

#### Loops of aux_rev/12 
* Loop 134: aux_rev(A,B,A,C,D,E,F,G,H,I,J,K)->  aux_rev(A',B',C',D',E',F',G',H',H,I,J,K)
                  [D'+H'+1>=A+G,B'+F'>=E,G>=H'+1,G'>=1,E'>=1,K>=0,J>=0,I>=0,H>=0,G>=0,E>=0,A>=1,C+G=D'+H',B+E=B'+F',A+1=C',A+1=A',G'+1=F,E'+1=D] 
* Loop 135: aux_rev(A,B,A,C,D,E,F,G,A,B,A,C) [C+1>=A,E>=0,B>=0,A>=1,G=0,F=1,D=1] 

### Ranking functions of CR aux_rev(A,B,C,D,E,F,G,H,I,J,K,L) 
* RF of phase [134]: [-A+D+H+2,-C+D+H+2,E-1,G-1,H+1]

#### Partial ranking functions of CR aux_rev(A,B,C,D,E,F,G,H,I,J,K,L) 
* Partial RF of phase [134]:
  - RF of loop [134:1]:
    -A+D+H+2
    -C+D+H+2
    E-1
    G-1
    H+1

Discarded unfeasible chain [[134]]...(Non-terminating chain proved terminating)

### Resulting Chains:aux_rev(A,B,C,D,E,F,G,H,I,J,K,L) 
* [[134],135]
* [135]


### Merging Chains  aux_rev/12 into  External patterns of execution 
* [[135]] --> 1 
* [[135,[134]]] --> 2 


### Specialization of cost equations rev/8 
* CE 12 is refined into CE [136,137] 


#### Refined cost equations rev/8 
* CE 136: rev(A,B,C,D,E,F,G,H) = 2+ aux_rev(I,F,J,K,L,B,M,N,O,F,P,Q):1
     [F>=0,B>=0,Q=0,P=1,O=1,N=0,M=1,L=1,K=0,J=1,I=1,H=0,G=1,E=1,D=0,C=1,A=1] 
* CE 137: rev(A,B,A,C,A,D,A,C) = 2+ aux_rev(E,F,G,H,A,B,A,C,A,D,A,C):2
     [B+F>=D,C+1>=A,D>=0,A>=2,B>=0,F>=0,H=0,G=1,E=1] 

### Cost equations --> "Loop" of rev/8 
* CEs [137] --> Loop 136 
* CEs [136] --> Loop 137 

#### Loops of rev/8 
* Loop 136: rev(A,B,A,C,A,D,A,C) [C+1>=A,D>=0,B>=0,A>=2] 
* Loop 137: rev(A,B,C,D,E,F,G,H) [F>=0,B>=0,H=0,G=1,E=1,D=0,C=1,A=1] 

### Ranking functions of CR rev(A,B,C,D,E,F,G,H) 

#### Partial ranking functions of CR rev(A,B,C,D,E,F,G,H) 


### Resulting Chains:rev(A,B,C,D,E,F,G,H) 
* [137]
* [136]


### Merging Chains  rev/8 into  External patterns of execution 
* [[137]] --> 1 
* [[136]] --> 2 


### Specialization of cost equations is_palindrome/3 
* CE 16 is refined into CE [138,139] 


#### Refined cost equations is_palindrome/3 
* CE 138: is_palindrome(A,B,C) = 2+ rev(D,B,E,F,G,H,I,J):1+ eq_lists(K,B,L,H,M):1
     [H>=0,B>=0,M=1,L=1,K=1,J=0,I=1,G=1,F=0,E=1,D=1,C=1,A=1] 
* CE 139: is_palindrome(A,B,C) = 2+ rev(A,B,A,D,A,E,A,D):2+ eq_lists(A,B,A,E,C):6
     [B+C+E>=1,D+1>=A,C>=0,E>=0,A>=2,B>=0,1>=C] 

### Cost equations --> "Loop" of is_palindrome/3 
* CEs [139] --> Loop 138 
* CEs [138] --> Loop 139 

#### Loops of is_palindrome/3 
* Loop 138: is_palindrome(A,B,C) [C>=0,B>=0,A>=2,1>=C] 
* Loop 139: is_palindrome(A,B,C) [B>=0,C=1,A=1] 

### Ranking functions of CR is_palindrome(A,B,C) 

#### Partial ranking functions of CR is_palindrome(A,B,C) 


### Resulting Chains:is_palindrome(A,B,C) 
* [139]
* [138]


### Merging Chains  is_palindrome/3 into  External patterns of execution 
* [[139]] --> 1 
* [[138]] --> 2 


### Specialization of cost equations last/4 
* CE 3 is refined into CE [140] 
* CE 2 is refined into CE [141] 
* CE 1 is refined into CE [142] 


#### Refined cost equations last/4 
* CE 140: last(A,B,C,D) = 7+ last(E,F,C,D)
     [B>=F+1,F>=2,D>=0,C>=0,A>=3,A=E+1] 
* CE 141: last(A,B,C,B) = 6
     [B>=1,C=1,A=2] 
* CE 142: last(A,B,C,D) = 3
     [D=0,C=1,B=0,A=1] 

### Cost equations --> "Loop" of last/4 
* CEs [141] --> Loop 140 
* CEs [142] --> Loop 141 
* CEs [140] --> Loop 142 

#### Loops of last/4 
* Loop 140: last(A,B,C,B) [B>=1,C=1,A=2] 
* Loop 141: last(A,B,C,D) [D=0,C=1,B=0,A=1] 
* Loop 142: last(A,B,C,D)->  last(A',B',C,D)
                  [B>=B'+1,B'>=2,D>=0,C>=0,A>=3,A=A'+1] 

### Ranking functions of CR last(A,B,C,D) 
* RF of phase [142]: [A-2,B-2]

#### Partial ranking functions of CR last(A,B,C,D) 
* Partial RF of phase [142]:
  - RF of loop [142:1]:
    A-2
    B-2

Discarded unfeasible chain [[142]]...(Non-terminating chain proved terminating)

### Resulting Chains:last(A,B,C,D) 
* [[142],140]
* [141]
* [140]


### Merging Chains  last/4 into  External patterns of execution 
* [[141]] --> 1 
* [[140]] --> 2 
* [[140,[142]]] --> 3 


### Specialization of cost equations last_two/5 
* CE 5 is refined into CE [143] 
* CE 4 is refined into CE [144] 
* CE 7 is refined into CE [145] 
* CE 6 is refined into CE [146] 


#### Refined cost equations last_two/5 
* CE 143: last_two(A,B,C,D,B) = 10
     [B>=2,D=1,C=1,A=3] 
* CE 144: last_two(A,B,C,D,E) = 6
     [B>=1,E=0,D=1,C=0,A=2] 
* CE 145: last_two(A,B,C,D,E) = 3
     [E=0,D=1,C=0,B=0,A=1] 
* CE 146: last_two(A,B,C,D,E) = 10+ last_two(F,G,C,D,E)
     [B>=G+1,G>=3,F>=3,E>=0,D>=0,C>=0,F+1=A] 

### Cost equations --> "Loop" of last_two/5 
* CEs [146] --> Loop 143 
* CEs [143] --> Loop 144 
* CEs [144] --> Loop 145 
* CEs [145] --> Loop 146 

#### Loops of last_two/5 
* Loop 143: last_two(A,B,C,D,E)->  last_two(A',B',C,D,E)
                  [B>=B'+1,B'>=3,A'>=3,E>=0,D>=0,C>=0,A'+1=A] 
* Loop 144: last_two(A,B,C,D,B) [B>=2,D=1,C=1,A=3] 
* Loop 145: last_two(A,B,C,D,E) [B>=1,E=0,D=1,C=0,A=2] 
* Loop 146: last_two(A,B,C,D,E) [E=0,D=1,C=0,B=0,A=1] 

### Ranking functions of CR last_two(A,B,C,D,E) 
* RF of phase [143]: [A-3,B-3]

#### Partial ranking functions of CR last_two(A,B,C,D,E) 
* Partial RF of phase [143]:
  - RF of loop [143:1]:
    A-3
    B-3

Discarded unfeasible chain [[143]]...(Non-terminating chain proved terminating)

### Resulting Chains:last_two(A,B,C,D,E) 
* [[143],144]
* [146]
* [145]
* [144]


### Merging Chains  last_two/5 into  External patterns of execution 
* [[146]] --> 1 
* [[145]] --> 2 
* [[144]] --> 3 
* [[144,[143]]] --> 4 


### Specialization of cost equations aux_length/8 
* CE 44 is refined into CE [147] 
* CE 43 is refined into CE [148] 


#### Refined cost equations aux_length/8 
* CE 147: aux_length(A,B,C,D,E,E,E,E) = 2
     [E>=0,B>=0,D=0,C=1,A=1] 
* CE 148: aux_length(A,B,C,D,E,E,F,G) = 6+ aux_length(H,I,J,K,L,M,F,G)
     [D>=K+1,J>=1,H>=1,G>=0,F>=0,E>=0,D>=0,B>=0,E+1=M,E+1=L,J+1=C,H+1=A] 

### Cost equations --> "Loop" of aux_length/8 
* CEs [148] --> Loop 147 
* CEs [147] --> Loop 148 

#### Loops of aux_length/8 
* Loop 147: aux_length(A,B,C,D,E,E,F,G)->  aux_length(A',B',C',D',E',F',F,G)
                  [D>=D'+1,C'>=1,A'>=1,G>=0,F>=0,E>=0,D>=0,B>=0,E+1=F',E+1=E',C'+1=C,A'+1=A] 
* Loop 148: aux_length(A,B,C,D,E,E,E,E) [E>=0,B>=0,D=0,C=1,A=1] 

### Ranking functions of CR aux_length(A,B,C,D,E,F,G,H) 
* RF of phase [147]: [A-1,C-1,D+1]

#### Partial ranking functions of CR aux_length(A,B,C,D,E,F,G,H) 
* Partial RF of phase [147]:
  - RF of loop [147:1]:
    A-1
    C-1
    D+1

Discarded unfeasible chain [[147]]...(Non-terminating chain proved terminating)

### Resulting Chains:aux_length(A,B,C,D,E,F,G,H) 
* [[147],148]
* [148]


### Merging Chains  aux_length/8 into  External patterns of execution 
* [[148]] --> 1 
* [[148,[147]]] --> 2 


### Specialization of cost equations lengthL/6 
* CE 11 is refined into CE [149,150] 


#### Refined cost equations lengthL/6 
* CE 149: lengthL(A,B,C,D,E,F) = 2+ aux_length(G,B,H,I,J,K,L,M):1
     [B>=0,M=0,L=0,K=0,J=0,I=0,H=1,G=1,F=0,E=0,D=0,C=1,A=1] 
* CE 150: lengthL(A,B,A,C,D,E) = 2+ aux_length(A,B,A,C,F,G,H,I):2
     [C+1>=A,A>=2,B>=0,A=I+1,A=H+1,A=E+1,A=D+1,G=0,F=0] 

### Cost equations --> "Loop" of lengthL/6 
* CEs [150] --> Loop 149 
* CEs [149] --> Loop 150 

#### Loops of lengthL/6 
* Loop 149: lengthL(A,B,A,C,D,E) [C+1>=A,B>=0,A>=2,A=E+1,A=D+1] 
* Loop 150: lengthL(A,B,C,D,E,F) [B>=0,F=0,E=0,D=0,C=1,A=1] 

### Ranking functions of CR lengthL(A,B,C,D,E,F) 

#### Partial ranking functions of CR lengthL(A,B,C,D,E,F) 


### Resulting Chains:lengthL(A,B,C,D,E,F) 
* [150]
* [149]


### Merging Chains  lengthL/6 into  External patterns of execution 
* [[150]] --> 1 
* [[149]] --> 2 


### Specialization of cost equations minusminus_aux/4 
* CE 89 is refined into CE [151] 
* CE 88 is refined into CE [152] 


#### Refined cost equations minusminus_aux/4 
* CE 151: minusminus_aux(A,B,C,D) = 3
     [D>=0,A>=1,A=B+1,C=1] 
* CE 152: minusminus_aux(A,B,C,D) = 6+ minusminus_aux(E,B,F,G)
     [A+G>=0,B>=A,F>=1,A>=0,A+G=D,A+1=E,F+1=C] 

### Cost equations --> "Loop" of minusminus_aux/4 
* CEs [152] --> Loop 151 
* CEs [151] --> Loop 152 

#### Loops of minusminus_aux/4 
* Loop 151: minusminus_aux(A,B,C,D)->  minusminus_aux(A',B,B',C')
                  [A+C'>=0,B>=A,B'>=1,A>=0,A+C'=D,A+1=A',B'+1=C] 
* Loop 152: minusminus_aux(A,B,C,D) [D>=0,A>=1,A=B+1,C=1] 

### Ranking functions of CR minusminus_aux(A,B,C,D) 
* RF of phase [151]: [-A+B+1]

#### Partial ranking functions of CR minusminus_aux(A,B,C,D) 
* Partial RF of phase [151]:
  - RF of loop [151:1]:
    -A+B+1

Discarded unfeasible chain [[151]]...(Non-terminating chain proved terminating)

### Resulting Chains:minusminus_aux(A,B,C,D) 
* [[151],152]


### Merging Chains  minusminus_aux/4 into  External patterns of execution 
* [[152,[151]]] --> 1 


### Specialization of cost equations case_41/4 
* CE 80 is refined into CE [153] 
* CE 81 is refined into CE [154] 


#### Refined cost equations case_41/4 
* CE 153: case_41(A,B,C,D) = 3+ minusminus_aux(B,E,C,F):1+ rev(C,F,C,G,C,D,C,G):2
     [F+2>=B+C,G+1>=C,D>=0,C>=3,B>=0,B+C=E+2,B+C=A+2] 
* CE 154: case_41(A,B,C,D) = 2+ minusminus_aux(A,E,C,D):1
     [D+2>=A+C,C>=2,A>=0,A+C=E+2,A+C=B+2] 

### Cost equations --> "Loop" of case_41/4 
* CEs [153] --> Loop 153 
* CEs [154] --> Loop 154 

#### Loops of case_41/4 
* Loop 153: case_41(A,B,C,D) [A>=B+1,D>=0,B>=0,A+2=B+C] 
* Loop 154: case_41(A,B,C,D) [D>=B,B>=A,A>=0,A+C=B+2] 

### Ranking functions of CR case_41(A,B,C,D) 

#### Partial ranking functions of CR case_41(A,B,C,D) 


### Resulting Chains:case_41(A,B,C,D) 
* [154]
* [153]


### Merging Chains  case_41/4 into  External patterns of execution 
* [[153]] --> 1 
* [[154]] --> 2 


### Specialization of cost equations minusminus/4 
* CE 38 is refined into CE [155,156] 


#### Refined cost equations minusminus/4 
* CE 155: minusminus(A,B,C,D) = 1+ case_41(E,B,C,D):1
     [D>=0,C>=3,B>=0,B+C=E+2,B+C=A+2] 
* CE 156: minusminus(A,B,C,D) = 1+ case_41(A,B,E,D):2
     [D>=B,B>=A,A>=0,B+2=A+E,B+2=A+C] 

### Cost equations --> "Loop" of minusminus/4 
* CEs [155] --> Loop 155 
* CEs [156] --> Loop 156 

#### Loops of minusminus/4 
* Loop 155: minusminus(A,B,C,D) [A>=B+1,D>=0,B>=0,A+2=B+C] 
* Loop 156: minusminus(A,B,C,D) [D>=B,B>=A,A>=0,A+C=B+2] 

### Ranking functions of CR minusminus(A,B,C,D) 

#### Partial ranking functions of CR minusminus(A,B,C,D) 


### Resulting Chains:minusminus(A,B,C,D) 
* [156]
* [155]


### Merging Chains  minusminus/4 into  External patterns of execution 
* [[156]] --> 1 
* [[155]] --> 2 


### Specialization of cost equations case_42/3 
* CE 83 is refined into CE [157] 
* CE 82 is refined into CE [158] 


#### Refined cost equations case_42/3 
* CE 157: case_42(A,B,B) = 1
     [A>=B,B>=0] 
* CE 158: case_42(A,B,A) = 1
     [B>=A+1,A>=0] 

### Cost equations --> "Loop" of case_42/3 
* CEs [157] --> Loop 157 
* CEs [158] --> Loop 158 

#### Loops of case_42/3 
* Loop 157: case_42(A,B,B) [A>=B,B>=0] 
* Loop 158: case_42(A,B,A) [B>=A+1,A>=0] 

### Ranking functions of CR case_42(A,B,C) 

#### Partial ranking functions of CR case_42(A,B,C) 


### Resulting Chains:case_42(A,B,C) 
* [158]
* [157]


### Merging Chains  case_42/3 into  External patterns of execution 
* [[158]] --> 1 
* [[157]] --> 2 


### Specialization of cost equations minL/3 
* CE 40 is refined into CE [159,160] 


#### Refined cost equations minL/3 
* CE 159: minL(A,B,A) = 1+ case_42(A,B,A):1
     [B>=A+1,A>=0] 
* CE 160: minL(A,B,B) = 1+ case_42(A,B,B):2
     [A>=B,B>=0] 

### Cost equations --> "Loop" of minL/3 
* CEs [160] --> Loop 159 
* CEs [159] --> Loop 160 

#### Loops of minL/3 
* Loop 159: minL(A,B,B) [A>=B,B>=0] 
* Loop 160: minL(A,B,A) [B>=A+1,A>=0] 

### Ranking functions of CR minL(A,B,C) 

#### Partial ranking functions of CR minL(A,B,C) 


### Resulting Chains:minL(A,B,C) 
* [160]
* [159]


### Merging Chains  minL/3 into  External patterns of execution 
* [[160]] --> 1 
* [[159]] --> 2 


### Specialization of cost equations rand_select_extract/8 
* CE 93 is refined into CE [161] 
* CE 91 is refined into CE [162] 
* CE 92 is refined into CE [163,164] 


#### Refined cost equations rand_select_extract/8 
* CE 161: rand_select_extract(A,B,C,D,E,F,G,H) = 10+ rand_select_extract(I,J,K,L,M,N,G,H)
     [J+M>=E,E>=M,M>=0,L>=1,K>=0,H>=0,G>=1,A>=1,B+E=J+M,A+1=I,L+1=D,K+1=C,N=1,F=1] 
* CE 162: rand_select_extract(A,B,C,D,E,F,G,H) = 5
     [H>=0,E>=0,C>=0,B>=0,A>=1,G=1,F=1,D=1] 
* CE 163: rand_select_extract(A,B,C,D,E,F,G,E) = 8+ concat(H,B,I,J,G,K,L,M,G,K,L,M):1
     [E>=K,M>=0,L>=0,K>=0,G>=1,B>=0,G+1=D,J=0,I=1,H=1,F=1,C=0,A=1] 
* CE 164: rand_select_extract(A,B,C,D,E,F,G,H) = 8+ concat(A,B,A,I,J,K,L,M,G,N,O,P):2
     [B+K>=N,E>=K,P>=I,O>=A,G>=A,I+1>=A,N>=0,K>=0,A>=2,B>=0,H+K=E+N,A+L=O+1,A+J=G+1,A+D=G+2,P=I+M,F=1,C=0] 

### Cost equations --> "Loop" of rand_select_extract/8 
* CEs [162] --> Loop 161 
* CEs [164] --> Loop 162 
* CEs [163] --> Loop 163 
* CEs [161] --> Loop 164 

#### Loops of rand_select_extract/8 
* Loop 161: rand_select_extract(A,B,C,D,E,F,G,H) [H>=0,E>=0,C>=0,B>=0,A>=1,G=1,F=1,D=1] 
* Loop 162: rand_select_extract(A,B,C,D,E,F,G,H) [B+E>=H,H>=0,E>=0,D>=2,B>=0,A>=2,A+D=G+2,F=1,C=0] 
* Loop 163: rand_select_extract(A,B,C,D,E,F,G,E) [E>=0,D>=2,B>=0,D=G+1,F=1,C=0,A=1] 
* Loop 164: rand_select_extract(A,B,C,D,E,F,G,H)->  rand_select_extract(A',B',C',D',E',F',G,H)
                  [B'+E'>=E,E>=E',E'>=0,D'>=1,C'>=0,H>=0,G>=1,A>=1,B+E=B'+E',A+1=A',D'+1=D,C'+1=C,F'=1,F=1] 

### Ranking functions of CR rand_select_extract(A,B,C,D,E,F,G,H) 
* RF of phase [164]: [C,D-1]

#### Partial ranking functions of CR rand_select_extract(A,B,C,D,E,F,G,H) 
* Partial RF of phase [164]:
  - RF of loop [164:1]:
    C
    D-1

Discarded unfeasible chain [[164]]...(Non-terminating chain proved terminating)

### Resulting Chains:rand_select_extract(A,B,C,D,E,F,G,H) 
* [[164],162]
* [[164],161]
* [163]
* [161]


### Merging Chains  rand_select_extract/8 into  External patterns of execution 
* [[163]] --> 1 
* [[161]] --> 2 
* [[161,[164]]] --> 3 
* [[162,[164]]] --> 4 


### Specialization of cost equations randomL/2 
* CE 39 is refined into CE [165] 


#### Refined cost equations randomL/2 
* CE 165: randomL(A,B) = 2
     [B>=0,A>=0] 

### Cost equations --> "Loop" of randomL/2 
* CEs [165] --> Loop 165 

#### Loops of randomL/2 
* Loop 165: randomL(A,B) [B>=0,A>=0] 

### Ranking functions of CR randomL(A,B) 

#### Partial ranking functions of CR randomL(A,B) 


### Resulting Chains:randomL(A,B) 
* [165]


### Merging Chains  randomL/2 into  External patterns of execution 
* [[165]] --> 1 


### Specialization of cost equations rand_select_extract_rand/6 
* CE 90 is refined into CE [166,167,168,169] 


#### Refined cost equations rand_select_extract_rand/6 
* CE 166: rand_select_extract_rand(A,B,C,D,E,B) = 3+ randomL(C,F):1+ rand_select_extract(G,H,I,J,B,K,E,B):1
     [B>=0,E>=1,H>=0,C>=0,E+1=J,E+1=A,K=1,I=0,G=1,F=0,D=1] 
* CE 167: rand_select_extract_rand(A,B,C,D,E,F) = 3+ randomL(C,G):1+ rand_select_extract(H,I,G,J,B,K,L,F):2
     [F>=0,B>=0,G>=0,I>=0,C>=0,L=1,K=1,J=1,H=1,E=1,D=1,A=1] 
* CE 168: rand_select_extract_rand(A,B,C,D,E,F) = 3+ randomL(C,G):1+ rand_select_extract(H,I,G,A,B,J,K,F):3
     [G+1>=A,F>=0,B>=0,A>=2,I>=0,C>=0,K=1,J=1,H=1,E=1,D=1] 
* CE 169: rand_select_extract_rand(A,B,C,D,E,F) = 3+ randomL(C,G):1+ rand_select_extract(H,I,G,J,B,K,E,F):4
     [B+I>=F,E>=G+1,F>=0,B>=0,G>=1,I>=0,C>=0,E+1=J,E+1=A,K=1,H=1,D=1] 

### Cost equations --> "Loop" of rand_select_extract_rand/6 
* CEs [169] --> Loop 166 
* CEs [166] --> Loop 167 
* CEs [168] --> Loop 168 
* CEs [167] --> Loop 169 

#### Loops of rand_select_extract_rand/6 
* Loop 166: rand_select_extract_rand(A,B,C,D,E,F) [F>=0,C>=0,B>=0,A>=3,A=E+1,D=1] 
* Loop 167: rand_select_extract_rand(A,B,C,D,E,B) [C>=0,B>=0,A>=2,A=E+1,D=1] 
* Loop 168: rand_select_extract_rand(A,B,C,D,E,F) [F>=0,C>=0,B>=0,A>=2,E=1,D=1] 
* Loop 169: rand_select_extract_rand(A,B,C,D,E,F) [F>=0,C>=0,B>=0,E=1,D=1,A=1] 

### Ranking functions of CR rand_select_extract_rand(A,B,C,D,E,F) 

#### Partial ranking functions of CR rand_select_extract_rand(A,B,C,D,E,F) 


### Resulting Chains:rand_select_extract_rand(A,B,C,D,E,F) 
* [169]
* [168]
* [167]
* [166]


### Merging Chains  rand_select_extract_rand/6 into  External patterns of execution 
* [[169]] --> 1 
* [[168]] --> 2 
* [[167]] --> 3 
* [[166]] --> 4 


### Specialization of cost equations rand_select_aux/8 
* CE 85 is refined into CE [170,171,172,173] 
* CE 84 is refined into CE [174] 


#### Refined cost equations rand_select_aux/8 
* CE 170: rand_select_aux(A,B,C,D,E,F,G,H) = 14+ rand_select_extract_rand(I,E,F,J,K,L):1+ rand_select_aux(M,N,O,P,Q,R,G,H)
     [O+Q>=L,M>=0,L>=0,F>=0,E>=0,H>=0,G>=1,B>=1,C+L=O+Q,F=R+1,B+1=N,M+1=A,P=1,K=1,J=1,I=1,D=1] 
* CE 171: rand_select_aux(A,B,C,D,E,F,G,H) = 14+ rand_select_extract_rand(D,E,F,I,J,K):2+ rand_select_aux(L,M,N,O,P,Q,G,H)
     [N+P>=K,L>=0,K>=0,F>=0,E>=0,D>=2,H>=0,G>=1,B>=1,C+K=N+P,F=Q+1,B+1=M,L+1=A,O=1,J=1,I=1] 
* CE 172: rand_select_aux(A,B,C,D,E,F,G,H) = 14+ rand_select_extract_rand(I,E,F,J,K,E):3+ rand_select_aux(L,M,N,K,O,P,G,H)
     [N+O>=E,L>=0,E>=0,K>=1,F>=0,H>=0,G>=1,B>=1,C+E=N+O,F=P+1,B+1=M,K+1=I,K+1=D,L+1=A,J=1] 
* CE 173: rand_select_aux(A,B,C,D,E,F,G,H) = 14+ rand_select_extract_rand(I,E,F,J,K,L):4+ rand_select_aux(M,N,O,K,P,Q,G,H)
     [O+P>=L,M>=0,L>=0,K>=2,F>=0,E>=0,H>=0,G>=1,B>=1,C+L=O+P,F=Q+1,B+1=N,K+1=I,K+1=D,M+1=A,J=1] 
* CE 174: rand_select_aux(A,B,C,D,E,F,B,C) = 3
     [F>=0,E>=0,D>=0,C>=0,B>=1,A=0] 

### Cost equations --> "Loop" of rand_select_aux/8 
* CEs [174] --> Loop 170 
* CEs [173] --> Loop 171 
* CEs [172] --> Loop 172 
* CEs [171] --> Loop 173 
* CEs [170] --> Loop 174 

#### Loops of rand_select_aux/8 
* Loop 170: rand_select_aux(A,B,C,D,E,F,B,C) [F>=0,E>=0,D>=0,C>=0,B>=1,A=0] 
* Loop 171: rand_select_aux(A,B,C,D,E,F,G,H)->  rand_select_aux(A',B',C',D',E',F',G,H)
                  [C'+E'>=C,H>=0,G>=1,F>=0,E>=0,D>=3,C>=0,B>=1,A>=1,F=F'+1,D=D'+1,B+1=B',A=A'+1] 
* Loop 172: rand_select_aux(A,B,C,D,E,F,G,H)->  rand_select_aux(A',B',C',D',E',F',G,H)
                  [H>=0,G>=1,F>=0,E>=0,D>=2,C>=0,B>=1,A>=1,C+E=C'+E',F=F'+1,D=D'+1,B+1=B',A=A'+1] 
* Loop 173: rand_select_aux(A,B,C,D,E,F,G,H)->  rand_select_aux(A',B',C',D',E',F',G,H)
                  [C'+E'>=C,H>=0,G>=1,F>=0,E>=0,D>=2,C>=0,B>=1,A>=1,F=F'+1,B+1=B',A=A'+1,D'=1] 
* Loop 174: rand_select_aux(A,B,C,D,E,F,G,H)->  rand_select_aux(A',B',C',D',E',F',G,H)
                  [C'+E'>=C,H>=0,G>=1,F>=0,E>=0,C>=0,B>=1,A>=1,F=F'+1,B+1=B',A=A'+1,D'=1,D=1] 

### Ranking functions of CR rand_select_aux(A,B,C,D,E,F,G,H) 
* RF of phase [171,172]: [A,D-1,F+1]
* RF of phase [174]: [A,F+1]

#### Partial ranking functions of CR rand_select_aux(A,B,C,D,E,F,G,H) 
* Partial RF of phase [171,172]:
  - RF of loop [171:1]:
    D-2
  - RF of loop [171:1,172:1]:
    A
    F+1
  - RF of loop [172:1]:
    D-1
* Partial RF of phase [174]:
  - RF of loop [174:1]:
    A
    F+1

Discarded unfeasible chain [[174]]...(Non-terminating chain proved terminating)
Discarded unfeasible chain [[171,172]](Non-terminating chain proved terminating)
Discarded unfeasible chain [[171,172],[174]](Non-terminating chain proved terminating)
Discarded unfeasible chain [[171,172],173,[174]](Non-terminating chain proved terminating)
Discarded unfeasible chain [173,[174]](Non-terminating chain proved terminating)

### Resulting Chains:rand_select_aux(A,B,C,D,E,F,G,H) 
* [[174],170]
* [[171,172],[174],170]
* [[171,172],173,[174],170]
* [[171,172],173,170]
* [[171,172],170]
* [173,[174],170]
* [173,170]
* [170]


### Merging Chains  rand_select_aux/8 into  External patterns of execution 
* [[170]] --> 1 
* [[170,173],[170,[171,172]],[170,173,[171,172]]] --> 2 
* [[170,[174]]] --> 3 
* [[170,[174],173],[170,[174],173,[171,172]],[170,[174],[171,172]]] --> 4 


### Specialization of cost equations rand_select/5 
* CE 41 is refined into CE [175,176,177,178,179,180] 


#### Refined cost equations rand_select/5 
* CE 175: rand_select(A,B,C,D,E) = 6+ lengthL(F,B,G,H,I,J):1+ minL(C,K,L):2+ rand_select_aux(M,N,E,O,B,P,Q,E):1
     [E>=0,B>=0,C>=0,Q=1,P=0,O=1,N=1,M=0,L=0,K=0,J=0,I=0,H=0,G=1,F=1,D=1,A=1] 
* CE 176: rand_select(A,B,C,D,E) = 6+ lengthL(A,B,A,F,G,H):2+ minL(I,J,K):1+ rand_select_aux(L,M,E,A,B,N,O,E):1
     [F+1>=A,E>=0,B>=0,A>=2,A=N+1,A=J+1,A=H+1,A=G+1,O=1,M=1,L=0,K=0,I=0,D=1,C=0] 
* CE 177: rand_select(A,B,C,D,E) = 6+ lengthL(A,B,A,F,G,H):2+ minL(I,J,K):1+ rand_select_aux(L,M,N,A,B,O,D,E):2
     [A>=D+1,F+1>=A,E>=0,D>=2,B>=0,N>=0,A=O+1,D=L+1,D=K+1,A=J+1,D=I+1,A=H+1,A=G+1,D=C+1,M=1] 
* CE 178: rand_select(A,B,C,D,E) = 6+ lengthL(A,B,A,F,G,H):2+ minL(I,J,K):1+ rand_select_aux(L,M,N,A,B,O,D,E):4
     [A>=D+1,F+1>=A,E>=0,D>=3,B>=0,N>=0,A=O+1,D=L+1,D=K+1,A=J+1,D=I+1,A=H+1,A=G+1,D=C+1,M=1] 
* CE 179: rand_select(A,B,C,A,D) = 6+ lengthL(A,B,A,E,F,G):2+ minL(C,H,I):2+ rand_select_aux(J,K,L,A,B,M,A,D):2
     [C+1>=A,E+1>=A,D>=0,A>=2,B>=0,L>=0,A=M+1,A=J+1,A=I+1,A=H+1,A=G+1,A=F+1,K=1] 
* CE 180: rand_select(A,B,C,A,D) = 6+ lengthL(A,B,A,E,F,G):2+ minL(C,H,I):2+ rand_select_aux(J,K,L,A,B,M,A,D):4
     [C+1>=A,E+1>=A,D>=0,A>=3,B>=0,L>=0,A=M+1,A=J+1,A=I+1,A=H+1,A=G+1,A=F+1,K=1] 

### Cost equations --> "Loop" of rand_select/5 
* CEs [179,180] --> Loop 175 
* CEs [177,178] --> Loop 176 
* CEs [176] --> Loop 177 
* CEs [175] --> Loop 178 

#### Loops of rand_select/5 
* Loop 175: rand_select(A,B,C,A,D) [C+1>=A,D>=0,B>=0,A>=2] 
* Loop 176: rand_select(A,B,C,D,E) [A>=C+2,E>=0,C>=1,B>=0,C+1=D] 
* Loop 177: rand_select(A,B,C,D,E) [E>=0,B>=0,A>=2,D=1,C=0] 
* Loop 178: rand_select(A,B,C,D,E) [E>=0,C>=0,B>=0,D=1,A=1] 

### Ranking functions of CR rand_select(A,B,C,D,E) 

#### Partial ranking functions of CR rand_select(A,B,C,D,E) 


### Resulting Chains:rand_select(A,B,C,D,E) 
* [178]
* [177]
* [176]
* [175]


### Merging Chains  rand_select/5 into  External patterns of execution 
* [[178]] --> 1 
* [[177]] --> 2 
* [[175]] --> 3 
* [[176]] --> 4 


### Specialization of cost equations lotto_select/4 
* CE 42 is refined into CE [181,182,183,184,185,186] 


#### Refined cost equations lotto_select/4 
* CE 181: lotto_select(A,B,C,D) = 3+ minusminus(E,F,G,H):1+ rand_select(G,H,I,J,D):2
     [H+1>=G,D>=0,G>=2,G=F+1,G=B+1,J=1,I=0,E=1,C=1,A=0] 
* CE 182: lotto_select(A,B,C,D) = 3+ minusminus(E,F,C,G):1+ rand_select(C,G,A,C,D):3
     [A+1>=C,G+1>=C,D>=0,C>=2,C=F+1,C=B+1,E=1] 
* CE 183: lotto_select(A,B,C,D) = 3+ minusminus(E,F,G,H):1+ rand_select(G,H,I,C,D):4
     [G>=C+1,H+1>=G,D>=0,C>=2,C=I+1,G=F+1,G=B+1,C=A+1,E=1] 
* CE 184: lotto_select(A,B,C,D) = 3+ minusminus(E,F,G,H):2+ rand_select(I,H,J,K,D):2
     [D>=0,H>=0,K=1,J=0,I=3,G=3,F=0,E=1,C=1,B=0,A=0] 
* CE 185: lotto_select(A,B,C,D) = 3+ minusminus(E,F,G,H):2+ rand_select(I,H,A,J,D):3
     [D>=0,A>=2,H>=0,J=3,I=3,G=3,F=0,E=1,C=3,B=0] 
* CE 186: lotto_select(A,B,C,D) = 3+ minusminus(E,F,G,H):2+ rand_select(I,H,J,K,D):4
     [D>=0,H>=0,K=2,J=1,I=3,G=3,F=0,E=1,C=2,B=0,A=1] 

### Cost equations --> "Loop" of lotto_select/4 
* CEs [183] --> Loop 179 
* CEs [182] --> Loop 180 
* CEs [185] --> Loop 181 
* CEs [186] --> Loop 182 
* CEs [181] --> Loop 183 
* CEs [184] --> Loop 184 

#### Loops of lotto_select/4 
* Loop 179: lotto_select(A,B,C,D) [B>=A+1,D>=0,A>=1,A+1=C] 
* Loop 180: lotto_select(A,B,C,D) [A>=B,D>=0,B>=1,B+1=C] 
* Loop 181: lotto_select(A,B,C,D) [D>=0,A>=2,C=3,B=0] 
* Loop 182: lotto_select(A,B,C,D) [D>=0,C=2,B=0,A=1] 
* Loop 183: lotto_select(A,B,C,D) [D>=0,B>=1,C=1,A=0] 
* Loop 184: lotto_select(A,B,C,D) [D>=0,C=1,B=0,A=0] 

### Ranking functions of CR lotto_select(A,B,C,D) 

#### Partial ranking functions of CR lotto_select(A,B,C,D) 


### Resulting Chains:lotto_select(A,B,C,D) 
* [184]
* [183]
* [182]
* [181]
* [180]
* [179]


### Merging Chains  lotto_select/4 into  External patterns of execution 
* [[184]] --> 1 
* [[183]] --> 2 
* [[182]] --> 3 
* [[181]] --> 4 
* [[179]] --> 5 
* [[180]] --> 6 


### Specialization of cost equations pack_aux/10 
* CE 54 is refined into CE [187] 
* CE 57 is refined into CE [188] 
* CE 55 is refined into CE [189] 
* CE 56 is refined into CE [190] 


#### Refined cost equations pack_aux/10 
* CE 187: pack_aux(A,B,C,D,E,F,G,H,I,J) = 7
     [B+E+G>=J,J>=B+E,D+4>=2*H,H>=2,E>=0,B>=0,A>=1,A+D+1=I,H=C+1,F=2] 
* CE 188: pack_aux(A,B,C,D,E,F,G,H,I,J) = 3
     [J>=0,G>=0,E>=0,B>=0,I=0,H=1,F=1,D=0,C=1,A=1] 
* CE 189: pack_aux(A,B,C,D,E,F,G,H,I,J) = 10+ pack_aux(K,L,C,D,E,M,N,H,I,J)
     [L+N>=G,G>=N,D+2>=2*C,N>=0,M>=2,J>=0,I>=0,H>=0,E>=0,C>=1,A>=1,B+G=L+N,A+1=K,M+1=F] 
* CE 190: pack_aux(A,B,C,D,E,F,G,H,I,J) = 12+ pack_aux(K,L,M,N,O,P,Q,H,I,J)
     [O+Q>=E+G,G>=Q+1,D+2>=2*C,Q>=0,P>=2,J>=0,I>=0,H>=0,E>=0,C>=1,A>=1,B+E+G=O+Q,A+D+1=N,C+1=M,P+1=F,K=1] 

### Cost equations --> "Loop" of pack_aux/10 
* CEs [189] --> Loop 185 
* CEs [190] --> Loop 186 
* CEs [187] --> Loop 187 
* CEs [188] --> Loop 188 

#### Loops of pack_aux/10 
* Loop 185: pack_aux(A,B,C,D,E,F,G,H,I,J)->  pack_aux(A',B',C,D,E,C',D',H,I,J)
                  [B+G>=B',B'>=B,D+2>=2*C,J>=0,I>=0,H>=0,F>=3,E>=0,C>=1,B>=0,A>=1,B+G=B'+D',F=C'+1,A+1=A'] 
* Loop 186: pack_aux(A,B,C,D,E,F,G,H,I,J)->  pack_aux(A',B',C',D',E',F',G',H,I,J)
                  [B+E+G>=E',E'>=B+E+1,D+2>=2*C,J>=0,I>=0,H>=0,F>=3,E>=0,C>=1,B>=0,A>=1,B+E+G=E'+G',A+D+1=D',F=F'+1,C+1=C',A'=1] 
* Loop 187: pack_aux(A,B,C,D,E,F,G,H,I,J) [B+E+G>=J,J>=B+E,D+2>=2*C,E>=0,C>=1,B>=0,A>=1,A+D+1=I,C+1=H,F=2] 
* Loop 188: pack_aux(A,B,C,D,E,F,G,H,I,J) [J>=0,G>=0,E>=0,B>=0,I=0,H=1,F=1,D=0,C=1,A=1] 

### Ranking functions of CR pack_aux(A,B,C,D,E,F,G,H,I,J) 
* RF of phase [185,186]: [F-2]

#### Partial ranking functions of CR pack_aux(A,B,C,D,E,F,G,H,I,J) 
* Partial RF of phase [185,186]:
  - RF of loop [185:1,186:1]:
    F-2
  - RF of loop [186:1]:
    G

Discarded unfeasible chain [[185,186]]...(Non-terminating chain proved terminating)

### Resulting Chains:pack_aux(A,B,C,D,E,F,G,H,I,J) 
* [[185,186],187]
* [188]
* [187]


### Merging Chains  pack_aux/10 into  External patterns of execution 
* [[188]] --> 1 
* [[187]] --> 2 
* [[187,[185,186]]] --> 3 


### Specialization of cost equations pack/5 
* CE 21 is refined into CE [191,192,193] 


#### Refined cost equations pack/5 
* CE 191: pack(A,B,C,D,E) = 3+ pack_aux(F,G,H,I,J,K,B,L,M,E):1
     [E>=0,B>=0,J>=0,G>=0,M=0,L=1,K=1,I=0,H=1,F=1,D=0,C=1,A=1] 
* CE 192: pack(A,B,C,D,E) = 3+ pack_aux(F,G,H,I,J,K,B,L,M,E):2
     [B+G+J>=E,E>=G+J,J>=0,G>=0,M=2,L=2,K=2,I=0,H=1,F=1,D=2,C=2,A=2] 
* CE 193: pack(A,B,C,D,E) = 3+ pack_aux(F,G,H,I,J,A,B,K,D,E):3
     [A+E>=D+G+J,A+B>=D,2*A>=D+2,D>=A,A>=3,J>=0,G>=0,D+2=A+K,D+2=A+C,I=0,H=1,F=1] 

### Cost equations --> "Loop" of pack/5 
* CEs [193] --> Loop 189 
* CEs [192] --> Loop 190 
* CEs [191] --> Loop 191 

#### Loops of pack/5 
* Loop 189: pack(A,B,C,D,E) [E+2>=C,B+2>=C,A>=C,C>=2,A>=3,A+C=D+2] 
* Loop 190: pack(A,B,C,D,E) [E>=0,B>=0,D=2,C=2,A=2] 
* Loop 191: pack(A,B,C,D,E) [E>=0,B>=0,D=0,C=1,A=1] 

### Ranking functions of CR pack(A,B,C,D,E) 

#### Partial ranking functions of CR pack(A,B,C,D,E) 


### Resulting Chains:pack(A,B,C,D,E) 
* [191]
* [190]
* [189]


### Merging Chains  pack/5 into  External patterns of execution 
* [[191]] --> 1 
* [[190]] --> 2 
* [[189]] --> 3 


### Specialization of cost equations removeAt/5 
* CE 34 is refined into CE [194] 
* CE 32 is refined into CE [195] 
* CE 33 is refined into CE [196] 


#### Refined cost equations removeAt/5 
* CE 194: removeAt(A,B,C,D,E) = 10+ removeAt(F,G,H,I,J)
     [C+J>=E,E>=J+1,I>=1,G>=1,E>=0,A>=2,E+H=C+J,A=F+1,I+1=D,G+1=B] 
* CE 195: removeAt(A,B,C,D,E) = 3
     [A>=0,E=0,D=1,C=0,B=1] 
* CE 196: removeAt(A,B,C,D,E) = 6
     [C>=E+1,E>=0,D>=1,D+1=B,A=1] 

### Cost equations --> "Loop" of removeAt/5 
* CEs [195] --> Loop 192 
* CEs [196] --> Loop 193 
* CEs [194] --> Loop 194 

#### Loops of removeAt/5 
* Loop 192: removeAt(A,B,C,D,E) [A>=0,E=0,D=1,C=0,B=1] 
* Loop 193: removeAt(A,B,C,D,E) [C>=E+1,E>=0,B>=2,B=D+1,A=1] 
* Loop 194: removeAt(A,B,C,D,E)->  removeAt(A',B',C',D',E')
                  [C+E'>=E,E>=E'+1,D'>=1,B'>=1,E>=0,A>=2,C+E'=E+C',A=A'+1,D'+1=D,B'+1=B] 

### Ranking functions of CR removeAt(A,B,C,D,E) 
* RF of phase [194]: [A-1,B-1,C]

#### Partial ranking functions of CR removeAt(A,B,C,D,E) 
* Partial RF of phase [194]:
  - RF of loop [194:1]:
    A-1
    B-1
    C

Discarded unfeasible chain [[194]]...(Non-terminating chain proved terminating)

### Resulting Chains:removeAt(A,B,C,D,E) 
* [[194],193]
* [[194],192]
* [193]
* [192]


### Merging Chains  removeAt/5 into  External patterns of execution 
* [[193]] --> 1 
* [[192]] --> 2 
* [[192,[194]]] --> 3 
* [[193,[194]]] --> 4 


### Specialization of cost equations prepend/6 
* CE 87 is refined into CE [197] 
* CE 86 is refined into CE [198] 


#### Refined cost equations prepend/6 
* CE 197: prepend(A,B,C,D,B,C) = 3
     [D>=1,C>=0,B>=0,A=0] 
* CE 198: prepend(A,B,C,D,E,F) = 7+ prepend(G,H,I,D,E,F)
     [G>=0,F>=0,E>=0,D>=1,C>=0,B>=1,C+D=I,B+1=H,G+1=A] 

### Cost equations --> "Loop" of prepend/6 
* CEs [198] --> Loop 195 
* CEs [197] --> Loop 196 

#### Loops of prepend/6 
* Loop 195: prepend(A,B,C,D,E,F)->  prepend(A',B',C',D,E,F)
                  [A'>=0,F>=0,E>=0,D>=1,C>=0,B>=1,C+D=C',B+1=B',A'+1=A] 
* Loop 196: prepend(A,B,C,D,B,C) [D>=1,C>=0,B>=0,A=0] 

### Ranking functions of CR prepend(A,B,C,D,E,F) 
* RF of phase [195]: [A]

#### Partial ranking functions of CR prepend(A,B,C,D,E,F) 
* Partial RF of phase [195]:
  - RF of loop [195:1]:
    A

Discarded unfeasible chain [[195]]...(Non-terminating chain proved terminating)

### Resulting Chains:prepend(A,B,C,D,E,F) 
* [[195],196]
* [196]


### Merging Chains  prepend/6 into  External patterns of execution 
* [[196]] --> 1 
* [[196,[195]]] --> 2 


### Specialization of cost equations replicate_aux/7 
* CE 63 is refined into CE [199] 
* CE 62 is refined into CE [200,201] 


#### Refined cost equations replicate_aux/7 
* CE 199: replicate_aux(A,B,C,D,E,A,B) = 2
     [E>=0,B>=0,A>=0,D=0,C=1] 
* CE 200: replicate_aux(A,B,C,D,E,F,G) = 5+ prepend(H,A,B,I,A,B):1+ replicate_aux(A,B,J,K,L,F,G)
     [I+K>=0,J>=1,B>=0,A>=0,I>=1,G>=0,F>=0,I+K=D,J+1=C,L=0,H=0,E=0] 
* CE 201: replicate_aux(A,B,C,D,E,F,G) = 5+ prepend(E,H,B,I,J,K):2+ replicate_aux(J,K,L,M,E,F,G)
     [K+1>=B+E+I,I+M>=0,J>=E+1,L>=1,I>=1,B>=0,E>=1,G>=0,F>=0,J=E+H,I+M=D,J=A+E,L+1=C] 

### Cost equations --> "Loop" of replicate_aux/7 
* CEs [201] --> Loop 197 
* CEs [200] --> Loop 198 
* CEs [199] --> Loop 199 

#### Loops of replicate_aux/7 
* Loop 197: replicate_aux(A,B,C,D,E,F,G)->  replicate_aux(A',B',C',D',E,F,G)
                  [B'+D'+1>=B+D+E,D>=D'+1,G>=0,F>=0,E>=1,D>=0,C>=2,B>=0,A>=1,A+E=A',C=C'+1] 
* Loop 198: replicate_aux(A,B,C,D,E,F,G)->  replicate_aux(A,B,A',B',C',F,G)
                  [D>=B'+1,G>=0,F>=0,D>=0,C>=2,B>=0,A>=0,C=A'+1,C'=0,E=0] 
* Loop 199: replicate_aux(A,B,C,D,E,A,B) [E>=0,B>=0,A>=0,D=0,C=1] 

### Ranking functions of CR replicate_aux(A,B,C,D,E,F,G) 
* RF of phase [197]: [C-1,D+1]
* RF of phase [198]: [C-1,D+1]

#### Partial ranking functions of CR replicate_aux(A,B,C,D,E,F,G) 
* Partial RF of phase [197]:
  - RF of loop [197:1]:
    C-1
    D+1
* Partial RF of phase [198]:
  - RF of loop [198:1]:
    C-1
    D+1

Discarded unfeasible chain [[198]]...(Non-terminating chain proved terminating)
Discarded unfeasible chain [[197]](Non-terminating chain proved terminating)

### Resulting Chains:replicate_aux(A,B,C,D,E,F,G) 
* [[198],199]
* [[197],199]
* [199]


### Merging Chains  replicate_aux/7 into  External patterns of execution 
* [[199,[198]]] --> 1 
* [[199]] --> 2 
* [[199,[197]]] --> 3 


### Specialization of cost equations replicate/5 
* CE 25 is refined into CE [202,203,204] 


#### Refined cost equations replicate/5 
* CE 202: replicate(A,B,C,D,E) = 3+ rev(F,G,H,I,J,K,L,M):1+ replicate_aux(N,O,P,Q,C,R,S):2
     [C>=0,K>=0,G>=0,S=0,R=1,Q=0,P=1,O=0,N=1,M=0,L=1,J=1,I=0,H=1,F=1,E=0,D=1,B=0,A=1] 
* CE 203: replicate(A,B,C,D,E) = 3+ rev(A,F,A,B,A,G,A,B):2+ replicate_aux(H,I,A,B,J,K,L):1
     [B+1>=A,A>=2,G>=0,F>=0,L=0,K=1,J=0,I=0,H=1,E=0,D=1,C=0] 
* CE 204: replicate(A,B,C,D,E) = 3+ rev(A,F,A,B,A,G,A,B):2+ replicate_aux(H,I,A,B,C,D,E):3
     [A+E>=B+D,D+1>=A+C,B+1>=A,C>=1,A>=2,G>=0,F>=0,I=0,H=1] 

### Cost equations --> "Loop" of replicate/5 
* CEs [204] --> Loop 200 
* CEs [203] --> Loop 201 
* CEs [202] --> Loop 202 

#### Loops of replicate/5 
* Loop 200: replicate(A,B,C,D,E) [A+E>=B+D,D+1>=A+C,B+1>=A,C>=1,A>=2] 
* Loop 201: replicate(A,B,C,D,E) [B+1>=A,A>=2,E=0,D=1,C=0] 
* Loop 202: replicate(A,B,C,D,E) [C>=0,E=0,D=1,B=0,A=1] 

### Ranking functions of CR replicate(A,B,C,D,E) 

#### Partial ranking functions of CR replicate(A,B,C,D,E) 


### Resulting Chains:replicate(A,B,C,D,E) 
* [202]
* [201]
* [200]


### Merging Chains  replicate/5 into  External patterns of execution 
* [[202]] --> 1 
* [[201]] --> 2 
* [[200]] --> 3 


### Specialization of cost equations case_33/6 
* CE 77 is refined into CE [205] 
* CE 76 is refined into CE [206] 


#### Refined cost equations case_33/6 
* CE 205: case_33(A,B,C,D,E,F) = 4
     [F>=0,E>=0,D>=0,C>=0,B>=1,A=0] 
* CE 206: case_33(A,B,C,D,E,F) = 2
     [E>=0,D>=0,C>=0,F=0,B=0,A=0] 

### Cost equations --> "Loop" of case_33/6 
* CEs [205] --> Loop 203 
* CEs [206] --> Loop 204 

#### Loops of case_33/6 
* Loop 203: case_33(A,B,C,D,E,F) [F>=0,E>=0,D>=0,C>=0,B>=1,A=0] 
* Loop 204: case_33(A,B,C,D,E,F) [E>=0,D>=0,C>=0,F=0,B=0,A=0] 

### Ranking functions of CR case_33(A,B,C,D,E,F) 

#### Partial ranking functions of CR case_33(A,B,C,D,E,F) 


### Resulting Chains:case_33(A,B,C,D,E,F) 
* [204]
* [203]


### Merging Chains  case_33/6 into  External patterns of execution 
* [[204]] --> 1 
* [[203]] --> 2 


### Specialization of cost equations split_aux/8 
* CE 69 is refined into CE [207] 
* CE 67 is refined into CE [208,209] 
* CE 68 is refined into CE [210,211] 


#### Refined cost equations split_aux/8 
* CE 207: split_aux(A,B,C,D,E,F,G,H) = 10+ split_aux(I,J,K,L,M,F,G,H)
     [K+M+1>=B+E,E>=M+1,M>=0,L>=1,I>=0,H>=0,G>=0,F>=0,B>=1,C+E=K+M,B+1=J,L+1=D,I+1=A] 
* CE 208: split_aux(A,B,C,D,E,F,G,H) = 5+ rev(I,J,K,L,M,N,O,P):1
     [N>=0,J>=0,A>=0,P=0,O=1,M=1,L=0,K=1,I=1,H=0,G=2,F=1,E=0,D=1,C=0,B=1] 
* CE 209: split_aux(A,B,C,D,E,F,G,C) = 5+ rev(B,H,B,C,B,I,B,C):2
     [C+1>=B,I>=0,B>=2,H>=0,A>=0,B+1=G,F=1,E=0,D=1] 
* CE 210: split_aux(A,B,C,D,E,F,G,E) = 8+ rev(H,I,J,K,L,M,N,O):1
     [M>=0,I>=0,E>=1,G>=3,G=D+1,O=0,N=1,L=1,K=0,J=1,H=1,F=1,C=0,B=1,A=0] 
* CE 211: split_aux(A,B,C,D,E,F,G,H) = 8+ rev(B,I,B,C,B,J,B,C):2
     [H>=C+1,C+1>=B,G>=B+2,J>=0,B>=2,I>=0,C+E=H,B+D=G,F=1,A=0] 

### Cost equations --> "Loop" of split_aux/8 
* CEs [209] --> Loop 205 
* CEs [208] --> Loop 206 
* CEs [211] --> Loop 207 
* CEs [210] --> Loop 208 
* CEs [207] --> Loop 209 

#### Loops of split_aux/8 
* Loop 205: split_aux(A,B,C,D,E,F,G,C) [C+1>=B,B>=2,A>=0,B+1=G,F=1,E=0,D=1] 
* Loop 206: split_aux(A,B,C,D,E,F,G,H) [A>=0,H=0,G=2,F=1,E=0,D=1,C=0,B=1] 
* Loop 207: split_aux(A,B,C,D,E,F,G,H) [C+1>=B,E>=1,D>=2,B>=2,C+E=H,B+D=G,F=1,A=0] 
* Loop 208: split_aux(A,B,C,D,E,F,G,E) [E>=1,D>=2,D+1=G,F=1,C=0,B=1,A=0] 
* Loop 209: split_aux(A,B,C,D,E,F,G,H)->  split_aux(A',B',C',D',E',F,G,H)
                  [C'+E'+1>=B+E,E>=E'+1,E'>=0,D'>=1,A'>=0,H>=0,G>=0,F>=0,B>=1,C+E=C'+E',B+1=B',D'+1=D,A'+1=A] 

### Ranking functions of CR split_aux(A,B,C,D,E,F,G,H) 
* RF of phase [209]: [A,-B+C+E+1,D-1,E]

#### Partial ranking functions of CR split_aux(A,B,C,D,E,F,G,H) 
* Partial RF of phase [209]:
  - RF of loop [209:1]:
    A
    -B+C+E+1
    D-1
    E

Discarded unfeasible chain [[209]]...(Non-terminating chain proved terminating)

### Resulting Chains:split_aux(A,B,C,D,E,F,G,H) 
* [[209],207]
* [[209],205]
* [208]
* [206]


### Merging Chains  split_aux/8 into  External patterns of execution 
* [[208]] --> 1 
* [[206]] --> 2 
* [[207,[209]]] --> 3 
* [[205,[209]]] --> 4 


### Specialization of cost equations split/6 
* CE 27 is refined into CE [212,213,214,215] 


#### Refined cost equations split/6 
* CE 212: split(A,B,C,D,E,B) = 2+ split_aux(F,G,H,I,B,J,E,B):1
     [B>=1,E>=3,E=I+1,E=A+1,J=1,H=0,G=1,F=0,D=1,C=0] 
* CE 213: split(A,B,C,D,E,F) = 2+ split_aux(C,G,H,I,J,K,L,M):2
     [C>=0,M=0,L=2,K=1,J=0,I=1,H=0,G=1,F=0,E=2,D=1,B=0,A=1] 
* CE 214: split(A,B,C,D,E,B) = 2+ split_aux(C,F,G,H,B,I,E,B):3
     [B>=C+1,E>=C+3,C>=1,E=H+1,E=A+1,I=1,G=0,F=1,D=1] 
* CE 215: split(A,B,C,D,E,B) = 2+ split_aux(C,F,G,H,B,I,E,B):4
     [B+2>=E,C+2>=E,E>=3,E=H+1,E=A+1,I=1,G=0,F=1,D=1] 

### Cost equations --> "Loop" of split/6 
* CEs [214] --> Loop 210 
* CEs [215] --> Loop 211 
* CEs [212] --> Loop 212 
* CEs [213] --> Loop 213 

#### Loops of split/6 
* Loop 210: split(A,B,C,D,E,B) [B>=C+1,A>=C+2,C>=1,A+1=E,D=1] 
* Loop 211: split(A,B,C,D,E,B) [C+1>=A,B+1>=A,A>=2,A+1=E,D=1] 
* Loop 212: split(A,B,C,D,E,B) [B>=1,A>=2,A+1=E,D=1,C=0] 
* Loop 213: split(A,B,C,D,E,F) [C>=0,F=0,E=2,D=1,B=0,A=1] 

### Ranking functions of CR split(A,B,C,D,E,F) 

#### Partial ranking functions of CR split(A,B,C,D,E,F) 


### Resulting Chains:split(A,B,C,D,E,F) 
* [213]
* [212]
* [211]
* [210]


### Merging Chains  split/6 into  External patterns of execution 
* [[213]] --> 1 
* [[212]] --> 2 
* [[211]] --> 3 
* [[210]] --> 4 


### Specialization of cost equations case_34/8 
* CE 79 is refined into CE [216,217,218,219,220,221,222] 
* CE 78 is refined into CE [223] 


#### Refined cost equations case_34/8 
* CE 216: case_34(A,B,C,D,E,F,G,H) = 7+ split(I,J,F,K,L,M):1+ concat(N,O,P,Q,R,S,T,U,R,S,V,W):1
     [S>=0,R>=0,O>=0,F>=0,C>=0,B>=1,W=0,V=1,U=0,T=1,Q=0,P=1,N=1,M=0,L=2,K=1,J=0,I=1,H=0,G=1,E=0,D=1,A=0] 
* CE 217: case_34(A,B,C,D,E,F,D,E) = 7+ split(D,E,G,H,I,E):2+ concat(J,K,L,M,N,O,D,E,N,O,D,E):1
     [E>=1,D>=2,O>=0,N>=0,K>=0,C>=0,B>=1,D+1=I,M=0,L=1,J=1,H=1,G=0,F=0,A=0] 
* CE 218: case_34(A,B,C,D,E,F,D,E) = 7+ split(D,E,G,H,I,E):2+ concat(J,K,J,L,M,N,O,P,Q,R,D,E):2
     [K+N>=R,E>=L,D>=J,Q>=J,L+1>=J,R>=0,N>=0,J>=2,K>=0,C>=0,B>=1,J+O=D+1,J+M=Q+1,E=L+P,D+1=I,H=1,G=0,F=0,A=0] 
* CE 219: case_34(A,B,C,D,E,F,D,E) = 7+ split(D,E,F,G,H,E):3+ concat(I,J,K,L,M,N,D,E,M,N,D,E):1
     [E+1>=D,F+1>=D,D>=2,N>=0,M>=0,J>=0,C>=0,B>=1,D+1=H,L=0,K=1,I=1,G=1,A=0] 
* CE 220: case_34(A,B,C,D,E,F,D,E) = 7+ split(D,E,F,G,H,E):3+ concat(I,J,I,K,L,M,N,O,P,Q,D,E):2
     [J+M>=Q,E+1>=D,F+1>=D,E>=K,D>=I,P>=I,K+1>=I,Q>=0,M>=0,I>=2,J>=0,C>=0,B>=1,I+N=D+1,I+L=P+1,E=K+O,D+1=H,G=1,A=0] 
* CE 221: case_34(A,B,C,D,E,F,D,E) = 7+ split(D,E,F,G,H,E):4+ concat(I,J,K,L,M,N,D,E,M,N,D,E):1
     [E>=F+1,D>=F+2,N>=0,M>=0,J>=0,F>=1,C>=0,B>=1,D+1=H,L=0,K=1,I=1,G=1,A=0] 
* CE 222: case_34(A,B,C,D,E,F,D,E) = 7+ split(D,E,F,G,H,E):4+ concat(I,J,I,K,L,M,N,O,P,Q,D,E):2
     [J+M>=Q,E>=K,D>=I,P>=I,K+1>=I,E>=F+1,D>=F+2,Q>=0,M>=0,I>=2,J>=0,F>=1,C>=0,B>=1,I+N=D+1,I+L=P+1,E=K+O,D+1=H,G=1,A=0] 
* CE 223: case_34(A,B,C,D,E,F,D,E) = 1
     [F>=0,E>=0,D>=1,C>=0,B=0,A=0] 

### Cost equations --> "Loop" of case_34/8 
* CEs [221,222] --> Loop 214 
* CEs [219,220] --> Loop 215 
* CEs [217,218] --> Loop 216 
* CEs [216] --> Loop 217 
* CEs [223] --> Loop 218 

#### Loops of case_34/8 
* Loop 214: case_34(A,B,C,D,E,F,D,E) [E>=F+1,D>=F+2,F>=1,C>=0,B>=1,A=0] 
* Loop 215: case_34(A,B,C,D,E,F,D,E) [F+1>=D,E+1>=D,D>=2,C>=0,B>=1,A=0] 
* Loop 216: case_34(A,B,C,D,E,F,D,E) [E>=1,D>=2,C>=0,B>=1,F=0,A=0] 
* Loop 217: case_34(A,B,C,D,E,F,G,H) [F>=0,C>=0,B>=1,H=0,G=1,E=0,D=1,A=0] 
* Loop 218: case_34(A,B,C,D,E,F,D,E) [F>=0,E>=0,D>=1,C>=0,B=0,A=0] 

### Ranking functions of CR case_34(A,B,C,D,E,F,G,H) 

#### Partial ranking functions of CR case_34(A,B,C,D,E,F,G,H) 


### Resulting Chains:case_34(A,B,C,D,E,F,G,H) 
* [218]
* [217]
* [216]
* [215]
* [214]


### Merging Chains  case_34/8 into  External patterns of execution 
* [[218]] --> 1 
* [[217]] --> 2 
* [[216]] --> 3 
* [[215]] --> 4 
* [[214]] --> 5 


### Specialization of cost equations rotate/5 
* CE 31 is refined into CE [224,225,226,227,228] 


#### Refined cost equations rotate/5 
* CE 224: rotate(A,B,C,D,E) = 9+ lengthL(F,G,H,I,J,K):1+ case_33(L,M,N,O,C,P):1+ case_34(Q,R,S,T,U,C,V,W):1
     [C>=0,G>=0,W=0,V=1,U=0,T=1,S=0,R=0,Q=0,P=0,O=0,N=1,M=0,L=0,K=0,J=0,I=0,H=1,F=1,E=0,D=1,B=0,A=1] 
* CE 225: rotate(A,B,C,A,B) = 9+ lengthL(A,D,A,B,E,F):2+ case_33(G,H,A,B,C,I):2+ case_34(J,K,L,A,B,C,A,B):1
     [B+1>=A,A>=2,C>=0,D>=0,A=L+1,A=H+1,A=F+1,A=E+1,K=0,J=0,I=0,G=0] 
* CE 226: rotate(A,B,C,A,B) = 9+ lengthL(A,D,A,B,E,F):2+ case_33(G,H,A,B,I,J):2+ case_34(K,J,L,A,B,M,A,B):3
     [B+1>=A,A>=2,J>=1,D>=0,A=L+1,A=H+1,A=F+1,A=E+1,M=0,K=0,I=0,G=0,C=0] 
* CE 227: rotate(A,B,C,A,B) = 9+ lengthL(A,D,A,B,E,F):2+ case_33(G,H,A,B,C,I):2+ case_34(J,I,K,A,B,C,A,B):4
     [B+1>=A,C+1>=A,A>=2,I>=1,D>=0,A=K+1,A=H+1,A=F+1,A=E+1,J=0,G=0] 
* CE 228: rotate(A,B,C,A,B) = 9+ lengthL(A,D,A,B,E,F):2+ case_33(G,H,A,B,C,I):2+ case_34(J,I,K,A,B,C,A,B):5
     [B+1>=A,A>=C+2,C>=1,I>=1,D>=0,A=K+1,A=H+1,A=F+1,A=E+1,J=0,G=0] 

### Cost equations --> "Loop" of rotate/5 
* CEs [225,226,227,228] --> Loop 219 
* CEs [224] --> Loop 220 

#### Loops of rotate/5 
* Loop 219: rotate(A,B,C,A,B) [B+1>=A,C>=0,A>=2] 
* Loop 220: rotate(A,B,C,D,E) [C>=0,E=0,D=1,B=0,A=1] 

### Ranking functions of CR rotate(A,B,C,D,E) 

#### Partial ranking functions of CR rotate(A,B,C,D,E) 


### Resulting Chains:rotate(A,B,C,D,E) 
* [220]
* [219]


### Merging Chains  rotate/5 into  External patterns of execution 
* [[220]] --> 1 
* [[219]] --> 2 


### Specialization of cost equations drop_slice/5 
* CE 72 is refined into CE [229] 
* CE 70 is refined into CE [230] 
* CE 71 is refined into CE [231] 


#### Refined cost equations drop_slice/5 
* CE 229: drop_slice(A,B,C,D,E) = 9+ drop_slice(F,G,H,D,E)
     [C>=H+1,H>=0,G>=1,F>=0,E>=0,D>=0,G+1=B,F+1=A] 
* CE 230: drop_slice(A,B,C,D,E) = 3
     [A>=0,E=0,D=1,C=0,B=1] 
* CE 231: drop_slice(A,B,C,B,C) = 6
     [C>=1,B>=2,A=0] 

### Cost equations --> "Loop" of drop_slice/5 
* CEs [230] --> Loop 221 
* CEs [231] --> Loop 222 
* CEs [229] --> Loop 223 

#### Loops of drop_slice/5 
* Loop 221: drop_slice(A,B,C,D,E) [A>=0,E=0,D=1,C=0,B=1] 
* Loop 222: drop_slice(A,B,C,B,C) [C>=1,B>=2,A=0] 
* Loop 223: drop_slice(A,B,C,D,E)->  drop_slice(A',B',C',D,E)
                  [C>=C'+1,C'>=0,B'>=1,A'>=0,E>=0,D>=0,B'+1=B,A'+1=A] 

### Ranking functions of CR drop_slice(A,B,C,D,E) 
* RF of phase [223]: [A,B-1,C]

#### Partial ranking functions of CR drop_slice(A,B,C,D,E) 
* Partial RF of phase [223]:
  - RF of loop [223:1]:
    A
    B-1
    C

Discarded unfeasible chain [[223]]...(Non-terminating chain proved terminating)

### Resulting Chains:drop_slice(A,B,C,D,E) 
* [[223],222]
* [[223],221]
* [222]
* [221]


### Merging Chains  drop_slice/5 into  External patterns of execution 
* [[222]] --> 1 
* [[221]] --> 2 
* [[221,[223]]] --> 3 
* [[222,[223]]] --> 4 


### Specialization of cost equations take_slice/5 
* CE 75 is refined into CE [232] 
* CE 73 is refined into CE [233] 
* CE 74 is refined into CE [234] 


#### Refined cost equations take_slice/5 
* CE 232: take_slice(A,B,C,D,E) = 10+ take_slice(F,G,H,I,J)
     [C+J>=E,E>=J+1,I>=1,G>=1,F>=0,E>=0,E+H=C+J,I+1=D,G+1=B,F+1=A] 
* CE 233: take_slice(A,B,C,D,E) = 3
     [A>=0,E=0,D=1,C=0,B=1] 
* CE 234: take_slice(A,B,C,D,E) = 7
     [C>=1,B>=2,E=0,D=1,A=0] 

### Cost equations --> "Loop" of take_slice/5 
* CEs [233] --> Loop 224 
* CEs [234] --> Loop 225 
* CEs [232] --> Loop 226 

#### Loops of take_slice/5 
* Loop 224: take_slice(A,B,C,D,E) [A>=0,E=0,D=1,C=0,B=1] 
* Loop 225: take_slice(A,B,C,D,E) [C>=1,B>=2,E=0,D=1,A=0] 
* Loop 226: take_slice(A,B,C,D,E)->  take_slice(A',B',C',D',E')
                  [C+E'>=E,E>=E'+1,D'>=1,B'>=1,A'>=0,E>=0,C+E'=E+C',D'+1=D,B'+1=B,A'+1=A] 

### Ranking functions of CR take_slice(A,B,C,D,E) 
* RF of phase [226]: [A,B-1,C]

#### Partial ranking functions of CR take_slice(A,B,C,D,E) 
* Partial RF of phase [226]:
  - RF of loop [226:1]:
    A
    B-1
    C

Discarded unfeasible chain [[226]]...(Non-terminating chain proved terminating)

### Resulting Chains:take_slice(A,B,C,D,E) 
* [[226],225]
* [[226],224]
* [225]
* [224]


### Merging Chains  take_slice/5 into  External patterns of execution 
* [[225]] --> 1 
* [[224]] --> 2 
* [[224,[226]]] --> 3 
* [[225,[226]]] --> 4 


### Specialization of cost equations slice/6 
* CE 28 is refined into CE [235,236,237,238,239,240,241,242] 


#### Refined cost equations slice/6 
* CE 235: slice(A,B,C,D,E,F) = 7+ drop_slice(G,A,B,A,B):1+ take_slice(H,A,B,I,J):1
     [B>=1,A>=2,J=0,I=1,H=0,G=0,F=0,E=1,D=0,C=1] 
* CE 236: slice(A,B,C,D,A,B) = 7+ drop_slice(E,A,B,A,B):1+ take_slice(D,A,B,A,B):3
     [B+1>=A,D+1>=A,A>=2,E=0,C=1] 
* CE 237: slice(A,B,C,D,E,F) = 7+ drop_slice(G,A,B,A,B):1+ take_slice(H,A,B,E,F):4
     [B>=F+1,F+1>=E,A>=E+1,E>=2,E=H+1,E=D+1,G=0,C=1] 
* CE 238: slice(A,B,C,D,E,F) = 7+ drop_slice(G,H,I,J,K):2+ take_slice(L,M,N,O,P):2
     [L>=0,G>=0,G+L=D,G+1=C,P=0,O=1,N=0,M=1,K=0,J=1,I=0,H=1,F=0,E=1,B=0,A=1] 
* CE 239: slice(A,B,C,D,E,F) = 7+ drop_slice(G,A,B,H,I):3+ take_slice(J,K,L,M,N):2
     [B+1>=A,G+1>=A,J>=0,A>=2,G+J=D,G+1=C,N=0,M=1,L=0,K=1,I=0,H=1,F=0,E=1] 
* CE 240: slice(A,B,C,D,E,F) = 7+ drop_slice(G,A,B,H,I):4+ take_slice(J,H,I,K,L):1
     [B+H>=A+I,A>=H+1,I>=1,H>=2,G+H=A,D+H=A,C+H=A+1,L=0,K=1,J=0,F=0,E=1] 
* CE 241: slice(A,B,C,D,E,F) = 7+ drop_slice(G,A,B,E,F):4+ take_slice(H,E,F,E,F):3
     [B+E>=A+F,F+1>=E,H+1>=E,A>=E+1,E>=2,D+E=A+H,E+G=A,C+E=A+1] 
* CE 242: slice(A,B,C,D,E,F) = 7+ drop_slice(G,A,B,H,I):4+ take_slice(J,H,I,E,F):4
     [B+H>=A+I,I>=F+1,F+1>=E,H>=E+1,A>=H+1,E>=2,A+E=D+H+1,G+H=A,C+H=A+1,E=J+1] 

### Cost equations --> "Loop" of slice/6 
* CEs [242] --> Loop 227 
* CEs [241] --> Loop 228 
* CEs [239] --> Loop 229 
* CEs [240] --> Loop 230 
* CEs [237] --> Loop 231 
* CEs [236] --> Loop 232 
* CEs [235] --> Loop 233 
* CEs [238] --> Loop 234 

#### Loops of slice/6 
* Loop 227: slice(A,B,C,D,E,F) [C+F>=D+1,B>=C+F,A>=D+2,D>=C,C>=2,D+2=C+E] 
* Loop 228: slice(A,B,C,D,E,F) [B+1>=C+F,C+F>=A,A>=C+1,D+1>=A,C>=2,A+1=C+E] 
* Loop 229: slice(A,B,C,D,E,F) [D+1>=C,C>=A,B+1>=A,A>=2,F=0,E=1] 
* Loop 230: slice(A,B,C,D,E,F) [B>=C,A>=C+1,C>=2,C=D+1,F=0,E=1] 
* Loop 231: slice(A,B,C,D,E,F) [B>=F+1,F>=D,A>=D+2,D>=1,D+1=E,C=1] 
* Loop 232: slice(A,B,C,D,A,B) [D+1>=A,B+1>=A,A>=2,C=1] 
* Loop 233: slice(A,B,C,D,E,F) [B>=1,A>=2,F=0,E=1,D=0,C=1] 
* Loop 234: slice(A,B,C,D,E,F) [D+1>=C,C>=1,F=0,E=1,B=0,A=1] 

### Ranking functions of CR slice(A,B,C,D,E,F) 

#### Partial ranking functions of CR slice(A,B,C,D,E,F) 


### Resulting Chains:slice(A,B,C,D,E,F) 
* [234]
* [233]
* [232]
* [231]
* [230]
* [229]
* [228]
* [227]


### Merging Chains  slice/6 into  External patterns of execution 
* [[234]] --> 1 
* [[233]] --> 2 
* [[232]] --> 3 
* [[231]] --> 4 
* [[230]] --> 5 
* [[229]] --> 6 
* [[228]] --> 7 
* [[227]] --> 8 


Computing Bounds
=====================================

#### Simplifying cost structure of CE 96 

#### Computing cost of phase [96] 

#### Simplifying cost structure of CE 94 

#### Cost of loops [96] 

 * loop 96:at(A,B,C,D,E) -> [at(A',B',C',D',E')] 
9
##### Pending set at(A,B,C,D,E)
* Psum in Loop 96: [it(96)=<1]

###### Computing sum for it(96)=<1  in Loop 96 
   - Applying inductive sum strategy 
     - head Candidate: B-1 
     - head Candidate: A 
     - head Candidate: C 
     - head Candidate: A 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: C 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B-1 
     - tail Candidate: A 
     - tail Candidate: C 
     - tail Candidate: A 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(96)=<B-1,it(96)=<A,it(96)=<C,it(96)=<A,it(96)=<B-1,it(96)=<C,it(96)=<B-B',it(96)=<A-A',it(96)=<C-C',it(96)=<A-A',it(96)=<B-B',it(96)=<C-C'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [96] 

#### Simplifying cost structure of phase [96] 

#### Cost of phase [96]:at(A,B,C,D,E) -> [at(A',B',C',D',E')] 
9*it(96)+0
  Such that:it(96) =< A
it(96) =< A-A'
it(96) =< B
it(96) =< B-B'
it(96) =< C
it(96) =< C-C'

#### Simplifying cost structure of chain [[96],95] 

#### Simplifying cost structure of CE 95 

#### Found solution for phase  [96] in the cache 

#### Cost of phase [96]:at(A,B,C,D,E) -> [at(A',B',C',D',E')] 
9*it(96)+0
  Such that:it(96) =< A
it(96) =< A-A'
it(96) =< B
it(96) =< B-B'
it(96) =< C
it(96) =< C-C'

#### Simplifying cost structure of chain [[96],94] 

#### Cost of chains of at(A,B,C,D,E):
* Chain [[96],95]: 9*it(96)+7
  Such that:it(96) =< A

  with precondition: [D=1,A>=1,E>=1,B>=A+2,C>=A+E] 

* Chain [[96],94]: 9*it(96)+3
  Such that:it(96) =< B

  with precondition: [D=1,E=0,B>=2,A+1>=B,C+1>=B] 

* Chain [95]: 7
  with precondition: [A=0,D=1,B>=2,E>=1,C>=E] 

* Chain [94]: 3
  with precondition: [B=1,C=0,D=1,E=0,A>=0] 


#### Simplifying cost structure of CE 97 

#### Computing cost of phase [97,98] 

#### Simplifying cost structure of CE 99 

#### Simplifying cost structure of CE 100 

#### Cost of loops [97,98] 

 * loop 97:compress(A,B,C,D) -> [compress(A',B',C',D')] 
10
 * loop 98:compress(A,B,C,D) -> [compress(A',B',C',D')] 
11
##### Pending set compress(A,B,C,D)
* Psum in Loop 97: [it(97)=<1]
* Psum in Loop 98: [it(98)=<1]

###### Computing sum for it(97)=<1  in Loop 97 
   - Applying inductive sum strategy 
     - head Candidate: A-2 
       - Loop 98 is collaborative and bounds [it(98)] 
     - head Candidate: A-2 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-2 
       - Loop 98 is collaborative and bounds [it(98)] 
     - tail Candidate: A-2 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(97)+it(98)=<A-2,it(97)+it(98)=<A-2,it(97)+it(98)=<A-A',it(97)+it(98)=<A-A'] 

##### Pending set A
* Psum in Loop 98: [it(98)=<1]

###### Computing sum for it(98)=<1  in Loop 98 
   - Applying inductive sum strategy 
     - head Candidate: A-2 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A-2 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: B 
       - Loop 97 is collaborative
     - tail Candidate: A-2 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-2 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B 
       - Loop 97 is collaborative
 * Adding constraints: [it(97)+it(98)=<A-2,it(97)+it(98)=<A-2,it(98)=<B,it(97)+it(98)=<A-A',it(97)+it(98)=<A-A',it(98)=<B-B'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [97,98] 

#### Simplifying cost structure of phase [97,98] 

#### Cost of phase [97,98]:compress(A,B,C,D) -> [compress(A',B',C',D')] 
10*it(97)+11*it(98)+0
  Such that:it(98) =< B
it(98) =< B-B'
aux(1) =< A
aux(2) =< A-A'
it(97) =< aux(1)
it(98) =< aux(1)
it(97) =< aux(2)
it(98) =< aux(2)

#### Simplifying cost structure of chain [[97,98],99] 
 * Joined equivalent variables [aux(3),aux(1),aux(2)] into aux(3)

#### Simplifying cost structure of CE 98 

#### Cost of chains of compress(A,B,C,D):
* Chain [[97,98],99]: 10*it(97)+11*it(98)+7
  Such that:it(98) =< B
aux(3) =< A
it(97) =< aux(3)
it(98) =< aux(3)

  with precondition: [A>=3,C>=2,A>=C,B+2>=C,D+2>=C] 

* Chain [100]: 3
  with precondition: [A=1,C=1,B>=0,D>=0] 

* Chain [99]: 7
  with precondition: [A=2,C=2,B>=0,D>=0] 


#### Simplifying cost structure of CE 101 

#### Computing cost of phase [101] 

#### Simplifying cost structure of CE 102 

#### Cost of loops [101] 

 * loop 101:concat(A,B,C,D,E,F,G,H,I,J,K,L) -> [concat(A',B',C',D',E',F',G',H',I',J',K',L')] 
5
##### Pending set concat(A,B,C,D,E,F,G,H,I,J,K,L)
* Psum in Loop 101: [it(101)=<1]

###### Computing sum for it(101)=<1  in Loop 101 
   - Applying inductive sum strategy 
     - head Candidate: C-1 
     - head Candidate: D+1 
     - head Candidate: A-1 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: D+1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
     - tail Candidate: D+1 
     - tail Candidate: A-1 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: D+1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(101)=<C-1,it(101)=<D+1,it(101)=<A-1,it(101)=<A-1,it(101)=<C-1,it(101)=<D+1,it(101)=<C-C',it(101)=<D-D',it(101)=<A-A',it(101)=<A-A',it(101)=<C-C',it(101)=<D-D'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [101] 

#### Simplifying cost structure of phase [101] 

#### Cost of phase [101]:concat(A,B,C,D,E,F,G,H,I,J,K,L) -> [concat(A',B',C',D',E',F',G',H',I',J',K',L')] 
5*it(101)+0
  Such that:it(101) =< A
it(101) =< A-A'
it(101) =< C
it(101) =< C-C'
it(101) =< D+1
it(101) =< D-D'

#### Simplifying cost structure of chain [[101],102] 

#### Cost of chains of concat(A,B,C,D,E,F,G,H,I,J,K,L):
* Chain [[101],102]: 5*it(101)+2
  Such that:it(101) =< -E+I

  with precondition: [A=C,L=D+H,A+E=I+1,A+G=K+1,A>=2,B>=0,E>=1,F>=0,G>=1,J>=0,D+1>=A,L>=D,B+F>=J] 

* Chain [102]: 2
  with precondition: [A=1,C=1,D=0,E=I,F=J,G=K,H=L,B>=0,E>=0,F>=0,G>=0,H>=0] 


#### Simplifying cost structure of CE 105 

#### Computing cost of phase [105] 

#### Simplifying cost structure of CE 104 

#### Cost of loops [105] 

 * loop 105:drop_aux(A,B,C,D,E,F) -> [drop_aux(A',B',C',D',E',F')] 
7
##### Pending set drop_aux(A,B,C,D,E,F)
* Psum in Loop 105: [it(105)=<1]

###### Computing sum for it(105)=<1  in Loop 105 
   - Applying inductive sum strategy 
     - head Candidate: D 
     - head Candidate: C-1 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: D 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: D 
     - tail Candidate: C-1 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: D 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(105)=<D,it(105)=<C-1,it(105)=<C-1,it(105)=<D,it(105)=<D-D',it(105)=<C-C',it(105)=<C-C',it(105)=<D-D'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [105] 

#### Simplifying cost structure of phase [105] 

#### Cost of phase [105]:drop_aux(A,B,C,D,E,F) -> [drop_aux(A',B',C',D',E',F')] 
7*it(105)+0
  Such that:it(105) =< C
it(105) =< C-C'
it(105) =< D
it(105) =< D-D'

#### Simplifying cost structure of chain [[105],103] 

#### Computing cost of phase [104] 

#### Simplifying cost structure of CE 103 

#### Cost of loops [104] 

 * loop 104:drop_aux(A,B,C,D,E,F) -> [drop_aux(A',B',C',D',E',F')] 
9
##### Pending set drop_aux(A,B,C,D,E,F)
* Psum in Loop 104: [it(104)=<1]

###### Computing sum for it(104)=<1  in Loop 104 
   - Applying inductive sum strategy 
     - head Candidate: C-1 
     - head Candidate: D 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: D 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
     - tail Candidate: D 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: D 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(104)=<C-1,it(104)=<D,it(104)=<C-1,it(104)=<D,it(104)=<C-C',it(104)=<D-D',it(104)=<C-C',it(104)=<D-D'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [104] 

#### Simplifying cost structure of phase [104] 

#### Cost of phase [104]:drop_aux(A,B,C,D,E,F) -> [drop_aux(A',B',C',D',E',F')] 
9*it(104)+0
  Such that:it(104) =< C
it(104) =< C-C'
it(104) =< D
it(104) =< D-D'

#### Simplifying cost structure of chain [[104],103] 

#### Cost of chains of drop_aux(A,B,C,D,E,F):
* Chain [[105],103]: 7*it(105)+3
  Such that:it(105) =< C

  with precondition: [A=1,B=1,E=1,F=0,C>=2,D+1>=C] 

* Chain [[104],103]: 9*it(104)+3
  Such that:it(104) =< E

  with precondition: [F=D,C=E,A>=0,C>=2,B>=A+1,F+1>=C] 

* Chain [103]: 3
  with precondition: [C=1,D=0,E=1,F=0,A>=0,B>=1] 


#### Simplifying cost structure of CE 107 
 * Renamed intermediate variables: 
[ (eq(108,1),it(104))>>s(1)]

#### Simplifying cost structure of CE 108 
 * Renamed intermediate variables: 
[ (eq(106,1),it(105))>>s(2)]

#### Simplifying cost structure of CE 106 

#### Cost of chains of drop(A,B,C,D,E):
* Chain [108]: 5
  with precondition: [A=1,B=0,D=1,E=0,C>=0] 

* Chain [107]: 9*s(1)+5
  Such that:s(1) =< A

  with precondition: [C=0,A=D,B=E,A>=2,B+1>=A] 

* Chain [106]: 7*s(2)+5
  Such that:s(2) =< A

  with precondition: [C=1,D=1,E=0,A>=2,B+1>=A] 


#### Simplifying cost structure of CE 109 

#### Computing cost of phase [109] 

#### Simplifying cost structure of CE 110 

#### Cost of loops [109] 

 * loop 109:duplicate(A,B,C,D) -> [duplicate(A',B',C',D')] 
6
##### Pending set duplicate(A,B,C,D)
* Psum in Loop 109: [it(109)=<1]

###### Computing sum for it(109)=<1  in Loop 109 
   - Applying inductive sum strategy 
     - head Candidate: A-1 
     - head Candidate: B+1 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: B+1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
     - tail Candidate: B+1 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B+1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(109)=<A-1,it(109)=<B+1,it(109)=<A-1,it(109)=<B+1,it(109)=<A-A',it(109)=<B-B',it(109)=<A-A',it(109)=<B-B'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [109] 

#### Simplifying cost structure of phase [109] 

#### Cost of phase [109]:duplicate(A,B,C,D) -> [duplicate(A',B',C',D')] 
6*it(109)+0
  Such that:it(109) =< A
it(109) =< A-A'
it(109) =< B+1
it(109) =< B-B'

#### Simplifying cost structure of chain [[109],110] 

#### Cost of chains of duplicate(A,B,C,D):
* Chain [[109],110]: 6*it(109)+3
  Such that:it(109) =< C/2

  with precondition: [D=2*B,2*A=C+1,A>=2,D+2>=2*A] 

* Chain [110]: 3
  with precondition: [A=1,B=0,C=1,D=0] 


#### Simplifying cost structure of CE 111 

#### Computing cost of phase [111,112] 

#### Simplifying cost structure of CE 113 

#### Simplifying cost structure of CE 114 

#### Cost of loops [111,112] 

 * loop 111:encode_aux(A,B,C,D,E,F,G,H,I) -> [encode_aux(A',B',C',D',E',F',G',H',I')] 
11
 * loop 112:encode_aux(A,B,C,D,E,F,G,H,I) -> [encode_aux(A',B',C',D',E',F',G',H',I')] 
14
##### Pending set encode_aux(A,B,C,D,E,F,G,H,I)
* Psum in Loop 111: [it(111)=<1]
* Psum in Loop 112: [it(112)=<1]

###### Computing sum for it(111)=<1  in Loop 111 
   - Applying inductive sum strategy 
     - head Candidate: E-2 
       - Loop 112 is collaborative and bounds [it(112)] 
     - head Candidate: E-2 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: E-2 
       - Loop 112 is collaborative and bounds [it(112)] 
     - tail Candidate: E-2 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(111)+it(112)=<E-2,it(111)+it(112)=<E-2,it(111)+it(112)=<E-E',it(111)+it(112)=<E-E'] 

##### Pending set A
* Psum in Loop 112: [it(112)=<1]

###### Computing sum for it(112)=<1  in Loop 112 
   - Applying inductive sum strategy 
     - head Candidate: E-2 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: E-2 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: F 
       - Loop 111 is collaborative
     - tail Candidate: E-2 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: E-2 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: F 
       - Loop 111 is collaborative
 * Adding constraints: [it(111)+it(112)=<E-2,it(111)+it(112)=<E-2,it(112)=<F,it(111)+it(112)=<E-E',it(111)+it(112)=<E-E',it(112)=<F-F'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [111,112] 

#### Simplifying cost structure of phase [111,112] 

#### Cost of phase [111,112]:encode_aux(A,B,C,D,E,F,G,H,I) -> [encode_aux(A',B',C',D',E',F',G',H',I')] 
11*it(111)+14*it(112)+0
  Such that:it(112) =< F
it(112) =< F-F'
aux(4) =< E
aux(5) =< E-E'
it(111) =< aux(4)
it(112) =< aux(4)
it(111) =< aux(5)
it(112) =< aux(5)

#### Simplifying cost structure of chain [[111,112],113] 
 * Joined equivalent variables [aux(6),aux(4),aux(5)] into aux(6)

#### Simplifying cost structure of CE 112 

#### Cost of chains of encode_aux(A,B,C,D,E,F,G,H,I):
* Chain [[111,112],113]: 11*it(111)+14*it(112)+9
  Such that:it(112) =< F
aux(6) =< E
it(111) =< aux(6)
it(112) =< aux(6)

  with precondition: [C=B+1,G+1=H,A>=0,C>=1,D>=0,E>=3,G>=C,C+E>=G+2,A+D+E+F>=I+1,C+I+1>=A+D+E+G] 

* Chain [114]: 3
  with precondition: [A=0,B=0,C=1,E=1,G=0,H=1,D>=0,F>=0,I>=0] 

* Chain [113]: 9
  with precondition: [E=2,C=B+1,C=G,C+1=H,A>=0,C>=1,D>=0,I>=A+D+1,A+D+F+1>=I] 


#### Simplifying cost structure of CE 115 

#### Simplifying cost structure of CE 116 
 * Renamed intermediate variables: 
[ (eq(117,1),it(112))>>s(3), (eq(117,1),aux(6))>>s(4), (eq(117,1),it(111))>>s(5)]

#### Simplifying cost structure of CE 117 

#### Cost of chains of encode(A,B,C,D,E):
* Chain [117]: 6
  with precondition: [A=1,C=0,D=1,B>=0,E>=0] 

* Chain [116]: 12
  with precondition: [A=2,C=1,D=2,B>=0,E>=1] 

* Chain [115]: 14*s(3)+11*s(5)+12
  Such that:s(4) =< A
s(3) =< B
s(5) =< s(4)
s(3) =< s(4)

  with precondition: [C+1=D,A>=3,C>=1,A>=C+1,B+1>=C,E+2>=A+C] 


#### Simplifying cost structure of CE 119 

#### Simplifying cost structure of CE 118 

#### Cost of chains of case_10(A,B,C,D,E):
* Chain [119]: 2
  with precondition: [A=1,C=1,E=1,B>=0,D>=0] 

* Chain [118]: 3
  with precondition: [A=1,E=0,B>=0,C>=2,D>=0] 


#### Simplifying cost structure of CE 121 

#### Simplifying cost structure of CE 120 

#### Cost of chains of and_op(A,B,C):
* Chain [121]: 0
  with precondition: [A=0,C=0,B>=0] 

* Chain [120]: 0
  with precondition: [A=1,C=B,C>=0] 


#### Simplifying cost structure of CE 124 

#### Simplifying cost structure of CE 123 

#### Simplifying cost structure of CE 122 

#### Cost of chains of eq(A,B,C):
* Chain [124]: 0
  with precondition: [C=0,A>=0,B>=A+1] 

* Chain [123]: 0
  with precondition: [C=0,B>=0,A>=B+1] 

* Chain [122]: 0
  with precondition: [C=1,A=B,A>=0] 


#### Simplifying cost structure of CE 126 

#### Computing cost of phase [125,126,127] 

#### Simplifying cost structure of CE 130 

#### Simplifying cost structure of CE 129 

#### Simplifying cost structure of CE 128 

#### Cost of loops [125,126,127] 

 * loop 125:eq_lists(A,B,C,D,E) -> [eq_lists(A',B',C',D',E')] 
9
 * loop 126:eq_lists(A,B,C,D,E) -> [eq_lists(A',B',C',D',E')] 
9
 * loop 127:eq_lists(A,B,C,D,E) -> [eq_lists(A',B',C',D',E')] 
9
##### Pending set eq_lists(A,B,C,D,E)
* Psum in Loop 125: [it(125)=<1]
* Psum in Loop 126: [it(126)=<1]
* Psum in Loop 127: [it(127)=<1]

###### Computing sum for it(125)=<1  in Loop 125 
   - Applying inductive sum strategy 
     - head Candidate: C-1 
       - Loop 126 is collaborative and bounds [it(126)] 
       - Loop 127 is collaborative and bounds [it(127)] 
     - head Candidate: A-1 
       - Loop 126 is collaborative and bounds [it(126)] 
       - Loop 127 is collaborative and bounds [it(127)] 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - Loop 126 is collaborative and bounds [it(126)] 
       - Loop 127 is collaborative and bounds [it(127)] 
     - tail Candidate: A-1 
       - Loop 126 is collaborative and bounds [it(126)] 
       - Loop 127 is collaborative and bounds [it(127)] 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(125)+it(126)+it(127)=<C-1,it(125)+it(126)+it(127)=<A-1,it(125)+it(126)+it(127)=<A-1,it(125)+it(126)+it(127)=<C-1,it(125)+it(126)+it(127)=<C-C',it(125)+it(126)+it(127)=<A-A',it(125)+it(126)+it(127)=<A-A',it(125)+it(126)+it(127)=<C-C'] 

##### Pending set A
* Psum in Loop 126: [it(126)=<1]
* Psum in Loop 127: [it(127)=<1]

###### Computing sum for it(126)=<1  in Loop 126 
   - Applying inductive sum strategy 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: B 
       - Loop 125 is collaborative
       - Loop 127 is collaborative
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B 
       - Loop 125 is collaborative
       - Loop 127 is collaborative
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(125)+it(126)+it(127)=<C-1,it(125)+it(126)+it(127)=<A-1,it(125)+it(126)+it(127)=<A-1,it(126)=<B,it(125)+it(126)+it(127)=<C-1,it(125)+it(126)+it(127)=<C-C',it(125)+it(126)+it(127)=<A-A',it(125)+it(126)+it(127)=<A-A',it(126)=<B-B',it(125)+it(126)+it(127)=<C-C'] 

##### Pending set A
* Psum in Loop 127: [it(127)=<1]

###### Computing sum for it(127)=<1  in Loop 127 
   - Applying inductive sum strategy 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: D+1 
       - Loop 125 is collaborative
       - Loop 126 is collaborative
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: D+1 
       - Loop 125 is collaborative
       - Loop 126 is collaborative
 * Adding constraints: [it(125)+it(126)+it(127)=<C-1,it(125)+it(126)+it(127)=<A-1,it(125)+it(126)+it(127)=<A-1,it(125)+it(126)+it(127)=<C-1,it(127)=<D+1,it(125)+it(126)+it(127)=<C-C',it(125)+it(126)+it(127)=<A-A',it(125)+it(126)+it(127)=<A-A',it(125)+it(126)+it(127)=<C-C',it(127)=<D-D'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [125,126,127] 

#### Simplifying cost structure of phase [125,126,127] 

#### Cost of phase [125,126,127]:eq_lists(A,B,C,D,E) -> [eq_lists(A',B',C',D',E')] 
9*it(125)+9*it(126)+9*it(127)+0
  Such that:it(126) =< B
it(126) =< B-B'
it(127) =< D+1
it(127) =< D-D'
aux(7) =< A
aux(8) =< A-A'
aux(9) =< C
aux(10) =< C-C'
it(125) =< aux(7)
it(126) =< aux(7)
it(127) =< aux(7)
it(125) =< aux(8)
it(126) =< aux(8)
it(127) =< aux(8)
it(125) =< aux(9)
it(126) =< aux(9)
it(127) =< aux(9)
it(125) =< aux(10)
it(126) =< aux(10)
it(127) =< aux(10)

#### Simplifying cost structure of chain [[125,126,127],130] 
 * Joined equivalent variables [aux(11),aux(7),aux(8),aux(9),aux(10)] into aux(11)

#### Simplifying cost structure of CE 127 

#### Found solution for phase  [125,126,127] in the cache 

#### Cost of phase [125,126,127]:eq_lists(A,B,C,D,E) -> [eq_lists(A',B',C',D',E')] 
9*it(125)+9*it(126)+9*it(127)+0
  Such that:it(126) =< B
it(126) =< B-B'
it(127) =< D+1
it(127) =< D-D'
aux(7) =< A
aux(8) =< A-A'
aux(9) =< C
aux(10) =< C-C'
it(125) =< aux(7)
it(126) =< aux(7)
it(127) =< aux(7)
it(125) =< aux(8)
it(126) =< aux(8)
it(127) =< aux(8)
it(125) =< aux(9)
it(126) =< aux(9)
it(127) =< aux(9)
it(125) =< aux(10)
it(126) =< aux(10)
it(127) =< aux(10)

#### Simplifying cost structure of chain [[125,126,127],129] 
 * Joined equivalent variables [aux(12),aux(7),aux(8),aux(10)] into aux(12)

#### Simplifying cost structure of CE 125 

#### Found solution for phase  [125,126,127] in the cache 

#### Cost of phase [125,126,127]:eq_lists(A,B,C,D,E) -> [eq_lists(A',B',C',D',E')] 
9*it(125)+9*it(126)+9*it(127)+0
  Such that:it(126) =< B
it(126) =< B-B'
it(127) =< D+1
it(127) =< D-D'
aux(7) =< A
aux(8) =< A-A'
aux(9) =< C
aux(10) =< C-C'
it(125) =< aux(7)
it(126) =< aux(7)
it(127) =< aux(7)
it(125) =< aux(8)
it(126) =< aux(8)
it(127) =< aux(8)
it(125) =< aux(9)
it(126) =< aux(9)
it(127) =< aux(9)
it(125) =< aux(10)
it(126) =< aux(10)
it(127) =< aux(10)

#### Simplifying cost structure of chain [[125,126,127],128] 
 * Joined equivalent variables [aux(13),aux(8),aux(9),aux(10)] into aux(13)

#### Cost of chains of eq_lists(A,B,C,D,E):
* Chain [[125,126,127],130]: 9*it(125)+9*it(126)+9*it(127)+5
  Such that:it(126) =< B
it(127) =< D
aux(11) =< A
it(125) =< aux(11)
it(126) =< aux(11)
it(127) =< aux(11)

  with precondition: [A=C,1>=E,A>=2,B>=0,D>=0,E>=0,B+D+E>=1] 

* Chain [[125,126,127],129]: 9*it(125)+9*it(126)+9*it(127)+6
  Such that:it(126) =< B
aux(9) =< C
it(127) =< D
aux(12) =< A
it(125) =< aux(12)
it(126) =< aux(12)
it(127) =< aux(12)
it(125) =< aux(9)
it(126) =< aux(9)
it(127) =< aux(9)

  with precondition: [E=0,A>=2,B>=0,D>=0,C>=A+1] 

* Chain [[125,126,127],128]: 9*it(125)+9*it(126)+9*it(127)+6
  Such that:aux(7) =< A
it(126) =< B
it(127) =< D
aux(13) =< C
it(125) =< aux(7)
it(126) =< aux(7)
it(127) =< aux(7)
it(125) =< aux(13)
it(126) =< aux(13)
it(127) =< aux(13)

  with precondition: [E=0,B>=0,C>=2,D>=0,A>=C+1] 

* Chain [130]: 5
  with precondition: [A=1,C=1,E=1,B>=0,D>=0] 

* Chain [129]: 6
  with precondition: [A=1,E=0,B>=0,C>=2,D>=0] 

* Chain [128]: 6
  with precondition: [C=1,E=0,A>=2,B>=0,D>=0] 


#### Simplifying cost structure of CE 133 

#### Computing cost of phase [133] 

#### Simplifying cost structure of CE 131 

#### Cost of loops [133] 

 * loop 133:insertAt(A,B,C,D,E,F) -> [insertAt(A',B',C',D',E',F')] 
10
##### Pending set insertAt(A,B,C,D,E,F)
* Psum in Loop 133: [it(133)=<1]

###### Computing sum for it(133)=<1  in Loop 133 
   - Applying inductive sum strategy 
     - head Candidate: C-1 
     - head Candidate: B-1 
     - head Candidate: D 
     - head Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: D 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
     - tail Candidate: B-1 
     - tail Candidate: D 
     - tail Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: D 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(133)=<C-1,it(133)=<B-1,it(133)=<D,it(133)=<B-1,it(133)=<C-1,it(133)=<D,it(133)=<C-C',it(133)=<B-B',it(133)=<D-D',it(133)=<B-B',it(133)=<C-C',it(133)=<D-D'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [133] 

#### Simplifying cost structure of phase [133] 

#### Cost of phase [133]:insertAt(A,B,C,D,E,F) -> [insertAt(A',B',C',D',E',F')] 
10*it(133)+0
  Such that:it(133) =< B
it(133) =< B-B'
it(133) =< C
it(133) =< C-C'
it(133) =< D
it(133) =< D-D'

#### Simplifying cost structure of chain [[133],132] 

#### Simplifying cost structure of CE 132 

#### Found solution for phase  [133] in the cache 

#### Cost of phase [133]:insertAt(A,B,C,D,E,F) -> [insertAt(A',B',C',D',E',F')] 
10*it(133)+0
  Such that:it(133) =< B
it(133) =< B-B'
it(133) =< C
it(133) =< C-C'
it(133) =< D
it(133) =< D-D'

#### Simplifying cost structure of chain [[133],131] 

#### Cost of chains of insertAt(A,B,C,D,E,F):
* Chain [[133],132]: 10*it(133)+8
  Such that:it(133) =< B

  with precondition: [C+1=E,A+D=F,A>=1,B>=2,C>=B+1,F>=A+B] 

* Chain [[133],131]: 10*it(133)+3
  Such that:it(133) =< E

  with precondition: [F=D,C=E,A>=0,C>=2,B>=C,F+1>=C] 

* Chain [132]: 8
  with precondition: [B=1,C+1=E,A+D=F,A>=1,C>=2,D>=1] 

* Chain [131]: 3
  with precondition: [C=1,D=0,E=1,F=0,A>=0,B>=0] 


#### Simplifying cost structure of CE 134 

#### Computing cost of phase [134] 

#### Simplifying cost structure of CE 135 

#### Cost of loops [134] 

 * loop 134:aux_rev(A,B,C,D,E,F,G,H,I,J,K,L) -> [aux_rev(A',B',C',D',E',F',G',H',I',J',K',L')] 
5
##### Pending set aux_rev(A,B,C,D,E,F,G,H,I,J,K,L)
* Psum in Loop 134: [it(134)=<1]

###### Computing sum for it(134)=<1  in Loop 134 
   - Applying inductive sum strategy 
     - head Candidate: H+1 
     - head Candidate: -A+D+H+2 
     - head Candidate: -C+D+H+2 
     - head Candidate: G-1 
     - head Candidate: E-1 
     - head Candidate: E-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: G-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: H+1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: -A+D+H+2 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: -C+D+H+2 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: H+1 
     - tail Candidate: -A+D+H+2 
     - tail Candidate: -C+D+H+2 
     - tail Candidate: G-1 
     - tail Candidate: E-1 
     - tail Candidate: E-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: G-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: H+1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: -A+D+H+2 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: -C+D+H+2 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(134)=<H+1,it(134)=< -A+D+H+2,it(134)=< -C+D+H+2,it(134)=<G-1,it(134)=<E-1,it(134)=<E-1,it(134)=<G-1,it(134)=<H+1,it(134)=< -A+D+H+2,it(134)=< -C+D+H+2,it(134)=<H-H',it(134)=< -A+D+H+A'-D'-H',it(134)=< -C+D+H+C'-D'-H',it(134)=<G-G',it(134)=<E-E',it(134)=<E-E',it(134)=<G-G',it(134)=<H-H',it(134)=< -A+D+H+A'-D'-H',it(134)=< -C+D+H+C'-D'-H'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [134] 

#### Simplifying cost structure of phase [134] 

#### Cost of phase [134]:aux_rev(A,B,C,D,E,F,G,H,I,J,K,L) -> [aux_rev(A',B',C',D',E',F',G',H',I',J',K',L')] 
5*it(134)+0
  Such that:it(134) =< -A+D+H+2
it(134) =< -A+D+H+A'-D'-H'
it(134) =< -C+D+H+2
it(134) =< -C+D+H+C'-D'-H'
it(134) =< E
it(134) =< E-E'
it(134) =< G
it(134) =< G-G'
it(134) =< H+1
it(134) =< H-H'

#### Simplifying cost structure of chain [[134],135] 

#### Cost of chains of aux_rev(A,B,C,D,E,F,G,H,I,J,K,L):
* Chain [[134],135]: 5*it(134)+2
  Such that:it(134) =< -A+K

  with precondition: [A=C,E=G,A+E=I+1,A+E=K+1,D+H=L,A>=1,B>=0,E>=2,F>=0,J>=0,D+1>=A,H+1>=E,B+F>=J] 

* Chain [135]: 2
  with precondition: [E=1,G=1,H=0,C=A,J=B,C=I,C=K,D=L,C>=1,F>=0,J>=0,D+1>=C] 


#### Simplifying cost structure of CE 136 
 * Renamed intermediate variables: 
[ (eq(137,1),it(134))>>s(6)]

#### Simplifying cost structure of CE 137 

#### Cost of chains of rev(A,B,C,D,E,F,G,H):
* Chain [137]: 4
  with precondition: [A=1,C=1,D=0,E=1,G=1,H=0,B>=0,F>=0] 

* Chain [136]: 5*s(6)+4
  Such that:s(6) =< C

  with precondition: [A=C,A=E,A=G,D=H,A>=2,B>=0,F>=0,D+1>=A] 


#### Simplifying cost structure of CE 138 
 * Renamed intermediate variables: 
[ (eq(139,1),s(6))>>s(7)]
 * Renamed intermediate variables: 
[ (eq(139,2),it(126))>>s(8), (eq(139,2),it(127))>>s(9), (eq(139,2),aux(11))>>s(10), (eq(139,2),it(125))>>s(11)]

#### Simplifying cost structure of CE 139 
 * Joined equivalent variables [aux(14),s(10)] into aux(14)
 * Joined equivalent variables [s(9),s(11)] into s(9)
 * Joined equivalent variables [s(7),s(9)] into s(7)

#### Cost of chains of is_palindrome(A,B,C):
* Chain [139]: 11
  with precondition: [A=1,C=1,B>=0] 

* Chain [138]: 23*s(7)+9*s(8)+11
  Such that:s(8) =< B
aux(14) =< A
s(7) =< aux(14)
s(8) =< aux(14)

  with precondition: [1>=C,A>=2,B>=0,C>=0] 


#### Simplifying cost structure of CE 141 

#### Computing cost of phase [142] 

#### Simplifying cost structure of CE 140 

#### Cost of loops [142] 

 * loop 142:last(A,B,C,D) -> [last(A',B',C',D')] 
7
##### Pending set last(A,B,C,D)
* Psum in Loop 142: [it(142)=<1]

###### Computing sum for it(142)=<1  in Loop 142 
   - Applying inductive sum strategy 
     - head Candidate: A-2 
     - head Candidate: B-2 
     - head Candidate: A-2 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: B-2 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-2 
     - tail Candidate: B-2 
     - tail Candidate: A-2 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B-2 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(142)=<A-2,it(142)=<B-2,it(142)=<A-2,it(142)=<B-2,it(142)=<A-A',it(142)=<B-B',it(142)=<A-A',it(142)=<B-B'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [142] 

#### Simplifying cost structure of phase [142] 

#### Cost of phase [142]:last(A,B,C,D) -> [last(A',B',C',D')] 
7*it(142)+0
  Such that:it(142) =< A
it(142) =< A-A'
it(142) =< B
it(142) =< B-B'

#### Simplifying cost structure of chain [[142],140] 

#### Simplifying cost structure of CE 142 

#### Cost of chains of last(A,B,C,D):
* Chain [[142],140]: 7*it(142)+6
  Such that:it(142) =< A

  with precondition: [C=1,A>=3,D>=2,B+2>=A+D] 

* Chain [141]: 3
  with precondition: [A=1,B=0,C=1,D=0] 

* Chain [140]: 6
  with precondition: [A=2,C=1,B=D,B>=1] 


#### Simplifying cost structure of CE 143 

#### Computing cost of phase [143] 

#### Simplifying cost structure of CE 146 

#### Cost of loops [143] 

 * loop 143:last_two(A,B,C,D,E) -> [last_two(A',B',C',D',E')] 
10
##### Pending set last_two(A,B,C,D,E)
* Psum in Loop 143: [it(143)=<1]

###### Computing sum for it(143)=<1  in Loop 143 
   - Applying inductive sum strategy 
     - head Candidate: A-3 
     - head Candidate: B-3 
     - head Candidate: A-3 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: B-3 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-3 
     - tail Candidate: B-3 
     - tail Candidate: A-3 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B-3 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(143)=<A-3,it(143)=<B-3,it(143)=<A-3,it(143)=<B-3,it(143)=<A-A',it(143)=<B-B',it(143)=<A-A',it(143)=<B-B'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [143] 

#### Simplifying cost structure of phase [143] 

#### Cost of phase [143]:last_two(A,B,C,D,E) -> [last_two(A',B',C',D',E')] 
10*it(143)+0
  Such that:it(143) =< A
it(143) =< A-A'
it(143) =< B
it(143) =< B-B'

#### Simplifying cost structure of chain [[143],144] 

#### Simplifying cost structure of CE 145 

#### Simplifying cost structure of CE 144 

#### Cost of chains of last_two(A,B,C,D,E):
* Chain [[143],144]: 10*it(143)+10
  Such that:it(143) =< A

  with precondition: [C=1,D=1,A>=4,E>=3,B+3>=A+E] 

* Chain [146]: 3
  with precondition: [A=1,B=0,C=0,D=1,E=0] 

* Chain [145]: 6
  with precondition: [A=2,C=0,D=1,E=0,B>=1] 

* Chain [144]: 10
  with precondition: [A=3,C=1,D=1,B=E,B>=2] 


#### Simplifying cost structure of CE 147 

#### Computing cost of phase [147] 

#### Simplifying cost structure of CE 148 

#### Cost of loops [147] 

 * loop 147:aux_length(A,B,C,D,E,F,G,H) -> [aux_length(A',B',C',D',E',F',G',H')] 
6
##### Pending set aux_length(A,B,C,D,E,F,G,H)
* Psum in Loop 147: [it(147)=<1]

###### Computing sum for it(147)=<1  in Loop 147 
   - Applying inductive sum strategy 
     - head Candidate: C-1 
     - head Candidate: A-1 
     - head Candidate: D+1 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: D+1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
     - tail Candidate: A-1 
     - tail Candidate: D+1 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: D+1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(147)=<C-1,it(147)=<A-1,it(147)=<D+1,it(147)=<A-1,it(147)=<C-1,it(147)=<D+1,it(147)=<C-C',it(147)=<A-A',it(147)=<D-D',it(147)=<A-A',it(147)=<C-C',it(147)=<D-D'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [147] 

#### Simplifying cost structure of phase [147] 

#### Cost of phase [147]:aux_length(A,B,C,D,E,F,G,H) -> [aux_length(A',B',C',D',E',F',G',H')] 
6*it(147)+0
  Such that:it(147) =< A
it(147) =< A-A'
it(147) =< C
it(147) =< C-C'
it(147) =< D+1
it(147) =< D-D'

#### Simplifying cost structure of chain [[147],148] 

#### Cost of chains of aux_length(A,B,C,D,E,F,G,H):
* Chain [[147],148]: 6*it(147)+2
  Such that:it(147) =< A

  with precondition: [A=C,E=F,A+E=G+1,A+E=H+1,A>=2,B>=0,E>=0,D+1>=A] 

* Chain [148]: 2
  with precondition: [A=1,C=1,D=0,F=E,F=G,F=H,B>=0,F>=0] 


#### Simplifying cost structure of CE 149 
 * Renamed intermediate variables: 
[ (eq(150,1),it(147))>>s(12)]

#### Simplifying cost structure of CE 150 

#### Cost of chains of lengthL(A,B,C,D,E,F):
* Chain [150]: 4
  with precondition: [A=1,C=1,D=0,E=0,F=0,B>=0] 

* Chain [149]: 6*s(12)+4
  Such that:s(12) =< C

  with precondition: [A=C,A=E+1,A=F+1,A>=2,B>=0,D+1>=A] 


#### Simplifying cost structure of CE 151 

#### Computing cost of phase [151] 

#### Simplifying cost structure of CE 152 

#### Cost of loops [151] 

 * loop 151:minusminus_aux(A,B,C,D) -> [minusminus_aux(A',B',C',D')] 
6
##### Pending set minusminus_aux(A,B,C,D)
* Psum in Loop 151: [it(151)=<1]

###### Computing sum for it(151)=<1  in Loop 151 
   - Applying inductive sum strategy 
     - head Candidate: -A+B+1 
     - head Candidate: -A+B+1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: -A+B+1 
     - tail Candidate: -A+B+1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(151)=< -A+B+1,it(151)=< -A+B+1,it(151)=< -A+B+A'-B',it(151)=< -A+B+A'-B'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [151] 

#### Simplifying cost structure of phase [151] 

#### Cost of phase [151]:minusminus_aux(A,B,C,D) -> [minusminus_aux(A',B',C',D')] 
6*it(151)+0
  Such that:it(151) =< -A+B+1
it(151) =< -A+B+A'-B'

#### Simplifying cost structure of chain [[151],152] 

#### Cost of chains of minusminus_aux(A,B,C,D):
* Chain [[151],152]: 6*it(151)+3
  Such that:it(151) =< -A+B+1

  with precondition: [A+C=B+2,A>=0,B>=A,D>=B] 

 * Renamed intermediate variables: 
[ (eq(154,1),it(151))>>s(13)]

#### Simplifying cost structure of CE 154 
 * Renamed intermediate variables: 
[ (eq(153,1),it(151))>>s(14)]
 * Renamed intermediate variables: 
[ (eq(153,2),s(6))>>s(15)]

#### Simplifying cost structure of CE 153 

#### Cost of chains of case_41(A,B,C,D):
* Chain [154]: 6*s(13)+5
  Such that:s(13) =< -A+B+1

  with precondition: [A+C=B+2,A>=0,B>=A,D>=B] 

* Chain [153]: 6*s(14)+5*s(15)+10
  Such that:s(14) =< A-B+1
s(15) =< A-B+2

  with precondition: [A+2=B+C,B>=0,D>=0,A>=B+1] 

 * Renamed intermediate variables: 
[ (eq(156,1),s(13))>>s(16)]

#### Simplifying cost structure of CE 156 
 * Renamed intermediate variables: 
[ (eq(155,1),s(14))>>s(17), (eq(155,1),s(15))>>s(18)]

#### Simplifying cost structure of CE 155 

#### Cost of chains of minusminus(A,B,C,D):
* Chain [156]: 6*s(16)+6
  Such that:s(16) =< -A+B+1

  with precondition: [B+2=A+C,A>=0,B>=A,D>=B] 

* Chain [155]: 6*s(17)+5*s(18)+11
  Such that:s(17) =< A-B+1
s(18) =< A-B+2

  with precondition: [B+C=A+2,B>=0,D>=0,A>=B+1] 


#### Simplifying cost structure of CE 158 

#### Simplifying cost structure of CE 157 

#### Cost of chains of case_42(A,B,C):
* Chain [158]: 1
  with precondition: [A=C,A>=0,B>=A+1] 

* Chain [157]: 1
  with precondition: [B=C,B>=0,A>=B] 


#### Simplifying cost structure of CE 159 

#### Simplifying cost structure of CE 160 

#### Cost of chains of minL(A,B,C):
* Chain [160]: 2
  with precondition: [A=C,A>=0,B>=A+1] 

* Chain [159]: 2
  with precondition: [B=C,B>=0,A>=B] 

 * Renamed intermediate variables: 
[ (eq(164,1),it(101))>>s(19)]

#### Simplifying cost structure of CE 164 

#### Computing cost of phase [164] 

#### Simplifying cost structure of CE 161 

#### Cost of loops [164] 

 * loop 164:rand_select_extract(A,B,C,D,E,F,G,H) -> [rand_select_extract(A',B',C',D',E',F',G',H')] 
10
##### Pending set rand_select_extract(A,B,C,D,E,F,G,H)
* Psum in Loop 164: [it(164)=<1]

###### Computing sum for it(164)=<1  in Loop 164 
   - Applying inductive sum strategy 
     - head Candidate: C 
     - head Candidate: D-1 
     - head Candidate: C 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: D-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C 
     - tail Candidate: D-1 
     - tail Candidate: C 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: D-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(164)=<C,it(164)=<D-1,it(164)=<C,it(164)=<D-1,it(164)=<C-C',it(164)=<D-D',it(164)=<C-C',it(164)=<D-D'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [164] 

#### Simplifying cost structure of phase [164] 

#### Cost of phase [164]:rand_select_extract(A,B,C,D,E,F,G,H) -> [rand_select_extract(A',B',C',D',E',F',G',H')] 
10*it(164)+0
  Such that:it(164) =< C
it(164) =< C-C'
it(164) =< D
it(164) =< D-D'

#### Simplifying cost structure of chain [[164],162] 

#### Simplifying cost structure of CE 162 

#### Found solution for phase  [164] in the cache 

#### Cost of phase [164]:rand_select_extract(A,B,C,D,E,F,G,H) -> [rand_select_extract(A',B',C',D',E',F',G',H')] 
10*it(164)+0
  Such that:it(164) =< C
it(164) =< C-C'
it(164) =< D
it(164) =< D-D'

#### Simplifying cost structure of chain [[164],161] 

#### Simplifying cost structure of CE 163 

#### Cost of chains of rand_select_extract(A,B,C,D,E,F,G,H):
* Chain [[164],162]: 10*it(164)+5*s(19)+10
  Such that:it(164) =< C
s(19) =< C-D+G+2

  with precondition: [F=1,A+D=G+2,A>=1,B>=0,C>=1,E>=0,H>=0,D>=C+2,B+E>=H] 

* Chain [[164],161]: 10*it(164)+5
  Such that:it(164) =< D

  with precondition: [F=1,G=1,A>=1,B>=0,D>=2,E>=0,H>=0,C+1>=D] 

* Chain [163]: 10
  with precondition: [A=1,C=0,F=1,D=G+1,E=H,B>=0,D>=2,E>=0] 

* Chain [161]: 5
  with precondition: [D=1,F=1,G=1,A>=1,B>=0,C>=0,E>=0,H>=0] 


#### Simplifying cost structure of CE 165 

#### Cost of chains of randomL(A,B):
* Chain [165]: 2
  with precondition: [A>=0,B>=0] 


#### Simplifying cost structure of CE 167 
 * Renamed intermediate variables: 
[ (eq(168,2),it(164))>>s(20)]

#### Simplifying cost structure of CE 168 

#### Simplifying cost structure of CE 166 
 * Renamed intermediate variables: 
[ (eq(169,2),it(164))>>s(21), (eq(169,2),s(19))>>s(22)]

#### Simplifying cost structure of CE 169 
 * Joined equivalent variables [s(21),s(22)] into s(21)

#### Cost of chains of rand_select_extract_rand(A,B,C,D,E,F):
* Chain [169]: 10
  with precondition: [A=1,D=1,E=1,B>=0,C>=0,F>=0] 

* Chain [168]: 10*s(20)+10
  Such that:s(20) =< A

  with precondition: [D=1,E=1,A>=2,B>=0,C>=0,F>=0] 

* Chain [167]: 15
  with precondition: [D=1,A=E+1,B=F,A>=2,B>=0,C>=0] 

* Chain [166]: 15*s(21)+15
  Such that:aux(15) =< A
s(21) =< aux(15)

  with precondition: [D=1,A=E+1,A>=3,B>=0,C>=0,F>=0] 


#### Simplifying cost structure of CE 174 

#### Computing cost of phase [174] 

#### Simplifying cost structure of CE 170 

#### Cost of loops [174] 

 * loop 174:rand_select_aux(A,B,C,D,E,F,G,H) -> [rand_select_aux(A',B',C',D',E',F',G',H')] 
24
##### Pending set rand_select_aux(A,B,C,D,E,F,G,H)
* Psum in Loop 174: [it(174)=<1]

###### Computing sum for it(174)=<1  in Loop 174 
   - Applying inductive sum strategy 
     - head Candidate: F+1 
     - head Candidate: A 
     - head Candidate: A 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: F+1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: F+1 
     - tail Candidate: A 
     - tail Candidate: A 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: F+1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(174)=<F+1,it(174)=<A,it(174)=<A,it(174)=<F+1,it(174)=<F-F',it(174)=<A-A',it(174)=<A-A',it(174)=<F-F'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [174] 

#### Simplifying cost structure of phase [174] 

#### Cost of phase [174]:rand_select_aux(A,B,C,D,E,F,G,H) -> [rand_select_aux(A',B',C',D',E',F',G',H')] 
24*it(174)+0
  Such that:it(174) =< A
it(174) =< A-A'
it(174) =< F+1
it(174) =< F-F'

#### Simplifying cost structure of chain [[174],170] 

#### Computing cost of phase [171,172] 
 * Renamed intermediate variables: 
[ (eq(173,1),aux(15))>>s(23), (eq(173,1),s(21))>>s(24)]

#### Simplifying cost structure of CE 173 
 * Renamed intermediate variables: 
[ (it(171),s(23))>>s(25), (it(171),s(24))>>s(26)]

#### Simplifying cost structure of CE 172 

#### Cost of loops [171,172] 

 * loop 171:rand_select_aux(A,B,C,D,E,F,G,H) -> [rand_select_aux(A',B',C',D',E',F',G',H')] 
15*s(26)+29
  Such that:s(25) =< D'+1
s(26) =< s(25)

 * loop 172:rand_select_aux(A,B,C,D,E,F,G,H) -> [rand_select_aux(A',B',C',D',E',F',G',H')] 
29
##### Pending set rand_select_aux(A,B,C,D,E,F,G,H)
* Psum in Loop 171: [it(171)=<1,s(28)=<D'+1]
* Psum in Loop 172: [it(172)=<1]

###### Computing sum for it(171)=<1  in Loop 171 
   - Applying inductive sum strategy 
     - head Candidate: F+1 
       - Loop 172 is collaborative and bounds [it(172)] 
     - head Candidate: D-1 
       - Loop 172 is collaborative and bounds [it(172)] 
     - head Candidate: A 
       - Loop 172 is collaborative and bounds [it(172)] 
     - head Candidate: A 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: D-2 
       - Loop 172 is collaborative
     - head Candidate: F+1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: F+1 
       - Loop 172 is collaborative and bounds [it(172)] 
     - tail Candidate: D-1 
       - Loop 172 is collaborative and bounds [it(172)] 
     - tail Candidate: A 
       - Loop 172 is collaborative and bounds [it(172)] 
     - tail Candidate: A 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: D-2 
       - Loop 172 is collaborative and bounds [it(172)] 
     - tail Candidate: F+1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(171)+it(172)=<F+1,it(171)+it(172)=<D-1,it(171)+it(172)=<A,it(171)+it(172)=<A,it(171)=<D-2,it(171)+it(172)=<F+1,it(171)+it(172)=<F-F',it(171)+it(172)=<D-D',it(171)+it(172)=<A-A',it(171)+it(172)=<A-A',it(171)+it(172)=<D-D',it(171)+it(172)=<F-F'] 

##### Pending set A
* Psum in Loop 171: [s(28)=<D'+1]
* Psum in Loop 172: [it(172)=<1]

###### Computing sum for s(28)=<D'+1  in Loop 171 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(16)=<D] 
 * Adding constraints: [s(28)=<it(171)*aux(16)] 

##### Pending set rand_select_aux(A,B,C,D,E,F,G,H)
* Pmax/min: [aux(16)=<D]
* Psum in Loop 172: [it(172)=<1]

###### Computing max_min for aux(16)=<D  
   - Found a solution using transitive invariants 
 * Adding constraints:[aux(16)=<D] 

##### Pending set rand_select_aux(A,B,C,D,E,F,G,H)
* Psum in Loop 172: [it(172)=<1]

###### Computing sum for it(172)=<1  in Loop 172 
   - Applying inductive sum strategy 
     - head Candidate: F+1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: D-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: D-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: F+1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: F+1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: D-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: D-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: F+1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(171)+it(172)=<F+1,it(171)+it(172)=<D-1,it(171)+it(172)=<A,it(171)+it(172)=<A,it(171)+it(172)=<D-1,it(171)+it(172)=<F+1,it(171)+it(172)=<F-F',it(171)+it(172)=<D-D',it(171)+it(172)=<A-A',it(171)+it(172)=<A-A',it(171)+it(172)=<D-D',it(171)+it(172)=<F-F'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [171,172] 

#### Simplifying cost structure of phase [171,172] 
 * Joined equivalent variables [aux(19),aux(16)] into aux(19)
 * Joined equivalent variables [it(171),it(172)] into it(171)

#### Cost of phase [171,172]:rand_select_aux(A,B,C,D,E,F,G,H) -> [rand_select_aux(A',B',C',D',E',F',G',H')] 
58*it(171)+15*s(27)+0
  Such that:aux(17) =< A
aux(18) =< A-A'
aux(19) =< D
aux(20) =< D-D'
aux(21) =< F+1
aux(22) =< F-F'
it(171) =< aux(17)
it(171) =< aux(18)
it(171) =< aux(19)
it(171) =< aux(20)
it(171) =< aux(21)
it(171) =< aux(22)
s(28) =< it(171)*aux(19)
s(27) =< s(28)

#### Simplifying cost structure of chain [[171,172],[174],170] 
 * Joined equivalent variables [aux(23),aux(18),aux(19),aux(20),aux(22)] into aux(23)
 * Renamed intermediate variables: 
[ (eq(171,1),s(20))>>s(29)]

#### Simplifying cost structure of CE 171 

#### Simplifying cost structure of chain [173,[174],170] 

#### Found solution for phase  [171,172] in the cache 

#### Cost of phase [171,172]:rand_select_aux(A,B,C,D,E,F,G,H) -> [rand_select_aux(A',B',C',D',E',F',G',H')] 
58*it(171)+15*s(27)+0
  Such that:aux(17) =< A
aux(18) =< A-A'
aux(19) =< D
aux(20) =< D-D'
aux(21) =< F+1
aux(22) =< F-F'
it(171) =< aux(17)
it(171) =< aux(18)
it(171) =< aux(19)
it(171) =< aux(20)
it(171) =< aux(21)
it(171) =< aux(22)
s(28) =< it(171)*aux(19)
s(27) =< s(28)

#### Simplifying cost structure of chain [[171,172],173,[174],170] 
 * Joined equivalent variables [aux(24),aux(17)] into aux(24)
 * Joined equivalent variables [aux(25),aux(19)] into aux(25)
 * Joined equivalent variables [aux(18),aux(20),aux(22)] into aux(18)

#### Simplifying cost structure of chain [173,170] 

#### Found solution for phase  [171,172] in the cache 

#### Cost of phase [171,172]:rand_select_aux(A,B,C,D,E,F,G,H) -> [rand_select_aux(A',B',C',D',E',F',G',H')] 
58*it(171)+15*s(27)+0
  Such that:aux(17) =< A
aux(18) =< A-A'
aux(19) =< D
aux(20) =< D-D'
aux(21) =< F+1
aux(22) =< F-F'
it(171) =< aux(17)
it(171) =< aux(18)
it(171) =< aux(19)
it(171) =< aux(20)
it(171) =< aux(21)
it(171) =< aux(22)
s(28) =< it(171)*aux(19)
s(27) =< s(28)

#### Simplifying cost structure of chain [[171,172],173,170] 
 * Joined equivalent variables [aux(26),aux(17),aux(18),aux(20),aux(22)] into aux(26)

#### Found solution for phase  [171,172] in the cache 

#### Cost of phase [171,172]:rand_select_aux(A,B,C,D,E,F,G,H) -> [rand_select_aux(A',B',C',D',E',F',G',H')] 
58*it(171)+15*s(27)+0
  Such that:aux(17) =< A
aux(18) =< A-A'
aux(19) =< D
aux(20) =< D-D'
aux(21) =< F+1
aux(22) =< F-F'
it(171) =< aux(17)
it(171) =< aux(18)
it(171) =< aux(19)
it(171) =< aux(20)
it(171) =< aux(21)
it(171) =< aux(22)
s(28) =< it(171)*aux(19)
s(27) =< s(28)

#### Simplifying cost structure of chain [[171,172],170] 
 * Joined equivalent variables [aux(27),aux(17),aux(18),aux(20),aux(22)] into aux(27)
 * Renamed intermediate variables: 
[ (ch([173,170]),s(29))>>s(30)]
 * Renamed intermediate variables: 
[ (ch([[171,172],170]),aux(19))>>s(31), (ch([[171,172],170]),aux(21))>>s(32), (ch([[171,172],170]),aux(27))>>s(33), (ch([[171,172],170]),it(171))>>s(34), (ch([[171,172],170]),s(28))>>s(35), (ch([[171,172],170]),s(27))>>s(36)]
 * Renamed intermediate variables: 
[ (ch([[171,172],173,170]),s(29))>>s(37), (ch([[171,172],173,170]),aux(19))>>s(38), (ch([[171,172],173,170]),aux(21))>>s(39), (ch([[171,172],173,170]),aux(26))>>s(40), (ch([[171,172],173,170]),it(171))>>s(41), (ch([[171,172],173,170]),s(28))>>s(42), (ch([[171,172],173,170]),s(27))>>s(43)]
 * Joined equivalent variables [aux(28),s(33),s(40)] into aux(28)
 * Joined equivalent variables [aux(29),s(31),s(38)] into aux(29)
 * Joined equivalent variables [aux(30),s(32),s(39)] into aux(30)
 * Joined equivalent variables [s(34),s(41)] into s(34)
 * Joined equivalent variables [s(35),s(42)] into s(35)
 * Joined equivalent variables [s(36),s(43)] into s(36)
 * Renamed intermediate variables: 
[ (ch([173,[174],170]),it(174))>>s(44), (ch([173,[174],170]),s(29))>>s(45)]
 * Renamed intermediate variables: 
[ (ch([[171,172],173,[174],170]),aux(21))>>s(46), (ch([[171,172],173,[174],170]),aux(24))>>s(47), (ch([[171,172],173,[174],170]),aux(25))>>s(48), (ch([[171,172],173,[174],170]),aux(18))>>s(49), (ch([[171,172],173,[174],170]),it(174))>>s(50), (ch([[171,172],173,[174],170]),s(29))>>s(51), (ch([[171,172],173,[174],170]),it(171))>>s(52), (ch([[171,172],173,[174],170]),s(28))>>s(53), (ch([[171,172],173,[174],170]),s(27))>>s(54)]
 * Renamed intermediate variables: 
[ (ch([[171,172],[174],170]),aux(17))>>s(55), (ch([[171,172],[174],170]),it(174))>>s(56), (ch([[171,172],[174],170]),aux(21))>>s(57), (ch([[171,172],[174],170]),aux(23))>>s(58), (ch([[171,172],[174],170]),it(171))>>s(59), (ch([[171,172],[174],170]),s(28))>>s(60), (ch([[171,172],[174],170]),s(27))>>s(61)]
 * Joined equivalent variables [aux(31),s(47),s(55)] into aux(31)
 * Joined equivalent variables [aux(32),s(48),s(58)] into aux(32)
 * Joined equivalent variables [aux(33),s(46),s(57)] into aux(33)
 * Joined equivalent variables [s(44),s(50)] into s(44)
 * Joined equivalent variables [s(45),s(51)] into s(45)

#### Cost of chains of rand_select_aux(A,B,C,D,E,F,G,H):
* Chain [[174],170]: 24*it(174)+3
  Such that:it(174) =< A

  with precondition: [D=1,A+B=G,A>=1,B>=1,C>=0,E>=0,H>=0,F>=A] 

* Chain [[171,172],[174],170]: 58*it(171)+24*it(174)+15*s(27)+3
  Such that:aux(17) =< A
it(174) =< A-D+1
aux(21) =< F+1
aux(23) =< D
it(171) =< aux(17)
it(171) =< aux(23)
it(171) =< aux(21)
s(28) =< it(171)*aux(23)
s(27) =< s(28)

  with precondition: [A+B=G,B>=1,C>=0,D>=2,E>=0,H>=0,F>=A,A>=D] 

* Chain [[171,172],173,[174],170]: 58*it(171)+24*it(174)+15*s(27)+10*s(29)+27
  Such that:aux(21) =< F+1
aux(24) =< A
aux(25) =< D
aux(18) =< aux(24)
it(174) =< aux(24)
aux(18) =< aux(25)
s(29) =< aux(25)
it(171) =< aux(24)
it(171) =< aux(18)
it(171) =< aux(25)
it(171) =< aux(21)
s(28) =< it(171)*aux(25)
s(27) =< s(28)

  with precondition: [A+B=G,A>=3,B>=1,C>=0,D>=3,E>=0,H>=0,F>=A] 

* Chain [[171,172],173,170]: 58*it(171)+15*s(27)+10*s(29)+27
  Such that:s(29) =< -A+D+1
aux(19) =< D
aux(21) =< F+1
aux(26) =< A
it(171) =< aux(26)
it(171) =< aux(19)
it(171) =< aux(21)
s(28) =< it(171)*aux(19)
s(27) =< s(28)

  with precondition: [A+B=G,A>=2,B>=1,C>=0,E>=0,H>=0,D>=A+1,F>=A] 

* Chain [[171,172],170]: 58*it(171)+15*s(27)+3
  Such that:aux(19) =< D
aux(21) =< F+1
aux(27) =< A
it(171) =< aux(27)
it(171) =< aux(19)
it(171) =< aux(21)
s(28) =< it(171)*aux(19)
s(27) =< s(28)

  with precondition: [A+B=G,A>=1,B>=1,C>=0,E>=0,H>=0,D>=A+1,F>=A] 

* Chain [173,[174],170]: 24*it(174)+10*s(29)+27
  Such that:it(174) =< A
s(29) =< D

  with precondition: [A+B=G,A>=2,B>=1,C>=0,D>=2,E>=0,H>=0,F>=A] 

* Chain [173,170]: 10*s(29)+27
  Such that:s(29) =< D

  with precondition: [A=1,G=B+1,C>=0,D>=2,E>=0,F>=1,G>=2,H>=0] 

* Chain [170]: 3
  with precondition: [A=0,G=B,H=C,D>=0,E>=0,F>=0,G>=1,H>=0] 


#### Simplifying cost structure of CE 175 
 * Renamed intermediate variables: 
[ (eq(176,1),s(12))>>s(62)]

#### Simplifying cost structure of CE 176 
 * Renamed intermediate variables: 
[ (eq(177,1),s(12))>>s(63)]
 * Renamed intermediate variables: 
[ (eq(177,3),s(37))>>s(64), (eq(177,3),aux(28))>>s(65), (eq(177,3),aux(29))>>s(66), (eq(177,3),aux(30))>>s(67), (eq(177,3),s(30))>>s(68), (eq(177,3),s(34))>>s(69), (eq(177,3),s(35))>>s(70), (eq(177,3),s(36))>>s(71)]

#### Simplifying cost structure of CE 177 
 * Joined equivalent variables [aux(34),s(66),s(67)] into aux(34)
 * Joined equivalent variables [s(63),s(68)] into s(63)
 * Renamed intermediate variables: 
[ (eq(178,1),s(12))>>s(72)]
 * Renamed intermediate variables: 
[ (eq(178,3),s(56))>>s(73), (eq(178,3),aux(31))>>s(74), (eq(178,3),aux(32))>>s(75), (eq(178,3),aux(33))>>s(76), (eq(178,3),s(44))>>s(77), (eq(178,3),s(45))>>s(78), (eq(178,3),s(59))>>s(79), (eq(178,3),s(60))>>s(80), (eq(178,3),s(61))>>s(81), (eq(178,3),s(49))>>s(82), (eq(178,3),s(52))>>s(83), (eq(178,3),s(53))>>s(84), (eq(178,3),s(54))>>s(85)]

#### Simplifying cost structure of CE 178 
 * Joined equivalent variables [aux(35),s(75),s(76)] into aux(35)
 * Joined equivalent variables [s(72),s(78)] into s(72)
 * Joined equivalent variables [aux(36),aux(34),aux(35)] into aux(36)
 * Joined equivalent variables [aux(37),s(65),s(74)] into aux(37)
 * Joined equivalent variables [s(63),s(72)] into s(63)
 * Joined equivalent variables [s(69),s(79)] into s(69)
 * Joined equivalent variables [s(70),s(80)] into s(70)
 * Joined equivalent variables [s(71),s(81)] into s(71)
 * Renamed intermediate variables: 
[ (eq(179,1),s(12))>>s(86)]
 * Renamed intermediate variables: 
[ (eq(179,3),s(37))>>s(87), (eq(179,3),aux(28))>>s(88), (eq(179,3),aux(29))>>s(89), (eq(179,3),aux(30))>>s(90), (eq(179,3),s(30))>>s(91), (eq(179,3),s(34))>>s(92), (eq(179,3),s(35))>>s(93), (eq(179,3),s(36))>>s(94)]

#### Simplifying cost structure of CE 179 
 * Joined equivalent variables [aux(38),s(88),s(89),s(90)] into aux(38)
 * Joined equivalent variables [s(86),s(91),s(92)] into s(86)
 * Renamed intermediate variables: 
[ (eq(180,1),s(12))>>s(95)]
 * Renamed intermediate variables: 
[ (eq(180,3),s(56))>>s(96), (eq(180,3),aux(31))>>s(97), (eq(180,3),aux(32))>>s(98), (eq(180,3),aux(33))>>s(99), (eq(180,3),s(44))>>s(100), (eq(180,3),s(45))>>s(101), (eq(180,3),s(59))>>s(102), (eq(180,3),s(60))>>s(103), (eq(180,3),s(61))>>s(104), (eq(180,3),s(49))>>s(105), (eq(180,3),s(52))>>s(106), (eq(180,3),s(53))>>s(107), (eq(180,3),s(54))>>s(108)]

#### Simplifying cost structure of CE 180 
 * Joined equivalent variables [aux(39),s(97),s(98),s(99)] into aux(39)
 * Joined equivalent variables [aux(39),s(105)] into aux(39)
 * Joined equivalent variables [s(95),s(100),s(101),s(102)] into s(95)
 * Joined equivalent variables [s(95),s(106)] into s(95)
 * Joined equivalent variables [s(103),s(107)] into s(103)
 * Joined equivalent variables [s(104),s(108)] into s(104)
 * Joined equivalent variables [aux(40),aux(38),aux(39)] into aux(40)
 * Joined equivalent variables [s(86),s(95)] into s(86)
 * Joined equivalent variables [s(93),s(103)] into s(93)
 * Joined equivalent variables [s(94),s(104)] into s(94)

#### Cost of chains of rand_select(A,B,C,D,E):
* Chain [178]: 15
  with precondition: [A=1,D=1,B>=0,C>=0,E>=0] 

* Chain [177]: 6*s(62)+15
  Such that:s(62) =< A

  with precondition: [C=0,D=1,A>=2,B>=0,E>=0] 

* Chain [176]: 42*s(63)+10*s(64)+174*s(69)+45*s(71)+48*s(77)+58*s(83)+15*s(85)+39
  Such that:s(64) =< A-C+1
aux(36) =< A
aux(37) =< C
s(63) =< aux(36)
s(69) =< aux(37)
s(69) =< aux(36)
s(70) =< s(69)*aux(36)
s(71) =< s(70)
s(77) =< aux(37)
s(82) =< aux(37)
s(82) =< aux(36)
s(83) =< aux(37)
s(83) =< s(82)
s(83) =< aux(36)
s(84) =< s(83)*aux(36)
s(85) =< s(84)

  with precondition: [C+1=D,B>=0,C>=1,E>=0,A>=C+2] 

* Chain [175]: 322*s(86)+10*s(87)+60*s(94)+39
  Such that:s(87) =< 2
aux(40) =< A
s(86) =< aux(40)
s(93) =< s(86)*aux(40)
s(94) =< s(93)

  with precondition: [A=D,A>=2,B>=0,E>=0,C+1>=A] 

 * Renamed intermediate variables: 
[ (eq(184,1),s(17))>>s(109), (eq(184,1),s(18))>>s(110)]
 * Renamed intermediate variables: 
[ (eq(184,2),s(62))>>s(111)]

#### Simplifying cost structure of CE 184 
 * Joined equivalent variables [s(110),s(111)] into s(110)
 * Renamed intermediate variables: 
[ (eq(181,1),s(16))>>s(112)]
 * Renamed intermediate variables: 
[ (eq(181,2),s(62))>>s(113)]

#### Simplifying cost structure of CE 181 
 * Renamed intermediate variables: 
[ (eq(186,1),s(17))>>s(114), (eq(186,1),s(18))>>s(115)]
 * Renamed intermediate variables: 
[ (eq(186,2),s(64))>>s(116), (eq(186,2),aux(36))>>s(117), (eq(186,2),aux(37))>>s(118), (eq(186,2),s(63))>>s(119), (eq(186,2),s(69))>>s(120), (eq(186,2),s(70))>>s(121), (eq(186,2),s(71))>>s(122), (eq(186,2),s(77))>>s(123), (eq(186,2),s(82))>>s(124), (eq(186,2),s(83))>>s(125), (eq(186,2),s(84))>>s(126), (eq(186,2),s(85))>>s(127)]

#### Simplifying cost structure of CE 186 
 * Joined equivalent variables [aux(42),s(117)] into aux(42)
 * Joined equivalent variables [s(115),s(116)] into s(115)
 * Joined equivalent variables [s(115),s(119)] into s(115)
 * Renamed intermediate variables: 
[ (eq(185,1),s(17))>>s(128), (eq(185,1),s(18))>>s(129)]
 * Renamed intermediate variables: 
[ (eq(185,2),s(87))>>s(130), (eq(185,2),aux(40))>>s(131), (eq(185,2),s(86))>>s(132), (eq(185,2),s(93))>>s(133), (eq(185,2),s(94))>>s(134)]

#### Simplifying cost structure of CE 185 
 * Joined equivalent variables [aux(44),s(131)] into aux(44)
 * Joined equivalent variables [s(128),s(130)] into s(128)
 * Joined equivalent variables [s(129),s(132)] into s(129)
 * Renamed intermediate variables: 
[ (eq(182,1),s(16))>>s(135)]
 * Renamed intermediate variables: 
[ (eq(182,2),s(87))>>s(136), (eq(182,2),aux(40))>>s(137), (eq(182,2),s(86))>>s(138), (eq(182,2),s(93))>>s(139), (eq(182,2),s(94))>>s(140)]

#### Simplifying cost structure of CE 182 
 * Renamed intermediate variables: 
[ (eq(183,1),s(16))>>s(141)]
 * Renamed intermediate variables: 
[ (eq(183,2),s(64))>>s(142), (eq(183,2),aux(36))>>s(143), (eq(183,2),aux(37))>>s(144), (eq(183,2),s(63))>>s(145), (eq(183,2),s(69))>>s(146), (eq(183,2),s(70))>>s(147), (eq(183,2),s(71))>>s(148), (eq(183,2),s(77))>>s(149), (eq(183,2),s(82))>>s(150), (eq(183,2),s(83))>>s(151), (eq(183,2),s(84))>>s(152), (eq(183,2),s(85))>>s(153)]

#### Simplifying cost structure of CE 183 

#### Cost of chains of lotto_select(A,B,C,D):
* Chain [184]: 6*s(109)+11*s(110)+29
  Such that:s(109) =< 2
aux(41) =< 3
s(110) =< aux(41)

  with precondition: [A=0,B=0,C=1,D>=0] 

* Chain [183]: 6*s(112)+6*s(113)+24
  Such that:s(112) =< B
s(113) =< B+1

  with precondition: [A=0,C=1,B>=1,D>=0] 

* Chain [182]: 6*s(114)+57*s(115)+174*s(120)+45*s(122)+48*s(123)+58*s(125)+15*s(127)+53
  Such that:s(118) =< 1
s(114) =< 2
aux(42) =< 3
s(115) =< aux(42)
s(120) =< s(118)
s(120) =< aux(42)
s(121) =< s(120)*aux(42)
s(122) =< s(121)
s(123) =< s(118)
s(124) =< s(118)
s(124) =< aux(42)
s(125) =< s(118)
s(125) =< s(124)
s(125) =< aux(42)
s(126) =< s(125)*aux(42)
s(127) =< s(126)

  with precondition: [A=1,B=0,C=2,D>=0] 

* Chain [181]: 16*s(128)+327*s(129)+60*s(134)+53
  Such that:aux(43) =< 2
aux(44) =< 3
s(128) =< aux(43)
s(129) =< aux(44)
s(133) =< s(129)*aux(44)
s(134) =< s(133)

  with precondition: [B=0,C=3,A>=2,D>=0] 

* Chain [180]: 6*s(135)+10*s(136)+322*s(138)+60*s(140)+48
  Such that:s(136) =< 2
s(135) =< B
s(137) =< B+1
s(138) =< s(137)
s(139) =< s(138)*s(137)
s(140) =< s(139)

  with precondition: [B+1=C,B>=1,D>=0,A>=B] 

* Chain [179]: 6*s(141)+10*s(142)+42*s(145)+174*s(146)+45*s(148)+48*s(149)+58*s(151)+15*s(153)+48
  Such that:s(142) =< -A+B+2
s(144) =< A
s(141) =< B
s(143) =< B+1
s(145) =< s(143)
s(146) =< s(144)
s(146) =< s(143)
s(147) =< s(146)*s(143)
s(148) =< s(147)
s(149) =< s(144)
s(150) =< s(144)
s(150) =< s(143)
s(151) =< s(144)
s(151) =< s(150)
s(151) =< s(143)
s(152) =< s(151)*s(143)
s(153) =< s(152)

  with precondition: [A+1=C,A>=1,D>=0,B>=A+1] 


#### Simplifying cost structure of CE 187 

#### Computing cost of phase [185,186] 

#### Simplifying cost structure of CE 189 

#### Simplifying cost structure of CE 190 

#### Cost of loops [185,186] 

 * loop 185:pack_aux(A,B,C,D,E,F,G,H,I,J) -> [pack_aux(A',B',C',D',E',F',G',H',I',J')] 
10
 * loop 186:pack_aux(A,B,C,D,E,F,G,H,I,J) -> [pack_aux(A',B',C',D',E',F',G',H',I',J')] 
12
##### Pending set pack_aux(A,B,C,D,E,F,G,H,I,J)
* Psum in Loop 185: [it(185)=<1]
* Psum in Loop 186: [it(186)=<1]

###### Computing sum for it(185)=<1  in Loop 185 
   - Applying inductive sum strategy 
     - head Candidate: F-2 
       - Loop 186 is collaborative and bounds [it(186)] 
     - head Candidate: F-2 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: F-2 
       - Loop 186 is collaborative and bounds [it(186)] 
     - tail Candidate: F-2 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(185)+it(186)=<F-2,it(185)+it(186)=<F-2,it(185)+it(186)=<F-F',it(185)+it(186)=<F-F'] 

##### Pending set A
* Psum in Loop 186: [it(186)=<1]

###### Computing sum for it(186)=<1  in Loop 186 
   - Applying inductive sum strategy 
     - head Candidate: F-2 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: F-2 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: G 
       - Loop 185 is collaborative
     - tail Candidate: F-2 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: F-2 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: G 
       - Loop 185 is collaborative
 * Adding constraints: [it(185)+it(186)=<F-2,it(185)+it(186)=<F-2,it(186)=<G,it(185)+it(186)=<F-F',it(185)+it(186)=<F-F',it(186)=<G-G'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [185,186] 

#### Simplifying cost structure of phase [185,186] 

#### Cost of phase [185,186]:pack_aux(A,B,C,D,E,F,G,H,I,J) -> [pack_aux(A',B',C',D',E',F',G',H',I',J')] 
10*it(185)+12*it(186)+0
  Such that:it(186) =< G
it(186) =< G-G'
aux(45) =< F
aux(46) =< F-F'
it(185) =< aux(45)
it(186) =< aux(45)
it(185) =< aux(46)
it(186) =< aux(46)

#### Simplifying cost structure of chain [[185,186],187] 
 * Joined equivalent variables [aux(47),aux(45),aux(46)] into aux(47)

#### Simplifying cost structure of CE 188 

#### Cost of chains of pack_aux(A,B,C,D,E,F,G,H,I,J):
* Chain [[185,186],187]: 10*it(185)+12*it(186)+7
  Such that:it(186) =< G
aux(47) =< F
it(185) =< aux(47)
it(186) =< aux(47)

  with precondition: [C+I+2=A+D+F+H,A>=1,B>=0,C>=1,E>=0,F>=3,D+2>=2*C,H>=C+1,C+F>=H+1,C+G+1>=H,C+J+1>=B+E+H] 

* Chain [188]: 3
  with precondition: [A=1,C=1,D=0,F=1,H=1,I=0,B>=0,E>=0,G>=0,J>=0] 

* Chain [187]: 7
  with precondition: [F=2,C+1=H,A+D+1=I,B>=0,C>=1,E>=0,D+2>=2*C,I>=D+2,J>=B+E,B+E+G>=J] 


#### Simplifying cost structure of CE 191 

#### Simplifying cost structure of CE 192 
 * Renamed intermediate variables: 
[ (eq(193,1),it(186))>>s(154), (eq(193,1),aux(47))>>s(155), (eq(193,1),it(185))>>s(156)]

#### Simplifying cost structure of CE 193 

#### Cost of chains of pack(A,B,C,D,E):
* Chain [191]: 6
  with precondition: [A=1,C=1,D=0,B>=0,E>=0] 

* Chain [190]: 10
  with precondition: [A=2,C=2,D=2,B>=0,E>=0] 

* Chain [189]: 12*s(154)+10*s(156)+10
  Such that:s(155) =< A
s(154) =< B
s(156) =< s(155)
s(154) =< s(155)

  with precondition: [A+C=D+2,A>=3,C>=2,A>=C,B+2>=C,E+2>=C] 


#### Simplifying cost structure of CE 196 

#### Computing cost of phase [194] 

#### Simplifying cost structure of CE 194 

#### Cost of loops [194] 

 * loop 194:removeAt(A,B,C,D,E) -> [removeAt(A',B',C',D',E')] 
10
##### Pending set removeAt(A,B,C,D,E)
* Psum in Loop 194: [it(194)=<1]

###### Computing sum for it(194)=<1  in Loop 194 
   - Applying inductive sum strategy 
     - head Candidate: B-1 
     - head Candidate: A-1 
     - head Candidate: C 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: C 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B-1 
     - tail Candidate: A-1 
     - tail Candidate: C 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(194)=<B-1,it(194)=<A-1,it(194)=<C,it(194)=<A-1,it(194)=<B-1,it(194)=<C,it(194)=<B-B',it(194)=<A-A',it(194)=<C-C',it(194)=<A-A',it(194)=<B-B',it(194)=<C-C'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [194] 

#### Simplifying cost structure of phase [194] 

#### Cost of phase [194]:removeAt(A,B,C,D,E) -> [removeAt(A',B',C',D',E')] 
10*it(194)+0
  Such that:it(194) =< A
it(194) =< A-A'
it(194) =< B
it(194) =< B-B'
it(194) =< C
it(194) =< C-C'

#### Simplifying cost structure of chain [[194],193] 

#### Simplifying cost structure of CE 195 

#### Found solution for phase  [194] in the cache 

#### Cost of phase [194]:removeAt(A,B,C,D,E) -> [removeAt(A',B',C',D',E')] 
10*it(194)+0
  Such that:it(194) =< A
it(194) =< A-A'
it(194) =< B
it(194) =< B-B'
it(194) =< C
it(194) =< C-C'

#### Simplifying cost structure of chain [[194],192] 

#### Cost of chains of removeAt(A,B,C,D,E):
* Chain [[194],193]: 10*it(194)+6
  Such that:it(194) =< A

  with precondition: [B=D+1,A>=2,B>=A+1,E+1>=A,C>=E+1] 

* Chain [[194],192]: 10*it(194)+3
  Such that:it(194) =< D

  with precondition: [E=C,B=D,B>=2,A>=B,E+1>=B] 

* Chain [193]: 6
  with precondition: [A=1,B=D+1,B>=2,E>=0,C>=E+1] 

* Chain [192]: 3
  with precondition: [B=1,C=0,D=1,E=0,A>=0] 


#### Simplifying cost structure of CE 197 

#### Computing cost of phase [195] 

#### Simplifying cost structure of CE 198 

#### Cost of loops [195] 

 * loop 195:prepend(A,B,C,D,E,F) -> [prepend(A',B',C',D',E',F')] 
7
##### Pending set prepend(A,B,C,D,E,F)
* Psum in Loop 195: [it(195)=<1]

###### Computing sum for it(195)=<1  in Loop 195 
   - Applying inductive sum strategy 
     - head Candidate: A 
     - head Candidate: A 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A 
     - tail Candidate: A 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(195)=<A,it(195)=<A,it(195)=<A-A',it(195)=<A-A'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [195] 

#### Simplifying cost structure of phase [195] 

#### Cost of phase [195]:prepend(A,B,C,D,E,F) -> [prepend(A',B',C',D',E',F')] 
7*it(195)+0
  Such that:it(195) =< A
it(195) =< A-A'

#### Simplifying cost structure of chain [[195],196] 

#### Cost of chains of prepend(A,B,C,D,E,F):
* Chain [[195],196]: 7*it(195)+3
  Such that:it(195) =< -B+E

  with precondition: [A+B=E,A>=1,B>=1,C>=0,D>=1,F+1>=A+C+D] 

* Chain [196]: 3
  with precondition: [A=0,B=E,C=F,B>=0,C>=0,D>=1] 


#### Simplifying cost structure of CE 199 

#### Computing cost of phase [198] 

#### Simplifying cost structure of CE 200 

#### Cost of loops [198] 

 * loop 198:replicate_aux(A,B,C,D,E,F,G) -> [replicate_aux(A',B',C',D',E',F',G')] 
8
##### Pending set replicate_aux(A,B,C,D,E,F,G)
* Psum in Loop 198: [it(198)=<1]

###### Computing sum for it(198)=<1  in Loop 198 
   - Applying inductive sum strategy 
     - head Candidate: D+1 
     - head Candidate: C-1 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: D+1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: D+1 
     - tail Candidate: C-1 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: D+1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(198)=<D+1,it(198)=<C-1,it(198)=<C-1,it(198)=<D+1,it(198)=<D-D',it(198)=<C-C',it(198)=<C-C',it(198)=<D-D'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [198] 

#### Simplifying cost structure of phase [198] 

#### Cost of phase [198]:replicate_aux(A,B,C,D,E,F,G) -> [replicate_aux(A',B',C',D',E',F',G')] 
8*it(198)+0
  Such that:it(198) =< C
it(198) =< C-C'
it(198) =< D+1
it(198) =< D-D'

#### Simplifying cost structure of chain [[198],199] 

#### Computing cost of phase [197] 
 * Renamed intermediate variables: 
[ (eq(201,1),it(195))>>s(157)]

#### Simplifying cost structure of CE 201 
 * Renamed intermediate variables: 
[ (it(197),s(157))>>s(158)]

#### Cost of loops [197] 

 * loop 197:replicate_aux(A,B,C,D,E,F,G) -> [replicate_aux(A',B',C',D',E',F',G')] 
7*s(158)+8
  Such that:s(158) =< E'

##### Pending set replicate_aux(A,B,C,D,E,F,G)
* Psum in Loop 197: [it(197)=<1,s(159)=<E']

###### Computing sum for it(197)=<1  in Loop 197 
   - Applying inductive sum strategy 
     - head Candidate: C-1 
     - head Candidate: D+1 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: D+1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
     - tail Candidate: D+1 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: D+1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(197)=<C-1,it(197)=<D+1,it(197)=<C-1,it(197)=<D+1,it(197)=<C-C',it(197)=<D-D',it(197)=<C-C',it(197)=<D-D'] 

##### Pending set A
* Psum in Loop 197: [s(159)=<E']

###### Computing sum for s(159)=<E'  in Loop 197 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(48)=<E] 
 * Adding constraints: [s(159)=<it(197)*aux(48)] 

##### Pending set replicate_aux(A,B,C,D,E,F,G)
* Pmax/min: [aux(48)=<E]

###### Computing max_min for aux(48)=<E  
   - Found a solution using transitive invariants 
 * Adding constraints:[aux(48)=<E] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [197] 

#### Simplifying cost structure of phase [197] 

#### Cost of phase [197]:replicate_aux(A,B,C,D,E,F,G) -> [replicate_aux(A',B',C',D',E',F',G')] 
8*it(197)+7*s(159)+0
  Such that:it(197) =< C
it(197) =< C-C'
it(197) =< D+1
it(197) =< D-D'
aux(48) =< E
s(159) =< it(197)*aux(48)

#### Simplifying cost structure of chain [[197],199] 

#### Cost of chains of replicate_aux(A,B,C,D,E,F,G):
* Chain [[198],199]: 8*it(198)+2
  Such that:it(198) =< C

  with precondition: [A=1,B=0,E=0,F=1,G=0,C>=2,D+1>=C] 

* Chain [[197],199]: 8*it(197)+7*s(159)+2
  Such that:it(197) =< C
aux(48) =< E
s(159) =< it(197)*aux(48)

  with precondition: [A>=1,C>=2,E>=1,B+1>=A,D+1>=C,F+2>=A+C+E,A+C+G>=B+D+F+1] 

* Chain [199]: 2
  with precondition: [C=1,D=0,A=F,B=G,A>=1,E>=0,B+1>=A] 


#### Simplifying cost structure of CE 202 
 * Renamed intermediate variables: 
[ (eq(203,1),s(6))>>s(160)]
 * Renamed intermediate variables: 
[ (eq(203,2),it(198))>>s(161)]

#### Simplifying cost structure of CE 203 
 * Joined equivalent variables [s(160),s(161)] into s(160)
 * Renamed intermediate variables: 
[ (eq(204,1),s(6))>>s(162)]
 * Renamed intermediate variables: 
[ (eq(204,2),it(197))>>s(163), (eq(204,2),aux(48))>>s(164), (eq(204,2),s(159))>>s(165)]

#### Simplifying cost structure of CE 204 
 * Joined equivalent variables [s(162),s(163)] into s(162)

#### Cost of chains of replicate(A,B,C,D,E):
* Chain [202]: 9
  with precondition: [A=1,B=0,D=1,E=0,C>=0] 

* Chain [201]: 13*s(160)+9
  Such that:aux(49) =< A
s(160) =< aux(49)

  with precondition: [C=0,D=1,E=0,A>=2,B+1>=A] 

* Chain [200]: 13*s(162)+7*s(165)+9
  Such that:s(164) =< C
aux(50) =< A
s(162) =< aux(50)
s(165) =< s(162)*s(164)

  with precondition: [A>=2,C>=1,B+1>=A,D+1>=A+C,A+E>=B+D] 


#### Simplifying cost structure of CE 206 

#### Simplifying cost structure of CE 205 

#### Cost of chains of case_33(A,B,C,D,E,F):
* Chain [204]: 2
  with precondition: [A=0,B=0,F=0,C>=0,D>=0,E>=0] 

* Chain [203]: 4
  with precondition: [A=0,B>=1,C>=0,D>=0,E>=0,F>=0] 

 * Renamed intermediate variables: 
[ (eq(211,1),s(6))>>s(166)]

#### Simplifying cost structure of CE 211 

#### Computing cost of phase [209] 

#### Simplifying cost structure of CE 207 

#### Cost of loops [209] 

 * loop 209:split_aux(A,B,C,D,E,F,G,H) -> [split_aux(A',B',C',D',E',F',G',H')] 
10
##### Pending set split_aux(A,B,C,D,E,F,G,H)
* Psum in Loop 209: [it(209)=<1]

###### Computing sum for it(209)=<1  in Loop 209 
   - Applying inductive sum strategy 
     - head Candidate: E 
     - head Candidate: -B+C+E+1 
     - head Candidate: D-1 
     - head Candidate: A 
     - head Candidate: A 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: D-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: E 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: -B+C+E+1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: E 
     - tail Candidate: -B+C+E+1 
     - tail Candidate: D-1 
     - tail Candidate: A 
     - tail Candidate: A 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: D-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: E 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: -B+C+E+1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(209)=<E,it(209)=< -B+C+E+1,it(209)=<D-1,it(209)=<A,it(209)=<A,it(209)=<D-1,it(209)=<E,it(209)=< -B+C+E+1,it(209)=<E-E',it(209)=< -B+C+E+B'-C'-E',it(209)=<D-D',it(209)=<A-A',it(209)=<A-A',it(209)=<D-D',it(209)=<E-E',it(209)=< -B+C+E+B'-C'-E'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [209] 

#### Simplifying cost structure of phase [209] 

#### Cost of phase [209]:split_aux(A,B,C,D,E,F,G,H) -> [split_aux(A',B',C',D',E',F',G',H')] 
10*it(209)+0
  Such that:it(209) =< A
it(209) =< A-A'
it(209) =< -B+C+E+1
it(209) =< -B+C+E+B'-C'-E'
it(209) =< D
it(209) =< D-D'
it(209) =< E
it(209) =< E-E'

#### Simplifying cost structure of chain [[209],207] 
 * Renamed intermediate variables: 
[ (eq(209,1),s(6))>>s(167)]

#### Simplifying cost structure of CE 209 

#### Found solution for phase  [209] in the cache 

#### Cost of phase [209]:split_aux(A,B,C,D,E,F,G,H) -> [split_aux(A',B',C',D',E',F',G',H')] 
10*it(209)+0
  Such that:it(209) =< A
it(209) =< A-A'
it(209) =< -B+C+E+1
it(209) =< -B+C+E+B'-C'-E'
it(209) =< D
it(209) =< D-D'
it(209) =< E
it(209) =< E-E'

#### Simplifying cost structure of chain [[209],205] 

#### Simplifying cost structure of CE 210 

#### Simplifying cost structure of CE 208 

#### Cost of chains of split_aux(A,B,C,D,E,F,G,H):
* Chain [[209],207]: 10*it(209)+5*s(166)+12
  Such that:it(209) =< A
s(166) =< A-D+G

  with precondition: [F=1,B+D=G,C+E=H,A>=1,B>=1,D>=A+2,E>=A+1,C+1>=B] 

* Chain [[209],205]: 10*it(209)+5*s(167)+9
  Such that:it(209) =< D
s(167) =< G

  with precondition: [F=1,B+D=G,C+E=H,B>=1,D>=2,C+1>=B,A+1>=D,E+1>=D] 

* Chain [208]: 12
  with precondition: [A=0,B=1,C=0,F=1,D+1=G,E=H,D>=2,E>=1] 

* Chain [206]: 9
  with precondition: [B=1,C=0,D=1,E=0,F=1,G=2,H=0,A>=0] 


#### Simplifying cost structure of CE 213 

#### Simplifying cost structure of CE 212 
 * Renamed intermediate variables: 
[ (eq(215,1),it(209))>>s(168), (eq(215,1),s(167))>>s(169)]

#### Simplifying cost structure of CE 215 
 * Renamed intermediate variables: 
[ (eq(214,1),it(209))>>s(170), (eq(214,1),s(166))>>s(171)]

#### Simplifying cost structure of CE 214 

#### Cost of chains of split(A,B,C,D,E,F):
* Chain [213]: 11
  with precondition: [A=1,B=0,D=1,E=2,F=0,C>=0] 

* Chain [212]: 14
  with precondition: [C=0,D=1,A+1=E,B=F,A>=2,B>=1] 

* Chain [211]: 10*s(168)+5*s(169)+11
  Such that:s(168) =< A
s(169) =< A+1

  with precondition: [D=1,A+1=E,B=F,A>=2,B+1>=A,C+1>=A] 

* Chain [210]: 10*s(170)+5*s(171)+14
  Such that:s(170) =< C
s(171) =< C+1

  with precondition: [D=1,A+1=E,B=F,C>=1,A>=C+2,B>=C+1] 


#### Simplifying cost structure of CE 223 

#### Simplifying cost structure of CE 216 

#### Simplifying cost structure of CE 217 
 * Renamed intermediate variables: 
[ (eq(218,2),it(101))>>s(172)]

#### Simplifying cost structure of CE 218 
 * Renamed intermediate variables: 
[ (eq(219,1),s(168))>>s(173), (eq(219,1),s(169))>>s(174)]

#### Simplifying cost structure of CE 219 
 * Renamed intermediate variables: 
[ (eq(220,1),s(168))>>s(175), (eq(220,1),s(169))>>s(176)]
 * Renamed intermediate variables: 
[ (eq(220,2),it(101))>>s(177)]

#### Simplifying cost structure of CE 220 
 * Joined equivalent variables [s(175),s(177)] into s(175)
 * Joined equivalent variables [aux(52),aux(51)] into aux(52)
 * Joined equivalent variables [s(174),s(176)] into s(174)
 * Joined equivalent variables [s(173),s(175)] into s(173)
 * Renamed intermediate variables: 
[ (eq(221,1),s(170))>>s(178), (eq(221,1),s(171))>>s(179)]

#### Simplifying cost structure of CE 221 
 * Renamed intermediate variables: 
[ (eq(222,1),s(170))>>s(180), (eq(222,1),s(171))>>s(181)]
 * Renamed intermediate variables: 
[ (eq(222,2),it(101))>>s(182)]

#### Simplifying cost structure of CE 222 
 * Joined equivalent variables [s(178),s(180)] into s(178)
 * Joined equivalent variables [s(179),s(181)] into s(179)

#### Cost of chains of case_34(A,B,C,D,E,F,G,H):
* Chain [218]: 1
  with precondition: [A=0,B=0,D=G,E=H,C>=0,D>=1,E>=0,F>=0] 

* Chain [217]: 20
  with precondition: [A=0,D=1,E=0,G=1,H=0,B>=1,C>=0,F>=0] 

* Chain [216]: 5*s(172)+23
  Such that:s(172) =< D
s(172) =< E

  with precondition: [A=0,F=0,D=G,E=H,B>=1,C>=0,D>=2,E>=1] 

* Chain [215]: 25*s(173)+10*s(174)+20
  Such that:aux(52) =< D
aux(53) =< D+1
s(173) =< aux(52)
s(174) =< aux(53)

  with precondition: [A=0,D=G,E=H,B>=1,C>=0,D>=2,E+1>=D,F+1>=D] 

* Chain [214]: 20*s(178)+10*s(179)+5*s(182)+23
  Such that:s(182) =< D
s(182) =< E
aux(54) =< F
aux(55) =< F+1
s(178) =< aux(54)
s(179) =< aux(55)

  with precondition: [A=0,D=G,E=H,B>=1,C>=0,F>=1,D>=F+2,E>=F+1] 


#### Simplifying cost structure of CE 224 
 * Renamed intermediate variables: 
[ (eq(225,1),s(12))>>s(183)]

#### Simplifying cost structure of CE 225 
 * Renamed intermediate variables: 
[ (eq(226,1),s(12))>>s(184)]
 * Renamed intermediate variables: 
[ (eq(226,3),s(172))>>s(185)]

#### Simplifying cost structure of CE 226 
 * Renamed intermediate variables: 
[ (eq(227,1),s(12))>>s(186)]
 * Renamed intermediate variables: 
[ (eq(227,3),aux(52))>>s(187), (eq(227,3),aux(53))>>s(188), (eq(227,3),s(173))>>s(189), (eq(227,3),s(174))>>s(190)]

#### Simplifying cost structure of CE 227 
 * Joined equivalent variables [aux(57),s(187)] into aux(57)
 * Joined equivalent variables [s(186),s(189)] into s(186)
 * Renamed intermediate variables: 
[ (eq(228,1),s(12))>>s(191)]
 * Renamed intermediate variables: 
[ (eq(228,3),s(182))>>s(192), (eq(228,3),aux(54))>>s(193), (eq(228,3),aux(55))>>s(194), (eq(228,3),s(178))>>s(195), (eq(228,3),s(179))>>s(196)]

#### Simplifying cost structure of CE 228 
 * Joined equivalent variables [aux(59),aux(56),aux(57),aux(58)] into aux(59)
 * Joined equivalent variables [s(183),s(184),s(186),s(191)] into s(183)
 * Joined equivalent variables [s(185),s(192)] into s(185)

#### Cost of chains of rotate(A,B,C,D,E):
* Chain [220]: 16
  with precondition: [A=1,B=0,D=1,E=0,C>=0] 

* Chain [219]: 49*s(183)+10*s(185)+10*s(190)+20*s(195)+10*s(196)+40
  Such that:s(188) =< A+1
s(193) =< C
s(194) =< C+1
aux(59) =< A
aux(60) =< B
s(183) =< aux(59)
s(185) =< aux(60)
s(190) =< s(188)
s(185) =< aux(59)
s(195) =< s(193)
s(196) =< s(194)

  with precondition: [A=D,B=E,A>=2,C>=0,B+1>=A] 


#### Simplifying cost structure of CE 231 

#### Computing cost of phase [223] 

#### Simplifying cost structure of CE 229 

#### Cost of loops [223] 

 * loop 223:drop_slice(A,B,C,D,E) -> [drop_slice(A',B',C',D',E')] 
9
##### Pending set drop_slice(A,B,C,D,E)
* Psum in Loop 223: [it(223)=<1]

###### Computing sum for it(223)=<1  in Loop 223 
   - Applying inductive sum strategy 
     - head Candidate: B-1 
     - head Candidate: A 
     - head Candidate: C 
     - head Candidate: A 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: C 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B-1 
     - tail Candidate: A 
     - tail Candidate: C 
     - tail Candidate: A 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(223)=<B-1,it(223)=<A,it(223)=<C,it(223)=<A,it(223)=<B-1,it(223)=<C,it(223)=<B-B',it(223)=<A-A',it(223)=<C-C',it(223)=<A-A',it(223)=<B-B',it(223)=<C-C'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [223] 

#### Simplifying cost structure of phase [223] 

#### Cost of phase [223]:drop_slice(A,B,C,D,E) -> [drop_slice(A',B',C',D',E')] 
9*it(223)+0
  Such that:it(223) =< A
it(223) =< A-A'
it(223) =< B
it(223) =< B-B'
it(223) =< C
it(223) =< C-C'

#### Simplifying cost structure of chain [[223],222] 

#### Simplifying cost structure of CE 230 

#### Found solution for phase  [223] in the cache 

#### Cost of phase [223]:drop_slice(A,B,C,D,E) -> [drop_slice(A',B',C',D',E')] 
9*it(223)+0
  Such that:it(223) =< A
it(223) =< A-A'
it(223) =< B
it(223) =< B-B'
it(223) =< C
it(223) =< C-C'

#### Simplifying cost structure of chain [[223],221] 

#### Cost of chains of drop_slice(A,B,C,D,E):
* Chain [[223],222]: 9*it(223)+6
  Such that:it(223) =< B-D

  with precondition: [A+D=B,A>=1,E>=1,B>=A+2,C>=A+E] 

* Chain [[223],221]: 9*it(223)+3
  Such that:it(223) =< B

  with precondition: [D=1,E=0,B>=2,A+1>=B,C+1>=B] 

* Chain [222]: 6
  with precondition: [A=0,B=D,C=E,B>=2,C>=1] 

* Chain [221]: 3
  with precondition: [B=1,C=0,D=1,E=0,A>=0] 


#### Simplifying cost structure of CE 234 

#### Computing cost of phase [226] 

#### Simplifying cost structure of CE 232 

#### Cost of loops [226] 

 * loop 226:take_slice(A,B,C,D,E) -> [take_slice(A',B',C',D',E')] 
10
##### Pending set take_slice(A,B,C,D,E)
* Psum in Loop 226: [it(226)=<1]

###### Computing sum for it(226)=<1  in Loop 226 
   - Applying inductive sum strategy 
     - head Candidate: B-1 
     - head Candidate: A 
     - head Candidate: C 
     - head Candidate: A 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: C 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B-1 
     - tail Candidate: A 
     - tail Candidate: C 
     - tail Candidate: A 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(226)=<B-1,it(226)=<A,it(226)=<C,it(226)=<A,it(226)=<B-1,it(226)=<C,it(226)=<B-B',it(226)=<A-A',it(226)=<C-C',it(226)=<A-A',it(226)=<B-B',it(226)=<C-C'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [226] 

#### Simplifying cost structure of phase [226] 

#### Cost of phase [226]:take_slice(A,B,C,D,E) -> [take_slice(A',B',C',D',E')] 
10*it(226)+0
  Such that:it(226) =< A
it(226) =< A-A'
it(226) =< B
it(226) =< B-B'
it(226) =< C
it(226) =< C-C'

#### Simplifying cost structure of chain [[226],225] 

#### Simplifying cost structure of CE 233 

#### Found solution for phase  [226] in the cache 

#### Cost of phase [226]:take_slice(A,B,C,D,E) -> [take_slice(A',B',C',D',E')] 
10*it(226)+0
  Such that:it(226) =< A
it(226) =< A-A'
it(226) =< B
it(226) =< B-B'
it(226) =< C
it(226) =< C-C'

#### Simplifying cost structure of chain [[226],224] 

#### Cost of chains of take_slice(A,B,C,D,E):
* Chain [[226],225]: 10*it(226)+7
  Such that:it(226) =< D

  with precondition: [A+1=D,A>=1,B>=A+2,E>=A,C>=E+1] 

* Chain [[226],224]: 10*it(226)+3
  Such that:it(226) =< D

  with precondition: [E=C,B=D,B>=2,A+1>=B,E+1>=B] 

* Chain [225]: 7
  with precondition: [A=0,D=1,E=0,B>=2,C>=1] 

* Chain [224]: 3
  with precondition: [B=1,C=0,D=1,E=0,A>=0] 


#### Simplifying cost structure of CE 238 

#### Simplifying cost structure of CE 235 
 * Renamed intermediate variables: 
[ (eq(236,2),it(226))>>s(197)]

#### Simplifying cost structure of CE 236 
 * Renamed intermediate variables: 
[ (eq(237,2),it(226))>>s(198)]

#### Simplifying cost structure of CE 237 
 * Renamed intermediate variables: 
[ (eq(240,1),it(223))>>s(199)]

#### Simplifying cost structure of CE 240 
 * Renamed intermediate variables: 
[ (eq(239,1),it(223))>>s(200)]

#### Simplifying cost structure of CE 239 
 * Renamed intermediate variables: 
[ (eq(241,1),it(223))>>s(201)]
 * Renamed intermediate variables: 
[ (eq(241,2),it(226))>>s(202)]

#### Simplifying cost structure of CE 241 
 * Renamed intermediate variables: 
[ (eq(242,1),it(223))>>s(203)]
 * Renamed intermediate variables: 
[ (eq(242,2),it(226))>>s(204)]

#### Simplifying cost structure of CE 242 

#### Cost of chains of slice(A,B,C,D,E,F):
* Chain [234]: 13
  with precondition: [A=1,B=0,E=1,F=0,C>=1,D+1>=C] 

* Chain [233]: 20
  with precondition: [C=1,D=0,E=1,F=0,A>=2,B>=1] 

* Chain [232]: 10*s(197)+16
  Such that:s(197) =< A

  with precondition: [C=1,A=E,B=F,A>=2,B+1>=A,D+1>=A] 

* Chain [231]: 10*s(198)+20
  Such that:s(198) =< D+1

  with precondition: [C=1,D+1=E,D>=1,A>=D+2,F>=D,B>=F+1] 

* Chain [230]: 9*s(199)+20
  Such that:s(199) =< D

  with precondition: [E=1,F=0,C=D+1,C>=2,A>=C+1,B>=C] 

* Chain [229]: 9*s(200)+13
  Such that:s(200) =< A

  with precondition: [E=1,F=0,A>=2,B+1>=A,C>=A,D+1>=C] 

* Chain [228]: 9*s(201)+10*s(202)+16
  Such that:s(202) =< A-C+1
s(201) =< C

  with precondition: [C+E=A+1,C>=2,D+1>=A,A>=C+1,C+F>=A,B+1>=C+F] 

* Chain [227]: 9*s(203)+10*s(204)+20
  Such that:s(204) =< -C+D+2
s(203) =< C

  with precondition: [C+E=D+2,C>=2,D>=C,A>=D+2,B>=C+F,C+F>=D+1] 


Closed-form bounds of last(A,B,C,D): 
-------------------------------------
* Chain [[142],140] with precondition: [C=1,A>=3,D>=2,B+2>=A+D] 
    - Upper bound: 7*A+6 
    - Complexity: n 
* Chain [141] with precondition: [A=1,B=0,C=1,D=0] 
    - Upper bound: 3 
    - Complexity: constant 
* Chain [140] with precondition: [A=2,C=1,B=D,B>=1] 
    - Upper bound: 6 
    - Complexity: constant 

### Maximum cost of last(A,B,C,D): 7*A+6 
Asymptotic class: n 

Closed-form bounds of last_two(A,B,C,D,E): 
-------------------------------------
* Chain [[143],144] with precondition: [C=1,D=1,A>=4,E>=3,B+3>=A+E] 
    - Upper bound: 10*A+10 
    - Complexity: n 
* Chain [146] with precondition: [A=1,B=0,C=0,D=1,E=0] 
    - Upper bound: 3 
    - Complexity: constant 
* Chain [145] with precondition: [A=2,C=0,D=1,E=0,B>=1] 
    - Upper bound: 6 
    - Complexity: constant 
* Chain [144] with precondition: [A=3,C=1,D=1,B=E,B>=2] 
    - Upper bound: 10 
    - Complexity: constant 

### Maximum cost of last_two(A,B,C,D,E): 10*A+10 
Asymptotic class: n 

Closed-form bounds of at(A,B,C,D,E): 
-------------------------------------
* Chain [[96],95] with precondition: [D=1,A>=1,E>=1,B>=A+2,C>=A+E] 
    - Upper bound: 9*A+7 
    - Complexity: n 
* Chain [[96],94] with precondition: [D=1,E=0,B>=2,A+1>=B,C+1>=B] 
    - Upper bound: 9*B+3 
    - Complexity: n 
* Chain [95] with precondition: [A=0,D=1,B>=2,E>=1,C>=E] 
    - Upper bound: 7 
    - Complexity: constant 
* Chain [94] with precondition: [B=1,C=0,D=1,E=0,A>=0] 
    - Upper bound: 3 
    - Complexity: constant 

### Maximum cost of at(A,B,C,D,E): max([9*A+4,9*B])+3 
Asymptotic class: n 

Closed-form bounds of lengthL(A,B,C,D,E,F): 
-------------------------------------
* Chain [150] with precondition: [A=1,C=1,D=0,E=0,F=0,B>=0] 
    - Upper bound: 4 
    - Complexity: constant 
* Chain [149] with precondition: [A=C,A=E+1,A=F+1,A>=2,B>=0,D+1>=A] 
    - Upper bound: 6*C+4 
    - Complexity: n 

### Maximum cost of lengthL(A,B,C,D,E,F): 6*C+4 
Asymptotic class: n 

Closed-form bounds of rev(A,B,C,D,E,F,G,H): 
-------------------------------------
* Chain [137] with precondition: [A=1,C=1,D=0,E=1,G=1,H=0,B>=0,F>=0] 
    - Upper bound: 4 
    - Complexity: constant 
* Chain [136] with precondition: [A=C,A=E,A=G,D=H,A>=2,B>=0,F>=0,D+1>=A] 
    - Upper bound: 5*C+4 
    - Complexity: n 

### Maximum cost of rev(A,B,C,D,E,F,G,H): 5*C+4 
Asymptotic class: n 

Closed-form bounds of eq_lists(A,B,C,D,E): 
-------------------------------------
* Chain [[125,126,127],130] with precondition: [A=C,1>=E,A>=2,B>=0,D>=0,E>=0,B+D+E>=1] 
    - Upper bound: 9*A+9*B+9*D+5 
    - Complexity: n 
* Chain [[125,126,127],129] with precondition: [E=0,A>=2,B>=0,D>=0,C>=A+1] 
    - Upper bound: 9*A+9*B+9*D+6 
    - Complexity: n 
* Chain [[125,126,127],128] with precondition: [E=0,B>=0,C>=2,D>=0,A>=C+1] 
    - Upper bound: 9*A+9*B+9*D+6 
    - Complexity: n 
* Chain [130] with precondition: [A=1,C=1,E=1,B>=0,D>=0] 
    - Upper bound: 5 
    - Complexity: constant 
* Chain [129] with precondition: [A=1,E=0,B>=0,C>=2,D>=0] 
    - Upper bound: 6 
    - Complexity: constant 
* Chain [128] with precondition: [C=1,E=0,A>=2,B>=0,D>=0] 
    - Upper bound: 6 
    - Complexity: constant 

### Maximum cost of eq_lists(A,B,C,D,E): 9*A+9*B+9*D+6 
Asymptotic class: n 

Closed-form bounds of is_palindrome(A,B,C): 
-------------------------------------
* Chain [139] with precondition: [A=1,C=1,B>=0] 
    - Upper bound: 11 
    - Complexity: constant 
* Chain [138] with precondition: [1>=C,A>=2,B>=0,C>=0] 
    - Upper bound: 23*A+9*B+11 
    - Complexity: n 

### Maximum cost of is_palindrome(A,B,C): 23*A+9*B+11 
Asymptotic class: n 

Closed-form bounds of compress(A,B,C,D): 
-------------------------------------
* Chain [[97,98],99] with precondition: [A>=3,C>=2,A>=C,B+2>=C,D+2>=C] 
    - Upper bound: 10*A+11*B+7 
    - Complexity: n 
* Chain [100] with precondition: [A=1,C=1,B>=0,D>=0] 
    - Upper bound: 3 
    - Complexity: constant 
* Chain [99] with precondition: [A=2,C=2,B>=0,D>=0] 
    - Upper bound: 7 
    - Complexity: constant 

### Maximum cost of compress(A,B,C,D): 10*A+11*B+7 
Asymptotic class: n 

Closed-form bounds of pack(A,B,C,D,E): 
-------------------------------------
* Chain [191] with precondition: [A=1,C=1,D=0,B>=0,E>=0] 
    - Upper bound: 6 
    - Complexity: constant 
* Chain [190] with precondition: [A=2,C=2,D=2,B>=0,E>=0] 
    - Upper bound: 10 
    - Complexity: constant 
* Chain [189] with precondition: [A+C=D+2,A>=3,C>=2,A>=C,B+2>=C,E+2>=C] 
    - Upper bound: 10*A+12*B+10 
    - Complexity: n 

### Maximum cost of pack(A,B,C,D,E): 10*A+12*B+10 
Asymptotic class: n 

Closed-form bounds of encode(A,B,C,D,E): 
-------------------------------------
* Chain [117] with precondition: [A=1,C=0,D=1,B>=0,E>=0] 
    - Upper bound: 6 
    - Complexity: constant 
* Chain [116] with precondition: [A=2,C=1,D=2,B>=0,E>=1] 
    - Upper bound: 12 
    - Complexity: constant 
* Chain [115] with precondition: [C+1=D,A>=3,C>=1,A>=C+1,B+1>=C,E+2>=A+C] 
    - Upper bound: 11*A+14*B+12 
    - Complexity: n 

### Maximum cost of encode(A,B,C,D,E): 11*A+14*B+12 
Asymptotic class: n 

Closed-form bounds of duplicate(A,B,C,D): 
-------------------------------------
* Chain [[109],110] with precondition: [D=2*B,2*A=C+1,A>=2,D+2>=2*A] 
    - Upper bound: 6*A+3 
    - Complexity: n 
* Chain [110] with precondition: [A=1,B=0,C=1,D=0] 
    - Upper bound: 3 
    - Complexity: constant 

### Maximum cost of duplicate(A,B,C,D): 6*A+3 
Asymptotic class: n 

Closed-form bounds of replicate(A,B,C,D,E): 
-------------------------------------
* Chain [202] with precondition: [A=1,B=0,D=1,E=0,C>=0] 
    - Upper bound: 9 
    - Complexity: constant 
* Chain [201] with precondition: [C=0,D=1,E=0,A>=2,B+1>=A] 
    - Upper bound: 13*A+9 
    - Complexity: n 
* Chain [200] with precondition: [A>=2,C>=1,B+1>=A,D+1>=A+C,A+E>=B+D] 
    - Upper bound: 13*A+9+7*C*A 
    - Complexity: n^2 

### Maximum cost of replicate(A,B,C,D,E): 7*C*A+13*A+9 
Asymptotic class: n^2 

Closed-form bounds of drop(A,B,C,D,E): 
-------------------------------------
* Chain [108] with precondition: [A=1,B=0,D=1,E=0,C>=0] 
    - Upper bound: 5 
    - Complexity: constant 
* Chain [107] with precondition: [C=0,A=D,B=E,A>=2,B+1>=A] 
    - Upper bound: 9*A+5 
    - Complexity: n 
* Chain [106] with precondition: [C=1,D=1,E=0,A>=2,B+1>=A] 
    - Upper bound: 7*A+5 
    - Complexity: n 

### Maximum cost of drop(A,B,C,D,E): 9*A+5 
Asymptotic class: n 

Closed-form bounds of split(A,B,C,D,E,F): 
-------------------------------------
* Chain [213] with precondition: [A=1,B=0,D=1,E=2,F=0,C>=0] 
    - Upper bound: 11 
    - Complexity: constant 
* Chain [212] with precondition: [C=0,D=1,A+1=E,B=F,A>=2,B>=1] 
    - Upper bound: 14 
    - Complexity: constant 
* Chain [211] with precondition: [D=1,A+1=E,B=F,A>=2,B+1>=A,C+1>=A] 
    - Upper bound: 15*A+16 
    - Complexity: n 
* Chain [210] with precondition: [D=1,A+1=E,B=F,C>=1,A>=C+2,B>=C+1] 
    - Upper bound: 15*C+19 
    - Complexity: n 

### Maximum cost of split(A,B,C,D,E,F): max([15*C+8,15*A+5])+11 
Asymptotic class: n 

Closed-form bounds of slice(A,B,C,D,E,F): 
-------------------------------------
* Chain [234] with precondition: [A=1,B=0,E=1,F=0,C>=1,D+1>=C] 
    - Upper bound: 13 
    - Complexity: constant 
* Chain [233] with precondition: [C=1,D=0,E=1,F=0,A>=2,B>=1] 
    - Upper bound: 20 
    - Complexity: constant 
* Chain [232] with precondition: [C=1,A=E,B=F,A>=2,B+1>=A,D+1>=A] 
    - Upper bound: 10*A+16 
    - Complexity: n 
* Chain [231] with precondition: [C=1,D+1=E,D>=1,A>=D+2,F>=D,B>=F+1] 
    - Upper bound: 10*D+30 
    - Complexity: n 
* Chain [230] with precondition: [E=1,F=0,C=D+1,C>=2,A>=C+1,B>=C] 
    - Upper bound: 9*D+20 
    - Complexity: n 
* Chain [229] with precondition: [E=1,F=0,A>=2,B+1>=A,C>=A,D+1>=C] 
    - Upper bound: 9*A+13 
    - Complexity: n 
* Chain [228] with precondition: [C+E=A+1,C>=2,D+1>=A,A>=C+1,C+F>=A,B+1>=C+F] 
    - Upper bound: 10*A-C+26 
    - Complexity: n 
* Chain [227] with precondition: [C+E=D+2,C>=2,D>=C,A>=D+2,B>=C+F,C+F>=D+1] 
    - Upper bound: -C+10*D+40 
    - Complexity: n 

### Maximum cost of slice(A,B,C,D,E,F): max([10*A+3,max([10*D+17,9*C+3+max([-10*C+10*D+24,nat(A-C+1)*10])])])+13 
Asymptotic class: n 

Closed-form bounds of concat(A,B,C,D,E,F,G,H,I,J,K,L): 
-------------------------------------
* Chain [[101],102] with precondition: [A=C,L=D+H,A+E=I+1,A+G=K+1,A>=2,B>=0,E>=1,F>=0,G>=1,J>=0,D+1>=A,L>=D,B+F>=J] 
    - Upper bound: 5*A+2 
    - Complexity: n 
* Chain [102] with precondition: [A=1,C=1,D=0,E=I,F=J,G=K,H=L,B>=0,E>=0,F>=0,G>=0,H>=0] 
    - Upper bound: 2 
    - Complexity: constant 

### Maximum cost of concat(A,B,C,D,E,F,G,H,I,J,K,L): 5*A+2 
Asymptotic class: n 

Closed-form bounds of rotate(A,B,C,D,E): 
-------------------------------------
* Chain [220] with precondition: [A=1,B=0,D=1,E=0,C>=0] 
    - Upper bound: 16 
    - Complexity: constant 
* Chain [219] with precondition: [A=D,B=E,A>=2,C>=0,B+1>=A] 
    - Upper bound: 59*A+10*B+30*C+60 
    - Complexity: n 

### Maximum cost of rotate(A,B,C,D,E): 59*A+10*B+30*C+60 
Asymptotic class: n 

Closed-form bounds of removeAt(A,B,C,D,E): 
-------------------------------------
* Chain [[194],193] with precondition: [B=D+1,A>=2,B>=A+1,E+1>=A,C>=E+1] 
    - Upper bound: 10*A+6 
    - Complexity: n 
* Chain [[194],192] with precondition: [E=C,B=D,B>=2,A>=B,E+1>=B] 
    - Upper bound: 10*A+3 
    - Complexity: n 
* Chain [193] with precondition: [A=1,B=D+1,B>=2,E>=0,C>=E+1] 
    - Upper bound: 6 
    - Complexity: constant 
* Chain [192] with precondition: [B=1,C=0,D=1,E=0,A>=0] 
    - Upper bound: 3 
    - Complexity: constant 

### Maximum cost of removeAt(A,B,C,D,E): 10*A+6 
Asymptotic class: n 

Closed-form bounds of insertAt(A,B,C,D,E,F): 
-------------------------------------
* Chain [[133],132] with precondition: [C+1=E,A+D=F,A>=1,B>=2,C>=B+1,F>=A+B] 
    - Upper bound: 10*B+8 
    - Complexity: n 
* Chain [[133],131] with precondition: [F=D,C=E,A>=0,C>=2,B>=C,F+1>=C] 
    - Upper bound: 10*B+3 
    - Complexity: n 
* Chain [132] with precondition: [B=1,C+1=E,A+D=F,A>=1,C>=2,D>=1] 
    - Upper bound: 8 
    - Complexity: constant 
* Chain [131] with precondition: [C=1,D=0,E=1,F=0,A>=0,B>=0] 
    - Upper bound: 3 
    - Complexity: constant 

### Maximum cost of insertAt(A,B,C,D,E,F): 10*B+8 
Asymptotic class: n 

Closed-form bounds of minusminus(A,B,C,D): 
-------------------------------------
* Chain [156] with precondition: [B+2=A+C,A>=0,B>=A,D>=B] 
    - Upper bound: -6*A+6*B+12 
    - Complexity: n 
* Chain [155] with precondition: [B+C=A+2,B>=0,D>=0,A>=B+1] 
    - Upper bound: 11*A-11*B+27 
    - Complexity: n 

### Maximum cost of minusminus(A,B,C,D): max([nat(-A+B+1)*6,nat(A-B+1)*6+5+nat(A-B+2)*5])+6 
Asymptotic class: n 

Closed-form bounds of randomL(A,B): 
-------------------------------------
* Chain [165] with precondition: [A>=0,B>=0] 
    - Upper bound: 2 
    - Complexity: constant 

### Maximum cost of randomL(A,B): 2 
Asymptotic class: constant 

Closed-form bounds of minL(A,B,C): 
-------------------------------------
* Chain [160] with precondition: [A=C,A>=0,B>=A+1] 
    - Upper bound: 2 
    - Complexity: constant 
* Chain [159] with precondition: [B=C,B>=0,A>=B] 
    - Upper bound: 2 
    - Complexity: constant 

### Maximum cost of minL(A,B,C): 2 
Asymptotic class: constant 

Closed-form bounds of rand_select(A,B,C,D,E): 
-------------------------------------
* Chain [178] with precondition: [A=1,D=1,B>=0,C>=0,E>=0] 
    - Upper bound: 15 
    - Complexity: constant 
* Chain [177] with precondition: [C=0,D=1,A>=2,B>=0,E>=0] 
    - Upper bound: 6*A+15 
    - Complexity: n 
* Chain [176] with precondition: [C+1=D,B>=0,C>=1,E>=0,A>=C+2] 
    - Upper bound: 10*A-10*C+10+ (42*A+39+60*A*C+280*C) 
    - Complexity: n^2 
* Chain [175] with precondition: [A=D,A>=2,B>=0,E>=0,C+1>=A] 
    - Upper bound: 322*A+59+60*A*A 
    - Complexity: n^2 

### Maximum cost of rand_select(A,B,C,D,E): 36*A+24+max([280*A+20+60*A*A,60*A*C+280*C+nat(A-C+1)*10])+6*A+15 
Asymptotic class: n^2 

Closed-form bounds of lotto_select(A,B,C,D): 
-------------------------------------
* Chain [184] with precondition: [A=0,B=0,C=1,D>=0] 
    - Upper bound: 74 
    - Complexity: constant 
* Chain [183] with precondition: [A=0,C=1,B>=1,D>=0] 
    - Upper bound: 12*B+30 
    - Complexity: n 
* Chain [182] with precondition: [A=1,B=0,C=2,D>=0] 
    - Upper bound: 696 
    - Complexity: constant 
* Chain [181] with precondition: [B=0,C=3,A>=2,D>=0] 
    - Upper bound: 1606 
    - Complexity: constant 
* Chain [180] with precondition: [B+1=C,B>=1,D>=0,A>=B] 
    - Upper bound: 328*B+390+ (60*B+60)* (B+1) 
    - Complexity: n^2 
* Chain [179] with precondition: [A+1=C,A>=1,D>=0,B>=A+1] 
    - Upper bound: 280*A+48*B+90+ (60*B+60)*A+ (-10*A+10*B+20) 
    - Complexity: n^2 

### Maximum cost of lotto_select(A,B,C,D): max([1582,36*B+60+max([280*B+300+ (60*B+60)* (B+1), (60*B+60)*A+280*A+nat(-A+B+2)*10])+ (12*B+6)])+24 
Asymptotic class: n^2 
* Total analysis performed in 8655 ms.


Cost relation system solved by CoFloCo in 8661 ms.

Method last terminates?: YES

 - l_1: size of l wrt. List<A>
 - l_2: size of l wrt. A
UB for last(l_1,l_2) = 7*l_1+6

Method last_two terminates?: YES

 - l_1: size of l wrt. List<A>
 - l_2: size of l wrt. A
UB for last_two(l_1,l_2) = 10*l_1+10

Method at terminates?: YES

 - k_1: size of k wrt. Rat
 - l_1: size of l wrt. List<A>
 - l_2: size of l wrt. A
UB for at(k_1,l_1,l_2) = max([9*k_1+4,9*l_1])+3

Method lengthL terminates?: YES

 - list_1: size of list wrt. List<Rat>
 - list_2: size of list wrt. Rat
 - list_3: size of list wrt. List<A>
 - list_4: size of list wrt. A
UB for lengthL(list_1,list_2,list_3,list_4) = 6*list_3+4

Method rev terminates?: YES

 - l_1: size of l wrt. List<Rat>
 - l_2: size of l wrt. Rat
 - l_3: size of l wrt. List<A>
 - l_4: size of l wrt. A
UB for rev(l_1,l_2,l_3,l_4) = 5*l_3+4

Method eq_lists terminates?: YES

 - l1_1: size of l1 wrt. List<Rat>
 - l1_2: size of l1 wrt. Rat
 - l2_1: size of l2 wrt. List<Rat>
 - l2_2: size of l2 wrt. Rat
UB for eq_lists(l1_1,l1_2,l2_1,l2_2) = 9*l1_1+9*l1_2+9*l2_2+6

Method is_palindrome terminates?: YES

 - list_1: size of list wrt. List<Rat>
 - list_2: size of list wrt. Rat
UB for is_palindrome(list_1,list_2) = 23*list_1+9*list_2+11

Method compress terminates?: YES

 - l_1: size of l wrt. List<Rat>
 - l_2: size of l wrt. Rat
UB for compress(l_1,l_2) = 10*l_1+11*l_2+7

Method pack terminates?: YES

 - list_1: size of list wrt. List<Rat>
 - list_2: size of list wrt. Rat
UB for pack(list_1,list_2) = 10*list_1+12*list_2+10

Method encode terminates?: YES

 - list_1: size of list wrt. List<Rat>
 - list_2: size of list wrt. Rat
UB for encode(list_1,list_2) = 11*list_1+14*list_2+12

Method duplicate terminates?: YES

 - list_1: size of list wrt. List<A>
 - list_2: size of list wrt. A
UB for duplicate(list_1,list_2) = 6*list_1+3

Method replicate terminates?: YES

 - list_1: size of list wrt. List<A>
 - list_2: size of list wrt. A
 - n_1: size of n wrt. Rat
UB for replicate(list_1,list_2,n_1) = 7*n_1*list_1+13*list_1+9

Method drop terminates?: YES

 - list_1: size of list wrt. List<A>
 - list_2: size of list wrt. A
 - n_1: size of n wrt. Rat
UB for drop(list_1,list_2,n_1) = 9*list_1+5

Method split terminates?: YES

 - list_1: size of list wrt. List<A>
 - list_2: size of list wrt. A
 - n_1: size of n wrt. Rat
UB for split(list_1,list_2,n_1) = max([15*n_1+8,15*list_1+5])+11

Method slice terminates?: YES

 - list_1: size of list wrt. List<A>
 - list_2: size of list wrt. A
 - b_1: size of b wrt. Rat
 - e_1: size of e wrt. Rat
UB for slice(list_1,list_2,b_1,e_1) = max([10*list_1+3,max([10*e_1+17,9*b_1+3+max([-10*b_1+10*e_1+24,nat(list_1-b_1+1)*10])])])+13

Method concat terminates?: YES

 - l1_1: size of l1 wrt. List<Rat>
 - l1_2: size of l1 wrt. Rat
 - l1_3: size of l1 wrt. List<A>
 - l1_4: size of l1 wrt. A
 - l2_1: size of l2 wrt. List<Rat>
 - l2_2: size of l2 wrt. Rat
 - l2_3: size of l2 wrt. List<A>
 - l2_4: size of l2 wrt. A
UB for concat(l1_1,l1_2,l1_3,l1_4,l2_1,l2_2,l2_3,l2_4) = 5*l1_1+2

Method rotate terminates?: YES

 - list_1: size of list wrt. List<A>
 - list_2: size of list wrt. A
 - n_1: size of n wrt. Rat
UB for rotate(list_1,list_2,n_1) = 59*list_1+10*list_2+30*n_1+60

Method removeAt terminates?: YES

 - n_1: size of n wrt. Rat
 - l_1: size of l wrt. List<A>
 - l_2: size of l wrt. A
UB for removeAt(n_1,l_1,l_2) = 10*n_1+6

Method insertAt terminates?: YES

 - x_1: size of x wrt. A
 - n_1: size of n wrt. Rat
 - l_1: size of l wrt. List<A>
 - l_2: size of l wrt. A
UB for insertAt(x_1,n_1,l_1,l_2) = 10*n_1+8

Method minusminus terminates?: YES

 - a_1: size of a wrt. Rat
 - b_1: size of b wrt. Rat
UB for minusminus(a_1,b_1) = max([nat(-a_1+b_1+1)*6,nat(a_1-b_1+1)*6+5+nat(a_1-b_1+2)*5])+6

Method randomL terminates?: YES

 - n_1: size of n wrt. Rat
UB for randomL(n_1) = 2

Method minL terminates?: YES

 - m_1: size of m wrt. Rat
 - n_1: size of n wrt. Rat
UB for minL(m_1,n_1) = 2

Method rand_select terminates?: YES

 - list_1: size of list wrt. List<Rat>
 - list_2: size of list wrt. Rat
 - n_1: size of n wrt. Rat
UB for rand_select(list_1,list_2,n_1) = 36*list_1+24+max([280*list_1+20+60*list_1*list_1,60*list_1*n_1+280*n_1+nat(list_1-n_1+1)*10])+6*list_1+15

Method lotto_select terminates?: YES

 - n_1: size of n wrt. Rat
 - m_1: size of m wrt. Rat
UB for lotto_select(n_1,m_1) = max([1582,36*m_1+60+max([280*m_1+300+ (60*m_1+60)* (m_1+1), (60*m_1+60)*n_1+280*n_1+nat(-n_1+m_1+2)*10])+ (12*m_1+6)])+24
