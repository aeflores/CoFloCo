
Abs program loaded in 25 ms.

Rule based representation generated in 8 ms.

Rule based representation stored in /tmp/costabs/rbr.rbr

RBR properties stored in /tmp/costabs/rbr.properties

Class invariants generated and loaded in 1 ms.

Abstract compilation performed in 69 ms.

Cost relation system stored in /tmp/costabs/crs.crs

Generated 56 equations 
entry('dfs'(A,B,C,D,E,F):[]).
entry('make_btree'(A,B,C,D):[]).
entry('append_rev'(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O):[]).
entry('revL'(A,B,C,D,E,F,G,H,I,J):[]).
entry('bfs'(A,B,C,D,E,F):[]).
input_output_vars('and_op'(A,B,C),[A,B],[C]).
input_output_vars('append_rev'(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O),[A,B,C,D,E,F,G,H,I,J],[K,L,M,N,O]).
input_output_vars('bfs'(A,B,C,D,E,F),[A,B,C],[D,E,F]).
input_output_vars('bfs_aux'(A,B,C,D,E,F,G,H,I),[A,B,C,D,E,F,G],[H,I]).
input_output_vars('case_0'(A,B,C,D,E,F,G),[A,B,C,D],[E,F,G]).
input_output_vars('case_1'(A,B,C,D,E,F,G,H,I,J,K,L),[A,B,C,D,E,F,G,H,I],[J,K,L]).
input_output_vars('case_10'(A,B,C,D,E,F,G,H,I),[A,B,C,D,E,F,G],[H,I]).
input_output_vars('case_11'(A,B,C,D,E,F,G,H,I,J,K,L,M,N),[A,B,C,D,E,F,G,H,I,J,K,L],[M,N]).
input_output_vars('case_12'(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S),[A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q],[R,S]).
input_output_vars('case_13'(A,B,C,D,E,F,G,H),[A,B,C,D,E],[F,G,H]).
input_output_vars('case_2'(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q),[A,B,C,D,E,F,G,H,I,J,K,L,M,N],[O,P,Q]).
input_output_vars('case_3'(A,B,C,D,E),[A,B],[C,D,E]).
input_output_vars('case_4'(A,B,C,D,E,F,G,H),[A,B,C,D,E],[F,G,H]).
input_output_vars('case_5'(A,B,C,D,E,F,G,H,I,J,K,L,M,N),[A,B,C,D,E,F,G,H,I,J,K],[L,M,N]).
input_output_vars('case_6'(A,B,C,D),[A,B],[C,D]).
input_output_vars('case_7'(A,B,C,D,E,F,G,H,I,J),[A,B,C,D,E,F,G,H],[I,J]).
input_output_vars('case_8'(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O),[A,B,C,D,E,F,G,H,I,J],[K,L,M,N,O]).
input_output_vars('case_9'(A,B,C,D,E,F,G,H,I),[A,B,C,D,E,F,G],[H,I]).
input_output_vars('dfs'(A,B,C,D,E,F),[A,B,C],[D,E,F]).
input_output_vars('dfs_aux'(A,B,C,D,E,F,G),[A,B,C,D],[E,F,G]).
input_output_vars('eq'(A,B,C),[A,B],[C]).
input_output_vars('geq'(A,B,C),[A,B],[C]).
input_output_vars('gt'(A,B,C),[A,B],[C]).
input_output_vars('leq'(A,B,C),[A,B],[C]).
input_output_vars('lt'(A,B,C),[A,B],[C]).
input_output_vars('make_btree'(A,B,C,D),[A,B],[C,D]).
input_output_vars('maxNorm'(A,B,C),[A,B],[C]).
input_output_vars('neg'(A,B),[A],[B]).
input_output_vars('neq'(A,B,C),[A,B],[C]).
input_output_vars('or'(A,B,C),[A,B],[C]).
input_output_vars('revL'(A,B,C,D,E,F,G,H,I,J),[A,B,C,D,E],[F,G,H,I,J]).
input_output_vars('split'(A,B,C,D,E),[A,B],[C,D,E]).
eq('eq',[A,B,C],0,[],[A=B,C=1,A>=0,B>=0,C>=0]).
eq('eq',[A,B,C],0,[],[A>=B+1,C=0,A>=0,B>=0,C>=0]).
eq('eq',[A,B,C],0,[],[B>=A+1,C=0,A>=0,B>=0,C>=0]).
eq('neq',[A,B,C],0,[],[A=B,C=0,A>=0,B>=0,C>=0]).
eq('neq',[A,B,C],0,[],[A>=B+1,C=1,A>=0,B>=0,C>=0]).
eq('neq',[A,B,C],0,[],[B>=A+1,C=1,A>=0,B>=0,C>=0]).
eq('lt',[A,B,C],0,[],[B-A>=1,C=1,A>=0,B>=0,C>=0]).
eq('lt',[A,B,C],0,[],[B=<A,C=0,A>=0,B>=0,C>=0]).
eq('leq',[A,B,C],0,[],[A=<B,C=1,A>=0,B>=0,C>=0]).
eq('leq',[A,B,C],0,[],[A-B>=1,C=0,A>=0,B>=0,C>=0]).
eq('gt',[A,B,C],0,[],[A-B>=1,C=1,A>=0,B>=0,C>=0]).
eq('gt',[A,B,C],0,[],[A=<B,C=0,A>=0,B>=0,C>=0]).
eq('geq',[A,B,C],0,[],[B=<A,C=1,A>=0,B>=0,C>=0]).
eq('geq',[A,B,C],0,[],[B-A>=1,C=0,A>=0,B>=0,C>=0]).
eq('neg',[A,B],0,[],[A=0,B=1,A>=0,B>=0]).
eq('neg',[A,B],0,[],[A=1,B=0,A>=0,B>=0]).
eq('and_op',[A,B,C],0,[],[A=0,C=0,A>=0,B>=0,C>=0]).
eq('and_op',[A,B,C],0,[],[A=1,C=B,A>=0,B>=0,C>=0]).
eq('or',[A,B,C],0,[],[A=1,C=1,A>=0,B>=0,C>=0]).
eq('or',[A,B,C],0,[],[A=0,C=B,A>=0,B>=0,C>=0]).
eq('maxNorm',[A,B,A],0,[],[A>=1+B,A>=0,B>=0,A>=0]).
eq('maxNorm',[A,B,B],0,[],[A=<B,A>=0,B>=0,B>=0]).
eq('case_0',[A,B,C,D,E,F,G],2,[],[C=0,A=1,G=0,E=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0]).
eq('case_1',[A,B,C,D,E,F,G,H,I,J,K,L],2,['dfs_aux'(G,H,I,D,J,K,L)],[F=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0]).
eq('case_2',[A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q],2,[],[J=D,Q=F,P=E,O=1,F>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0,M>=0,N>=0,O>=0,P>=0,Q>=0]).
eq('case_2',[A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q],4,['dfs_aux'(R,S,T,D,O,P,Q)],[J>=D+1,U=N+I,V=M+H,W=G+1,G>=1,N>=1,T=L+U,S=K+V,R=W+1,W>=1,L>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0,M>=0,N>=0,O>=0,P>=0,Q>=0]).
eq('case_1',[A,B,C,D,E,F,G,H,I,J,K,L],3,['case_2'(A,B,C,D,E,F,G,H,I,M,N,O,P,Q,J,K,L)],[F=Q+O+1,E=M+N+P,Q>=1,O>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0]).
eq('case_0',[A,B,C,D,E,F,G],3,['case_1'(A,B,C,D,H,I,J,K,L,E,F,G)],[C=I+L,B=H+K,A=J+1,J>=1,I>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0]).
eq('dfs_aux',[A,B,C,D,E,F,G],1,['case_0'(A,B,C,D,E,F,G)],[A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0]).
eq('dfs',[A,B,C,D,E,F],3,['dfs_aux'(G,H,I,C,D,E,F)],[J=0,K=1,I=B+J,H=A+L,G=K+1,K>=1,B>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0]).
eq('case_3',[A,B,C,D,E],4,[],[A=1,F=1,G=1,E=H+I,D=F+G,C=1,G>=1,F>=1,A>=0,B>=0,C>=0,D>=0,E>=0]).
eq('case_4',[A,B,C,D,E,F,G,H],5,[],[D=1,I=1,J=C+K,L=I+1,I>=1,M=1,H=J+N,G=L+M,F=1,M>=1,L>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0]).
eq('case_5',[A,B,C,D,E,F,G,H,I,J,K,L,M,N],4,[],[C=O+P,B=Q+R,A=1,R>=1,Q>=1,S=F+O,T=Q+1,Q>=1,U=I+P,V=R+1,R>=1,N=S+U,M=T+V,L=1,V>=1,T>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0,M>=0,N>=0]).
eq('case_4',[A,B,C,D,E,F,G,H],6,['split'(I,J,K,L,M),'case_5'(N,O,P,A,B,C,D,E,Q,I,J,R,S,T)],[E=Q+J,D=I+1,I>=1,P=M,O=L,N=K,K>=1,H=T,G=S,F=R,R>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0]).
eq('case_3',[A,B,C,D,E],3,['case_4'(A,B,F,G,H,C,D,E)],[B=F+H,A=G+1,G>=1,A>=0,B>=0,C>=0,D>=0,E>=0]).
eq('split',[A,B,C,D,E],1,['case_3'(A,B,C,D,E)],[A>=0,B>=0,C>=0,D>=0,E>=0]).
eq('case_6',[A,B,C,D],2,[],[A=1,D=1,A>=0,B>=0,C>=0,D>=0]).
eq('case_7',[A,B,C,D,E,F,G,H,I,J],4,['make_btree'(K,L,M,N),'make_btree'(O,P,Q,R)],[C=L+P,B=K+O,A=1,O>=1,K>=1,J=R+N+1,I=F+M+Q,R>=1,N>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0]).
eq('case_6',[A,B,C,D],6,['split'(E,F,G,H,I),'case_7'(J,K,L,A,B,M,E,F,N,O)],[B=M+F,A=E+1,E>=1,L=I,K=H,J=G,G>=1,D=O,C=N,O>=1,A>=0,B>=0,C>=0,D>=0]).
eq('make_btree',[A,B,C,D],1,['case_6'(A,B,C,D)],[A>=0,B>=0,C>=0,D>=0]).
eq('case_8',[A,B,C,D,E,F,G,H,I,J,A,B,C,D,E],1,[],[J=0,I=1,H=0,F=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,A>=0,B>=0,C>=0,D>=0,E>=0]).
eq('case_8',[A,B,C,D,E,F,G,H,I,J,K,L,M,N,O],4,['append_rev'(P,Q,R,S,T,U,V,W,X,Y,K,L,M,N,O)],[J=Z+Y,I=X+1,H=A1+W,G=B1+V,F=U+1,X>=1,U>=1,Z>=1,A1>=1,T=Z+E,S=D+1,R=A1+C,Q=B1+B,P=A+1,D>=1,A>=1,Z>=1,A1>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0,M>=0,N>=0,O>=0]).
eq('append_rev',[A,B,C,D,E,F,G,H,I,J,K,L,M,N,O],1,['case_8'(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O)],[A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0,M>=0,N>=0,O>=0]).
eq('revL',[A,B,C,D,E,F,G,H,I,J],2,['append_rev'(K,L,M,N,O,A,B,C,D,E,F,G,H,I,J)],[O=0,N=1,M=0,K=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0]).
eq('case_10',[A,B,C,D,E,F,G,H,I],2,[],[F=0,D=1,I=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0]).
eq('case_10',[A,B,C,D,E,F,G,H,I],5,['revL'(D,E,F,J,K,L,M,N,O,P),'bfs_aux'(L,M,N,Q,R,S,G,H,I)],[F=T+U,E=V+W,D=X+1,X>=1,T>=1,S=0,Q=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0]).
eq('case_9',[A,B,C,D,E,F,G,H,I],2,['case_10'(A,B,C,D,E,F,G,H,I)],[C=0,A=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0]).
eq('case_11',[A,B,C,D,E,F,G,H,I,J,K,L,M,N],2,['bfs_aux'(J,K,L,D,E,F,G,M,N)],[I=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0,M>=0,N>=0]).
eq('case_12',[A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S],2,[],[G=M,S=Q+O+1,R=M+N+P,Q>=1,O>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0,M>=0,N>=0,O>=0,P>=0,Q>=0,R>=0,S>=0]).
eq('case_12',[A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S],4,['bfs_aux'(J,K,L,T,U,V,G,R,S)],[G>=M+1,W=O+F,X=N+E,Y=D+1,D>=1,O>=1,V=Q+W,U=P+X,T=Y+1,Y>=1,Q>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0,M>=0,N>=0,O>=0,P>=0,Q>=0,R>=0,S>=0]).
eq('case_11',[A,B,C,D,E,F,G,H,I,J,K,L,M,N],3,['case_12'(A,B,C,D,E,F,G,H,I,J,K,L,O,P,Q,R,S,M,N)],[I=S+Q+1,H=O+P+R,S>=1,Q>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0,M>=0,N>=0]).
eq('case_9',[A,B,C,D,E,F,G,H,I],3,['case_11'(A,B,C,D,E,F,G,J,K,L,M,N,H,I)],[C=K+N,B=J+M,A=L+1,L>=1,K>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0]).
eq('bfs_aux',[A,B,C,D,E,F,G,H,I],1,['case_9'(A,B,C,D,E,F,G,H,I)],[A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0]).
eq('case_13',[A,B,C,D,E,F,G,H],2,[],[B=1,H=0,F=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0]).
eq('case_13',[A,B,C,D,E,F,G,H],4,[],[B=I+J+1,A=E+K+L,I>=1,J>=1,M=I+J+1,N=E+K+L,I>=1,J>=1,H=M,G=N,F=1,M>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0]).
eq('bfs',[A,B,C,D,E,F],5,['bfs_aux'(G,H,I,J,K,L,C,M,N),'case_13'(M,N,A,B,C,D,E,F)],[O=0,P=1,I=B+O,H=A+Q,G=P+1,P>=1,B>=1,L=0,J=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0]).

Preprocessing Cost Relations
=====================================

#### Computed strongly connected components 
0. recursive  : [append_rev/15,case_8/15]
1. non_recursive  : [revL/10]
2. recursive  : [bfs_aux/9,case_10/9,case_11/14,case_12/19,case_9/9]
3. non_recursive  : [case_13/8]
4. non_recursive  : [bfs/6]
5. recursive  : [case_0/7,case_1/12,case_2/17,dfs_aux/7]
6. non_recursive  : [dfs/6]
7. non_recursive  : [case_5/14]
8. recursive [non_tail] : [case_3/5,case_4/8,split/5]
9. recursive [multiple] : [case_6/4,case_7/10,make_btree/4]
Warning: the following predicates are never called:[and_op/3,eq/3,geq/3,gt/3,leq/3,lt/3,maxNorm/3,neg/2,neq/3,or/3]

#### Obtained direct recursion through partial evaluation 
0. SCC is partially evaluated into append_rev/15
1. SCC is partially evaluated into revL/10
2. SCC is partially evaluated into bfs_aux/9
3. SCC is partially evaluated into case_13/8
4. SCC is partially evaluated into bfs/6
5. SCC is partially evaluated into dfs_aux/7
6. SCC is partially evaluated into dfs/6
7. SCC is completely evaluated into other SCCs
8. SCC is partially evaluated into split/5
9. SCC is partially evaluated into make_btree/4

Control-Flow Refinement of Cost Relations
=====================================

### Specialization of cost equations append_rev/15 
* CE 5 is refined into CE [22] 
* CE 4 is refined into CE [23] 


#### Refined cost equations append_rev/15 
* CE 22: append_rev(A,B,C,D,E,F,G,H,I,J,A,B,C,D,E) = 2
     [G>=0,E>=0,D>=0,C>=0,B>=0,A>=0,J=0,I=1,H=0,F=1] 
* CE 23: append_rev(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O) = 5+ append_rev(P,Q,R,S,T,U,V,W,X,Y,K,L,M,N,O)
     [T+Y>=J,R+W>=H,Q+V>=G,J>=Y+1,H>=W+1,X>=1,U>=1,O>=0,N>=0,M>=0,L>=0,K>=0,J>=0,H>=0,G>=0,D>=1,A>=1,T+Y=E+J,R+W=C+H,Q+V=B+G,D+1=S,A+1=P,X+1=I,U+1=F] 

### Cost equations --> "Loop" of append_rev/15 
* CEs [23] --> Loop 22 
* CEs [22] --> Loop 23 

#### Loops of append_rev/15 
* Loop 22: append_rev(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O)->  append_rev(A',B',C',D',E',F',G',H',I',J',K,L,M,N,O)
                  [E'+J'>=J,C'+H'>=H,B'+G'>=G,J>=J'+1,H>=H'+1,I'>=1,F'>=1,O>=0,N>=0,M>=0,L>=0,K>=0,J>=0,H>=0,G>=0,D>=1,A>=1,E+J=E'+J',C+H=C'+H',B+G=B'+G',D+1=D',A+1=A',I'+1=I,F'+1=F] 
* Loop 23: append_rev(A,B,C,D,E,F,G,H,I,J,A,B,C,D,E) [G>=0,E>=0,D>=0,C>=0,B>=0,A>=0,J=0,I=1,H=0,F=1] 

### Ranking functions of CR append_rev(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O) 
* RF of phase [22]: [F-1,H+1,I-1,J+1]

#### Partial ranking functions of CR append_rev(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O) 
* Partial RF of phase [22]:
  - RF of loop [22:1]:
    F-1
    H+1
    I-1
    J+1

Discarded unfeasible chain [[22]]...(Non-terminating chain proved terminating)

### Resulting Chains:append_rev(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O) 
* [[22],23]
* [23]


### Merging Chains  append_rev/15 into  External patterns of execution 
* [[23]] --> 1 
* [[23,[22]]] --> 2 


### Specialization of cost equations revL/10 
* CE 6 is refined into CE [24,25] 


#### Refined cost equations revL/10 
* CE 24: revL(A,B,C,D,E,F,G,H,I,J) = 2+ append_rev(K,G,L,M,N,O,B,P,Q,R,S,G,T,U,V):1
     [G>=0,B>=0,V=0,U=1,T=0,S=1,R=0,Q=1,P=0,O=1,N=0,M=1,L=0,K=1,J=0,I=1,H=0,F=1,E=0,D=1,C=0,A=1] 
* CE 25: revL(A,B,C,A,D,A,E,C,A,D) = 2+ append_rev(F,G,H,I,J,A,B,C,A,D,A,E,C,A,D):2
     [B+G>=E,D+1>=A,C+1>=A,E>=0,A>=2,B>=0,G>=0,J=0,I=1,H=0,F=1] 

### Cost equations --> "Loop" of revL/10 
* CEs [25] --> Loop 24 
* CEs [24] --> Loop 25 

#### Loops of revL/10 
* Loop 24: revL(A,B,C,A,D,A,E,C,A,D) [D+1>=A,C+1>=A,E>=0,B>=0,A>=2] 
* Loop 25: revL(A,B,C,D,E,F,G,H,I,J) [G>=0,B>=0,J=0,I=1,H=0,F=1,E=0,D=1,C=0,A=1] 

### Ranking functions of CR revL(A,B,C,D,E,F,G,H,I,J) 

#### Partial ranking functions of CR revL(A,B,C,D,E,F,G,H,I,J) 


### Resulting Chains:revL(A,B,C,D,E,F,G,H,I,J) 
* [25]
* [24]


### Merging Chains  revL/10 into  External patterns of execution 
* [[25]] --> 1 
* [[24]] --> 2 


### Specialization of cost equations bfs_aux/9 
* CE 16 is refined into CE [26] 
* CE 19 is refined into CE [27] 
* CE 17 is refined into CE [28] 
* CE 15 is refined into CE [29] 
* CE 18 is refined into CE [30] 


#### Refined cost equations bfs_aux/9 
* CE 26: bfs_aux(A,B,C,D,E,F,G,H,I) = 9
     [C>=I,B>=H,H>=G,F+1>=D,I>=3,G>=0,E>=0,D>=1,A>=2] 
* CE 27: bfs_aux(A,B,C,D,E,F,G,H,I) = 5
     [H>=0,G>=0,E>=0,B>=0,I=1,F=0,D=1,C=0,A=1] 
* CE 28: bfs_aux(A,B,C,D,E,F,G,H,I) = 11+ bfs_aux(J,K,L,M,N,O,G,H,I)
     [G+K+N>=B+E+1,B+E>=K+N,C>=L+3,N>=E,F+1>=D,L>=0,K>=0,J>=1,I>=0,H>=0,E>=0,D>=1,L+O+1=C+F,D+2=M,J+1=A] 
* CE 29: bfs_aux(A,B,C,D,E,F,G,H,I) = 6+ bfs_aux(J,K,L,D,E,F,G,H,I)
     [B>=K,F+1>=D,L>=0,K>=0,J>=1,I>=0,H>=0,G>=0,E>=0,D>=1,L+1=C,J+1=A] 
* CE 30: bfs_aux(A,B,C,D,E,F,G,H,I) = 8+ revL(D,E,F,D,J,D,K,F,D,J):2+ bfs_aux(D,K,F,L,M,N,G,H,I)
     [J+1>=D,F+1>=D,K>=0,D>=2,E>=0,I>=0,H>=0,G>=0,B>=0,N=0,L=1,C=0,A=1] 

### Cost equations --> "Loop" of bfs_aux/9 
* CEs [28] --> Loop 26 
* CEs [29] --> Loop 27 
* CEs [30] --> Loop 28 
* CEs [26] --> Loop 29 
* CEs [27] --> Loop 30 

#### Loops of bfs_aux/9 
* Loop 26: bfs_aux(A,B,C,D,E,F,G,H,I)->  bfs_aux(A',B',C',D',E',F',G,H,I)
                  [G+B'+E'>=B+E+1,B+E>=B'+E',C>=C'+3,E'>=E,F+1>=D,C'>=0,B'>=0,I>=0,H>=0,E>=0,D>=1,A>=2,C+F=C'+F'+1,D+2=D',A=A'+1] 
* Loop 27: bfs_aux(A,B,C,D,E,F,G,H,I)->  bfs_aux(A',B',C',D,E,F,G,H,I)
                  [B>=B',F+1>=D,B'>=0,I>=0,H>=0,G>=0,E>=0,D>=1,C>=1,A>=2,C=C'+1,A=A'+1] 
* Loop 28: bfs_aux(A,B,C,D,E,F,G,H,I)->  bfs_aux(D,A',F,B',C',D',G,H,I)
                  [F+1>=D,A'>=0,I>=0,H>=0,G>=0,E>=0,D>=2,B>=0,D'=0,B'=1,C=0,A=1] 
* Loop 29: bfs_aux(A,B,C,D,E,F,G,H,I) [C>=I,B>=H,H>=G,F+1>=D,I>=3,G>=0,E>=0,D>=1,A>=2] 
* Loop 30: bfs_aux(A,B,C,D,E,F,G,H,I) [H>=0,G>=0,E>=0,B>=0,I=1,F=0,D=1,C=0,A=1] 

### Ranking functions of CR bfs_aux(A,B,C,D,E,F,G,H,I) 
* RF of phase [26,27,28]: [-2*A+3*C-D+3*F+4,-A+2*C+2*F+1,3*C+D+3*F-3]

#### Partial ranking functions of CR bfs_aux(A,B,C,D,E,F,G,H,I) 
* Partial RF of phase [26,27,28]:
  - RF of loop [26:1]:
    C+F-2
    C/3-2/3 depends on loops [28:1] 
    C/3-D/3+F/3-1/3 depends on loops [28:1] 
  - RF of loop [26:1,27:1]:
    A-1 depends on loops [28:1] 
  - RF of loop [27:1]:
    C depends on loops [28:1] 
    C+F
  - RF of loop [28:1]:
    -A+2 depends on loops [26:1,27:1] 
    -C+1 depends on loops [26:1,27:1] 
    D-1 depends on loops [26:1] 
    F depends on loops [26:1] 

Discarded unfeasible chain [[26,27,28]]...(Non-terminating chain proved terminating)

### Resulting Chains:bfs_aux(A,B,C,D,E,F,G,H,I) 
* [[26,27,28],30]
* [[26,27,28],29]
* [29]


### Merging Chains  bfs_aux/9 into  External patterns of execution 
* [[30,[26,27,28]]] --> 1 
* [[29,[26,27,28]]] --> 2 
* [[29]] --> 3 


### Specialization of cost equations case_13/8 
* CE 21 is refined into CE [31] 
* CE 20 is refined into CE [32] 


#### Refined cost equations case_13/8 
* CE 31: case_13(A,B,C,D,E,F,A,B) = 4
     [A>=0,E>=0,D>=1,C>=0,B>=3,F=1] 
* CE 32: case_13(A,B,C,D,E,F,G,H) = 2
     [G>=0,E>=0,D>=1,C>=0,A>=0,H=0,F=1,B=1] 

### Cost equations --> "Loop" of case_13/8 
* CEs [31] --> Loop 31 
* CEs [32] --> Loop 32 

#### Loops of case_13/8 
* Loop 31: case_13(A,B,C,D,E,F,A,B) [E>=0,D>=1,C>=0,B>=3,A>=0,F=1] 
* Loop 32: case_13(A,B,C,D,E,F,G,H) [G>=0,E>=0,D>=1,C>=0,A>=0,H=0,F=1,B=1] 

### Ranking functions of CR case_13(A,B,C,D,E,F,G,H) 

#### Partial ranking functions of CR case_13(A,B,C,D,E,F,G,H) 


### Resulting Chains:case_13(A,B,C,D,E,F,G,H) 
* [32]
* [31]


### Merging Chains  case_13/8 into  External patterns of execution 
* [[32]] --> 1 
* [[31]] --> 2 


### Specialization of cost equations bfs/6 
* CE 7 is refined into CE [33,34,35] 


#### Refined cost equations bfs/6 
* CE 33: bfs(A,B,C,D,E,F) = 5+ bfs_aux(G,H,B,I,J,K,C,L,M):1+ case_13(L,N,A,B,C,O,E,P):1
     [E>=0,C>=0,B>=1,A>=0,L>=0,J>=0,H>=0,P=0,O=1,N=1,M=1,K=0,I=1,G=2,F=0,D=1] 
* CE 34: bfs(A,B,C,D,E,F) = 5+ bfs_aux(G,H,B,I,J,K,C,E,F):2+ case_13(E,F,A,B,C,L,E,F):2
     [B>=F+1,E>=C,F>=3,C>=1,A>=0,J>=0,H>=0,L=1,K=0,I=1,G=2,D=1] 
* CE 35: bfs(A,B,C,D,E,F) = 5+ bfs_aux(G,H,B,I,J,K,C,E,F):3+ case_13(E,F,A,B,C,L,E,F):2
     [B>=F,H>=E,E>=C,F>=3,C>=0,A>=0,J>=0,L=1,K=0,I=1,G=2,D=1] 

### Cost equations --> "Loop" of bfs/6 
* CEs [34,35] --> Loop 33 
* CEs [33] --> Loop 34 

#### Loops of bfs/6 
* Loop 33: bfs(A,B,C,D,E,F) [B>=F,E>=C,F>=3,C>=0,A>=0,D=1] 
* Loop 34: bfs(A,B,C,D,E,F) [E>=0,C>=0,B>=1,A>=0,F=0,D=1] 

### Ranking functions of CR bfs(A,B,C,D,E,F) 

#### Partial ranking functions of CR bfs(A,B,C,D,E,F) 


### Resulting Chains:bfs(A,B,C,D,E,F) 
* [34]
* [33]


### Merging Chains  bfs/6 into  External patterns of execution 
* [[34]] --> 1 
* [[33]] --> 2 


### Specialization of cost equations dfs_aux/7 
* CE 9 is refined into CE [36] 
* CE 11 is refined into CE [37] 
* CE 10 is refined into CE [38] 
* CE 8 is refined into CE [39] 


#### Refined cost equations dfs_aux/7 
* CE 36: dfs_aux(A,B,C,D,E,F,G) = 9
     [C>=G,B>=F,F>=D,G>=3,D>=0,A>=2,E=1] 
* CE 37: dfs_aux(A,B,C,D,E,F,G) = 3
     [F>=0,D>=0,B>=0,G=0,E=1,C=0,A=1] 
* CE 38: dfs_aux(A,B,C,D,E,F,G) = 11+ dfs_aux(H,I,J,D,E,F,G)
     [B>=D+I+1,I>=0,G>=0,F>=0,E>=0,D>=0,C>=3,A>=2,C=J+1,A+1=H] 
* CE 39: dfs_aux(A,B,C,D,E,F,G) = 6+ dfs_aux(H,I,J,D,E,F,G)
     [B>=I,J>=0,I>=0,H>=1,G>=0,F>=0,E>=0,D>=0,J+1=C,H+1=A] 

### Cost equations --> "Loop" of dfs_aux/7 
* CEs [38] --> Loop 35 
* CEs [39] --> Loop 36 
* CEs [36] --> Loop 37 
* CEs [37] --> Loop 38 

#### Loops of dfs_aux/7 
* Loop 35: dfs_aux(A,B,C,D,E,F,G)->  dfs_aux(A',B',C',D,E,F,G)
                  [B>=D+B'+1,B'>=0,G>=0,F>=0,E>=0,D>=0,C>=3,A>=2,C=C'+1,A+1=A'] 
* Loop 36: dfs_aux(A,B,C,D,E,F,G)->  dfs_aux(A',B',C',D,E,F,G)
                  [B>=B',B'>=0,G>=0,F>=0,E>=0,D>=0,C>=1,A>=2,C=C'+1,A=A'+1] 
* Loop 37: dfs_aux(A,B,C,D,E,F,G) [C>=G,B>=F,F>=D,G>=3,D>=0,A>=2,E=1] 
* Loop 38: dfs_aux(A,B,C,D,E,F,G) [F>=0,D>=0,B>=0,G=0,E=1,C=0,A=1] 

### Ranking functions of CR dfs_aux(A,B,C,D,E,F,G) 
* RF of phase [35,36]: [A+2*B-1,C]

#### Partial ranking functions of CR dfs_aux(A,B,C,D,E,F,G) 
* Partial RF of phase [35,36]:
  - RF of loop [35:1]:
    B
    B-D
    C-2
  - RF of loop [36:1]:
    A-1 depends on loops [35:1] 
    C

Discarded unfeasible chain [[35,36]]...(Non-terminating chain proved terminating)

### Resulting Chains:dfs_aux(A,B,C,D,E,F,G) 
* [[35,36],38]
* [[35,36],37]
* [37]


### Merging Chains  dfs_aux/7 into  External patterns of execution 
* [[38,[35,36]]] --> 1 
* [[37],[37,[35,36]]] --> 2 


### Specialization of cost equations dfs/6 
* CE 1 is refined into CE [40,41] 


#### Refined cost equations dfs/6 
* CE 40: dfs(A,B,C,D,E,F) = 3+ dfs_aux(G,H,B,C,I,E,J):1
     [2*H+1>=B,E>=0,C>=0,B>=1,A>=0,J=0,I=1,G=2,F=0,D=1] 
* CE 41: dfs(A,B,C,D,E,F) = 3+ dfs_aux(G,H,B,C,I,E,F):2
     [B>=F,H>=E,E>=C,F>=3,C>=0,A>=0,I=1,G=2,D=1] 

### Cost equations --> "Loop" of dfs/6 
* CEs [41] --> Loop 39 
* CEs [40] --> Loop 40 

#### Loops of dfs/6 
* Loop 39: dfs(A,B,C,D,E,F) [B>=F,E>=C,F>=3,C>=0,A>=0,D=1] 
* Loop 40: dfs(A,B,C,D,E,F) [E>=0,C>=0,B>=1,A>=0,F=0,D=1] 

### Ranking functions of CR dfs(A,B,C,D,E,F) 

#### Partial ranking functions of CR dfs(A,B,C,D,E,F) 


### Resulting Chains:dfs(A,B,C,D,E,F) 
* [40]
* [39]


### Merging Chains  dfs/6 into  External patterns of execution 
* [[40]] --> 1 
* [[39]] --> 2 


### Specialization of cost equations split/5 
* CE 14 is refined into CE [42] 
* CE 13 is refined into CE [43] 
* CE 12 is refined into CE [44] 


#### Refined cost equations split/5 
* CE 42: split(A,B,C,D,E) = 14+ split(F,G,H,I,J)
     [E>=J,J>=0,G>=0,D>=4,A>=3,E+G=B+J,D=I+2,A=F+2,H=1,C=1] 
* CE 43: split(A,B,C,D,E) = 9
     [E>=0,B>=0,D=3,C=1,A=2] 
* CE 44: split(A,B,C,D,E) = 5
     [E>=0,B>=0,D=2,C=1,A=1] 

### Cost equations --> "Loop" of split/5 
* CEs [43] --> Loop 41 
* CEs [44] --> Loop 42 
* CEs [42] --> Loop 43 

#### Loops of split/5 
* Loop 41: split(A,B,C,D,E) [E>=0,B>=0,D=3,C=1,A=2] 
* Loop 42: split(A,B,C,D,E) [E>=0,B>=0,D=2,C=1,A=1] 
* Loop 43: split(A,B,C,D,E)->  split(A',B',C',D',E')
                  [E>=E',E'>=0,B'>=0,D>=4,A>=3,E+B'=B+E',D=D'+2,A=A'+2,C'=1,C=1] 

### Ranking functions of CR split(A,B,C,D,E) 
* RF of phase [43]: [A/2-1]

#### Partial ranking functions of CR split(A,B,C,D,E) 
* Partial RF of phase [43]:
  - RF of loop [43:1]:
    A/2-1

Discarded unfeasible chain [[43]]...(Non-terminating chain proved terminating)

### Resulting Chains:split(A,B,C,D,E) 
* [[43],42]
* [[43],41]
* [42]
* [41]


### Merging Chains  split/5 into  External patterns of execution 
* [[42]] --> 1 
* [[41]] --> 2 
* [[41,[43]],[42,[43]]] --> 3 


### Specialization of cost equations make_btree/4 
* CE 3 is refined into CE [45,46,47] 
* CE 2 is refined into CE [48] 


#### Refined cost equations make_btree/4 
* CE 45: make_btree(A,B,C,D) = 11+ split(E,F,G,H,I):1+ make_btree(J,K,L,M)+ make_btree(N,O,P,Q)
     [B+L+P>=F,B>=F,Q>=1,M>=1,I>=0,F>=0,C+F=B+L+P,I=K+O,M+Q+1=D,N=1,J=1,H=2,G=1,E=1,A=2] 
* CE 46: make_btree(A,B,C,D) = 11+ split(E,F,G,H,I):2+ make_btree(J,K,L,M)+ make_btree(N,O,P,Q)
     [B+L+P>=F,B>=F,Q>=1,N>=1,M>=1,I>=0,F>=0,2>=N,C+F=B+L+P,I=K+O,M+Q+1=D,J+N=3,H=3,G=1,E=2,A=3] 
* CE 47: make_btree(A,B,C,D) = 11+ split(E,F,G,A,H):3+ make_btree(I,J,K,L)+ make_btree(M,N,O,P)
     [B+K+O>=F,A>=M+1,B>=F,P>=1,M>=1,L>=1,H>=0,A>=4,F>=0,C+F=B+K+O,H=J+N,A=I+M,L+P+1=D,A=E+1,G=1] 
* CE 48: make_btree(A,B,C,D) = 3
     [C>=0,B>=0,D=1,A=1] 

### Cost equations --> "Loop" of make_btree/4 
* CEs [48] --> Loop 44 
* CEs [47] --> Loop 45 
* CEs [46] --> Loop 46 
* CEs [45] --> Loop 47 

#### Loops of make_btree/4 
* Loop 44: make_btree(A,B,C,D) [C>=0,B>=0,D=1,A=1] 
* Loop 45: make_btree(A,B,C,D)->  make_btree(A',B',C',D')  make_btree(A'2,B'2,C'2,D'2)
                  [B+C'+C'2>=C,C>=C'+C'2,B'+B'2>=0,D>=D'+2,A>=A'+1,D'>=1,A'>=1,C>=0,A>=4,A=A'+A'2,D'+D'2+1=D] 
* Loop 46: make_btree(A,B,C,D)->  make_btree(A',B',C',D')  make_btree(A'2,B'2,C'2,D'2)
                  [B+C'+C'2>=C,C>=C'+C'2,B'+B'2>=0,D>=D'+2,D'>=1,A'>=1,C>=0,2>=A',D'+D'2+1=D,A'+A'2=3,A=3] 
* Loop 47: make_btree(A,B,C,D)->  make_btree(A',B',C',D')  make_btree(A'2,B'2,C'2,D'2)
                  [B+C'+C'2>=C,C>=C'+C'2,B'+B'2>=0,D>=D'+2,D'>=1,C>=0,D'+D'2+1=D,A'2=1,A'=1,A=2] 

### Ranking functions of CR make_btree(A,B,C,D) 
* RF of phase [45]: [A-3]

#### Partial ranking functions of CR make_btree(A,B,C,D) 
* Partial RF of phase [45]:
  - RF of loop [45:1,45:2]:
    A-3

Discarded unfeasible chain [multiple([45],[[],[multiple(47,[[44]])],[multiple(46,[[multiple(47,[[44]])],[44]])],[44]])]...(Non-terminating chain proved terminating)
Remaining chain: [multiple([45],[[multiple(47,[[44]])],[multiple(46,[[multiple(47,[[44]])],[44]])],[44]])]

### Resulting Chains:make_btree(A,B,C,D) 
* [multiple(47,[[44]])]
* [multiple(46,[[multiple(47,[[44]])],[44]])]
* [44]
* [multiple([45],[[multiple(47,[[44]])],[multiple(46,[[multiple(47,[[44]])],[44]])],[44]])]


### Merging Chains  make_btree/4 into  External patterns of execution 
* [[44]] --> 1 
* [[multiple(47,[[44]])]] --> 2 
* [[multiple(46,[[multiple(47,[[44]])],[44]])]] --> 3 
* [[multiple([45],[[multiple(47,[[44]])],[multiple(46,[[multiple(47,[[44]])],[44]])],[44]])]] --> 4 


Computing Bounds
=====================================

#### Simplifying cost structure of CE 22 

#### Computing cost of phase [22] 

#### Simplifying cost structure of CE 23 

#### Cost of loops [22] 

 * loop 22:append_rev(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O) -> [append_rev(A',B',C',D',E',F',G',H',I',J',K',L',M',N',O')] 
5
##### Pending set append_rev(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O)
* Psum in Loop 22: [it(22)=<1]

###### Computing sum for it(22)=<1  in Loop 22 
   - Applying inductive sum strategy 
     - head Candidate: J+1 
     - head Candidate: H+1 
     - head Candidate: F-1 
     - head Candidate: I-1 
     - head Candidate: F-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: H+1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: I-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: J+1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: J+1 
     - tail Candidate: H+1 
     - tail Candidate: F-1 
     - tail Candidate: I-1 
     - tail Candidate: F-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: H+1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: I-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: J+1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(22)=<J+1,it(22)=<H+1,it(22)=<F-1,it(22)=<I-1,it(22)=<F-1,it(22)=<H+1,it(22)=<I-1,it(22)=<J+1,it(22)=<J-J',it(22)=<H-H',it(22)=<F-F',it(22)=<I-I',it(22)=<F-F',it(22)=<H-H',it(22)=<I-I',it(22)=<J-J'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [22] 

#### Simplifying cost structure of phase [22] 

#### Cost of phase [22]:append_rev(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O) -> [append_rev(A',B',C',D',E',F',G',H',I',J',K',L',M',N',O')] 
5*it(22)+0
  Such that:it(22) =< F
it(22) =< F-F'
it(22) =< H+1
it(22) =< H-H'
it(22) =< I
it(22) =< I-I'
it(22) =< J+1
it(22) =< J-J'

#### Simplifying cost structure of chain [[22],23] 

#### Cost of chains of append_rev(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O):
* Chain [[22],23]: 5*it(22)+2
  Such that:it(22) =< I

  with precondition: [F=I,A+F=K+1,C+H=M,D+F=N+1,E+J=O,A>=1,B>=0,C>=0,D>=1,E>=0,F>=2,G>=0,L>=0,H+1>=F,J+1>=F,B+G>=L] 

* Chain [23]: 2
  with precondition: [F=1,H=0,I=1,J=0,A=K,B=L,C=M,D=N,E=O,A>=0,B>=0,C>=0,D>=0,E>=0,G>=0] 


#### Simplifying cost structure of CE 24 
 * Renamed intermediate variables: 
[ (eq(25,1),it(22))>>s(1)]

#### Simplifying cost structure of CE 25 

#### Cost of chains of revL(A,B,C,D,E,F,G,H,I,J):
* Chain [25]: 4
  with precondition: [A=1,C=0,D=1,E=0,F=1,H=0,I=1,J=0,B>=0,G>=0] 

* Chain [24]: 5*s(1)+4
  Such that:s(1) =< D

  with precondition: [A=D,A=F,C=H,A=I,E=J,A>=2,B>=0,G>=0,C+1>=A,E+1>=A] 


#### Simplifying cost structure of CE 27 

#### Computing cost of phase [26,27,28] 

#### Simplifying cost structure of CE 28 

#### Simplifying cost structure of CE 29 
 * Renamed intermediate variables: 
[ (eq(30,1),s(1))>>s(2)]

#### Simplifying cost structure of CE 30 
 * Renamed intermediate variables: 
[ (it(28),s(2))>>s(3)]

#### Cost of loops [26,27,28] 

 * loop 26:bfs_aux(A,B,C,D,E,F,G,H,I) -> [bfs_aux(A',B',C',D',E',F',G',H',I')] 
11
 * loop 27:bfs_aux(A,B,C,D,E,F,G,H,I) -> [bfs_aux(A',B',C',D',E',F',G',H',I')] 
6
 * loop 28:bfs_aux(A,B,C,D,E,F,G,H,I) -> [bfs_aux(A',B',C',D',E',F',G',H',I')] 
5*s(3)+12
  Such that:s(3) =< A'

##### Pending set bfs_aux(A,B,C,D,E,F,G,H,I)
* Psum in Loop 26: [it(26)=<1]
* Psum in Loop 27: [it(27)=<1]
* Psum in Loop 28: [it(28)=<1,s(4)=<A']

###### Computing sum for it(26)=<1  in Loop 26 
   - Applying inductive sum strategy 
     - head Candidate: 3*C+D+3*F-3 
       - Loop 27 is collaborative and bounds [it(27)] 
       - Loop 28 is collaborative and bounds [it(28)] 
     - head Candidate: -2*A+3*C-D+3*F+4 
       - Loop 27 is collaborative and bounds [it(27)] 
       - Loop 28 is collaborative and bounds [it(28)] 
     - head Candidate: -A+2*C+2*F+1 
       - Loop 27 is collaborative and bounds [it(27)] 
       - Loop 28 is collaborative and bounds [it(28)] 
     - head Candidate: A-1 
       - Loop 27 is collaborative and bounds [it(27)] 
       - Loop 28 adds an expression [F,D-1]
     - head Candidate: C/3-2/3 
       - Loop 27 is collaborative
       - Loop 28 adds an expression [F/3]
     - head Candidate: C+F-2 
       - Loop 27 is collaborative
       - Loop 28 is collaborative
     - head Candidate: C/3-D/3+F/3-1/3 
       - Loop 27 is collaborative
       - Loop 28 adds an expression [A'/3-1/3]
     - tail Candidate: 3*C+D+3*F-3 
       - Loop 27 is collaborative and bounds [it(27)] 
       - Loop 28 is collaborative and bounds [it(28)] 
     - tail Candidate: -2*A+3*C-D+3*F+4 
       - Loop 27 is collaborative and bounds [it(27)] 
       - Loop 28 is collaborative and bounds [it(28)] 
     - tail Candidate: -A+2*C+2*F+1 
       - Loop 27 is collaborative and bounds [it(27)] 
       - Loop 28 is collaborative and bounds [it(28)] 
     - tail Candidate: A-1 
       - Loop 27 is collaborative and bounds [it(27)] 
       - Loop 28 adds an expression [F,D-1]
     - tail Candidate: C/3-2/3 
       - Loop 27 is collaborative
       - Loop 28 adds an expression [F/3]
     - tail Candidate: C+F-2 
       - Loop 27 is collaborative and bounds [it(27)] 
       - Loop 28 is collaborative
     - tail Candidate: C/3-D/3+F/3-1/3 
       - Loop 27 is collaborative
       - Loop 28 adds an expression [A'/3-1/3]
 * Adding constraints: [it(26)+it(27)=<aux(1)+aux(2),it(26)=<aux(3)+aux(4),it(26)=<aux(5)+aux(6),it(26)+it(27)=<aux(7)+aux(8),it(26)=<aux(9)+aux(10),it(26)=<aux(11)+aux(12),it(26)+it(27)+it(28)=<3*C+D+3*F-3,it(26)+it(27)+it(28)=< -2*A+3*C-D+3*F+4,it(26)+it(27)+it(28)=< -A+2*C+2*F+1,aux(2)=<A-1,aux(4)=<C/3-2/3,it(26)=<C+F-2,aux(6)=<C/3-D/3+F/3-1/3,it(26)+it(27)+it(28)=<3*C+D+3*F-3*C'-D'-3*F',it(26)+it(27)+it(28)=< -2*A+3*C-D+3*F+2*A'-3*C'+D'-3*F',it(26)+it(27)+it(28)=< -A+2*C+2*F+A'-2*C'-2*F',aux(8)=<A-A',aux(10)=<C/3-C'/3,it(26)+it(27)=<C+F-C'-F',aux(12)=<C/3-D/3+F/3-C'/3+D'/3-F'/3] 

##### Pending set A
* Psum in Loop 27: [it(27)=<1]
* Psum in Loop 28: [it(28)=<1,s(4)=<A',aux(1)=<D-1,aux(7)=<D-1,aux(1)=<F,aux(7)=<F,aux(3)=<F/3,aux(9)=<F/3,aux(5)=<A'/3-1/3,aux(11)=<A'/3-1/3]

###### Computing sum for it(27)=<1  in Loop 27 
   - Applying inductive sum strategy 
     - head Candidate: 3*C+D+3*F-3 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: -2*A+3*C-D+3*F+4 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: -A+2*C+2*F+1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: C 
       - Loop 26 is collaborative
       - Loop 28 adds an expression [F]
     - head Candidate: C+F 
       - Loop 26 is collaborative
       - Loop 28 is collaborative
     - tail Candidate: 3*C+D+3*F-3 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: -2*A+3*C-D+3*F+4 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: -A+2*C+2*F+1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C 
       - Loop 26 is collaborative
       - Loop 28 adds an expression [F]
     - tail Candidate: C+F 
       - Loop 26 is collaborative
       - Loop 28 is collaborative
 * Adding constraints: [it(26)+it(27)=<aux(1)+aux(13),it(27)=<aux(14)+aux(15),it(26)+it(27)=<aux(7)+aux(16),it(27)=<aux(17)+aux(18),it(26)+it(27)+it(28)=<3*C+D+3*F-3,it(26)+it(27)+it(28)=< -2*A+3*C-D+3*F+4,it(26)+it(27)+it(28)=< -A+2*C+2*F+1,aux(13)=<A-1,aux(15)=<C,it(27)=<C+F,it(26)+it(27)+it(28)=<3*C+D+3*F-3*C'-D'-3*F',it(26)+it(27)+it(28)=< -2*A+3*C-D+3*F+2*A'-3*C'+D'-3*F',it(26)+it(27)+it(28)=< -A+2*C+2*F+A'-2*C'-2*F',aux(16)=<A-A',aux(18)=<C-C',it(27)=<C+F-C'-F'] 

##### Pending set A
* Psum in Loop 28: [it(28)=<1,s(4)=<A',aux(1)=<D-1,aux(7)=<D-1,aux(1)=<F,aux(7)=<F,aux(14)=<F,aux(17)=<F,aux(3)=<F/3,aux(9)=<F/3,aux(5)=<A'/3-1/3,aux(11)=<A'/3-1/3]

###### Computing sum for it(28)=<1  in Loop 28 
   - Applying inductive sum strategy 
     - head Candidate: 3*C+D+3*F-3 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: -2*A+3*C-D+3*F+4 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: -A+2*C+2*F+1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: -A+2 
       - Loop 26 adds a constant 1/1 
       - Loop 27 adds a constant 1/1 
     - head Candidate: -C+1 
       - Loop 26 adds an expression [-D+F'+2,-F+F'+1]
       - Loop 27 adds a constant 1/1 
     - head Candidate: D-1 
       - Loop 26 adds a constant 2/1 
       - Loop 27 is collaborative
     - head Candidate: F 
       - Loop 26 adds an expression [C-C'-1]
       - Loop 27 is collaborative
     - tail Candidate: 3*C+D+3*F-3 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: -2*A+3*C-D+3*F+4 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: -A+2*C+2*F+1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: -A+2 
       - Loop 26 adds a constant 1/1 
       - Loop 27 adds a constant 1/1 
     - tail Candidate: -C+1 
       - Loop 26 adds an expression [-D+F'+2,-F+F'+1]
       - Loop 27 adds a constant 1/1 
     - tail Candidate: D-1 
       - Loop 26 adds a constant 2/1 
       - Loop 27 is collaborative
     - tail Candidate: F 
       - Loop 26 adds an expression [C-C'-1]
       - Loop 27 is collaborative
 * Adding constraints: [it(28)=<it(27)+it(26)+aux(19),it(28)=<it(27)+aux(20)+aux(21),it(28)=<it(26)*2+aux(22),it(28)=<aux(23)+aux(24),it(28)=<it(27)+it(26)+aux(25),it(28)=<it(27)+aux(26)+aux(27),it(28)=<it(26)*2+aux(28),it(28)=<aux(29)+aux(30),it(26)+it(27)+it(28)=<3*C+D+3*F-3,it(26)+it(27)+it(28)=< -2*A+3*C-D+3*F+4,it(26)+it(27)+it(28)=< -A+2*C+2*F+1,aux(19)=< -A+2,aux(21)=< -C+1,aux(22)=<D-1,aux(24)=<F,it(26)+it(27)+it(28)=<3*C+D+3*F-3*C'-D'-3*F',it(26)+it(27)+it(28)=< -2*A+3*C-D+3*F+2*A'-3*C'+D'-3*F',it(26)+it(27)+it(28)=< -A+2*C+2*F+A'-2*C'-2*F',aux(25)=< -A+A',aux(27)=< -C+C',aux(28)=<D-D',aux(30)=<F-F'] 

##### Pending set A
* Psum in Loop 26: [aux(23)=<C-C'-1,aux(29)=<C-C'-1,aux(20)=< -D+F'+2,aux(26)=< -D+F'+2,aux(20)=< -F+F'+1,aux(26)=< -F+F'+1]
* Psum in Loop 28: [s(4)=<A',aux(1)=<D-1,aux(7)=<D-1,aux(1)=<F,aux(7)=<F,aux(14)=<F,aux(17)=<F,aux(3)=<F/3,aux(9)=<F/3,aux(5)=<A'/3-1/3,aux(11)=<A'/3-1/3]

###### Computing sum for aux(23)=<C-C'-1  in Loop 26 
   - Applying inductive sum strategy 
     - head Candidate: -A+2*C+D/2+F-1/2 
       - Loop 27 is collaborative
       - Loop 28 has a reset to  [2*F-2,-D+2*F]
     - head Candidate: C+D/2-3/2 
       - Loop 27 is collaborative
       - Loop 28 adds an expression [F-A'/2+1/2]
     - tail Candidate: -A+2*C+D/2+F-1/2 
       - Loop 27 is collaborative
       - Loop 28 has undefined behavior 
     - tail Candidate: C+D/2-3/2 
       - Loop 27 is collaborative
       - Loop 28 adds an expression [F-A'/2+1/2]
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(37)=<C-1] 
 * Adding constraints: [aux(23)=<it(26)*aux(37),aux(23)=<aux(31)+aux(32),aux(23)=<aux(33)+aux(34),aux(23)=<aux(35)+aux(36),aux(32)=< -A+2*C+D/2+F-1/2,aux(34)=<C+D/2-3/2,aux(36)=<C+D/2-C'-D'/2] 

##### Pending set bfs_aux(A,B,C,D,E,F,G,H,I)
* Pmax/min: [aux(37)=<C-1]
* Psum in Loop 26: [aux(29)=<C-C'-1,aux(20)=< -D+F'+2,aux(26)=< -D+F'+2,aux(20)=< -F+F'+1,aux(26)=< -F+F'+1]
* Psum in Loop 28: [s(4)=<A',aux(1)=<D-1,aux(7)=<D-1,aux(1)=<F,aux(7)=<F,aux(14)=<F,aux(17)=<F,aux(3)=<F/3,aux(9)=<F/3,aux(5)=<A'/3-1/3,aux(11)=<A'/3-1/3,aux(31)=< -D+2*F,aux(33)=<F-A'/2+1/2,aux(35)=<F-A'/2+1/2,aux(31)=<2*F-2]

###### Computing max_min for aux(37)=<C-1  
   - Found a solution using transitive invariants 
 * Adding constraints:[aux(37)=<C+F-1,aux(37)=<3*C+2*D+F-5] 

##### Pending set bfs_aux(A,B,C,D,E,F,G,H,I)
* Psum in Loop 26: [aux(29)=<C-C'-1,aux(20)=< -D+F'+2,aux(26)=< -D+F'+2,aux(20)=< -F+F'+1,aux(26)=< -F+F'+1]
* Psum in Loop 28: [s(4)=<A',aux(1)=<D-1,aux(7)=<D-1,aux(1)=<F,aux(7)=<F,aux(14)=<F,aux(17)=<F,aux(3)=<F/3,aux(9)=<F/3,aux(5)=<A'/3-1/3,aux(11)=<A'/3-1/3,aux(31)=< -D+2*F,aux(33)=<F-A'/2+1/2,aux(35)=<F-A'/2+1/2,aux(31)=<2*F-2]

###### Computing sum for aux(29)=<C-C'-1  in Loop 26 
   - Found a solution using cacheing 
 * Adding constraints: [aux(29)=<aux(38),aux(38)=<it(26)*aux(37),aux(38)=<aux(31)+aux(32),aux(38)=<aux(33)+aux(34),aux(38)=<aux(35)+aux(36)] 

##### Pending set bfs_aux(A,B,C,D,E,F,G,H,I)
* Psum in Loop 26: [aux(20)=< -D+F'+2,aux(26)=< -D+F'+2,aux(20)=< -F+F'+1,aux(26)=< -F+F'+1]
* Psum in Loop 28: [s(4)=<A',aux(1)=<D-1,aux(7)=<D-1,aux(1)=<F,aux(7)=<F,aux(14)=<F,aux(17)=<F,aux(3)=<F/3,aux(9)=<F/3,aux(5)=<A'/3-1/3,aux(11)=<A'/3-1/3,aux(31)=< -D+2*F,aux(33)=<F-A'/2+1/2,aux(35)=<F-A'/2+1/2,aux(31)=<2*F-2]

###### Computing sum for aux(20)=< -D+F'+2  in Loop 26 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(39)=<C-D+F+1] 
 * Adding constraints: [aux(20)=<it(26)*aux(39)] 

##### Pending set bfs_aux(A,B,C,D,E,F,G,H,I)
* Pmax/min: [aux(39)=<C-D+F+1]
* Psum in Loop 26: [aux(26)=< -D+F'+2,aux(20)=< -F+F'+1,aux(26)=< -F+F'+1]
* Psum in Loop 28: [s(4)=<A',aux(1)=<D-1,aux(7)=<D-1,aux(1)=<F,aux(7)=<F,aux(14)=<F,aux(17)=<F,aux(3)=<F/3,aux(9)=<F/3,aux(5)=<A'/3-1/3,aux(11)=<A'/3-1/3,aux(31)=< -D+2*F,aux(33)=<F-A'/2+1/2,aux(35)=<F-A'/2+1/2,aux(31)=<2*F-2]

###### Computing max_min for aux(39)=<C-D+F+1  
   - Found a solution using transitive invariants 
 * Adding constraints:[aux(39)=<C+F,aux(39)=<3*C+2*D+F-4] 

##### Pending set bfs_aux(A,B,C,D,E,F,G,H,I)
* Psum in Loop 26: [aux(26)=< -D+F'+2,aux(20)=< -F+F'+1,aux(26)=< -F+F'+1]
* Psum in Loop 28: [s(4)=<A',aux(1)=<D-1,aux(7)=<D-1,aux(1)=<F,aux(7)=<F,aux(14)=<F,aux(17)=<F,aux(3)=<F/3,aux(9)=<F/3,aux(5)=<A'/3-1/3,aux(11)=<A'/3-1/3,aux(31)=< -D+2*F,aux(33)=<F-A'/2+1/2,aux(35)=<F-A'/2+1/2,aux(31)=<2*F-2]

###### Computing sum for aux(26)=< -D+F'+2  in Loop 26 
   - Found a solution using cacheing 
 * Adding constraints: [aux(26)=<aux(40),aux(40)=<it(26)*aux(39)] 

##### Pending set bfs_aux(A,B,C,D,E,F,G,H,I)
* Psum in Loop 26: [aux(20)=< -F+F'+1,aux(26)=< -F+F'+1]
* Psum in Loop 28: [s(4)=<A',aux(1)=<D-1,aux(7)=<D-1,aux(1)=<F,aux(7)=<F,aux(14)=<F,aux(17)=<F,aux(3)=<F/3,aux(9)=<F/3,aux(5)=<A'/3-1/3,aux(11)=<A'/3-1/3,aux(31)=< -D+2*F,aux(33)=<F-A'/2+1/2,aux(35)=<F-A'/2+1/2,aux(31)=<2*F-2]

###### Computing sum for aux(20)=< -F+F'+1  in Loop 26 
   - Applying inductive sum strategy 
     - head Candidate: 2*C+D/2+F-3/2 
       - Loop 27 is collaborative
       - Loop 28 has a reset to  [2*F-1]
     - head Candidate: 2*C+F-1 
       - Loop 27 is collaborative
       - Loop 28 has a reset to  [2*F-1]
     - tail Candidate: 2*C+D/2+F-3/2 
       - Loop 27 is collaborative
       - Loop 28 has undefined behavior 
     - tail Candidate: 2*C+F-1 
       - Loop 27 is collaborative
       - Loop 28 has undefined behavior 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(45)=<C] 
 * Adding constraints: [aux(20)=<it(26)*aux(45),aux(20)=<aux(41)+aux(42),aux(20)=<aux(43)+aux(44),aux(42)=<2*C+D/2+F-3/2,aux(44)=<2*C+F-1] 

##### Pending set bfs_aux(A,B,C,D,E,F,G,H,I)
* Pmax/min: [aux(45)=<C]
* Psum in Loop 26: [aux(26)=< -F+F'+1]
* Psum in Loop 28: [s(4)=<A',aux(1)=<D-1,aux(7)=<D-1,aux(1)=<F,aux(7)=<F,aux(14)=<F,aux(17)=<F,aux(3)=<F/3,aux(9)=<F/3,aux(5)=<A'/3-1/3,aux(11)=<A'/3-1/3,aux(31)=< -D+2*F,aux(33)=<F-A'/2+1/2,aux(35)=<F-A'/2+1/2,aux(31)=<2*F-2,aux(41)=<2*F-1,aux(43)=<2*F-1]

###### Computing max_min for aux(45)=<C  
   - Found a solution using cacheing 
 * Adding constraints:[aux(45)=<aux(37)+1] 

##### Pending set bfs_aux(A,B,C,D,E,F,G,H,I)
* Psum in Loop 26: [aux(26)=< -F+F'+1]
* Psum in Loop 28: [s(4)=<A',aux(1)=<D-1,aux(7)=<D-1,aux(1)=<F,aux(7)=<F,aux(14)=<F,aux(17)=<F,aux(3)=<F/3,aux(9)=<F/3,aux(5)=<A'/3-1/3,aux(11)=<A'/3-1/3,aux(31)=< -D+2*F,aux(33)=<F-A'/2+1/2,aux(35)=<F-A'/2+1/2,aux(31)=<2*F-2,aux(41)=<2*F-1,aux(43)=<2*F-1]

###### Computing sum for aux(26)=< -F+F'+1  in Loop 26 
   - Found a solution using cacheing 
 * Adding constraints: [aux(26)=<aux(46),aux(46)=<it(26)*aux(45),aux(46)=<aux(41)+aux(42),aux(46)=<aux(43)+aux(44)] 

##### Pending set bfs_aux(A,B,C,D,E,F,G,H,I)
* Psum in Loop 28: [s(4)=<A',aux(1)=<D-1,aux(7)=<D-1,aux(1)=<F,aux(7)=<F,aux(14)=<F,aux(17)=<F,aux(3)=<F/3,aux(9)=<F/3,aux(5)=<A'/3-1/3,aux(11)=<A'/3-1/3,aux(31)=< -D+2*F,aux(33)=<F-A'/2+1/2,aux(35)=<F-A'/2+1/2,aux(31)=<2*F-2,aux(41)=<2*F-1,aux(43)=<2*F-1]

###### Computing sum for s(4)=<A'  in Loop 28 
   - Applying inductive sum strategy 
     - head Candidate: -A+F+2 
       - Loop 26 adds an expression [C-C']
       - Loop 27 adds a constant 1/1 
     - head Candidate: -A+D+1 
       - Loop 26 adds a constant 3/1 
       - Loop 27 adds a constant 1/1 
     - tail Candidate: -A+F+2 
       - Loop 26 adds an expression [C-C']
       - Loop 27 adds a constant 1/1 
     - tail Candidate: -A+D+1 
       - Loop 26 adds a constant 3/1 
       - Loop 27 adds a constant 1/1 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(53)=<D,aux(53)=<F+1] 
 * Adding constraints: [s(4)=<it(28)*aux(53),s(4)=<it(27)+aux(47)+aux(48),s(4)=<it(27)+it(26)*3+aux(49),s(4)=<it(27)+aux(50)+aux(51),s(4)=<it(27)+it(26)*3+aux(52),aux(48)=< -A+F+2,aux(49)=< -A+D+1,aux(51)=< -A+F+A'-F',aux(52)=< -A+D+A'-D'] 

##### Pending set bfs_aux(A,B,C,D,E,F,G,H,I)
* Pmax/min: [aux(53)=<D,aux(53)=<F+1]
* Psum in Loop 26: [aux(47)=<C-C',aux(50)=<C-C']
* Psum in Loop 28: [aux(1)=<D-1,aux(7)=<D-1,aux(1)=<F,aux(7)=<F,aux(14)=<F,aux(17)=<F,aux(3)=<F/3,aux(9)=<F/3,aux(5)=<A'/3-1/3,aux(11)=<A'/3-1/3,aux(31)=< -D+2*F,aux(33)=<F-A'/2+1/2,aux(35)=<F-A'/2+1/2,aux(31)=<2*F-2,aux(41)=<2*F-1,aux(43)=<2*F-1]

###### Computing max_min for aux(53)=<D  
   - Found a solution using transitive invariants 
 * Adding constraints:[aux(53)=<6*C+5*D+2*F-10,aux(53)=<A/2+C/2+D/2+F/2] 

##### Pending set bfs_aux(A,B,C,D,E,F,G,H,I)
* Pmax/min: [aux(53)=<F+1]
* Psum in Loop 26: [aux(47)=<C-C',aux(50)=<C-C']
* Psum in Loop 28: [aux(1)=<D-1,aux(7)=<D-1,aux(1)=<F,aux(7)=<F,aux(14)=<F,aux(17)=<F,aux(3)=<F/3,aux(9)=<F/3,aux(5)=<A'/3-1/3,aux(11)=<A'/3-1/3,aux(31)=< -D+2*F,aux(33)=<F-A'/2+1/2,aux(35)=<F-A'/2+1/2,aux(31)=<2*F-2,aux(41)=<2*F-1,aux(43)=<2*F-1]

###### Computing max_min for aux(53)=<F+1  
   - Found a solution using transitive invariants 
 * Adding constraints:[aux(53)=<C+F+1,aux(53)=<C+D+F-1] 

##### Pending set bfs_aux(A,B,C,D,E,F,G,H,I)
* Psum in Loop 26: [aux(47)=<C-C',aux(50)=<C-C']
* Psum in Loop 28: [aux(1)=<D-1,aux(7)=<D-1,aux(1)=<F,aux(7)=<F,aux(14)=<F,aux(17)=<F,aux(3)=<F/3,aux(9)=<F/3,aux(5)=<A'/3-1/3,aux(11)=<A'/3-1/3,aux(31)=< -D+2*F,aux(33)=<F-A'/2+1/2,aux(35)=<F-A'/2+1/2,aux(31)=<2*F-2,aux(41)=<2*F-1,aux(43)=<2*F-1]

###### Computing sum for aux(47)=<C-C'  in Loop 26 
   - Applying inductive sum strategy 
     - head Candidate: 2*C+D/2+F-3/2 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: 2*C+F-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: 2*C+D/2+F-3/2 
       - We failed to classify this candidate before 
     - tail Candidate: 2*C+F-1 
       - We failed to classify this candidate before 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(56)=<C] 
 * Adding constraints: [aux(47)=<it(26)*aux(56),aux(47)=<aux(41)+aux(54),aux(47)=<aux(43)+aux(55),aux(54)=<2*C+D/2+F-3/2,aux(55)=<2*C+F-1] 

##### Pending set bfs_aux(A,B,C,D,E,F,G,H,I)
* Pmax/min: [aux(56)=<C]
* Psum in Loop 26: [aux(50)=<C-C']
* Psum in Loop 28: [aux(1)=<D-1,aux(7)=<D-1,aux(1)=<F,aux(7)=<F,aux(14)=<F,aux(17)=<F,aux(3)=<F/3,aux(9)=<F/3,aux(5)=<A'/3-1/3,aux(11)=<A'/3-1/3,aux(31)=< -D+2*F,aux(33)=<F-A'/2+1/2,aux(35)=<F-A'/2+1/2,aux(31)=<2*F-2,aux(41)=<2*F-1,aux(43)=<2*F-1]

###### Computing max_min for aux(56)=<C  
   - Found a solution using cacheing 
 * Adding constraints:[aux(56)=<aux(37)+1] 

##### Pending set bfs_aux(A,B,C,D,E,F,G,H,I)
* Psum in Loop 26: [aux(50)=<C-C']
* Psum in Loop 28: [aux(1)=<D-1,aux(7)=<D-1,aux(1)=<F,aux(7)=<F,aux(14)=<F,aux(17)=<F,aux(3)=<F/3,aux(9)=<F/3,aux(5)=<A'/3-1/3,aux(11)=<A'/3-1/3,aux(31)=< -D+2*F,aux(33)=<F-A'/2+1/2,aux(35)=<F-A'/2+1/2,aux(31)=<2*F-2,aux(41)=<2*F-1,aux(43)=<2*F-1]

###### Computing sum for aux(50)=<C-C'  in Loop 26 
   - Found a solution using cacheing 
 * Adding constraints: [aux(50)=<aux(57),aux(57)=<it(26)*aux(56),aux(57)=<aux(41)+aux(54),aux(57)=<aux(43)+aux(55)] 

##### Pending set bfs_aux(A,B,C,D,E,F,G,H,I)
* Psum in Loop 28: [aux(1)=<D-1,aux(7)=<D-1,aux(1)=<F,aux(7)=<F,aux(14)=<F,aux(17)=<F,aux(3)=<F/3,aux(9)=<F/3,aux(5)=<A'/3-1/3,aux(11)=<A'/3-1/3,aux(31)=< -D+2*F,aux(33)=<F-A'/2+1/2,aux(35)=<F-A'/2+1/2,aux(31)=<2*F-2,aux(41)=<2*F-1,aux(43)=<2*F-1]

###### Computing sum for aux(1)=<D-1  in Loop 28 
   - Applying inductive sum strategy 
     - head Candidate: -A+F+1 
       - Loop 26 adds an expression [C-C']
       - Loop 27 adds a constant 1/1 
     - head Candidate: -A+C+F+1 
       - Loop 26 is collaborative
       - Loop 27 is collaborative
     - tail Candidate: -A+F+1 
       - Loop 26 adds an expression [C-C']
       - Loop 27 adds a constant 1/1 
     - tail Candidate: -A+C+F+1 
       - Loop 26 is collaborative
       - Loop 27 is collaborative
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(62)=<D-1] 
 * Adding constraints: [aux(1)=<it(28)*aux(62),aux(1)=<it(27)+aux(58)+aux(59),aux(1)=<it(27)+aux(60)+aux(61),aux(59)=< -A+F+1,aux(1)=< -A+C+F+1,aux(61)=< -A+F+A'-F',aux(1)=< -A+C+F+A'-C'-F'] 

##### Pending set bfs_aux(A,B,C,D,E,F,G,H,I)
* Pmax/min: [aux(62)=<D-1]
* Psum in Loop 26: [aux(58)=<C-C',aux(60)=<C-C']
* Psum in Loop 28: [aux(7)=<D-1,aux(1)=<F,aux(7)=<F,aux(14)=<F,aux(17)=<F,aux(3)=<F/3,aux(9)=<F/3,aux(5)=<A'/3-1/3,aux(11)=<A'/3-1/3,aux(31)=< -D+2*F,aux(33)=<F-A'/2+1/2,aux(35)=<F-A'/2+1/2,aux(31)=<2*F-2,aux(41)=<2*F-1,aux(43)=<2*F-1]

###### Computing max_min for aux(62)=<D-1  
   - Found a solution using cacheing 
 * Adding constraints:[aux(62)=<aux(53)-1] 

##### Pending set bfs_aux(A,B,C,D,E,F,G,H,I)
* Psum in Loop 26: [aux(58)=<C-C',aux(60)=<C-C']
* Psum in Loop 28: [aux(7)=<D-1,aux(1)=<F,aux(7)=<F,aux(14)=<F,aux(17)=<F,aux(3)=<F/3,aux(9)=<F/3,aux(5)=<A'/3-1/3,aux(11)=<A'/3-1/3,aux(31)=< -D+2*F,aux(33)=<F-A'/2+1/2,aux(35)=<F-A'/2+1/2,aux(31)=<2*F-2,aux(41)=<2*F-1,aux(43)=<2*F-1]

###### Computing sum for aux(58)=<C-C'  in Loop 26 
   - Found a solution using cacheing 
 * Adding constraints: [aux(58)=<aux(63),aux(63)=<it(26)*aux(56),aux(63)=<aux(41)+aux(54),aux(63)=<aux(43)+aux(55)] 

##### Pending set bfs_aux(A,B,C,D,E,F,G,H,I)
* Psum in Loop 26: [aux(60)=<C-C']
* Psum in Loop 28: [aux(7)=<D-1,aux(1)=<F,aux(7)=<F,aux(14)=<F,aux(17)=<F,aux(3)=<F/3,aux(9)=<F/3,aux(5)=<A'/3-1/3,aux(11)=<A'/3-1/3,aux(31)=< -D+2*F,aux(33)=<F-A'/2+1/2,aux(35)=<F-A'/2+1/2,aux(31)=<2*F-2,aux(41)=<2*F-1,aux(43)=<2*F-1]

###### Computing sum for aux(60)=<C-C'  in Loop 26 
   - Found a solution using cacheing 
 * Adding constraints: [aux(60)=<aux(64),aux(64)=<it(26)*aux(56),aux(64)=<aux(41)+aux(54),aux(64)=<aux(43)+aux(55)] 

##### Pending set bfs_aux(A,B,C,D,E,F,G,H,I)
* Psum in Loop 28: [aux(7)=<D-1,aux(1)=<F,aux(7)=<F,aux(14)=<F,aux(17)=<F,aux(3)=<F/3,aux(9)=<F/3,aux(5)=<A'/3-1/3,aux(11)=<A'/3-1/3,aux(31)=< -D+2*F,aux(33)=<F-A'/2+1/2,aux(35)=<F-A'/2+1/2,aux(31)=<2*F-2,aux(41)=<2*F-1,aux(43)=<2*F-1]

###### Computing sum for aux(7)=<D-1  in Loop 28 
   - Found a solution using cacheing 
 * Adding constraints: [aux(7)=<aux(65),aux(65)=<it(28)*aux(62),aux(65)=<it(27)+aux(58)+aux(59),aux(65)=<it(27)+aux(60)+aux(61),aux(65)=< -A+C+F+1,aux(65)=< -A+C+F+A'-C'-F'] 

##### Pending set bfs_aux(A,B,C,D,E,F,G,H,I)
* Psum in Loop 28: [aux(1)=<F,aux(7)=<F,aux(14)=<F,aux(17)=<F,aux(3)=<F/3,aux(9)=<F/3,aux(5)=<A'/3-1/3,aux(11)=<A'/3-1/3,aux(31)=< -D+2*F,aux(33)=<F-A'/2+1/2,aux(35)=<F-A'/2+1/2,aux(31)=<2*F-2,aux(41)=<2*F-1,aux(43)=<2*F-1]

###### Computing sum for aux(1)=<F  in Loop 28 
   - Applying inductive sum strategy 
     - head Candidate: F 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: F 
       - The candidate was classified before. We reuse its previous classification 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(68)=<F] 
 * Adding constraints: [aux(1)=<it(28)*aux(68),aux(1)=<aux(23)+aux(66),aux(1)=<aux(29)+aux(67),aux(66)=<F,aux(67)=<F-F'] 

##### Pending set bfs_aux(A,B,C,D,E,F,G,H,I)
* Pmax/min: [aux(68)=<F]
* Psum in Loop 28: [aux(7)=<F,aux(14)=<F,aux(17)=<F,aux(3)=<F/3,aux(9)=<F/3,aux(5)=<A'/3-1/3,aux(11)=<A'/3-1/3,aux(31)=< -D+2*F,aux(33)=<F-A'/2+1/2,aux(35)=<F-A'/2+1/2,aux(31)=<2*F-2,aux(41)=<2*F-1,aux(43)=<2*F-1]

###### Computing max_min for aux(68)=<F  
   - Found a solution using cacheing 
 * Adding constraints:[aux(68)=<aux(53)-1] 

##### Pending set bfs_aux(A,B,C,D,E,F,G,H,I)
* Psum in Loop 28: [aux(7)=<F,aux(14)=<F,aux(17)=<F,aux(3)=<F/3,aux(9)=<F/3,aux(5)=<A'/3-1/3,aux(11)=<A'/3-1/3,aux(31)=< -D+2*F,aux(33)=<F-A'/2+1/2,aux(35)=<F-A'/2+1/2,aux(31)=<2*F-2,aux(41)=<2*F-1,aux(43)=<2*F-1]

###### Computing sum for aux(7)=<F  in Loop 28 
   - Found a solution using cacheing 
 * Adding constraints: [aux(7)=<aux(69),aux(69)=<it(28)*aux(68),aux(69)=<aux(23)+aux(66),aux(69)=<aux(29)+aux(67)] 

##### Pending set bfs_aux(A,B,C,D,E,F,G,H,I)
* Psum in Loop 28: [aux(14)=<F,aux(17)=<F,aux(3)=<F/3,aux(9)=<F/3,aux(5)=<A'/3-1/3,aux(11)=<A'/3-1/3,aux(31)=< -D+2*F,aux(33)=<F-A'/2+1/2,aux(35)=<F-A'/2+1/2,aux(31)=<2*F-2,aux(41)=<2*F-1,aux(43)=<2*F-1]

###### Computing sum for aux(14)=<F  in Loop 28 
   - Found a solution using cacheing 
 * Adding constraints: [aux(14)=<aux(70),aux(70)=<it(28)*aux(68),aux(70)=<aux(23)+aux(66),aux(70)=<aux(29)+aux(67)] 

##### Pending set bfs_aux(A,B,C,D,E,F,G,H,I)
* Psum in Loop 28: [aux(17)=<F,aux(3)=<F/3,aux(9)=<F/3,aux(5)=<A'/3-1/3,aux(11)=<A'/3-1/3,aux(31)=< -D+2*F,aux(33)=<F-A'/2+1/2,aux(35)=<F-A'/2+1/2,aux(31)=<2*F-2,aux(41)=<2*F-1,aux(43)=<2*F-1]

###### Computing sum for aux(17)=<F  in Loop 28 
   - Found a solution using cacheing 
 * Adding constraints: [aux(17)=<aux(71),aux(71)=<it(28)*aux(68),aux(71)=<aux(23)+aux(66),aux(71)=<aux(29)+aux(67)] 

##### Pending set bfs_aux(A,B,C,D,E,F,G,H,I)
* Psum in Loop 28: [aux(3)=<F/3,aux(9)=<F/3,aux(5)=<A'/3-1/3,aux(11)=<A'/3-1/3,aux(31)=< -D+2*F,aux(33)=<F-A'/2+1/2,aux(35)=<F-A'/2+1/2,aux(31)=<2*F-2,aux(41)=<2*F-1,aux(43)=<2*F-1]

###### Computing sum for aux(3)=<F/3  in Loop 28 
   - Found a solution using cacheing 
 * Adding constraints: [aux(3)=<aux(72)* (1/3),aux(72)=<it(28)*aux(68),aux(72)=<aux(23)+aux(66),aux(72)=<aux(29)+aux(67)] 

##### Pending set bfs_aux(A,B,C,D,E,F,G,H,I)
* Psum in Loop 28: [aux(9)=<F/3,aux(5)=<A'/3-1/3,aux(11)=<A'/3-1/3,aux(31)=< -D+2*F,aux(33)=<F-A'/2+1/2,aux(35)=<F-A'/2+1/2,aux(31)=<2*F-2,aux(41)=<2*F-1,aux(43)=<2*F-1]

###### Computing sum for aux(9)=<F/3  in Loop 28 
   - Found a solution using cacheing 
 * Adding constraints: [aux(9)=<aux(73)* (1/3),aux(73)=<it(28)*aux(68),aux(73)=<aux(23)+aux(66),aux(73)=<aux(29)+aux(67)] 

##### Pending set bfs_aux(A,B,C,D,E,F,G,H,I)
* Psum in Loop 28: [aux(5)=<A'/3-1/3,aux(11)=<A'/3-1/3,aux(31)=< -D+2*F,aux(33)=<F-A'/2+1/2,aux(35)=<F-A'/2+1/2,aux(31)=<2*F-2,aux(41)=<2*F-1,aux(43)=<2*F-1]

###### Computing sum for aux(5)=<A'/3-1/3  in Loop 28 
   - Applying inductive sum strategy 
     - head Candidate: -A/3+C/3+F/3+1/3 
       - Loop 26 is collaborative
       - Loop 27 is collaborative
     - head Candidate: -A/3+F/3+1/3 
       - Loop 26 adds an expression [C/3-C'/3]
       - Loop 27 adds a constant 1/3 
     - tail Candidate: -A/3+C/3+F/3+1/3 
       - Loop 26 is collaborative
       - Loop 27 is collaborative
     - tail Candidate: -A/3+F/3+1/3 
       - Loop 26 adds an expression [C/3-C'/3]
       - Loop 27 adds a constant 1/3 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(78)=<F/3,aux(78)=<D/3-1/3] 
 * Adding constraints: [aux(5)=<it(28)*aux(78),aux(5)=<it(27)* (1/3)+aux(74)+aux(75),aux(5)=<it(27)* (1/3)+aux(76)+aux(77),aux(5)=< -A/3+C/3+F/3+1/3,aux(75)=< -A/3+F/3+1/3,aux(5)=< -A/3+C/3+F/3+A'/3-C'/3-F'/3,aux(77)=< -A/3+F/3+A'/3-F'/3] 

##### Pending set bfs_aux(A,B,C,D,E,F,G,H,I)
* Pmax/min: [aux(78)=<D/3-1/3,aux(78)=<F/3]
* Psum in Loop 26: [aux(74)=<C/3-C'/3,aux(76)=<C/3-C'/3]
* Psum in Loop 28: [aux(11)=<A'/3-1/3,aux(31)=< -D+2*F,aux(33)=<F-A'/2+1/2,aux(35)=<F-A'/2+1/2,aux(31)=<2*F-2,aux(41)=<2*F-1,aux(43)=<2*F-1]

###### Computing max_min for aux(78)=<D/3-1/3  
   - Found a solution using cacheing 
 * Adding constraints:[aux(78)=<aux(53)* (1/3)-1/3] 

##### Pending set bfs_aux(A,B,C,D,E,F,G,H,I)
* Pmax/min: [aux(78)=<F/3]
* Psum in Loop 26: [aux(74)=<C/3-C'/3,aux(76)=<C/3-C'/3]
* Psum in Loop 28: [aux(11)=<A'/3-1/3,aux(31)=< -D+2*F,aux(33)=<F-A'/2+1/2,aux(35)=<F-A'/2+1/2,aux(31)=<2*F-2,aux(41)=<2*F-1,aux(43)=<2*F-1]

###### Computing max_min for aux(78)=<F/3  
   - Found a solution using cacheing 
 * Adding constraints:[aux(78)=<aux(53)* (1/3)-1/3] 

##### Pending set bfs_aux(A,B,C,D,E,F,G,H,I)
* Psum in Loop 26: [aux(74)=<C/3-C'/3,aux(76)=<C/3-C'/3]
* Psum in Loop 28: [aux(11)=<A'/3-1/3,aux(31)=< -D+2*F,aux(33)=<F-A'/2+1/2,aux(35)=<F-A'/2+1/2,aux(31)=<2*F-2,aux(41)=<2*F-1,aux(43)=<2*F-1]

###### Computing sum for aux(74)=<C/3-C'/3  in Loop 26 
   - Found a solution using cacheing 
 * Adding constraints: [aux(74)=<aux(79)* (1/3),aux(79)=<it(26)*aux(56),aux(79)=<aux(41)+aux(54),aux(79)=<aux(43)+aux(55)] 

##### Pending set bfs_aux(A,B,C,D,E,F,G,H,I)
* Psum in Loop 26: [aux(76)=<C/3-C'/3]
* Psum in Loop 28: [aux(11)=<A'/3-1/3,aux(31)=< -D+2*F,aux(33)=<F-A'/2+1/2,aux(35)=<F-A'/2+1/2,aux(31)=<2*F-2,aux(41)=<2*F-1,aux(43)=<2*F-1]

###### Computing sum for aux(76)=<C/3-C'/3  in Loop 26 
   - Found a solution using cacheing 
 * Adding constraints: [aux(76)=<aux(80)* (1/3),aux(80)=<it(26)*aux(56),aux(80)=<aux(41)+aux(54),aux(80)=<aux(43)+aux(55)] 

##### Pending set bfs_aux(A,B,C,D,E,F,G,H,I)
* Psum in Loop 28: [aux(11)=<A'/3-1/3,aux(31)=< -D+2*F,aux(33)=<F-A'/2+1/2,aux(35)=<F-A'/2+1/2,aux(31)=<2*F-2,aux(41)=<2*F-1,aux(43)=<2*F-1]

###### Computing sum for aux(11)=<A'/3-1/3  in Loop 28 
   - Found a solution using cacheing 
 * Adding constraints: [aux(11)=<aux(81),aux(81)=<it(28)*aux(78),aux(81)=<it(27)* (1/3)+aux(74)+aux(75),aux(81)=<it(27)* (1/3)+aux(76)+aux(77),aux(81)=< -A/3+C/3+F/3+1/3,aux(81)=< -A/3+C/3+F/3+A'/3-C'/3-F'/3] 

##### Pending set bfs_aux(A,B,C,D,E,F,G,H,I)
* Psum in Loop 28: [aux(31)=< -D+2*F,aux(33)=<F-A'/2+1/2,aux(35)=<F-A'/2+1/2,aux(31)=<2*F-2,aux(41)=<2*F-1,aux(43)=<2*F-1]

###### Computing sum for aux(31)=< -D+2*F  in Loop 28 
   - Applying inductive sum strategy 
     - head Candidate: A+2*F-3 
       - Loop 26 adds an expression [2*C-2*C'-3]
       - Loop 27 is collaborative
     - head Candidate: -D+2*F 
       - Loop 26 adds an expression [2*C-2*C'-4]
       - Loop 27 is collaborative
     - tail Candidate: A+2*F-3 
       - Loop 26 adds an expression [2*C-2*C'-3]
       - Loop 27 is collaborative
     - tail Candidate: -D+2*F 
       - Loop 26 adds an expression [2*C-2*C'-4]
       - Loop 27 is collaborative
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(90)=< -D+2*F] 
 * Adding constraints: [aux(31)=<it(28)*aux(90),aux(31)=<aux(82)+aux(83),aux(31)=<aux(84)+aux(85),aux(31)=<aux(86)+aux(87),aux(31)=<aux(88)+aux(89),aux(83)=<A+2*F-3,aux(85)=< -D+2*F,aux(87)=<A+2*F-A'-2*F',aux(89)=< -D+2*F+D'-2*F'] 

##### Pending set bfs_aux(A,B,C,D,E,F,G,H,I)
* Pmax/min: [aux(90)=< -D+2*F]
* Psum in Loop 26: [aux(84)=<2*C-2*C'-4,aux(88)=<2*C-2*C'-4,aux(82)=<2*C-2*C'-3,aux(86)=<2*C-2*C'-3]
* Psum in Loop 28: [aux(33)=<F-A'/2+1/2,aux(35)=<F-A'/2+1/2,aux(31)=<2*F-2,aux(41)=<2*F-1,aux(43)=<2*F-1]

###### Computing max_min for aux(90)=< -D+2*F  
   - Found a solution using transitive invariants 
 * Adding constraints:[aux(90)=<2*C+2*F-2,aux(90)=<2*C+D+2*F-4] 

##### Pending set bfs_aux(A,B,C,D,E,F,G,H,I)
* Psum in Loop 26: [aux(84)=<2*C-2*C'-4,aux(88)=<2*C-2*C'-4,aux(82)=<2*C-2*C'-3,aux(86)=<2*C-2*C'-3]
* Psum in Loop 28: [aux(33)=<F-A'/2+1/2,aux(35)=<F-A'/2+1/2,aux(31)=<2*F-2,aux(41)=<2*F-1,aux(43)=<2*F-1]

###### Computing sum for aux(84)=<2*C-2*C'-4  in Loop 26 
   - Applying inductive sum strategy 
     - head Candidate: -2*A+4*C+2*D+2*F-4 
       - Loop 27 is collaborative
       - Loop 28 has a reset to  [4*F-6,-2*D+4*F-2]
     - head Candidate: 2*C+2*D-6 
       - Loop 27 is collaborative
       - Loop 28 adds an expression [2*F-2*A'+2]
     - tail Candidate: -2*A+4*C+2*D+2*F-4 
       - Loop 27 is collaborative
       - Loop 28 has undefined behavior 
     - tail Candidate: 2*C+2*D-6 
       - Loop 27 is collaborative
       - Loop 28 adds an expression [2*F-2*A'+2]
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(97)=<2*C-4] 
 * Adding constraints: [aux(84)=<it(26)*aux(97),aux(84)=<aux(91)+aux(92),aux(84)=<aux(93)+aux(94),aux(84)=<aux(95)+aux(96),aux(92)=< -2*A+4*C+2*D+2*F-4,aux(94)=<2*C+2*D-6,aux(96)=<2*C+2*D-2*C'-2*D'] 

##### Pending set bfs_aux(A,B,C,D,E,F,G,H,I)
* Pmax/min: [aux(97)=<2*C-4]
* Psum in Loop 26: [aux(88)=<2*C-2*C'-4,aux(82)=<2*C-2*C'-3,aux(86)=<2*C-2*C'-3]
* Psum in Loop 28: [aux(33)=<F-A'/2+1/2,aux(35)=<F-A'/2+1/2,aux(31)=<2*F-2,aux(41)=<2*F-1,aux(43)=<2*F-1,aux(91)=< -2*D+4*F-2,aux(93)=<2*F-2*A'+2,aux(95)=<2*F-2*A'+2,aux(91)=<4*F-6]

###### Computing max_min for aux(97)=<2*C-4  
   - Found a solution using cacheing 
 * Adding constraints:[aux(97)=<aux(37)*2-2] 

##### Pending set bfs_aux(A,B,C,D,E,F,G,H,I)
* Psum in Loop 26: [aux(88)=<2*C-2*C'-4,aux(82)=<2*C-2*C'-3,aux(86)=<2*C-2*C'-3]
* Psum in Loop 28: [aux(33)=<F-A'/2+1/2,aux(35)=<F-A'/2+1/2,aux(31)=<2*F-2,aux(41)=<2*F-1,aux(43)=<2*F-1,aux(91)=< -2*D+4*F-2,aux(93)=<2*F-2*A'+2,aux(95)=<2*F-2*A'+2,aux(91)=<4*F-6]

###### Computing sum for aux(88)=<2*C-2*C'-4  in Loop 26 
   - Found a solution using cacheing 
 * Adding constraints: [aux(88)=<aux(98),aux(98)=<it(26)*aux(97),aux(98)=<aux(91)+aux(92),aux(98)=<aux(93)+aux(94),aux(98)=<aux(95)+aux(96)] 

##### Pending set bfs_aux(A,B,C,D,E,F,G,H,I)
* Psum in Loop 26: [aux(82)=<2*C-2*C'-3,aux(86)=<2*C-2*C'-3]
* Psum in Loop 28: [aux(33)=<F-A'/2+1/2,aux(35)=<F-A'/2+1/2,aux(31)=<2*F-2,aux(41)=<2*F-1,aux(43)=<2*F-1,aux(91)=< -2*D+4*F-2,aux(93)=<2*F-2*A'+2,aux(95)=<2*F-2*A'+2,aux(91)=<4*F-6]

###### Computing sum for aux(82)=<2*C-2*C'-3  in Loop 26 
   - Applying inductive sum strategy 
     - head Candidate: -2*A+4*C+3/2*D+2*F-5/2 
       - Loop 27 is collaborative
       - Loop 28 has a reset to  [4*F-5,-2*D+4*F-1]
     - head Candidate: 2*C+3/2*D-9/2 
       - Loop 27 is collaborative
       - Loop 28 adds an expression [2*F-3/2*A'+3/2]
     - tail Candidate: -2*A+4*C+3/2*D+2*F-5/2 
       - Loop 27 is collaborative
       - Loop 28 has undefined behavior 
     - tail Candidate: 2*C+3/2*D-9/2 
       - Loop 27 is collaborative
       - Loop 28 adds an expression [2*F-3/2*A'+3/2]
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(105)=<2*C-3] 
 * Adding constraints: [aux(82)=<it(26)*aux(105),aux(82)=<aux(99)+aux(100),aux(82)=<aux(101)+aux(102),aux(82)=<aux(103)+aux(104),aux(100)=< -2*A+4*C+3/2*D+2*F-5/2,aux(102)=<2*C+3/2*D-9/2,aux(104)=<2*C+3/2*D-2*C'-3/2*D'] 

##### Pending set bfs_aux(A,B,C,D,E,F,G,H,I)
* Pmax/min: [aux(105)=<2*C-3]
* Psum in Loop 26: [aux(86)=<2*C-2*C'-3]
* Psum in Loop 28: [aux(33)=<F-A'/2+1/2,aux(35)=<F-A'/2+1/2,aux(31)=<2*F-2,aux(41)=<2*F-1,aux(43)=<2*F-1,aux(91)=< -2*D+4*F-2,aux(99)=< -2*D+4*F-1,aux(93)=<2*F-2*A'+2,aux(95)=<2*F-2*A'+2,aux(101)=<2*F-3/2*A'+3/2,aux(103)=<2*F-3/2*A'+3/2,aux(91)=<4*F-6,aux(99)=<4*F-5]

###### Computing max_min for aux(105)=<2*C-3  
   - Found a solution using cacheing 
 * Adding constraints:[aux(105)=<aux(37)*2-1] 

##### Pending set bfs_aux(A,B,C,D,E,F,G,H,I)
* Psum in Loop 26: [aux(86)=<2*C-2*C'-3]
* Psum in Loop 28: [aux(33)=<F-A'/2+1/2,aux(35)=<F-A'/2+1/2,aux(31)=<2*F-2,aux(41)=<2*F-1,aux(43)=<2*F-1,aux(91)=< -2*D+4*F-2,aux(99)=< -2*D+4*F-1,aux(93)=<2*F-2*A'+2,aux(95)=<2*F-2*A'+2,aux(101)=<2*F-3/2*A'+3/2,aux(103)=<2*F-3/2*A'+3/2,aux(91)=<4*F-6,aux(99)=<4*F-5]

###### Computing sum for aux(86)=<2*C-2*C'-3  in Loop 26 
   - Found a solution using cacheing 
 * Adding constraints: [aux(86)=<aux(106),aux(106)=<it(26)*aux(105),aux(106)=<aux(99)+aux(100),aux(106)=<aux(101)+aux(102),aux(106)=<aux(103)+aux(104)] 

##### Pending set bfs_aux(A,B,C,D,E,F,G,H,I)
* Psum in Loop 28: [aux(33)=<F-A'/2+1/2,aux(35)=<F-A'/2+1/2,aux(31)=<2*F-2,aux(41)=<2*F-1,aux(43)=<2*F-1,aux(91)=< -2*D+4*F-2,aux(99)=< -2*D+4*F-1,aux(93)=<2*F-2*A'+2,aux(95)=<2*F-2*A'+2,aux(101)=<2*F-3/2*A'+3/2,aux(103)=<2*F-3/2*A'+3/2,aux(91)=<4*F-6,aux(99)=<4*F-5]

###### Computing sum for aux(33)=<F-A'/2+1/2  in Loop 28 
   - Applying inductive sum strategy 
     - head Candidate: F-1/2 
       - Loop 26 adds an expression [C-C'-1]
       - Loop 27 is collaborative
     - head Candidate: -D/2+F+1/2 
       - Loop 26 adds an expression [C-C'-2]
       - Loop 27 is collaborative
     - tail Candidate: F-1/2 
       - Loop 26 adds an expression [C-C'-1]
       - Loop 27 is collaborative
     - tail Candidate: -D/2+F+1/2 
       - Loop 26 adds an expression [C-C'-2]
       - Loop 27 is collaborative
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(115)=<F-1/2,aux(115)=< -D/2+F+1/2] 
 * Adding constraints: [aux(33)=<it(28)*aux(115),aux(33)=<aux(107)+aux(108),aux(33)=<aux(109)+aux(110),aux(33)=<aux(111)+aux(112),aux(33)=<aux(113)+aux(114),aux(108)=<F-1/2,aux(110)=< -D/2+F+1/2,aux(112)=<F-F',aux(114)=< -D/2+F+D'/2-F'] 

##### Pending set bfs_aux(A,B,C,D,E,F,G,H,I)
* Pmax/min: [aux(115)=< -D/2+F+1/2,aux(115)=<F-1/2]
* Psum in Loop 26: [aux(109)=<C-C'-2,aux(113)=<C-C'-2,aux(107)=<C-C'-1,aux(111)=<C-C'-1]
* Psum in Loop 28: [aux(35)=<F-A'/2+1/2,aux(31)=<2*F-2,aux(41)=<2*F-1,aux(43)=<2*F-1,aux(91)=< -2*D+4*F-2,aux(99)=< -2*D+4*F-1,aux(93)=<2*F-2*A'+2,aux(95)=<2*F-2*A'+2,aux(101)=<2*F-3/2*A'+3/2,aux(103)=<2*F-3/2*A'+3/2,aux(91)=<4*F-6,aux(99)=<4*F-5]

###### Computing max_min for aux(115)=< -D/2+F+1/2  
   - Found a solution using cacheing 
 * Adding constraints:[aux(115)=<aux(90)* (1/2)+1/2] 

##### Pending set bfs_aux(A,B,C,D,E,F,G,H,I)
* Pmax/min: [aux(115)=<F-1/2]
* Psum in Loop 26: [aux(109)=<C-C'-2,aux(113)=<C-C'-2,aux(107)=<C-C'-1,aux(111)=<C-C'-1]
* Psum in Loop 28: [aux(35)=<F-A'/2+1/2,aux(31)=<2*F-2,aux(41)=<2*F-1,aux(43)=<2*F-1,aux(91)=< -2*D+4*F-2,aux(99)=< -2*D+4*F-1,aux(93)=<2*F-2*A'+2,aux(95)=<2*F-2*A'+2,aux(101)=<2*F-3/2*A'+3/2,aux(103)=<2*F-3/2*A'+3/2,aux(91)=<4*F-6,aux(99)=<4*F-5]

###### Computing max_min for aux(115)=<F-1/2  
   - Found a solution using cacheing 
 * Adding constraints:[aux(115)=<aux(53)-3/2] 

##### Pending set bfs_aux(A,B,C,D,E,F,G,H,I)
* Psum in Loop 26: [aux(109)=<C-C'-2,aux(113)=<C-C'-2,aux(107)=<C-C'-1,aux(111)=<C-C'-1]
* Psum in Loop 28: [aux(35)=<F-A'/2+1/2,aux(31)=<2*F-2,aux(41)=<2*F-1,aux(43)=<2*F-1,aux(91)=< -2*D+4*F-2,aux(99)=< -2*D+4*F-1,aux(93)=<2*F-2*A'+2,aux(95)=<2*F-2*A'+2,aux(101)=<2*F-3/2*A'+3/2,aux(103)=<2*F-3/2*A'+3/2,aux(91)=<4*F-6,aux(99)=<4*F-5]

###### Computing sum for aux(109)=<C-C'-2  in Loop 26 
   - Found a solution using cacheing 
 * Adding constraints: [aux(109)=<aux(116)* (1/2),aux(116)=<it(26)*aux(97),aux(116)=<aux(91)+aux(92),aux(116)=<aux(93)+aux(94),aux(116)=<aux(95)+aux(96)] 

##### Pending set bfs_aux(A,B,C,D,E,F,G,H,I)
* Psum in Loop 26: [aux(113)=<C-C'-2,aux(107)=<C-C'-1,aux(111)=<C-C'-1]
* Psum in Loop 28: [aux(35)=<F-A'/2+1/2,aux(31)=<2*F-2,aux(41)=<2*F-1,aux(43)=<2*F-1,aux(91)=< -2*D+4*F-2,aux(99)=< -2*D+4*F-1,aux(93)=<2*F-2*A'+2,aux(95)=<2*F-2*A'+2,aux(101)=<2*F-3/2*A'+3/2,aux(103)=<2*F-3/2*A'+3/2,aux(91)=<4*F-6,aux(99)=<4*F-5]

###### Computing sum for aux(113)=<C-C'-2  in Loop 26 
   - Found a solution using cacheing 
 * Adding constraints: [aux(113)=<aux(117)* (1/2),aux(117)=<it(26)*aux(97),aux(117)=<aux(91)+aux(92),aux(117)=<aux(93)+aux(94),aux(117)=<aux(95)+aux(96)] 

##### Pending set bfs_aux(A,B,C,D,E,F,G,H,I)
* Psum in Loop 26: [aux(107)=<C-C'-1,aux(111)=<C-C'-1]
* Psum in Loop 28: [aux(35)=<F-A'/2+1/2,aux(31)=<2*F-2,aux(41)=<2*F-1,aux(43)=<2*F-1,aux(91)=< -2*D+4*F-2,aux(99)=< -2*D+4*F-1,aux(93)=<2*F-2*A'+2,aux(95)=<2*F-2*A'+2,aux(101)=<2*F-3/2*A'+3/2,aux(103)=<2*F-3/2*A'+3/2,aux(91)=<4*F-6,aux(99)=<4*F-5]

###### Computing sum for aux(107)=<C-C'-1  in Loop 26 
   - Found a solution using cacheing 
 * Adding constraints: [aux(107)=<aux(118),aux(118)=<it(26)*aux(37),aux(118)=<aux(31)+aux(32),aux(118)=<aux(33)+aux(34),aux(118)=<aux(35)+aux(36)] 

##### Pending set bfs_aux(A,B,C,D,E,F,G,H,I)
* Psum in Loop 26: [aux(111)=<C-C'-1]
* Psum in Loop 28: [aux(35)=<F-A'/2+1/2,aux(31)=<2*F-2,aux(41)=<2*F-1,aux(43)=<2*F-1,aux(91)=< -2*D+4*F-2,aux(99)=< -2*D+4*F-1,aux(93)=<2*F-2*A'+2,aux(95)=<2*F-2*A'+2,aux(101)=<2*F-3/2*A'+3/2,aux(103)=<2*F-3/2*A'+3/2,aux(91)=<4*F-6,aux(99)=<4*F-5]

###### Computing sum for aux(111)=<C-C'-1  in Loop 26 
   - Found a solution using cacheing 
 * Adding constraints: [aux(111)=<aux(119),aux(119)=<it(26)*aux(37),aux(119)=<aux(31)+aux(32),aux(119)=<aux(33)+aux(34),aux(119)=<aux(35)+aux(36)] 

##### Pending set bfs_aux(A,B,C,D,E,F,G,H,I)
* Psum in Loop 28: [aux(35)=<F-A'/2+1/2,aux(31)=<2*F-2,aux(41)=<2*F-1,aux(43)=<2*F-1,aux(91)=< -2*D+4*F-2,aux(99)=< -2*D+4*F-1,aux(93)=<2*F-2*A'+2,aux(95)=<2*F-2*A'+2,aux(101)=<2*F-3/2*A'+3/2,aux(103)=<2*F-3/2*A'+3/2,aux(91)=<4*F-6,aux(99)=<4*F-5]

###### Computing sum for aux(35)=<F-A'/2+1/2  in Loop 28 
   - Found a solution using cacheing 
 * Adding constraints: [aux(35)=<aux(120),aux(120)=<it(28)*aux(115),aux(120)=<aux(107)+aux(108),aux(120)=<aux(109)+aux(110),aux(120)=<aux(111)+aux(112),aux(120)=<aux(113)+aux(114)] 

##### Pending set bfs_aux(A,B,C,D,E,F,G,H,I)
* Psum in Loop 28: [aux(31)=<2*F-2,aux(41)=<2*F-1,aux(43)=<2*F-1,aux(91)=< -2*D+4*F-2,aux(99)=< -2*D+4*F-1,aux(93)=<2*F-2*A'+2,aux(95)=<2*F-2*A'+2,aux(101)=<2*F-3/2*A'+3/2,aux(103)=<2*F-3/2*A'+3/2,aux(91)=<4*F-6,aux(99)=<4*F-5]

###### Computing sum for aux(31)=<2*F-2  in Loop 28 
   - Applying inductive sum strategy 
     - head Candidate: 2*F-2 
       - Loop 26 adds an expression [2*C-2*C'-2]
       - Loop 27 is collaborative
     - tail Candidate: 2*F-2 
       - Loop 26 adds an expression [2*C-2*C'-2]
       - Loop 27 is collaborative
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(125)=<2*F-2] 
 * Adding constraints: [aux(31)=<it(28)*aux(125),aux(31)=<aux(121)+aux(122),aux(31)=<aux(123)+aux(124),aux(122)=<2*F-2,aux(124)=<2*F-2*F'] 

##### Pending set bfs_aux(A,B,C,D,E,F,G,H,I)
* Pmax/min: [aux(125)=<2*F-2]
* Psum in Loop 26: [aux(121)=<2*C-2*C'-2,aux(123)=<2*C-2*C'-2]
* Psum in Loop 28: [aux(41)=<2*F-1,aux(43)=<2*F-1,aux(91)=< -2*D+4*F-2,aux(99)=< -2*D+4*F-1,aux(93)=<2*F-2*A'+2,aux(95)=<2*F-2*A'+2,aux(101)=<2*F-3/2*A'+3/2,aux(103)=<2*F-3/2*A'+3/2,aux(91)=<4*F-6,aux(99)=<4*F-5]

###### Computing max_min for aux(125)=<2*F-2  
   - Found a solution using cacheing 
 * Adding constraints:[aux(125)=<aux(53)*2-4] 

##### Pending set bfs_aux(A,B,C,D,E,F,G,H,I)
* Psum in Loop 26: [aux(121)=<2*C-2*C'-2,aux(123)=<2*C-2*C'-2]
* Psum in Loop 28: [aux(41)=<2*F-1,aux(43)=<2*F-1,aux(91)=< -2*D+4*F-2,aux(99)=< -2*D+4*F-1,aux(93)=<2*F-2*A'+2,aux(95)=<2*F-2*A'+2,aux(101)=<2*F-3/2*A'+3/2,aux(103)=<2*F-3/2*A'+3/2,aux(91)=<4*F-6,aux(99)=<4*F-5]

###### Computing sum for aux(121)=<2*C-2*C'-2  in Loop 26 
   - Found a solution using cacheing 
 * Adding constraints: [aux(121)=<aux(126)*2,aux(126)=<it(26)*aux(37),aux(126)=<aux(31)+aux(32),aux(126)=<aux(33)+aux(34),aux(126)=<aux(35)+aux(36)] 

##### Pending set bfs_aux(A,B,C,D,E,F,G,H,I)
* Psum in Loop 26: [aux(123)=<2*C-2*C'-2]
* Psum in Loop 28: [aux(41)=<2*F-1,aux(43)=<2*F-1,aux(91)=< -2*D+4*F-2,aux(99)=< -2*D+4*F-1,aux(93)=<2*F-2*A'+2,aux(95)=<2*F-2*A'+2,aux(101)=<2*F-3/2*A'+3/2,aux(103)=<2*F-3/2*A'+3/2,aux(91)=<4*F-6,aux(99)=<4*F-5]

###### Computing sum for aux(123)=<2*C-2*C'-2  in Loop 26 
   - Found a solution using cacheing 
 * Adding constraints: [aux(123)=<aux(127)*2,aux(127)=<it(26)*aux(37),aux(127)=<aux(31)+aux(32),aux(127)=<aux(33)+aux(34),aux(127)=<aux(35)+aux(36)] 

##### Pending set bfs_aux(A,B,C,D,E,F,G,H,I)
* Psum in Loop 28: [aux(41)=<2*F-1,aux(43)=<2*F-1,aux(91)=< -2*D+4*F-2,aux(99)=< -2*D+4*F-1,aux(93)=<2*F-2*A'+2,aux(95)=<2*F-2*A'+2,aux(101)=<2*F-3/2*A'+3/2,aux(103)=<2*F-3/2*A'+3/2,aux(91)=<4*F-6,aux(99)=<4*F-5]

###### Computing sum for aux(41)=<2*F-1  in Loop 28 
   - Applying inductive sum strategy 
     - head Candidate: 2*F-1 
       - Loop 26 adds an expression [2*C-2*C'-2]
       - Loop 27 is collaborative
     - tail Candidate: 2*F-1 
       - Loop 26 adds an expression [2*C-2*C'-2]
       - Loop 27 is collaborative
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(132)=<2*F-1] 
 * Adding constraints: [aux(41)=<it(28)*aux(132),aux(41)=<aux(128)+aux(129),aux(41)=<aux(130)+aux(131),aux(129)=<2*F-1,aux(131)=<2*F-2*F'] 

##### Pending set bfs_aux(A,B,C,D,E,F,G,H,I)
* Pmax/min: [aux(132)=<2*F-1]
* Psum in Loop 26: [aux(128)=<2*C-2*C'-2,aux(130)=<2*C-2*C'-2]
* Psum in Loop 28: [aux(43)=<2*F-1,aux(91)=< -2*D+4*F-2,aux(99)=< -2*D+4*F-1,aux(93)=<2*F-2*A'+2,aux(95)=<2*F-2*A'+2,aux(101)=<2*F-3/2*A'+3/2,aux(103)=<2*F-3/2*A'+3/2,aux(91)=<4*F-6,aux(99)=<4*F-5]

###### Computing max_min for aux(132)=<2*F-1  
   - Found a solution using cacheing 
 * Adding constraints:[aux(132)=<aux(53)*2-3] 

##### Pending set bfs_aux(A,B,C,D,E,F,G,H,I)
* Psum in Loop 26: [aux(128)=<2*C-2*C'-2,aux(130)=<2*C-2*C'-2]
* Psum in Loop 28: [aux(43)=<2*F-1,aux(91)=< -2*D+4*F-2,aux(99)=< -2*D+4*F-1,aux(93)=<2*F-2*A'+2,aux(95)=<2*F-2*A'+2,aux(101)=<2*F-3/2*A'+3/2,aux(103)=<2*F-3/2*A'+3/2,aux(91)=<4*F-6,aux(99)=<4*F-5]

###### Computing sum for aux(128)=<2*C-2*C'-2  in Loop 26 
   - Found a solution using cacheing 
 * Adding constraints: [aux(128)=<aux(133)*2,aux(133)=<it(26)*aux(37),aux(133)=<aux(31)+aux(32),aux(133)=<aux(33)+aux(34),aux(133)=<aux(35)+aux(36)] 

##### Pending set bfs_aux(A,B,C,D,E,F,G,H,I)
* Psum in Loop 26: [aux(130)=<2*C-2*C'-2]
* Psum in Loop 28: [aux(43)=<2*F-1,aux(91)=< -2*D+4*F-2,aux(99)=< -2*D+4*F-1,aux(93)=<2*F-2*A'+2,aux(95)=<2*F-2*A'+2,aux(101)=<2*F-3/2*A'+3/2,aux(103)=<2*F-3/2*A'+3/2,aux(91)=<4*F-6,aux(99)=<4*F-5]

###### Computing sum for aux(130)=<2*C-2*C'-2  in Loop 26 
   - Found a solution using cacheing 
 * Adding constraints: [aux(130)=<aux(134)*2,aux(134)=<it(26)*aux(37),aux(134)=<aux(31)+aux(32),aux(134)=<aux(33)+aux(34),aux(134)=<aux(35)+aux(36)] 

##### Pending set bfs_aux(A,B,C,D,E,F,G,H,I)
* Psum in Loop 28: [aux(43)=<2*F-1,aux(91)=< -2*D+4*F-2,aux(99)=< -2*D+4*F-1,aux(93)=<2*F-2*A'+2,aux(95)=<2*F-2*A'+2,aux(101)=<2*F-3/2*A'+3/2,aux(103)=<2*F-3/2*A'+3/2,aux(91)=<4*F-6,aux(99)=<4*F-5]

###### Computing sum for aux(43)=<2*F-1  in Loop 28 
   - Found a solution using cacheing 
 * Adding constraints: [aux(43)=<aux(135),aux(135)=<it(28)*aux(132),aux(135)=<aux(128)+aux(129),aux(135)=<aux(130)+aux(131)] 

##### Pending set bfs_aux(A,B,C,D,E,F,G,H,I)
* Psum in Loop 28: [aux(91)=< -2*D+4*F-2,aux(99)=< -2*D+4*F-1,aux(93)=<2*F-2*A'+2,aux(95)=<2*F-2*A'+2,aux(101)=<2*F-3/2*A'+3/2,aux(103)=<2*F-3/2*A'+3/2,aux(91)=<4*F-6,aux(99)=<4*F-5]

###### Computing sum for aux(91)=< -2*D+4*F-2  in Loop 28 
   - Applying inductive sum strategy 
     - head Candidate: 4*F-6 
       - Loop 26 adds an expression [4*C-4*C'-4]
       - Loop 27 is collaborative
     - head Candidate: 2*A+4*F-8 
       - Loop 26 adds an expression [4*C-4*C'-6]
       - Loop 27 is collaborative
     - tail Candidate: 4*F-6 
       - Loop 26 adds an expression [4*C-4*C'-4]
       - Loop 27 is collaborative
     - tail Candidate: 2*A+4*F-8 
       - Loop 26 adds an expression [4*C-4*C'-6]
       - Loop 27 is collaborative
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(144)=< -2*D+4*F-2] 
 * Adding constraints: [aux(91)=<it(28)*aux(144),aux(91)=<aux(136)+aux(137),aux(91)=<aux(138)+aux(139),aux(91)=<aux(140)+aux(141),aux(91)=<aux(142)+aux(143),aux(137)=<4*F-6,aux(139)=<2*A+4*F-8,aux(141)=<4*F-4*F',aux(143)=<2*A+4*F-2*A'-4*F'] 

##### Pending set bfs_aux(A,B,C,D,E,F,G,H,I)
* Pmax/min: [aux(144)=< -2*D+4*F-2]
* Psum in Loop 26: [aux(138)=<4*C-4*C'-6,aux(142)=<4*C-4*C'-6,aux(136)=<4*C-4*C'-4,aux(140)=<4*C-4*C'-4]
* Psum in Loop 28: [aux(99)=< -2*D+4*F-1,aux(93)=<2*F-2*A'+2,aux(95)=<2*F-2*A'+2,aux(101)=<2*F-3/2*A'+3/2,aux(103)=<2*F-3/2*A'+3/2,aux(91)=<4*F-6,aux(99)=<4*F-5]

###### Computing max_min for aux(144)=< -2*D+4*F-2  
   - Found a solution using cacheing 
 * Adding constraints:[aux(144)=<aux(90)*2-2] 

##### Pending set bfs_aux(A,B,C,D,E,F,G,H,I)
* Psum in Loop 26: [aux(138)=<4*C-4*C'-6,aux(142)=<4*C-4*C'-6,aux(136)=<4*C-4*C'-4,aux(140)=<4*C-4*C'-4]
* Psum in Loop 28: [aux(99)=< -2*D+4*F-1,aux(93)=<2*F-2*A'+2,aux(95)=<2*F-2*A'+2,aux(101)=<2*F-3/2*A'+3/2,aux(103)=<2*F-3/2*A'+3/2,aux(91)=<4*F-6,aux(99)=<4*F-5]

###### Computing sum for aux(138)=<4*C-4*C'-6  in Loop 26 
   - Found a solution using cacheing 
 * Adding constraints: [aux(138)=<aux(145)*2,aux(145)=<it(26)*aux(105),aux(145)=<aux(99)+aux(100),aux(145)=<aux(101)+aux(102),aux(145)=<aux(103)+aux(104)] 

##### Pending set bfs_aux(A,B,C,D,E,F,G,H,I)
* Psum in Loop 26: [aux(142)=<4*C-4*C'-6,aux(136)=<4*C-4*C'-4,aux(140)=<4*C-4*C'-4]
* Psum in Loop 28: [aux(99)=< -2*D+4*F-1,aux(93)=<2*F-2*A'+2,aux(95)=<2*F-2*A'+2,aux(101)=<2*F-3/2*A'+3/2,aux(103)=<2*F-3/2*A'+3/2,aux(91)=<4*F-6,aux(99)=<4*F-5]

###### Computing sum for aux(142)=<4*C-4*C'-6  in Loop 26 
   - Found a solution using cacheing 
 * Adding constraints: [aux(142)=<aux(146)*2,aux(146)=<it(26)*aux(105),aux(146)=<aux(99)+aux(100),aux(146)=<aux(101)+aux(102),aux(146)=<aux(103)+aux(104)] 

##### Pending set bfs_aux(A,B,C,D,E,F,G,H,I)
* Psum in Loop 26: [aux(136)=<4*C-4*C'-4,aux(140)=<4*C-4*C'-4]
* Psum in Loop 28: [aux(99)=< -2*D+4*F-1,aux(93)=<2*F-2*A'+2,aux(95)=<2*F-2*A'+2,aux(101)=<2*F-3/2*A'+3/2,aux(103)=<2*F-3/2*A'+3/2,aux(91)=<4*F-6,aux(99)=<4*F-5]

###### Computing sum for aux(136)=<4*C-4*C'-4  in Loop 26 
   - Found a solution using cacheing 
 * Adding constraints: [aux(136)=<aux(147)*4,aux(147)=<it(26)*aux(37),aux(147)=<aux(31)+aux(32),aux(147)=<aux(33)+aux(34),aux(147)=<aux(35)+aux(36)] 

##### Pending set bfs_aux(A,B,C,D,E,F,G,H,I)
* Psum in Loop 26: [aux(140)=<4*C-4*C'-4]
* Psum in Loop 28: [aux(99)=< -2*D+4*F-1,aux(93)=<2*F-2*A'+2,aux(95)=<2*F-2*A'+2,aux(101)=<2*F-3/2*A'+3/2,aux(103)=<2*F-3/2*A'+3/2,aux(91)=<4*F-6,aux(99)=<4*F-5]

###### Computing sum for aux(140)=<4*C-4*C'-4  in Loop 26 
   - Found a solution using cacheing 
 * Adding constraints: [aux(140)=<aux(148)*4,aux(148)=<it(26)*aux(37),aux(148)=<aux(31)+aux(32),aux(148)=<aux(33)+aux(34),aux(148)=<aux(35)+aux(36)] 

##### Pending set bfs_aux(A,B,C,D,E,F,G,H,I)
* Psum in Loop 28: [aux(99)=< -2*D+4*F-1,aux(93)=<2*F-2*A'+2,aux(95)=<2*F-2*A'+2,aux(101)=<2*F-3/2*A'+3/2,aux(103)=<2*F-3/2*A'+3/2,aux(91)=<4*F-6,aux(99)=<4*F-5]

###### Computing sum for aux(99)=< -2*D+4*F-1  in Loop 28 
   - Applying inductive sum strategy 
     - head Candidate: 4*F-5 
       - Loop 26 adds an expression [4*C-4*C'-4]
       - Loop 27 is collaborative
     - head Candidate: 2*A+4*F-7 
       - Loop 26 adds an expression [4*C-4*C'-6]
       - Loop 27 is collaborative
     - tail Candidate: 4*F-5 
       - Loop 26 adds an expression [4*C-4*C'-4]
       - Loop 27 is collaborative
     - tail Candidate: 2*A+4*F-7 
       - Loop 26 adds an expression [4*C-4*C'-6]
       - Loop 27 is collaborative
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(157)=< -2*D+4*F-1] 
 * Adding constraints: [aux(99)=<it(28)*aux(157),aux(99)=<aux(149)+aux(150),aux(99)=<aux(151)+aux(152),aux(99)=<aux(153)+aux(154),aux(99)=<aux(155)+aux(156),aux(150)=<4*F-5,aux(152)=<2*A+4*F-7,aux(154)=<4*F-4*F',aux(156)=<2*A+4*F-2*A'-4*F'] 

##### Pending set bfs_aux(A,B,C,D,E,F,G,H,I)
* Pmax/min: [aux(157)=< -2*D+4*F-1]
* Psum in Loop 26: [aux(151)=<4*C-4*C'-6,aux(155)=<4*C-4*C'-6,aux(149)=<4*C-4*C'-4,aux(153)=<4*C-4*C'-4]
* Psum in Loop 28: [aux(93)=<2*F-2*A'+2,aux(95)=<2*F-2*A'+2,aux(101)=<2*F-3/2*A'+3/2,aux(103)=<2*F-3/2*A'+3/2,aux(91)=<4*F-6,aux(99)=<4*F-5]

###### Computing max_min for aux(157)=< -2*D+4*F-1  
   - Found a solution using cacheing 
 * Adding constraints:[aux(157)=<aux(90)*2-1] 

##### Pending set bfs_aux(A,B,C,D,E,F,G,H,I)
* Psum in Loop 26: [aux(151)=<4*C-4*C'-6,aux(155)=<4*C-4*C'-6,aux(149)=<4*C-4*C'-4,aux(153)=<4*C-4*C'-4]
* Psum in Loop 28: [aux(93)=<2*F-2*A'+2,aux(95)=<2*F-2*A'+2,aux(101)=<2*F-3/2*A'+3/2,aux(103)=<2*F-3/2*A'+3/2,aux(91)=<4*F-6,aux(99)=<4*F-5]

###### Computing sum for aux(151)=<4*C-4*C'-6  in Loop 26 
   - Found a solution using cacheing 
 * Adding constraints: [aux(151)=<aux(158)*2,aux(158)=<it(26)*aux(105),aux(158)=<aux(99)+aux(100),aux(158)=<aux(101)+aux(102),aux(158)=<aux(103)+aux(104)] 

##### Pending set bfs_aux(A,B,C,D,E,F,G,H,I)
* Psum in Loop 26: [aux(155)=<4*C-4*C'-6,aux(149)=<4*C-4*C'-4,aux(153)=<4*C-4*C'-4]
* Psum in Loop 28: [aux(93)=<2*F-2*A'+2,aux(95)=<2*F-2*A'+2,aux(101)=<2*F-3/2*A'+3/2,aux(103)=<2*F-3/2*A'+3/2,aux(91)=<4*F-6,aux(99)=<4*F-5]

###### Computing sum for aux(155)=<4*C-4*C'-6  in Loop 26 
   - Found a solution using cacheing 
 * Adding constraints: [aux(155)=<aux(159)*2,aux(159)=<it(26)*aux(105),aux(159)=<aux(99)+aux(100),aux(159)=<aux(101)+aux(102),aux(159)=<aux(103)+aux(104)] 

##### Pending set bfs_aux(A,B,C,D,E,F,G,H,I)
* Psum in Loop 26: [aux(149)=<4*C-4*C'-4,aux(153)=<4*C-4*C'-4]
* Psum in Loop 28: [aux(93)=<2*F-2*A'+2,aux(95)=<2*F-2*A'+2,aux(101)=<2*F-3/2*A'+3/2,aux(103)=<2*F-3/2*A'+3/2,aux(91)=<4*F-6,aux(99)=<4*F-5]

###### Computing sum for aux(149)=<4*C-4*C'-4  in Loop 26 
   - Found a solution using cacheing 
 * Adding constraints: [aux(149)=<aux(160)*4,aux(160)=<it(26)*aux(37),aux(160)=<aux(31)+aux(32),aux(160)=<aux(33)+aux(34),aux(160)=<aux(35)+aux(36)] 

##### Pending set bfs_aux(A,B,C,D,E,F,G,H,I)
* Psum in Loop 26: [aux(153)=<4*C-4*C'-4]
* Psum in Loop 28: [aux(93)=<2*F-2*A'+2,aux(95)=<2*F-2*A'+2,aux(101)=<2*F-3/2*A'+3/2,aux(103)=<2*F-3/2*A'+3/2,aux(91)=<4*F-6,aux(99)=<4*F-5]

###### Computing sum for aux(153)=<4*C-4*C'-4  in Loop 26 
   - Found a solution using cacheing 
 * Adding constraints: [aux(153)=<aux(161)*4,aux(161)=<it(26)*aux(37),aux(161)=<aux(31)+aux(32),aux(161)=<aux(33)+aux(34),aux(161)=<aux(35)+aux(36)] 

##### Pending set bfs_aux(A,B,C,D,E,F,G,H,I)
* Psum in Loop 28: [aux(93)=<2*F-2*A'+2,aux(95)=<2*F-2*A'+2,aux(101)=<2*F-3/2*A'+3/2,aux(103)=<2*F-3/2*A'+3/2,aux(91)=<4*F-6,aux(99)=<4*F-5]

###### Computing sum for aux(93)=<2*F-2*A'+2  in Loop 28 
   - Applying inductive sum strategy 
     - head Candidate: 2*F-2 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: 2*A+2*F-4 
       - Loop 26 adds an expression [2*C-2*C'-4]
       - Loop 27 is collaborative
     - tail Candidate: 2*F-2 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: 2*A+2*F-4 
       - Loop 26 adds an expression [2*C-2*C'-4]
       - Loop 27 is collaborative
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(168)=<2*F-2,aux(168)=< -2*D+2*F+2] 
 * Adding constraints: [aux(93)=<it(28)*aux(168),aux(93)=<aux(121)+aux(162),aux(93)=<aux(163)+aux(164),aux(93)=<aux(123)+aux(165),aux(93)=<aux(166)+aux(167),aux(162)=<2*F-2,aux(164)=<2*A+2*F-4,aux(165)=<2*F-2*F',aux(167)=<2*A+2*F-2*A'-2*F'] 

##### Pending set bfs_aux(A,B,C,D,E,F,G,H,I)
* Pmax/min: [aux(168)=< -2*D+2*F+2,aux(168)=<2*F-2]
* Psum in Loop 26: [aux(163)=<2*C-2*C'-4,aux(166)=<2*C-2*C'-4]
* Psum in Loop 28: [aux(95)=<2*F-2*A'+2,aux(101)=<2*F-3/2*A'+3/2,aux(103)=<2*F-3/2*A'+3/2,aux(91)=<4*F-6,aux(99)=<4*F-5]

###### Computing max_min for aux(168)=< -2*D+2*F+2  
   - Found a solution using transitive invariants 
 * Adding constraints:[aux(168)=<2*C+2*F-2,aux(168)=<6*C+4*D+2*F-10] 

##### Pending set bfs_aux(A,B,C,D,E,F,G,H,I)
* Pmax/min: [aux(168)=<2*F-2]
* Psum in Loop 26: [aux(163)=<2*C-2*C'-4,aux(166)=<2*C-2*C'-4]
* Psum in Loop 28: [aux(95)=<2*F-2*A'+2,aux(101)=<2*F-3/2*A'+3/2,aux(103)=<2*F-3/2*A'+3/2,aux(91)=<4*F-6,aux(99)=<4*F-5]

###### Computing max_min for aux(168)=<2*F-2  
   - Found a solution using cacheing 
 * Adding constraints:[aux(168)=<aux(53)*2-4] 

##### Pending set bfs_aux(A,B,C,D,E,F,G,H,I)
* Psum in Loop 26: [aux(163)=<2*C-2*C'-4,aux(166)=<2*C-2*C'-4]
* Psum in Loop 28: [aux(95)=<2*F-2*A'+2,aux(101)=<2*F-3/2*A'+3/2,aux(103)=<2*F-3/2*A'+3/2,aux(91)=<4*F-6,aux(99)=<4*F-5]

###### Computing sum for aux(163)=<2*C-2*C'-4  in Loop 26 
   - Found a solution using cacheing 
 * Adding constraints: [aux(163)=<aux(169),aux(169)=<it(26)*aux(97),aux(169)=<aux(91)+aux(92),aux(169)=<aux(93)+aux(94),aux(169)=<aux(95)+aux(96)] 

##### Pending set bfs_aux(A,B,C,D,E,F,G,H,I)
* Psum in Loop 26: [aux(166)=<2*C-2*C'-4]
* Psum in Loop 28: [aux(95)=<2*F-2*A'+2,aux(101)=<2*F-3/2*A'+3/2,aux(103)=<2*F-3/2*A'+3/2,aux(91)=<4*F-6,aux(99)=<4*F-5]

###### Computing sum for aux(166)=<2*C-2*C'-4  in Loop 26 
   - Found a solution using cacheing 
 * Adding constraints: [aux(166)=<aux(170),aux(170)=<it(26)*aux(97),aux(170)=<aux(91)+aux(92),aux(170)=<aux(93)+aux(94),aux(170)=<aux(95)+aux(96)] 

##### Pending set bfs_aux(A,B,C,D,E,F,G,H,I)
* Psum in Loop 28: [aux(95)=<2*F-2*A'+2,aux(101)=<2*F-3/2*A'+3/2,aux(103)=<2*F-3/2*A'+3/2,aux(91)=<4*F-6,aux(99)=<4*F-5]

###### Computing sum for aux(95)=<2*F-2*A'+2  in Loop 28 
   - Found a solution using cacheing 
 * Adding constraints: [aux(95)=<aux(171),aux(171)=<it(28)*aux(168),aux(171)=<aux(121)+aux(162),aux(171)=<aux(163)+aux(164),aux(171)=<aux(123)+aux(165),aux(171)=<aux(166)+aux(167)] 

##### Pending set bfs_aux(A,B,C,D,E,F,G,H,I)
* Psum in Loop 28: [aux(101)=<2*F-3/2*A'+3/2,aux(103)=<2*F-3/2*A'+3/2,aux(91)=<4*F-6,aux(99)=<4*F-5]

###### Computing sum for aux(101)=<2*F-3/2*A'+3/2  in Loop 28 
   - Applying inductive sum strategy 
     - head Candidate: 2*F-3/2 
       - Loop 26 adds an expression [2*C-2*C'-2]
       - Loop 27 is collaborative
     - head Candidate: -3/2*D+2*F+3/2 
       - Loop 26 adds an expression [2*C-2*C'-5]
       - Loop 27 is collaborative
     - tail Candidate: 2*F-3/2 
       - Loop 26 adds an expression [2*C-2*C'-2]
       - Loop 27 is collaborative
     - tail Candidate: -3/2*D+2*F+3/2 
       - Loop 26 adds an expression [2*C-2*C'-5]
       - Loop 27 is collaborative
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(180)=<2*F-3/2,aux(180)=< -3/2*D+2*F+3/2] 
 * Adding constraints: [aux(101)=<it(28)*aux(180),aux(101)=<aux(172)+aux(173),aux(101)=<aux(174)+aux(175),aux(101)=<aux(176)+aux(177),aux(101)=<aux(178)+aux(179),aux(173)=<2*F-3/2,aux(175)=< -3/2*D+2*F+3/2,aux(177)=<2*F-2*F',aux(179)=< -3/2*D+2*F+3/2*D'-2*F'] 

##### Pending set bfs_aux(A,B,C,D,E,F,G,H,I)
* Pmax/min: [aux(180)=< -3/2*D+2*F+3/2,aux(180)=<2*F-3/2]
* Psum in Loop 26: [aux(174)=<2*C-2*C'-5,aux(178)=<2*C-2*C'-5,aux(172)=<2*C-2*C'-2,aux(176)=<2*C-2*C'-2]
* Psum in Loop 28: [aux(103)=<2*F-3/2*A'+3/2,aux(91)=<4*F-6,aux(99)=<4*F-5]

###### Computing max_min for aux(180)=< -3/2*D+2*F+3/2  
   - Found a solution using transitive invariants 
 * Adding constraints:[aux(180)=<2*C+2*F-3/2,aux(180)=<6*C+9/2*D+2*F-21/2] 

##### Pending set bfs_aux(A,B,C,D,E,F,G,H,I)
* Pmax/min: [aux(180)=<2*F-3/2]
* Psum in Loop 26: [aux(174)=<2*C-2*C'-5,aux(178)=<2*C-2*C'-5,aux(172)=<2*C-2*C'-2,aux(176)=<2*C-2*C'-2]
* Psum in Loop 28: [aux(103)=<2*F-3/2*A'+3/2,aux(91)=<4*F-6,aux(99)=<4*F-5]

###### Computing max_min for aux(180)=<2*F-3/2  
   - Found a solution using cacheing 
 * Adding constraints:[aux(180)=<aux(53)*2-7/2] 

##### Pending set bfs_aux(A,B,C,D,E,F,G,H,I)
* Psum in Loop 26: [aux(174)=<2*C-2*C'-5,aux(178)=<2*C-2*C'-5,aux(172)=<2*C-2*C'-2,aux(176)=<2*C-2*C'-2]
* Psum in Loop 28: [aux(103)=<2*F-3/2*A'+3/2,aux(91)=<4*F-6,aux(99)=<4*F-5]

###### Computing sum for aux(174)=<2*C-2*C'-5  in Loop 26 
   - Applying inductive sum strategy 
     - head Candidate: -2*A+4*C+5/2*D+2*F-11/2 
       - Loop 27 is collaborative
       - Loop 28 has a reset to  [4*F-7,-2*D+4*F-3]
     - head Candidate: 2*C+5/2*D-15/2 
       - Loop 27 is collaborative
       - Loop 28 adds an expression [2*F-5/2*A'+5/2]
     - tail Candidate: -2*A+4*C+5/2*D+2*F-11/2 
       - Loop 27 is collaborative
       - Loop 28 has undefined behavior 
     - tail Candidate: 2*C+5/2*D-15/2 
       - Loop 27 is collaborative
       - Loop 28 adds an expression [2*F-5/2*A'+5/2]
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(187)=<2*C-5] 
 * Adding constraints: [aux(174)=<it(26)*aux(187),aux(174)=<aux(181)+aux(182),aux(174)=<aux(183)+aux(184),aux(174)=<aux(185)+aux(186),aux(182)=< -2*A+4*C+5/2*D+2*F-11/2,aux(184)=<2*C+5/2*D-15/2,aux(186)=<2*C+5/2*D-2*C'-5/2*D'] 

##### Pending set bfs_aux(A,B,C,D,E,F,G,H,I)
* Pmax/min: [aux(187)=<2*C-5]
* Psum in Loop 26: [aux(178)=<2*C-2*C'-5,aux(172)=<2*C-2*C'-2,aux(176)=<2*C-2*C'-2]
* Psum in Loop 28: [aux(103)=<2*F-3/2*A'+3/2,aux(91)=<4*F-6,aux(99)=<4*F-5,aux(181)=< -2*D+4*F-3,aux(183)=<2*F-5/2*A'+5/2,aux(185)=<2*F-5/2*A'+5/2,aux(181)=<4*F-7]

###### Computing max_min for aux(187)=<2*C-5  
   - Found a solution using cacheing 
 * Adding constraints:[aux(187)=<aux(37)*2-3] 

##### Pending set bfs_aux(A,B,C,D,E,F,G,H,I)
* Psum in Loop 26: [aux(178)=<2*C-2*C'-5,aux(172)=<2*C-2*C'-2,aux(176)=<2*C-2*C'-2]
* Psum in Loop 28: [aux(103)=<2*F-3/2*A'+3/2,aux(91)=<4*F-6,aux(99)=<4*F-5,aux(181)=< -2*D+4*F-3,aux(183)=<2*F-5/2*A'+5/2,aux(185)=<2*F-5/2*A'+5/2,aux(181)=<4*F-7]

###### Computing sum for aux(178)=<2*C-2*C'-5  in Loop 26 
   - Found a solution using cacheing 
 * Adding constraints: [aux(178)=<aux(188),aux(188)=<it(26)*aux(187),aux(188)=<aux(181)+aux(182),aux(188)=<aux(183)+aux(184),aux(188)=<aux(185)+aux(186)] 

##### Pending set bfs_aux(A,B,C,D,E,F,G,H,I)
* Psum in Loop 26: [aux(172)=<2*C-2*C'-2,aux(176)=<2*C-2*C'-2]
* Psum in Loop 28: [aux(103)=<2*F-3/2*A'+3/2,aux(91)=<4*F-6,aux(99)=<4*F-5,aux(181)=< -2*D+4*F-3,aux(183)=<2*F-5/2*A'+5/2,aux(185)=<2*F-5/2*A'+5/2,aux(181)=<4*F-7]

###### Computing sum for aux(172)=<2*C-2*C'-2  in Loop 26 
   - Found a solution using cacheing 
 * Adding constraints: [aux(172)=<aux(189)*2,aux(189)=<it(26)*aux(37),aux(189)=<aux(31)+aux(32),aux(189)=<aux(33)+aux(34),aux(189)=<aux(35)+aux(36)] 

##### Pending set bfs_aux(A,B,C,D,E,F,G,H,I)
* Psum in Loop 26: [aux(176)=<2*C-2*C'-2]
* Psum in Loop 28: [aux(103)=<2*F-3/2*A'+3/2,aux(91)=<4*F-6,aux(99)=<4*F-5,aux(181)=< -2*D+4*F-3,aux(183)=<2*F-5/2*A'+5/2,aux(185)=<2*F-5/2*A'+5/2,aux(181)=<4*F-7]

###### Computing sum for aux(176)=<2*C-2*C'-2  in Loop 26 
   - Found a solution using cacheing 
 * Adding constraints: [aux(176)=<aux(190)*2,aux(190)=<it(26)*aux(37),aux(190)=<aux(31)+aux(32),aux(190)=<aux(33)+aux(34),aux(190)=<aux(35)+aux(36)] 

##### Pending set bfs_aux(A,B,C,D,E,F,G,H,I)
* Psum in Loop 28: [aux(103)=<2*F-3/2*A'+3/2,aux(91)=<4*F-6,aux(99)=<4*F-5,aux(181)=< -2*D+4*F-3,aux(183)=<2*F-5/2*A'+5/2,aux(185)=<2*F-5/2*A'+5/2,aux(181)=<4*F-7]

###### Computing sum for aux(103)=<2*F-3/2*A'+3/2  in Loop 28 
   - Found a solution using cacheing 
 * Adding constraints: [aux(103)=<aux(191),aux(191)=<it(28)*aux(180),aux(191)=<aux(172)+aux(173),aux(191)=<aux(174)+aux(175),aux(191)=<aux(176)+aux(177),aux(191)=<aux(178)+aux(179)] 

##### Pending set bfs_aux(A,B,C,D,E,F,G,H,I)
* Psum in Loop 28: [aux(91)=<4*F-6,aux(99)=<4*F-5,aux(181)=< -2*D+4*F-3,aux(183)=<2*F-5/2*A'+5/2,aux(185)=<2*F-5/2*A'+5/2,aux(181)=<4*F-7]

###### Computing sum for aux(91)=<4*F-6  in Loop 28 
   - Applying inductive sum strategy 
     - head Candidate: 4*F-6 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: 4*F-6 
       - The candidate was classified before. We reuse its previous classification 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(194)=<4*F-6] 
 * Adding constraints: [aux(91)=<it(28)*aux(194),aux(91)=<aux(136)+aux(192),aux(91)=<aux(140)+aux(193),aux(192)=<4*F-6,aux(193)=<4*F-4*F'] 

##### Pending set bfs_aux(A,B,C,D,E,F,G,H,I)
* Pmax/min: [aux(194)=<4*F-6]
* Psum in Loop 28: [aux(99)=<4*F-5,aux(181)=< -2*D+4*F-3,aux(183)=<2*F-5/2*A'+5/2,aux(185)=<2*F-5/2*A'+5/2,aux(181)=<4*F-7]

###### Computing max_min for aux(194)=<4*F-6  
   - Found a solution using cacheing 
 * Adding constraints:[aux(194)=<aux(53)*4-10] 

##### Pending set bfs_aux(A,B,C,D,E,F,G,H,I)
* Psum in Loop 28: [aux(99)=<4*F-5,aux(181)=< -2*D+4*F-3,aux(183)=<2*F-5/2*A'+5/2,aux(185)=<2*F-5/2*A'+5/2,aux(181)=<4*F-7]

###### Computing sum for aux(99)=<4*F-5  in Loop 28 
   - Applying inductive sum strategy 
     - head Candidate: 4*F-5 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: 4*F-5 
       - The candidate was classified before. We reuse its previous classification 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(197)=<4*F-5] 
 * Adding constraints: [aux(99)=<it(28)*aux(197),aux(99)=<aux(149)+aux(195),aux(99)=<aux(153)+aux(196),aux(195)=<4*F-5,aux(196)=<4*F-4*F'] 

##### Pending set bfs_aux(A,B,C,D,E,F,G,H,I)
* Pmax/min: [aux(197)=<4*F-5]
* Psum in Loop 28: [aux(181)=< -2*D+4*F-3,aux(183)=<2*F-5/2*A'+5/2,aux(185)=<2*F-5/2*A'+5/2,aux(181)=<4*F-7]

###### Computing max_min for aux(197)=<4*F-5  
   - Found a solution using cacheing 
 * Adding constraints:[aux(197)=<aux(53)*4-9] 

##### Pending set bfs_aux(A,B,C,D,E,F,G,H,I)
* Psum in Loop 28: [aux(181)=< -2*D+4*F-3,aux(183)=<2*F-5/2*A'+5/2,aux(185)=<2*F-5/2*A'+5/2,aux(181)=<4*F-7]

###### Computing sum for aux(181)=< -2*D+4*F-3  in Loop 28 
   - Applying inductive sum strategy 
     - head Candidate: 4*F-7 
       - Loop 26 adds an expression [4*C-4*C'-4]
       - Loop 27 is collaborative
     - head Candidate: 2*A+4*F-9 
       - Loop 26 adds an expression [4*C-4*C'-6]
       - Loop 27 is collaborative
     - tail Candidate: 4*F-7 
       - Loop 26 adds an expression [4*C-4*C'-4]
       - Loop 27 is collaborative
     - tail Candidate: 2*A+4*F-9 
       - Loop 26 adds an expression [4*C-4*C'-6]
       - Loop 27 is collaborative
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(206)=< -2*D+4*F-3] 
 * Adding constraints: [aux(181)=<it(28)*aux(206),aux(181)=<aux(198)+aux(199),aux(181)=<aux(200)+aux(201),aux(181)=<aux(202)+aux(203),aux(181)=<aux(204)+aux(205),aux(199)=<4*F-7,aux(201)=<2*A+4*F-9,aux(203)=<4*F-4*F',aux(205)=<2*A+4*F-2*A'-4*F'] 

##### Pending set bfs_aux(A,B,C,D,E,F,G,H,I)
* Pmax/min: [aux(206)=< -2*D+4*F-3]
* Psum in Loop 26: [aux(200)=<4*C-4*C'-6,aux(204)=<4*C-4*C'-6,aux(198)=<4*C-4*C'-4,aux(202)=<4*C-4*C'-4]
* Psum in Loop 28: [aux(183)=<2*F-5/2*A'+5/2,aux(185)=<2*F-5/2*A'+5/2,aux(181)=<4*F-7]

###### Computing max_min for aux(206)=< -2*D+4*F-3  
   - Found a solution using cacheing 
 * Adding constraints:[aux(206)=<aux(90)*2-3] 

##### Pending set bfs_aux(A,B,C,D,E,F,G,H,I)
* Psum in Loop 26: [aux(200)=<4*C-4*C'-6,aux(204)=<4*C-4*C'-6,aux(198)=<4*C-4*C'-4,aux(202)=<4*C-4*C'-4]
* Psum in Loop 28: [aux(183)=<2*F-5/2*A'+5/2,aux(185)=<2*F-5/2*A'+5/2,aux(181)=<4*F-7]

###### Computing sum for aux(200)=<4*C-4*C'-6  in Loop 26 
   - Found a solution using cacheing 
 * Adding constraints: [aux(200)=<aux(207)*2,aux(207)=<it(26)*aux(105),aux(207)=<aux(99)+aux(100),aux(207)=<aux(101)+aux(102),aux(207)=<aux(103)+aux(104)] 

##### Pending set bfs_aux(A,B,C,D,E,F,G,H,I)
* Psum in Loop 26: [aux(204)=<4*C-4*C'-6,aux(198)=<4*C-4*C'-4,aux(202)=<4*C-4*C'-4]
* Psum in Loop 28: [aux(183)=<2*F-5/2*A'+5/2,aux(185)=<2*F-5/2*A'+5/2,aux(181)=<4*F-7]

###### Computing sum for aux(204)=<4*C-4*C'-6  in Loop 26 
   - Found a solution using cacheing 
 * Adding constraints: [aux(204)=<aux(208)*2,aux(208)=<it(26)*aux(105),aux(208)=<aux(99)+aux(100),aux(208)=<aux(101)+aux(102),aux(208)=<aux(103)+aux(104)] 

##### Pending set bfs_aux(A,B,C,D,E,F,G,H,I)
* Psum in Loop 26: [aux(198)=<4*C-4*C'-4,aux(202)=<4*C-4*C'-4]
* Psum in Loop 28: [aux(183)=<2*F-5/2*A'+5/2,aux(185)=<2*F-5/2*A'+5/2,aux(181)=<4*F-7]

###### Computing sum for aux(198)=<4*C-4*C'-4  in Loop 26 
   - Found a solution using cacheing 
 * Adding constraints: [aux(198)=<aux(209)*4,aux(209)=<it(26)*aux(37),aux(209)=<aux(31)+aux(32),aux(209)=<aux(33)+aux(34),aux(209)=<aux(35)+aux(36)] 

##### Pending set bfs_aux(A,B,C,D,E,F,G,H,I)
* Psum in Loop 26: [aux(202)=<4*C-4*C'-4]
* Psum in Loop 28: [aux(183)=<2*F-5/2*A'+5/2,aux(185)=<2*F-5/2*A'+5/2,aux(181)=<4*F-7]

###### Computing sum for aux(202)=<4*C-4*C'-4  in Loop 26 
   - Found a solution using cacheing 
 * Adding constraints: [aux(202)=<aux(210)*4,aux(210)=<it(26)*aux(37),aux(210)=<aux(31)+aux(32),aux(210)=<aux(33)+aux(34),aux(210)=<aux(35)+aux(36)] 

##### Pending set bfs_aux(A,B,C,D,E,F,G,H,I)
* Psum in Loop 28: [aux(183)=<2*F-5/2*A'+5/2,aux(185)=<2*F-5/2*A'+5/2,aux(181)=<4*F-7]

###### Computing sum for aux(183)=<2*F-5/2*A'+5/2  in Loop 28 
   - Applying inductive sum strategy 
     - head Candidate: -C/2-5/2*D+2*F+5/2 
       - Loop 26 has a reset to  [2*C-5/2*D+2*F-9/2]
       - Loop 27 adds a constant 1/2 
     - head Candidate: -5/2*D+5/2*F+5/2 
       - Loop 26 adds an expression [5/2*C-5/2*C'-15/2]
       - Loop 27 is collaborative
     - tail Candidate: -C/2-5/2*D+2*F+5/2 
       - Loop 26 has undefined behavior 
     - tail Candidate: -5/2*D+5/2*F+5/2 
       - Loop 26 adds an expression [5/2*C-5/2*C'-15/2]
       - Loop 27 is collaborative
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(217)=<2*F-5/2,aux(217)=< -5/2*D+2*F+5/2] 
 * Adding constraints: [aux(183)=<it(28)*aux(217),aux(183)=<it(27)* (1/2)+aux(211)+aux(212),aux(183)=<aux(213)+aux(214),aux(183)=<aux(215)+aux(216),aux(212)=< -C/2-5/2*D+2*F+5/2,aux(214)=< -5/2*D+5/2*F+5/2,aux(216)=< -5/2*D+5/2*F+5/2*D'-5/2*F'] 

##### Pending set bfs_aux(A,B,C,D,E,F,G,H,I)
* Pmax/min: [aux(217)=< -5/2*D+2*F+5/2,aux(217)=<2*F-5/2]
* Psum in Loop 26: [aux(211)=<2*C-5/2*D+2*F-9/2,aux(213)=<5/2*C-5/2*C'-15/2,aux(215)=<5/2*C-5/2*C'-15/2]
* Psum in Loop 28: [aux(185)=<2*F-5/2*A'+5/2,aux(181)=<4*F-7]

###### Computing max_min for aux(217)=< -5/2*D+2*F+5/2  
   - Found a solution using transitive invariants 
 * Adding constraints:[aux(217)=<2*C+2*F-2,aux(217)=<6*C+4*D+2*F-10] 

##### Pending set bfs_aux(A,B,C,D,E,F,G,H,I)
* Pmax/min: [aux(217)=<2*F-5/2]
* Psum in Loop 26: [aux(211)=<2*C-5/2*D+2*F-9/2,aux(213)=<5/2*C-5/2*C'-15/2,aux(215)=<5/2*C-5/2*C'-15/2]
* Psum in Loop 28: [aux(185)=<2*F-5/2*A'+5/2,aux(181)=<4*F-7]

###### Computing max_min for aux(217)=<2*F-5/2  
   - Found a solution using cacheing 
 * Adding constraints:[aux(217)=<aux(53)*2-9/2] 

##### Pending set bfs_aux(A,B,C,D,E,F,G,H,I)
* Psum in Loop 26: [aux(211)=<2*C-5/2*D+2*F-9/2,aux(213)=<5/2*C-5/2*C'-15/2,aux(215)=<5/2*C-5/2*C'-15/2]
* Psum in Loop 28: [aux(185)=<2*F-5/2*A'+5/2,aux(181)=<4*F-7]

###### Computing sum for aux(211)=<2*C-5/2*D+2*F-9/2  in Loop 26 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(218)=<2*C-5/2*D+2*F-9/2] 
 * Adding constraints: [aux(211)=<it(26)*aux(218)] 

##### Pending set bfs_aux(A,B,C,D,E,F,G,H,I)
* Psum in Loop 26: [aux(213)=<5/2*C-5/2*C'-15/2,aux(215)=<5/2*C-5/2*C'-15/2]
* Psum in Loop 28: [aux(185)=<2*F-5/2*A'+5/2,aux(181)=<4*F-7]

###### Computing sum for aux(213)=<5/2*C-5/2*C'-15/2  in Loop 26 
   - Applying inductive sum strategy 
     - head Candidate: -5/2*A+5*C+15/4*D+5/2*F-35/4 
       - Loop 27 is collaborative
       - Loop 28 has a reset to  [5*F-10,-5/2*D+5*F-5]
     - head Candidate: 5/2*C+15/4*D-45/4 
       - Loop 27 is collaborative
       - Loop 28 adds an expression [5/2*F-15/4*A'+15/4]
     - tail Candidate: -5/2*A+5*C+15/4*D+5/2*F-35/4 
       - Loop 27 is collaborative
       - Loop 28 has undefined behavior 
     - tail Candidate: 5/2*C+15/4*D-45/4 
       - Loop 27 is collaborative
       - Loop 28 adds an expression [5/2*F-15/4*A'+15/4]
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(225)=<5/2*C-15/2] 
 * Adding constraints: [aux(213)=<it(26)*aux(225),aux(213)=<aux(219)+aux(220),aux(213)=<aux(221)+aux(222),aux(213)=<aux(223)+aux(224),aux(220)=< -5/2*A+5*C+15/4*D+5/2*F-35/4,aux(222)=<5/2*C+15/4*D-45/4,aux(224)=<5/2*C+15/4*D-5/2*C'-15/4*D'] 

##### Pending set bfs_aux(A,B,C,D,E,F,G,H,I)
* Psum in Loop 26: [aux(215)=<5/2*C-5/2*C'-15/2]
* Psum in Loop 28: [aux(185)=<2*F-5/2*A'+5/2,aux(181)=<4*F-7]

###### Computing sum for aux(215)=<5/2*C-5/2*C'-15/2  in Loop 26 
   - Found a solution using cacheing 
 * Adding constraints: [aux(215)=<aux(226),aux(226)=<it(26)*aux(225),aux(226)=<aux(219)+aux(220),aux(226)=<aux(221)+aux(222),aux(226)=<aux(223)+aux(224)] 

##### Pending set bfs_aux(A,B,C,D,E,F,G,H,I)
* Psum in Loop 28: [aux(185)=<2*F-5/2*A'+5/2,aux(181)=<4*F-7]

###### Computing sum for aux(185)=<2*F-5/2*A'+5/2  in Loop 28 
   - Found a solution using cacheing 
 * Adding constraints: [aux(185)=<aux(227),aux(227)=<it(28)*aux(217),aux(227)=<it(27)* (1/2)+aux(211)+aux(212),aux(227)=<aux(213)+aux(214),aux(227)=<aux(215)+aux(216)] 

##### Pending set bfs_aux(A,B,C,D,E,F,G,H,I)
* Psum in Loop 28: [aux(181)=<4*F-7]

###### Computing sum for aux(181)=<4*F-7  in Loop 28 
   - Applying inductive sum strategy 
     - head Candidate: 4*F-7 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: 4*F-7 
       - The candidate was classified before. We reuse its previous classification 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(230)=<4*F-7] 
 * Adding constraints: [aux(181)=<it(28)*aux(230),aux(181)=<aux(198)+aux(228),aux(181)=<aux(202)+aux(229),aux(228)=<4*F-7,aux(229)=<4*F-4*F'] 

##### Pending set bfs_aux(A,B,C,D,E,F,G,H,I)
* Pmax/min: [aux(230)=<4*F-7]

###### Computing max_min for aux(230)=<4*F-7  
   - Found a solution using cacheing 
 * Adding constraints:[aux(230)=<aux(53)*4-11] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [26,27,28] 
Found a cycle in the non-final constraints
 Removed possibly redundant constraints to solve a cycle in the cost structure 
it(26)+it(27)=<aux(1)+aux(2)
it(26)=<aux(3)+aux(4)
it(26)=<aux(5)+aux(6)
it(26)+it(27)=<aux(7)+aux(8)
it(26)=<aux(9)+aux(10)
it(26)=<aux(11)+aux(12)
it(26)+it(27)=<aux(1)+aux(13)
it(27)=<aux(14)+aux(15)
it(26)+it(27)=<aux(7)+aux(16)
it(27)=<aux(17)+aux(18)
it(28)=<it(27)+it(26)+aux(19)
it(28)=<it(27)+aux(20)+aux(21)
it(28)=<it(26)*2+aux(22)
it(28)=<aux(23)+aux(24)
it(28)=<it(27)+it(26)+aux(25)
it(28)=<it(27)+aux(26)+aux(27)
it(28)=<it(26)*2+aux(28)
it(28)=<aux(29)+aux(30)
aux(1)=<it(28)*aux(62)
aux(1)=<it(27)+aux(58)+aux(59)
aux(1)=<it(27)+aux(60)+aux(61)
aux(65)=<it(28)*aux(62)
aux(65)=<it(27)+aux(58)+aux(59)
aux(65)=<it(27)+aux(60)+aux(61)
aux(1)=<it(28)*aux(68)
aux(1)=<aux(23)+aux(66)
aux(1)=<aux(29)+aux(67)
aux(5)=<it(28)*aux(78)
aux(5)=<it(27)* (1/3)+aux(74)+aux(75)
aux(5)=<it(27)* (1/3)+aux(76)+aux(77)
aux(81)=<it(28)*aux(78)
aux(81)=<it(27)* (1/3)+aux(74)+aux(75)
aux(81)=<it(27)* (1/3)+aux(76)+aux(77)
Found a cycle in the non-final constraints
 Removed possibly redundant constraints to solve a cycle in the cost structure 
aux(23)=<aux(31)+aux(32)
aux(23)=<aux(33)+aux(34)
aux(23)=<aux(35)+aux(36)
aux(38)=<aux(31)+aux(32)
aux(38)=<aux(33)+aux(34)
aux(38)=<aux(35)+aux(36)
aux(20)=<aux(41)+aux(42)
aux(20)=<aux(43)+aux(44)
aux(26)=<aux(46)
aux(46)=<aux(41)+aux(42)
aux(46)=<aux(43)+aux(44)
s(4)=<it(27)+aux(47)+aux(48)
s(4)=<it(27)+aux(50)+aux(51)
aux(47)=<aux(41)+aux(54)
aux(47)=<aux(43)+aux(55)
aux(57)=<aux(41)+aux(54)
aux(57)=<aux(43)+aux(55)
aux(63)=<aux(41)+aux(54)
aux(63)=<aux(43)+aux(55)
aux(64)=<aux(41)+aux(54)
aux(64)=<aux(43)+aux(55)
aux(7)=<aux(69)
aux(69)=<aux(23)+aux(66)
aux(69)=<aux(29)+aux(67)
aux(70)=<aux(23)+aux(66)
aux(70)=<aux(29)+aux(67)
aux(71)=<aux(23)+aux(66)
aux(71)=<aux(29)+aux(67)
aux(72)=<aux(23)+aux(66)
aux(72)=<aux(29)+aux(67)
aux(73)=<aux(23)+aux(66)
aux(73)=<aux(29)+aux(67)
aux(79)=<aux(41)+aux(54)
aux(79)=<aux(43)+aux(55)
aux(80)=<aux(41)+aux(54)
aux(80)=<aux(43)+aux(55)
aux(31)=<aux(82)+aux(83)
aux(31)=<aux(84)+aux(85)
aux(31)=<aux(86)+aux(87)
aux(31)=<aux(88)+aux(89)
aux(84)=<aux(91)+aux(92)
aux(84)=<aux(93)+aux(94)
aux(84)=<aux(95)+aux(96)
aux(98)=<aux(91)+aux(92)
aux(98)=<aux(93)+aux(94)
aux(98)=<aux(95)+aux(96)
aux(82)=<aux(99)+aux(100)
aux(82)=<aux(101)+aux(102)
aux(82)=<aux(103)+aux(104)
aux(106)=<aux(99)+aux(100)
aux(106)=<aux(101)+aux(102)
aux(106)=<aux(103)+aux(104)
aux(33)=<aux(107)+aux(108)
aux(33)=<aux(109)+aux(110)
aux(33)=<aux(111)+aux(112)
aux(33)=<aux(113)+aux(114)
aux(116)=<aux(91)+aux(92)
aux(116)=<aux(93)+aux(94)
aux(116)=<aux(95)+aux(96)
aux(117)=<aux(91)+aux(92)
aux(117)=<aux(93)+aux(94)
aux(117)=<aux(95)+aux(96)
aux(118)=<aux(31)+aux(32)
aux(118)=<aux(33)+aux(34)
aux(118)=<aux(35)+aux(36)
aux(119)=<aux(31)+aux(32)
aux(119)=<aux(33)+aux(34)
aux(119)=<aux(35)+aux(36)
aux(120)=<aux(107)+aux(108)
aux(120)=<aux(109)+aux(110)
aux(120)=<aux(111)+aux(112)
aux(120)=<aux(113)+aux(114)
aux(31)=<aux(121)+aux(122)
aux(31)=<aux(123)+aux(124)
aux(126)=<aux(31)+aux(32)
aux(126)=<aux(33)+aux(34)
aux(126)=<aux(35)+aux(36)
aux(127)=<aux(31)+aux(32)
aux(127)=<aux(33)+aux(34)
aux(127)=<aux(35)+aux(36)
aux(41)=<aux(128)+aux(129)
aux(41)=<aux(130)+aux(131)
aux(133)=<aux(31)+aux(32)
aux(133)=<aux(33)+aux(34)
aux(133)=<aux(35)+aux(36)
aux(134)=<aux(31)+aux(32)
aux(134)=<aux(33)+aux(34)
aux(134)=<aux(35)+aux(36)
aux(135)=<aux(128)+aux(129)
aux(135)=<aux(130)+aux(131)
aux(91)=<aux(136)+aux(137)
aux(91)=<aux(138)+aux(139)
aux(91)=<aux(140)+aux(141)
aux(91)=<aux(142)+aux(143)
aux(145)=<aux(99)+aux(100)
aux(145)=<aux(101)+aux(102)
aux(145)=<aux(103)+aux(104)
aux(146)=<aux(99)+aux(100)
aux(146)=<aux(101)+aux(102)
aux(146)=<aux(103)+aux(104)
aux(147)=<aux(31)+aux(32)
aux(147)=<aux(33)+aux(34)
aux(147)=<aux(35)+aux(36)
aux(148)=<aux(31)+aux(32)
aux(148)=<aux(33)+aux(34)
aux(148)=<aux(35)+aux(36)
aux(99)=<aux(149)+aux(150)
aux(99)=<aux(151)+aux(152)
aux(99)=<aux(153)+aux(154)
aux(99)=<aux(155)+aux(156)
aux(158)=<aux(99)+aux(100)
aux(158)=<aux(101)+aux(102)
aux(158)=<aux(103)+aux(104)
aux(159)=<aux(99)+aux(100)
aux(159)=<aux(101)+aux(102)
aux(159)=<aux(103)+aux(104)
aux(160)=<aux(31)+aux(32)
aux(160)=<aux(33)+aux(34)
aux(160)=<aux(35)+aux(36)
aux(161)=<aux(31)+aux(32)
aux(161)=<aux(33)+aux(34)
aux(161)=<aux(35)+aux(36)
aux(93)=<aux(121)+aux(162)
aux(93)=<aux(163)+aux(164)
aux(93)=<aux(123)+aux(165)
aux(93)=<aux(166)+aux(167)
aux(169)=<aux(91)+aux(92)
aux(169)=<aux(93)+aux(94)
aux(169)=<aux(95)+aux(96)
aux(170)=<aux(91)+aux(92)
aux(170)=<aux(93)+aux(94)
aux(170)=<aux(95)+aux(96)
aux(171)=<aux(121)+aux(162)
aux(171)=<aux(163)+aux(164)
aux(171)=<aux(123)+aux(165)
aux(171)=<aux(166)+aux(167)
aux(101)=<aux(172)+aux(173)
aux(101)=<aux(174)+aux(175)
aux(101)=<aux(176)+aux(177)
aux(101)=<aux(178)+aux(179)
aux(174)=<aux(181)+aux(182)
aux(188)=<aux(181)+aux(182)
aux(189)=<aux(31)+aux(32)
aux(189)=<aux(33)+aux(34)
aux(189)=<aux(35)+aux(36)
aux(190)=<aux(31)+aux(32)
aux(190)=<aux(33)+aux(34)
aux(190)=<aux(35)+aux(36)
aux(191)=<aux(172)+aux(173)
aux(191)=<aux(174)+aux(175)
aux(191)=<aux(176)+aux(177)
aux(191)=<aux(178)+aux(179)
aux(91)=<aux(136)+aux(192)
aux(91)=<aux(140)+aux(193)
aux(99)=<aux(149)+aux(195)
aux(99)=<aux(153)+aux(196)
aux(181)=<aux(198)+aux(199)
aux(181)=<aux(200)+aux(201)
aux(181)=<aux(202)+aux(203)
aux(181)=<aux(204)+aux(205)
aux(207)=<aux(99)+aux(100)
aux(207)=<aux(101)+aux(102)
aux(207)=<aux(103)+aux(104)
aux(208)=<aux(99)+aux(100)
aux(208)=<aux(101)+aux(102)
aux(208)=<aux(103)+aux(104)
aux(209)=<aux(31)+aux(32)
aux(209)=<aux(33)+aux(34)
aux(209)=<aux(35)+aux(36)
aux(210)=<aux(31)+aux(32)
aux(210)=<aux(33)+aux(34)
aux(210)=<aux(35)+aux(36)
aux(181)=<aux(198)+aux(228)
aux(181)=<aux(202)+aux(229)

#### Simplifying cost structure of phase [26,27,28] 
 * Joined equivalent variables [aux(38),aux(29)] into aux(38)
 * Joined equivalent variables [aux(40),aux(26)] into aux(40)
 * Joined equivalent variables [aux(57),aux(50)] into aux(57)
 * Joined equivalent variables [aux(63),aux(58)] into aux(63)
 * Joined equivalent variables [aux(64),aux(60)] into aux(64)
 * Joined equivalent variables [aux(65),aux(7)] into aux(65)
 * Joined equivalent variables [aux(70),aux(14)] into aux(70)
 * Joined equivalent variables [aux(71),aux(17)] into aux(71)
 * Joined equivalent variables [aux(81),aux(11)] into aux(81)
 * Joined equivalent variables [aux(98),aux(88)] into aux(98)
 * Joined equivalent variables [aux(106),aux(86)] into aux(106)
 * Joined equivalent variables [aux(118),aux(107)] into aux(118)
 * Joined equivalent variables [aux(119),aux(111)] into aux(119)
 * Joined equivalent variables [aux(120),aux(35)] into aux(120)
 * Joined equivalent variables [aux(135),aux(43)] into aux(135)
 * Joined equivalent variables [aux(169),aux(163)] into aux(169)
 * Joined equivalent variables [aux(170),aux(166)] into aux(170)
 * Joined equivalent variables [aux(171),aux(95)] into aux(171)
 * Joined equivalent variables [aux(188),aux(178)] into aux(188)
 * Joined equivalent variables [aux(191),aux(103)] into aux(191)
 * Joined equivalent variables [aux(226),aux(215)] into aux(226)
 * Joined equivalent variables [aux(227),aux(185)] into aux(227)
 * Joined equivalent variables [aux(237),aux(51),aux(61)] into aux(237)
 * Joined equivalent variables [aux(238),aux(2),aux(13)] into aux(238)
 * Joined equivalent variables [aux(239),aux(8),aux(16)] into aux(239)
 * Joined equivalent variables [aux(240),aux(139),aux(152),aux(201)] into aux(240)
 * Joined equivalent variables [aux(241),aux(143),aux(156),aux(205)] into aux(241)
 * Joined equivalent variables [aux(246),aux(42),aux(54)] into aux(246)
 * Joined equivalent variables [aux(247),aux(44),aux(55)] into aux(247)
 * Joined equivalent variables [aux(253),aux(24),aux(66),aux(108)] into aux(253)
 * Joined equivalent variables [aux(254),aux(30),aux(67),aux(112)] into aux(254)
 * Joined equivalent variables [aux(255),aux(122),aux(129),aux(162),aux(173)] into aux(255)
 * Joined equivalent variables [aux(256),aux(124),aux(131),aux(165),aux(177)] into aux(256)
 * Joined equivalent variables [aux(257),aux(137),aux(150),aux(192),aux(195),aux(199),aux(228)] into aux(257)
 * Joined equivalent variables [aux(258),aux(141),aux(154),aux(193),aux(196),aux(203),aux(229)] into aux(258)
 * Joined equivalent variables [aux(62),aux(68)] into aux(62)
 * Joined equivalent variables [aux(45),aux(56)] into aux(45)
 * Joined equivalent variables [aux(213),aux(226)] into aux(213)
 * Joined equivalent variables [aux(183),aux(227)] into aux(183)
 * Joined equivalent variables [aux(23),aux(38),aux(118),aux(119),aux(126),aux(127),aux(133),aux(134),aux(147),aux(148),aux(160),aux(161),aux(189),aux(190),aux(209),aux(210)] into aux(23)
 * Joined equivalent variables [aux(82),aux(106),aux(145),aux(146),aux(158),aux(159),aux(207),aux(208)] into aux(82)
 * Joined equivalent variables [aux(101),aux(191)] into aux(101)
 * Joined equivalent variables [aux(174),aux(188)] into aux(174)
 * Joined equivalent variables [aux(93),aux(171)] into aux(93)
 * Joined equivalent variables [aux(84),aux(98),aux(116),aux(117),aux(169),aux(170)] into aux(84)
 * Joined equivalent variables [aux(41),aux(135)] into aux(41)
 * Joined equivalent variables [aux(33),aux(120)] into aux(33)
 * Joined equivalent variables [aux(47),aux(57),aux(63),aux(64),aux(79),aux(80)] into aux(47)
 * Joined equivalent variables [aux(69),aux(70),aux(71),aux(72),aux(73)] into aux(69)
 * Joined equivalent variables [it(26),it(27)] into it(26)
 * Joined equivalent variables [aux(1),aux(65)] into aux(1)
 * Joined equivalent variables [aux(5),aux(81)] into aux(5)
 * Joined equivalent variables [aux(37),aux(39)] into aux(37)
 * Joined equivalent variables [aux(23),aux(40)] into aux(23)
 * Joined equivalent variables [aux(136),aux(140),aux(149),aux(153),aux(198),aux(202)] into aux(136)
 * Joined equivalent variables [aux(138),aux(142),aux(151),aux(155),aux(200),aux(204)] into aux(138)
 * Joined equivalent variables [aux(121),aux(123),aux(128),aux(130),aux(172),aux(176)] into aux(121)
 * Joined equivalent variables [aux(109),aux(113)] into aux(109)
 * Joined equivalent variables [aux(74),aux(76)] into aux(74)
 * Joined equivalent variables [aux(3),aux(9)] into aux(3)

#### Cost of phase [26,27,28]:bfs_aux(A,B,C,D,E,F,G,H,I) -> [bfs_aux(A',B',C',D',E',F',G',H',I')] 
17*it(26)+12*it(28)+5*s(4)+0
  Such that:aux(49) =< -A+D+1
aux(52) =< -A+D+A'-D'
aux(53) =< A/2+C/2+D/2+F/2
aux(53) =< C+D+F
aux(53) =< C+F+1
aux(53) =< 6*C+5*D+2*F
aux(231) =< -2*A+3*C-D+3*F+4
aux(232) =< -2*A+3*C-D+3*F+2*A'-3*C'+D'-3*F'
aux(235) =< -A+2*C+2*F+1
aux(236) =< -A+2*C+2*F+A'-2*C'-2*F'
aux(244) =< C+F
aux(245) =< C+F-C'-F'
aux(249) =< 3*C+D+3*F
aux(250) =< 3*C+D+3*F-3*C'-D'-3*F'
it(26) =< aux(231)
it(28) =< aux(231)
it(26) =< aux(232)
it(28) =< aux(232)
it(26) =< aux(235)
it(28) =< aux(235)
it(26) =< aux(236)
it(28) =< aux(236)
it(26) =< aux(244)
it(26) =< aux(245)
it(26) =< aux(249)
it(28) =< aux(249)
it(26) =< aux(250)
it(28) =< aux(250)
s(4) =< it(26)+it(26)*3+aux(52)
s(4) =< it(26)+it(26)*3+aux(49)
s(4) =< it(28)*aux(53)

#### Simplifying cost structure of chain [[26,27,28],30] 
 * Joined equivalent variables [aux(259),aux(235),aux(236)] into aux(259)
 * Joined equivalent variables [aux(260),aux(244),aux(245)] into aux(260)
 * Joined equivalent variables [aux(261),aux(249),aux(250)] into aux(261)

#### Simplifying cost structure of CE 26 

#### Found solution for phase  [26,27,28] in the cache 

#### Cost of phase [26,27,28]:bfs_aux(A,B,C,D,E,F,G,H,I) -> [bfs_aux(A',B',C',D',E',F',G',H',I')] 
17*it(26)+12*it(28)+5*s(4)+0
  Such that:aux(49) =< -A+D+1
aux(52) =< -A+D+A'-D'
aux(53) =< A/2+C/2+D/2+F/2
aux(53) =< C+D+F
aux(53) =< C+F+1
aux(53) =< 6*C+5*D+2*F
aux(231) =< -2*A+3*C-D+3*F+4
aux(232) =< -2*A+3*C-D+3*F+2*A'-3*C'+D'-3*F'
aux(235) =< -A+2*C+2*F+1
aux(236) =< -A+2*C+2*F+A'-2*C'-2*F'
aux(244) =< C+F
aux(245) =< C+F-C'-F'
aux(249) =< 3*C+D+3*F
aux(250) =< 3*C+D+3*F-3*C'-D'-3*F'
it(26) =< aux(231)
it(28) =< aux(231)
it(26) =< aux(232)
it(28) =< aux(232)
it(26) =< aux(235)
it(28) =< aux(235)
it(26) =< aux(236)
it(28) =< aux(236)
it(26) =< aux(244)
it(26) =< aux(245)
it(26) =< aux(249)
it(28) =< aux(249)
it(26) =< aux(250)
it(28) =< aux(250)
s(4) =< it(26)+it(26)*3+aux(52)
s(4) =< it(26)+it(26)*3+aux(49)
s(4) =< it(28)*aux(53)

#### Simplifying cost structure of chain [[26,27,28],29] 

#### Cost of chains of bfs_aux(A,B,C,D,E,F,G,H,I):
* Chain [[26,27,28],30]: 17*it(26)+12*it(28)+5*s(4)+5
  Such that:aux(232) =< -2*A+3*C-D+3*F+3
aux(231) =< -2*A+3*C-D+3*F+4
aux(52) =< -A+D
aux(49) =< -A+D+1
aux(53) =< A/2+C/2+D/2+F/2
aux(52) =< D
aux(259) =< -A+2*C+2*F+1
aux(260) =< C+F
aux(261) =< 3*C+D+3*F
it(26) =< aux(231)
it(28) =< aux(231)
it(26) =< aux(232)
it(28) =< aux(232)
it(26) =< aux(259)
it(28) =< aux(259)
it(26) =< aux(260)
it(26) =< aux(261)
it(28) =< aux(261)
s(4) =< it(26)+it(26)*3+aux(52)
s(4) =< it(26)+it(26)*3+aux(49)
s(4) =< it(28)*aux(53)

  with precondition: [I=1,A>=1,B>=0,D>=1,E>=0,G>=0,H>=0,C+1>=A,F+1>=D,A+D>=3] 

* Chain [[26,27,28],29]: 17*it(26)+12*it(28)+5*s(4)+9
  Such that:aux(250) =< -4*A+7*C-3*D+7*F-3*I+7
aux(52) =< -3*A+3*C+3*F+2
aux(52) =< -2*A+2*C+2*F+2
aux(231) =< -2*A+3*C-D+3*F+4
aux(245) =< -A+2*C-D+2*F-I+2
aux(235) =< -A+2*C+2*F+1
aux(49) =< -A+D+1
aux(53) =< A/2+C/2+D/2+F/2
aux(244) =< C+F
aux(53) =< C+F+1
aux(245) =< C+F-I
aux(249) =< 3*C+D+3*F
aux(250) =< 3*C+D+3*F-3*I
aux(236) =< 3*C+3*D+3*F+2*G-3*I
aux(236) =< 4*C+4*D+3*F-3*I
aux(232) =< 5*C+5*D+5*F+4*G-5*I
aux(232) =< 7*C+7*D+5*F-5*I
it(26) =< aux(231)
it(28) =< aux(231)
it(26) =< aux(232)
it(28) =< aux(232)
it(26) =< aux(235)
it(28) =< aux(235)
it(26) =< aux(236)
it(28) =< aux(236)
it(26) =< aux(244)
it(26) =< aux(245)
it(26) =< aux(249)
it(28) =< aux(249)
it(26) =< aux(250)
it(28) =< aux(250)
s(4) =< it(26)+it(26)*3+aux(52)
s(4) =< it(26)+it(26)*3+aux(49)
s(4) =< it(28)*aux(53)

  with precondition: [A>=1,B>=0,C>=0,D>=1,E>=0,G>=0,I>=3,F+1>=D,H>=G,A+D>=3,C+3*D>=6,F+3*A>=6,3*C+4*F>=3*I+3,C+F+1>=A,C+F>=I,A+G+2*D>=5,C+G+4*D>=8,2*F+3*A+3*G>=9,4*F+7*C+1>=4*A+3*I,F+2*C+1>=A+I,C+D+F>=I+2,D+F+2*C>=A+I+1,F+4*C+9*D>=A+I+17] 

* Chain [29]: 9
  with precondition: [A>=2,D>=1,E>=0,G>=0,I>=3,F+1>=D,H>=G,B>=H,C>=I,C+F+1>=A] 


#### Simplifying cost structure of CE 32 

#### Simplifying cost structure of CE 31 

#### Cost of chains of case_13(A,B,C,D,E,F,G,H):
* Chain [32]: 2
  with precondition: [B=1,F=1,H=0,A>=0,C>=0,D>=1,E>=0,G>=0] 

* Chain [31]: 4
  with precondition: [F=1,G=A,H=B,C>=0,D>=1,E>=0,G>=0,H>=3] 

 * Renamed intermediate variables: 
[ (eq(33,1),aux(232))>>s(5), (eq(33,1),aux(231))>>s(6), (eq(33,1),aux(52))>>s(7), (eq(33,1),aux(49))>>s(8), (eq(33,1),aux(53))>>s(9), (eq(33,1),aux(259))>>s(10), (eq(33,1),aux(260))>>s(11), (eq(33,1),aux(261))>>s(12), (eq(33,1),it(26))>>s(13), (eq(33,1),it(28))>>s(14), (eq(33,1),s(4))>>s(15)]

#### Simplifying cost structure of CE 33 
 * Joined equivalent variables [aux(262),s(8)] into aux(262)
 * Joined equivalent variables [aux(263),s(5),s(6)] into aux(263)
 * Renamed intermediate variables: 
[ (eq(34,1),aux(250))>>s(16), (eq(34,1),aux(52))>>s(17), (eq(34,1),aux(231))>>s(18), (eq(34,1),aux(245))>>s(19), (eq(34,1),aux(235))>>s(20), (eq(34,1),aux(49))>>s(21), (eq(34,1),aux(53))>>s(22), (eq(34,1),aux(244))>>s(23), (eq(34,1),aux(249))>>s(24), (eq(34,1),aux(236))>>s(25), (eq(34,1),aux(232))>>s(26), (eq(34,1),it(26))>>s(27), (eq(34,1),it(28))>>s(28), (eq(34,1),s(4))>>s(29)]

#### Simplifying cost structure of CE 34 
 * Joined equivalent variables [aux(264),s(19),s(23)] into aux(264)
 * Joined equivalent variables [aux(265),s(17),s(20)] into aux(265)
 * Joined equivalent variables [aux(266),s(16),s(18)] into aux(266)

#### Simplifying cost structure of CE 35 

#### Cost of chains of bfs(A,B,C,D,E,F):
* Chain [34]: 17*s(13)+12*s(14)+5*s(15)+12
  Such that:s(11) =< B
s(10) =< 2*B
s(12) =< 3*B+1
s(9) =< B/2+3/2
aux(263) =< 3*B
s(13) =< aux(263)
s(14) =< aux(263)
s(13) =< s(10)
s(14) =< s(10)
s(13) =< s(11)
s(13) =< s(12)
s(14) =< s(12)
s(15) =< s(13)+s(13)*3
s(15) =< s(13)+s(13)*3
s(15) =< s(14)*s(9)

  with precondition: [D=1,F=0,A>=0,B>=1,C>=0,E>=0] 

* Chain [33]: 17*s(27)+12*s(28)+5*s(29)+18
  Such that:aux(264) =< B
aux(265) =< 2*B
aux(266) =< 3*B
s(24) =< 3*B+1
s(25) =< 3*B+2*C
s(25) =< 4*B
s(26) =< 5*B+4*C
s(26) =< 7*B
s(22) =< B/2+3/2
s(27) =< aux(266)
s(28) =< aux(266)
s(27) =< s(26)
s(28) =< s(26)
s(27) =< aux(265)
s(28) =< aux(265)
s(27) =< s(25)
s(28) =< s(25)
s(27) =< aux(264)
s(27) =< s(24)
s(28) =< s(24)
s(29) =< s(27)+s(27)*3+aux(265)
s(29) =< s(27)+s(27)*3
s(29) =< s(28)*s(22)

  with precondition: [D=1,A>=0,C>=0,F>=3,E>=C,B>=F] 


#### Simplifying cost structure of CE 37 

#### Computing cost of phase [35,36] 

#### Simplifying cost structure of CE 38 

#### Simplifying cost structure of CE 39 

#### Cost of loops [35,36] 

 * loop 35:dfs_aux(A,B,C,D,E,F,G) -> [dfs_aux(A',B',C',D',E',F',G')] 
11
 * loop 36:dfs_aux(A,B,C,D,E,F,G) -> [dfs_aux(A',B',C',D',E',F',G')] 
6
##### Pending set dfs_aux(A,B,C,D,E,F,G)
* Psum in Loop 35: [it(35)=<1]
* Psum in Loop 36: [it(36)=<1]

###### Computing sum for it(35)=<1  in Loop 35 
   - Applying inductive sum strategy 
     - head Candidate: A+2*B-1 
       - Loop 36 is collaborative and bounds [it(36)] 
     - head Candidate: C 
       - Loop 36 is collaborative and bounds [it(36)] 
     - head Candidate: B 
       - Loop 36 is collaborative
     - head Candidate: C-2 
       - Loop 36 is collaborative
     - head Candidate: B-D 
       - Loop 36 is collaborative
     - tail Candidate: A+2*B-1 
       - Loop 36 is collaborative and bounds [it(36)] 
     - tail Candidate: C 
       - Loop 36 is collaborative and bounds [it(36)] 
     - tail Candidate: B 
       - Loop 36 is collaborative
     - tail Candidate: C-2 
       - Loop 36 is collaborative and bounds [it(36)] 
     - tail Candidate: B-D 
       - Loop 36 is collaborative
 * Adding constraints: [it(35)+it(36)=<A+2*B-1,it(35)+it(36)=<C,it(35)=<B,it(35)=<C-2,it(35)=<B-D,it(35)+it(36)=<A+2*B-A'-2*B',it(35)+it(36)=<C-C',it(35)=<B-B',it(35)+it(36)=<C-C',it(35)=<B-D-B'+D'] 

##### Pending set A
* Psum in Loop 36: [it(36)=<1]

###### Computing sum for it(36)=<1  in Loop 36 
   - Applying inductive sum strategy 
     - head Candidate: A+2*B-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: C 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A-1 
       - Loop 35 adds a constant 1/1 
     - head Candidate: C 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A+2*B-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
       - Loop 35 adds a constant 1/1 
     - tail Candidate: C 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(36)=<it(35)+aux(267),it(36)=<it(35)+aux(268),it(35)+it(36)=<A+2*B-1,it(35)+it(36)=<C,aux(267)=<A-1,it(35)+it(36)=<C,it(35)+it(36)=<A+2*B-A'-2*B',it(35)+it(36)=<C-C',aux(268)=<A-A',it(35)+it(36)=<C-C'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [35,36] 

#### Simplifying cost structure of phase [35,36] 

#### Cost of phase [35,36]:dfs_aux(A,B,C,D,E,F,G) -> [dfs_aux(A',B',C',D',E',F',G')] 
11*it(35)+6*it(36)+0
  Such that:aux(267) =< A
aux(268) =< A-A'
it(35) =< B
it(35) =< B-D
it(35) =< B-D-B'+D'
it(35) =< B-B'
aux(269) =< A+2*B
aux(270) =< A+2*B-A'-2*B'
aux(271) =< C
aux(272) =< C-C'
it(35) =< aux(269)
it(36) =< aux(269)
it(35) =< aux(270)
it(36) =< aux(270)
it(35) =< aux(271)
it(36) =< aux(271)
it(35) =< aux(272)
it(36) =< aux(272)
it(36) =< it(35)+aux(268)
it(36) =< it(35)+aux(267)

#### Simplifying cost structure of chain [[35,36],38] 
 * Joined equivalent variables [aux(273),aux(267),aux(268)] into aux(273)
 * Joined equivalent variables [aux(274),aux(269),aux(270)] into aux(274)
 * Joined equivalent variables [aux(275),aux(271),aux(272)] into aux(275)

#### Simplifying cost structure of CE 36 

#### Found solution for phase  [35,36] in the cache 

#### Cost of phase [35,36]:dfs_aux(A,B,C,D,E,F,G) -> [dfs_aux(A',B',C',D',E',F',G')] 
11*it(35)+6*it(36)+0
  Such that:aux(267) =< A
aux(268) =< A-A'
it(35) =< B
it(35) =< B-D
it(35) =< B-D-B'+D'
it(35) =< B-B'
aux(269) =< A+2*B
aux(270) =< A+2*B-A'-2*B'
aux(271) =< C
aux(272) =< C-C'
it(35) =< aux(269)
it(36) =< aux(269)
it(35) =< aux(270)
it(36) =< aux(270)
it(35) =< aux(271)
it(36) =< aux(271)
it(35) =< aux(272)
it(36) =< aux(272)
it(36) =< it(35)+aux(268)
it(36) =< it(35)+aux(267)

#### Simplifying cost structure of chain [[35,36],37] 
 * Joined equivalent variables [aux(276),aux(267)] into aux(276)
 * Renamed intermediate variables: 
[ (ch([[35,36],37]),aux(269))>>s(30), (ch([[35,36],37]),it(35))>>s(31), (ch([[35,36],37]),aux(270))>>s(32), (ch([[35,36],37]),aux(271))>>s(33), (ch([[35,36],37]),aux(276))>>s(34), (ch([[35,36],37]),aux(277))>>s(35), (ch([[35,36],37]),aux(278))>>s(36), (ch([[35,36],37]),aux(268))>>s(37), (ch([[35,36],37]),aux(272))>>s(38), (ch([[35,36],37]),it(36))>>s(39)]

#### Cost of chains of dfs_aux(A,B,C,D,E,F,G):
* Chain [[35,36],38]: 11*it(35)+6*it(36)+3
  Such that:it(35) =< B
it(35) =< B-D
aux(273) =< A
aux(274) =< A+2*B
aux(275) =< C
it(35) =< aux(274)
it(36) =< aux(274)
it(35) =< aux(275)
it(36) =< aux(275)
it(36) =< it(35)+aux(273)

  with precondition: [E=1,G=0,A>=2,D>=0,F>=0,C+1>=A,A+2*B>=C+1] 

* Chain [[35,36],37]: 11*it(35)+6*it(36)+9
  Such that:aux(269) =< A+2*B
it(35) =< B-F
aux(270) =< 2*B+C-2*F-G
aux(271) =< C
aux(276) =< A
aux(277) =< A+2*B-2*F
aux(278) =< C-G
aux(268) =< aux(276)
aux(270) =< aux(277)
aux(272) =< aux(277)
aux(268) =< aux(278)
aux(272) =< aux(278)
it(35) =< aux(269)
it(36) =< aux(269)
it(35) =< aux(270)
it(36) =< aux(270)
it(35) =< aux(271)
it(36) =< aux(271)
it(35) =< aux(272)
it(36) =< aux(272)
it(36) =< it(35)+aux(268)
it(36) =< it(35)+aux(276)

  with precondition: [E=1,A>=2,D>=0,G>=3,F>=D,B>=F,C>=G+1,A+B>=F+3] 

* Chain [37]: 9
  with precondition: [E=1,A>=2,D>=0,G>=3,F>=D,B>=F,C>=G] 

 * Renamed intermediate variables: 
[ (eq(40,1),it(35))>>s(40), (eq(40,1),aux(273))>>s(41), (eq(40,1),aux(274))>>s(42), (eq(40,1),aux(275))>>s(43), (eq(40,1),it(36))>>s(44)]

#### Simplifying cost structure of CE 40 
 * Renamed intermediate variables: 
[ (eq(41,1),s(34))>>s(45), (eq(41,1),s(30))>>s(46), (eq(41,1),s(35))>>s(47), (eq(41,1),s(31))>>s(48), (eq(41,1),s(32))>>s(49), (eq(41,1),s(33))>>s(50), (eq(41,1),s(36))>>s(51), (eq(41,1),s(37))>>s(52), (eq(41,1),s(38))>>s(53), (eq(41,1),s(39))>>s(54)]

#### Simplifying cost structure of CE 41 
 * Joined equivalent variables [aux(279),s(50),s(51)] into aux(279)
 * Joined equivalent variables [s(47),s(49)] into s(47)

#### Cost of chains of dfs(A,B,C,D,E,F):
* Chain [40]: 11*s(40)+6*s(44)+6
  Such that:s(41) =< 2
s(43) =< B
s(40) =< s(43)
s(44) =< s(43)
s(44) =< s(40)+s(41)

  with precondition: [D=1,F=0,A>=0,B>=1,C>=0,E>=0] 

* Chain [39]: 11*s(48)+6*s(54)+12
  Such that:s(45) =< 2
aux(279) =< B
s(52) =< s(45)
s(52) =< aux(279)
s(53) =< aux(279)
s(48) =< aux(279)
s(54) =< aux(279)
s(48) =< s(53)
s(54) =< s(53)
s(54) =< s(48)+s(52)
s(54) =< s(48)+s(45)

  with precondition: [D=1,A>=0,C>=0,F>=3,E>=C,B>=F] 


#### Simplifying cost structure of CE 44 

#### Computing cost of phase [43] 

#### Simplifying cost structure of CE 42 

#### Cost of loops [43] 

 * loop 43:split(A,B,C,D,E) -> [split(A',B',C',D',E')] 
14
##### Pending set split(A,B,C,D,E)
* Psum in Loop 43: [it(43)=<1]

###### Computing sum for it(43)=<1  in Loop 43 
   - Applying inductive sum strategy 
     - head Candidate: A/2-1 
     - head Candidate: A/2-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A/2-1 
     - tail Candidate: A/2-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(43)=<A/2-1,it(43)=<A/2-1,it(43)=<A/2-A'/2,it(43)=<A/2-A'/2] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [43] 

#### Simplifying cost structure of phase [43] 

#### Cost of phase [43]:split(A,B,C,D,E) -> [split(A',B',C',D',E')] 
14*it(43)+0
  Such that:it(43) =< A/2
it(43) =< A/2-A'/2

#### Simplifying cost structure of chain [[43],42] 

#### Simplifying cost structure of CE 43 

#### Found solution for phase  [43] in the cache 

#### Cost of phase [43]:split(A,B,C,D,E) -> [split(A',B',C',D',E')] 
14*it(43)+0
  Such that:it(43) =< A/2
it(43) =< A/2-A'/2

#### Simplifying cost structure of chain [[43],41] 
 * Renamed intermediate variables: 
[ (ch([[43],41]),it(43))>>s(55)]
 * Renamed intermediate variables: 
[ (ch([[43],42]),it(43))>>s(56)]
 * Joined equivalent variables [s(55),s(56)] into s(55)

#### Cost of chains of split(A,B,C,D,E):
* Chain [[43],42]: 14*it(43)+5
  Such that:it(43) =< D/2

  with precondition: [C=1,A+1=D,A>=3,B>=0,E>=0] 

* Chain [[43],41]: 14*it(43)+9
  Such that:it(43) =< D/2

  with precondition: [C=1,A+1=D,A>=4,B>=0,E>=0] 

* Chain [42]: 5
  with precondition: [A=1,C=1,D=2,B>=0,E>=0] 

* Chain [41]: 9
  with precondition: [A=2,C=1,D=3,B>=0,E>=0] 


#### Simplifying cost structure of CE 48 

#### Simplifying cost structure of CE 45 

#### Simplifying cost structure of chain [multiple(47,[[44]])] 

#### Simplifying cost structure of CE 46 

#### Simplifying cost structure of chain [multiple(46,[[multiple(47,[[44]])],[44]])] 

#### Computing cost of chain [multiple([45],[[multiple(47,[[44]])],[multiple(46,[[multiple(47,[[44]])],[44]])],[44]])] with multiple recursion
 * Renamed intermediate variables: 
[ (eq(47,1),aux(280))>>s(57), (eq(47,1),s(55))>>s(58)]

#### Simplifying cost structure of CE 47 
 * Renamed intermediate variables: 
[ (it(45),s(57))>>s(59), (it(45),s(58))>>s(60)]

#### Cost of loops [45] 

 * loop 45:make_btree(A,B,C,D) -> [make_btree(A',B',C',D'),make_btree(A'2,B'2,C'2,D'2)] 
28*s(60)+20
  Such that:s(59) =< A'/2+A'2/2
s(60) =< s(59)

##### Pending set make_btree(A,B,C,D)
* Psum in Loop 45: [it(45)=<1,s(62)=<A'/2+A'2/2]
* Psum in Chain-Tail [44]: [it([44])=<1]
* Psum in Chain-Tail [multiple(46,[[multiple(47,[[44]])],[44]])]: [it([multiple(46,[[multiple(47,[[44]])],[44]])])=<1]
* Psum in Chain-Tail [multiple(47,[[44]])]: [it([multiple(47,[[44]])])=<1]

###### Computing sum for it(45)=<1  in Loop 45 
   - Applying inductive sum strategy 
     - head Candidate: A-1 
       - Chain-Tail [multiple(47,[[44]])] is collaborative and bounds [it([multiple(47,[[44]])])] 
       - Chain-Tail [multiple(46,[[multiple(47,[[44]])],[44]])] is collaborative and bounds [it([multiple(46,[[multiple(47,[[44]])],[44]])])] 
       - Chain-Tail [44] is collaborative
     - head Candidate: A/2-1 
       - Chain-Tail [multiple(47,[[44]])] is collaborative
       - Chain-Tail [multiple(46,[[multiple(47,[[44]])],[44]])] is collaborative
       - Chain [44] is ignored
     - tail Candidate: A-1 
       - Chain-Tail [multiple(47,[[44]])] is collaborative and bounds [it([multiple(47,[[44]])])] 
       - Chain-Tail [multiple(46,[[multiple(47,[[44]])],[44]])] is collaborative and bounds [it([multiple(46,[[multiple(47,[[44]])],[44]])])] 
       - Chain-Tail [44] is collaborative
     - tail Candidate: A/2-1 
       - Chain-Tail [multiple(47,[[44]])] is collaborative
       - Chain-Tail [multiple(46,[[multiple(47,[[44]])],[44]])] is collaborative
       - Chain-Tail [44] adds a constant 1/2 
 * Adding constraints: [it(45)=<it([44])* (1/2)+aux(281),it(45)+it([multiple(46,[[multiple(47,[[44]])],[44]])])+it([multiple(47,[[44]])])=<A-1,it(45)=<A/2-1,it(45)+it([multiple(46,[[multiple(47,[[44]])],[44]])])+it([multiple(47,[[44]])])=<A-1,aux(281)=<A/2-1] 

##### Pending set A
* Psum in Loop 45: [s(62)=<A'/2+A'2/2]
* Psum in Chain-Tail [44]: [it([44])=<1]
* Psum in Chain-Tail [multiple(46,[[multiple(47,[[44]])],[44]])]: [it([multiple(46,[[multiple(47,[[44]])],[44]])])=<1]
* Psum in Chain-Tail [multiple(47,[[44]])]: [it([multiple(47,[[44]])])=<1]

###### Computing sum for s(62)=<A'/2+A'2/2  in Loop 45 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(282)=<A/2] 
 * Adding constraints: [s(62)=<it(45)*aux(282)] 

##### Pending set make_btree(A,B,C,D)
* Pmax/min: [aux(282)=<A/2]
* Psum in Chain-Tail [44]: [it([44])=<1]
* Psum in Chain-Tail [multiple(46,[[multiple(47,[[44]])],[44]])]: [it([multiple(46,[[multiple(47,[[44]])],[44]])])=<1]
* Psum in Chain-Tail [multiple(47,[[44]])]: [it([multiple(47,[[44]])])=<1]

###### Computing max_min for aux(282)=<A/2  
   - Found a solution using transitive invariants 
 * Adding constraints:[aux(282)=<A/2] 

##### Pending set make_btree(A,B,C,D)
* Psum in Chain-Tail [44]: [it([44])=<1]
* Psum in Chain-Tail [multiple(46,[[multiple(47,[[44]])],[44]])]: [it([multiple(46,[[multiple(47,[[44]])],[44]])])=<1]
* Psum in Chain-Tail [multiple(47,[[44]])]: [it([multiple(47,[[44]])])=<1]

###### Computing sum for it([44])=<1  in Chain-Tail [44] 
   - Applying inductive sum strategy 
     - head Candidate: A 
       - Loop 45 is collaborative
       - Chain-Tail [multiple(47,[[44]])] is collaborative and bounds [it([multiple(47,[[44]])])] 
       - Chain-Tail [multiple(46,[[multiple(47,[[44]])],[44]])] is collaborative and bounds [it([multiple(46,[[multiple(47,[[44]])],[44]])])] 
     - tail Candidate: A 
       - Loop 45 is collaborative
       - Chain-Tail [multiple(47,[[44]])] is collaborative and bounds [it([multiple(47,[[44]])])] 
       - Chain-Tail [multiple(46,[[multiple(47,[[44]])],[44]])] is collaborative and bounds [it([multiple(46,[[multiple(47,[[44]])],[44]])])] 
 * Adding constraints: [it([44])+it([multiple(46,[[multiple(47,[[44]])],[44]])])+it([multiple(47,[[44]])])=<A,it([44])+it([multiple(46,[[multiple(47,[[44]])],[44]])])+it([multiple(47,[[44]])])=<A] 

##### Pending set make_btree(A,B,C,D)
* Psum in Chain-Tail [multiple(46,[[multiple(47,[[44]])],[44]])]: [it([multiple(46,[[multiple(47,[[44]])],[44]])])=<1]
* Psum in Chain-Tail [multiple(47,[[44]])]: [it([multiple(47,[[44]])])=<1]

###### Computing sum for it([multiple(46,[[multiple(47,[[44]])],[44]])])=<1  in Chain-Tail [multiple(46,[[multiple(47,[[44]])],[44]])] 
   - Applying inductive sum strategy 
     - head Candidate: A/3 
       - Loop 45 is collaborative
       - Chain-Tail [multiple(47,[[44]])] is collaborative
       - Chain-Tail [44] is collaborative
     - tail Candidate: A/3 
       - Loop 45 is collaborative
       - Chain-Tail [multiple(47,[[44]])] is collaborative
       - Chain-Tail [44] is collaborative
 * Adding constraints: [it([multiple(46,[[multiple(47,[[44]])],[44]])])=<A/3,it([multiple(46,[[multiple(47,[[44]])],[44]])])=<A/3] 

##### Pending set make_btree(A,B,C,D)
* Psum in Chain-Tail [multiple(47,[[44]])]: [it([multiple(47,[[44]])])=<1]

###### Computing sum for it([multiple(47,[[44]])])=<1  in Chain-Tail [multiple(47,[[44]])] 
   - Applying inductive sum strategy 
     - head Candidate: A/2 
       - Loop 45 is collaborative
       - Chain-Tail [multiple(46,[[multiple(47,[[44]])],[44]])] is collaborative
       - Chain-Tail [44] is collaborative
     - tail Candidate: A/2 
       - Loop 45 is collaborative
       - Chain-Tail [multiple(46,[[multiple(47,[[44]])],[44]])] is collaborative
       - Chain-Tail [44] is collaborative
 * Adding constraints: [it([multiple(47,[[44]])])=<A/2,it([multiple(47,[[44]])])=<A/2] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [45,[multiple(47,[[44]])],[multiple(46,[[multiple(47,[[44]])],[44]])],[44]] 

#### Simplifying cost structure of phase [45,[multiple(47,[[44]])],[multiple(46,[[multiple(47,[[44]])],[44]])],[44]] 
 * Joined equivalent variables [aux(284),aux(281),aux(282)] into aux(284)

#### Cost of phase [45]:make_btree(A,B,C,D) -> [] 
20*it(45)+3*it([44])+64*it([multiple(46,[[multiple(47,[[44]])],[44]])])+22*it([multiple(47,[[44]])])+28*s(61)+0
  Such that:it([multiple(46,[[multiple(47,[[44]])],[44]])]) =< A/3
aux(283) =< A
aux(284) =< A/2
it(45) =< aux(283)
it([44]) =< aux(283)
it([multiple(46,[[multiple(47,[[44]])],[44]])]) =< aux(283)
it([multiple(47,[[44]])]) =< aux(283)
it(45) =< aux(284)
it([multiple(47,[[44]])]) =< aux(284)
it(45) =< it([44])* (1/2)+aux(284)
s(62) =< it(45)*aux(284)
s(61) =< s(62)

#### Cost of chains of make_btree(A,B,C,D):
* Chain [multiple(47,[[44]])]: 22
  with precondition: [A=2,D=3,B>=0,C>=0] 

* Chain [multiple(46,[[multiple(47,[[44]])],[44]])]: 64
  with precondition: [A=3,D=5,B>=0,C>=0] 

* Chain [44]: 3
  with precondition: [A=1,D=1,B>=0,C>=0] 

* Chain [multiple([45],[[multiple(47,[[44]])],[multiple(46,[[multiple(47,[[44]])],[44]])],[44]])]: 20*it(45)+3*it([44])+64*it([multiple(46,[[multiple(47,[[44]])],[44]])])+22*it([multiple(47,[[44]])])+28*s(61)+0
  Such that:it([multiple(46,[[multiple(47,[[44]])],[44]])]) =< A/3
aux(283) =< A
aux(284) =< A/2
it(45) =< aux(283)
it([44]) =< aux(283)
it([multiple(46,[[multiple(47,[[44]])],[44]])]) =< aux(283)
it([multiple(47,[[44]])]) =< aux(283)
it(45) =< aux(284)
it([multiple(47,[[44]])]) =< aux(284)
it(45) =< it([44])* (1/2)+aux(284)
s(62) =< it(45)*aux(284)
s(61) =< s(62)

  with precondition: [2*A=D+1,A>=4,B>=0,C>=0] 

 * Joined equivalent variables [aux(279),s(53)] into aux(279)

Closed-form bounds of dfs(A,B,C,D,E,F): 
-------------------------------------
* Chain [40] with precondition: [D=1,F=0,A>=0,B>=1,C>=0,E>=0] 
    - Upper bound: 17*B+6 
    - Complexity: n 
* Chain [39] with precondition: [D=1,A>=0,C>=0,F>=3,E>=C,B>=F] 
    - Upper bound: 17*B+12 
    - Complexity: n 

### Maximum cost of dfs(A,B,C,D,E,F): 17*B+12 
Asymptotic class: n 

Closed-form bounds of make_btree(A,B,C,D): 
-------------------------------------
* Chain [multiple(47,[[44]])] with precondition: [A=2,D=3,B>=0,C>=0] 
    - Upper bound: 22 
    - Complexity: constant 
* Chain [multiple(46,[[multiple(47,[[44]])],[44]])] with precondition: [A=3,D=5,B>=0,C>=0] 
    - Upper bound: 64 
    - Complexity: constant 
* Chain [44] with precondition: [A=1,D=1,B>=0,C>=0] 
    - Upper bound: 3 
    - Complexity: constant 
* Chain [multiple([45],[[multiple(47,[[44]])],[multiple(46,[[multiple(47,[[44]])],[44]])],[44]])] with precondition: [2*A=D+1,A>=4,B>=0,C>=0] 
    - Upper bound: 14*A*A+45*A+64/3*A 
    - Complexity: n^2 

### Maximum cost of make_btree(A,B,C,D): max([64,14*A*A+45*A+64/3*A]) 
Asymptotic class: n^2 

Closed-form bounds of append_rev(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O): 
-------------------------------------
* Chain [[22],23] with precondition: [F=I,A+F=K+1,C+H=M,D+F=N+1,E+J=O,A>=1,B>=0,C>=0,D>=1,E>=0,F>=2,G>=0,L>=0,H+1>=F,J+1>=F,B+G>=L] 
    - Upper bound: 5*I+2 
    - Complexity: n 
* Chain [23] with precondition: [F=1,H=0,I=1,J=0,A=K,B=L,C=M,D=N,E=O,A>=0,B>=0,C>=0,D>=0,E>=0,G>=0] 
    - Upper bound: 2 
    - Complexity: constant 

### Maximum cost of append_rev(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O): 5*I+2 
Asymptotic class: n 

Closed-form bounds of revL(A,B,C,D,E,F,G,H,I,J): 
-------------------------------------
* Chain [25] with precondition: [A=1,C=0,D=1,E=0,F=1,H=0,I=1,J=0,B>=0,G>=0] 
    - Upper bound: 4 
    - Complexity: constant 
* Chain [24] with precondition: [A=D,A=F,C=H,A=I,E=J,A>=2,B>=0,G>=0,C+1>=A,E+1>=A] 
    - Upper bound: 5*D+4 
    - Complexity: n 

### Maximum cost of revL(A,B,C,D,E,F,G,H,I,J): 5*D+4 
Asymptotic class: n 

Closed-form bounds of bfs(A,B,C,D,E,F): 
-------------------------------------
* Chain [34] with precondition: [D=1,F=0,A>=0,B>=1,C>=0,E>=0] 
    - Upper bound: 147*B+12 
    - Complexity: n 
* Chain [33] with precondition: [D=1,A>=0,C>=0,F>=3,E>=C,B>=F] 
    - Upper bound: 157*B+18 
    - Complexity: n 

### Maximum cost of bfs(A,B,C,D,E,F): 157*B+18 
Asymptotic class: n 
* Total analysis performed in 6521 ms.


Cost relation system solved by CoFloCo in 6528 ms.

Method dfs terminates?: YES

 - t_1: size of t wrt. Rat
 - t_2: size of t wrt. Btree
 - x_1: size of x wrt. Rat
UB for dfs(t_1,t_2,x_1) = 17*t_2+12

Method make_btree terminates?: YES

 - l_1: size of l wrt. List<Rat>
 - l_2: size of l wrt. Rat
UB for make_btree(l_1,l_2) = max([64,14*l_1*l_1+45*l_1+64/3*l_1])

Method append_rev terminates?: YES

 - acc_1: size of acc wrt. List<Btree>
 - acc_2: size of acc wrt. Rat
 - acc_3: size of acc wrt. Btree
 - acc_4: size of acc wrt. List<A>
 - acc_5: size of acc wrt. A
 - l_1: size of l wrt. List<Btree>
 - l_2: size of l wrt. Rat
 - l_3: size of l wrt. Btree
 - l_4: size of l wrt. List<A>
 - l_5: size of l wrt. A
UB for append_rev(acc_1,acc_2,acc_3,acc_4,acc_5,l_1,l_2,l_3,l_4,l_5) = 5*l_4+2

Method revL terminates?: YES

 - l_1: size of l wrt. List<Btree>
 - l_2: size of l wrt. Rat
 - l_3: size of l wrt. Btree
 - l_4: size of l wrt. List<A>
 - l_5: size of l wrt. A
UB for revL(l_1,l_2,l_3,l_4,l_5) = 5*l_4+4

Method bfs terminates?: YES

 - t_1: size of t wrt. Rat
 - t_2: size of t wrt. Btree
 - x_1: size of x wrt. Rat
UB for bfs(t_1,t_2,x_1) = 157*t_2+18
