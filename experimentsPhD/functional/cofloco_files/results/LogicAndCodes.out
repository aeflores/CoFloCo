
Abs program loaded in 19 ms.

Rule based representation generated in 10 ms.

Rule based representation stored in /tmp/costabs/rbr.rbr

RBR properties stored in /tmp/costabs/rbr.properties

Class invariants generated and loaded in 0 ms.

Abstract compilation performed in 80 ms.

Cost relation system stored in /tmp/costabs/crs.crs

Generated 51 equations 
entry('eval2'(A,B,C,D,E,F,G):[]).
entry('table2'(A,B,C,D,E,F,G):[]).
entry('rev'(A,B,C,D,E,F,G,H,I,J,K,L):[]).
entry('concat'(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X):[]).
entry('assoc'(A,B,C,D,E,F):[]).
entry('eval'(A,B,C,D,E,F,G):[]).
entry('table_make'(A,B,C,D,E,F,G,H,I,J,K,L,M,N):[]).
input_output_vars('and_op'(A,B,C),[A,B],[C]).
input_output_vars('assoc'(A,B,C,D,E,F),[A,B,C,D,E],[F]).
input_output_vars('aux_rev'(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R),[A,B,C,D,E,F,G,H,I,J,K,L],[M,N,O,P,Q,R]).
input_output_vars('case_0'(A,B,C,D,E,F,G),[A,B,C,D,E,F],[G]).
input_output_vars('case_1'(A,B,C,D,E,F,G,H),[A,B,C,D,E,F,G],[H]).
input_output_vars('case_2'(A,B,C,D,E,F,G,H),[A,B,C,D,E,F,G],[H]).
input_output_vars('case_3'(A,B,C,D,E,F),[A,B,C,D,E],[F]).
input_output_vars('case_4'(A,B,C,D,E,F,G,H,I,J,K,L),[A,B,C,D,E,F,G,H,I,J,K],[L]).
input_output_vars('case_5'(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R),[A,B,C,D,E,F,G,H,I,J,K,L],[M,N,O,P,Q,R]).
input_output_vars('case_6'(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X),[A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P],[Q,R,S,T,U,V,W,X]).
input_output_vars('case_7'(A,B,C,D,E,F,G),[A,B,C,D,E,F],[G]).
input_output_vars('case_8'(A,B,C,D,E,F,G,H,I,J,K,L,M,N),[A,B,C,D,E,F,G,H],[I,J,K,L,M,N]).
input_output_vars('concat'(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X),[A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P],[Q,R,S,T,U,V,W,X]).
input_output_vars('eq'(A,B,C),[A,B],[C]).
input_output_vars('eval'(A,B,C,D,E,F,G),[A,B,C,D,E,F],[G]).
input_output_vars('eval2'(A,B,C,D,E,F,G),[A,B,C,D,E,F],[G]).
input_output_vars('geq'(A,B,C),[A,B],[C]).
input_output_vars('gt'(A,B,C),[A,B],[C]).
input_output_vars('leq'(A,B,C),[A,B],[C]).
input_output_vars('lt'(A,B,C),[A,B],[C]).
input_output_vars('maxNorm'(A,B,C),[A,B],[C]).
input_output_vars('neg'(A,B),[A],[B]).
input_output_vars('neq'(A,B,C),[A,B],[C]).
input_output_vars('or'(A,B,C),[A,B],[C]).
input_output_vars('rev'(A,B,C,D,E,F,G,H,I,J,K,L),[A,B,C,D,E,F],[G,H,I,J,K,L]).
input_output_vars('table2'(A,B,C,D,E,F,G),[A,B,C,D],[E,F,G]).
input_output_vars('table_make'(A,B,C,D,E,F,G,H,I,J,K,L,M,N),[A,B,C,D,E,F,G,H],[I,J,K,L,M,N]).
eq('eq',[A,B,C],0,[],[A=B,C=1,A>=0,B>=0,C>=0]).
eq('eq',[A,B,C],0,[],[A>=B+1,C=0,A>=0,B>=0,C>=0]).
eq('eq',[A,B,C],0,[],[B>=A+1,C=0,A>=0,B>=0,C>=0]).
eq('neq',[A,B,C],0,[],[A=B,C=0,A>=0,B>=0,C>=0]).
eq('neq',[A,B,C],0,[],[A>=B+1,C=1,A>=0,B>=0,C>=0]).
eq('neq',[A,B,C],0,[],[B>=A+1,C=1,A>=0,B>=0,C>=0]).
eq('lt',[A,B,C],0,[],[B-A>=1,C=1,A>=0,B>=0,C>=0]).
eq('lt',[A,B,C],0,[],[B=<A,C=0,A>=0,B>=0,C>=0]).
eq('leq',[A,B,C],0,[],[A=<B,C=1,A>=0,B>=0,C>=0]).
eq('leq',[A,B,C],0,[],[A-B>=1,C=0,A>=0,B>=0,C>=0]).
eq('gt',[A,B,C],0,[],[A-B>=1,C=1,A>=0,B>=0,C>=0]).
eq('gt',[A,B,C],0,[],[A=<B,C=0,A>=0,B>=0,C>=0]).
eq('geq',[A,B,C],0,[],[B=<A,C=1,A>=0,B>=0,C>=0]).
eq('geq',[A,B,C],0,[],[B-A>=1,C=0,A>=0,B>=0,C>=0]).
eq('neg',[A,B],0,[],[A=0,B=1,A>=0,B>=0]).
eq('neg',[A,B],0,[],[A=1,B=0,A>=0,B>=0]).
eq('and_op',[A,B,C],0,[],[A=0,C=0,A>=0,B>=0,C>=0]).
eq('and_op',[A,B,C],0,[],[A=1,C=B,A>=0,B>=0,C>=0]).
eq('or',[A,B,C],0,[],[A=1,C=1,A>=0,B>=0,C>=0]).
eq('or',[A,B,C],0,[],[A=0,C=B,A>=0,B>=0,C>=0]).
eq('maxNorm',[A,B,A],0,[],[A>=1+B,A>=0,B>=0,A>=0]).
eq('maxNorm',[A,B,B],0,[],[A=<B,A>=0,B>=0,B>=0]).
eq('case_1',[A,B,C,D,E,F,G,B],1,[],[G=A,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,B>=0]).
eq('case_2',[A,B,C,D,E,F,G,D],1,[],[G=C,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,D>=0]).
eq('case_2',[A,B,C,D,E,F,G,H],2,[],[G>=C+1,H=0,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0]).
eq('case_1',[A,B,C,D,E,F,G,H],2,['case_2'(A,B,C,D,E,F,G,H)],[G>=A+1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0]).
eq('case_0',[A,B,C,D,E,F,G],2,['case_1'(A,B,C,D,E,F,H,G)],[F=1,E=H,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0]).
eq('case_0',[A,B,C,D,E,F,G],4,['eval2'(A,B,C,D,H,I,J),'neg'(J,G)],[F=I+1,E=H,I>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0]).
eq('case_0',[A,B,C,D,E,F,G],6,['eval2'(A,B,C,D,H,I,J),'eval2'(A,B,C,D,K,L,M),'and_op'(J,M,G)],[F=L+I+1,E=H+K,L>=1,I>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0]).
eq('case_0',[A,B,C,D,E,F,G],7,['eval2'(A,B,C,D,H,I,J),'eval2'(A,B,C,D,K,L,M),'or'(J,M,G)],[F=L+I+1,E=H+K,L>=1,I>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0]).
eq('eval2',[A,B,C,D,E,F,G],1,['case_0'(A,B,C,D,E,F,G)],[A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0]).
eq('table2',[A,B,C,D,E,F,G],29,['eval2'(A,H,B,I,C,D,J),'eval2'(A,K,B,L,C,D,M),'eval2'(A,N,B,O,C,D,P),'eval2'(A,Q,B,R,C,D,S)],[T=1,U=1,H=1,I=1,V=T+U+J,W=1,J>=0,U>=0,T>=0,X=1,Y=0,K=1,L=0,Z=X+Y+M,A1=1,M>=0,Y>=0,X>=0,B1=0,C1=1,N=0,O=1,D1=B1+C1+P,E1=1,P>=0,C1>=0,B1>=0,F1=0,G1=0,Q=0,R=0,H1=F1+G1+S,I1=1,S>=0,G1>=0,F1>=0,J1=0,K1=1,L1=0,M1=H1+J1,N1=K1+1,O1=I1+L1,K1>=1,I1>=1,P1=D1+M1,Q1=N1+1,R1=E1+O1,N1>=1,E1>=1,S1=Z+P1,T1=Q1+1,U1=A1+R1,Q1>=1,A1>=1,G=V+S1,F=T1+1,E=W+U1,T1>=1,W>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0]).
eq('case_4',[A,B,C,D,E,F,G,H,I,J,K,G],1,[],[F=A,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,G>=0]).
eq('case_4',[A,B,C,D,E,F,G,H,I,J,K,L],2,['assoc'(A,H,I,J,K,L)],[F>=A+1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0]).
eq('case_3',[A,B,C,D,E,F],2,['case_4'(A,B,C,D,E,G,H,I,J,K,L,F)],[E=L+H,D=K+G,C=J+1,B=1+I,J>=1,H>=0,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0]).
eq('assoc',[A,B,C,D,E,F],1,['case_3'(A,B,C,D,E,F)],[A>=0,B>=0,C>=0,D>=0,E>=0,F>=0]).
eq('case_5',[A,B,C,D,E,F,G,H,I,J,K,L,A,B,C,D,E,F],1,[],[L=0,K=1,J=0,H=1,G=0,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0]).
eq('case_5',[A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R],4,['aux_rev'(S,T,U,V,W,X,Y,Z,A1,B1,C1,D1,M,N,O,P,Q,R)],[L=E1+D1,K=C1+1,J=F1+B1,I=G1+A1,H=Z+1,G=H1+Y,C1>=1,Z>=1,E1>=1,H1>=1,X=E1+F,W=E+1,V=F1+D,U=G1+C,T=B+1,S=H1+A,E>=1,B>=1,E1>=1,H1>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0,M>=0,N>=0,O>=0,P>=0,Q>=0,R>=0]).
eq('aux_rev',[A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R],1,['case_5'(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R)],[A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0,M>=0,N>=0,O>=0,P>=0,Q>=0,R>=0]).
eq('rev',[A,B,C,D,E,F,G,H,I,J,K,L],2,['aux_rev'(M,N,O,P,Q,R,A,B,C,D,E,F,G,H,I,J,K,L)],[R=0,Q=1,P=0,N=1,M=0,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0]).
eq('case_6',[A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,I,J,K,L,M,N,O,P],1,[],[H=0,G=1,F=0,D=0,C=1,B=0,A=0,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0,M>=0,N>=0,O>=0,P>=0,I>=0,J>=0,K>=0,L>=0,M>=0,N>=0,O>=0,P>=0]).
eq('case_6',[A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X],4,['concat'(Y,Z,A1,B1,C1,D1,E1,F1,I,J,K,L,M,N,O,P,G1,H1,I1,J1,K1,L1,M1,N1)],[H=O1+F1,G=E1+1,F=P1+D1,E=Q1+C1,D=R1+B1,C=A1+1,B=S1+Z,A=T1+Y,E1>=1,A1>=1,O1>=1,T1>=1,X=O1+N1,W=M1+1,V=P1+L1,U=Q1+K1,T=R1+J1,S=I1+1,R=S1+H1,Q=T1+G1,M1>=1,I1>=1,O1>=1,T1>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0,M>=0,N>=0,O>=0,P>=0,Q>=0,R>=0,S>=0,T>=0,U>=0,V>=0,W>=0,X>=0]).
eq('concat',[A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X],1,['case_6'(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X)],[A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0,M>=0,N>=0,O>=0,P>=0,Q>=0,R>=0,S>=0,T>=0,U>=0,V>=0,W>=0,X>=0]).
eq('case_7',[A,B,C,D,E,F,G],2,['assoc'(H,A,B,C,D,G)],[F=1,E=H,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0]).
eq('case_7',[A,B,C,D,E,F,G],4,['eval'(A,B,C,D,H,I,J),'neg'(J,G)],[F=I+1,E=H,I>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0]).
eq('case_7',[A,B,C,D,E,F,G],6,['eval'(A,B,C,D,H,I,J),'eval'(A,B,C,D,K,L,M),'and_op'(J,M,G)],[F=L+I+1,E=H+K,L>=1,I>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0]).
eq('case_7',[A,B,C,D,E,F,G],7,['eval'(A,B,C,D,H,I,J),'eval'(A,B,C,D,K,L,M),'or'(J,M,G)],[F=L+I+1,E=H+K,L>=1,I>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0]).
eq('eval',[A,B,C,D,E,F,G],1,['case_7'(A,B,C,D,E,F,G)],[A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0]).
eq('case_8',[A,B,C,D,E,F,G,H,I,J,K,L,M,N],6,['rev'(A,B,C,D,O,P,Q,R,S,T,U,V),'eval'(A,B,C,D,G,H,W)],[E=1,X=T+W,Y=S,Z=R,A1=Q,B1=1,W>=0,R>=1,C1=0,D1=0,E1=1,F1=0,G1=0,N=X+C1,M=Y+H1,L=Z+D1,K=E1+1,J=A1+F1,I=B1+G1,E1>=1,B1>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0,M>=0,N>=0]).
eq('case_8',[A,B,C,D,E,F,G,H,I,J,K,L,M,N],11,['table_make'(O,P,Q,R,S,T,G,H,U,V,W,X,Y,Z),'table_make'(A1,B1,C1,D1,S,T,G,H,E1,F1,G1,H1,I1,J1),'concat'(U,V,W,X,Y,Z,K1,L1,E1,F1,G1,H1,I1,J1,M1,N1,I,J,K,L,M,N,O1,P1)],[F=Q1+T,E=S+1,S>=1,R1=1,S1=R1,T1=Q1,U1=1,R1>=0,R=S1+D,Q=T1+C,P=B+1,O=U1+A,B>=1,U1>=1,V1=0,W1=V1,X1=Q1,Y1=1,V1>=0,D1=W1+D,C1=X1+C,B1=B+1,A1=Y1+A,B>=1,Y1>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0,M>=0,N>=0]).
eq('table_make',[A,B,C,D,E,F,G,H,I,J,K,L,M,N],1,['case_8'(A,B,C,D,E,F,G,H,I,J,K,L,M,N)],[A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0,M>=0,N>=0]).

Preprocessing Cost Relations
=====================================

#### Computed strongly connected components 
0. recursive  : [assoc/6,case_3/6,case_4/12]
1. recursive  : [case_6/24,concat/24]
2. non_recursive  : [and_op/3]
3. non_recursive  : [neg/2]
4. non_recursive  : [or/3]
5. recursive [non_tail,multiple] : [case_7/7,eval/7]
6. non_recursive  : [case_2/8]
7. non_recursive  : [case_1/8]
8. recursive [non_tail,multiple] : [case_0/7,eval2/7]
9. recursive  : [aux_rev/18,case_5/18]
10. non_recursive  : [rev/12]
11. non_recursive  : [table2/7]
12. recursive [non_tail,multiple] : [case_8/14,table_make/14]
Warning: the following predicates are never called:[eq/3,geq/3,gt/3,leq/3,lt/3,maxNorm/3,neq/3]

#### Obtained direct recursion through partial evaluation 
0. SCC is partially evaluated into assoc/6
1. SCC is partially evaluated into concat/24
2. SCC is partially evaluated into and_op/3
3. SCC is partially evaluated into neg/2
4. SCC is partially evaluated into or/3
5. SCC is partially evaluated into eval/7
6. SCC is partially evaluated into case_2/8
7. SCC is partially evaluated into case_1/8
8. SCC is partially evaluated into eval2/7
9. SCC is partially evaluated into aux_rev/18
10. SCC is partially evaluated into rev/12
11. SCC is partially evaluated into table2/7
12. SCC is partially evaluated into table_make/14

Control-Flow Refinement of Cost Relations
=====================================

### Specialization of cost equations assoc/6 
* CE 10 is refined into CE [29] 
* CE 9 is refined into CE [30] 


#### Refined cost equations assoc/6 
* CE 29: assoc(A,B,C,D,E,F) = 4
     [E>=F,D>=A,F>=0,C>=2,B>=1,A>=0] 
* CE 30: assoc(A,B,C,D,E,F) = 5+ assoc(A,G,H,I,J,F)
     [D>=A+I+1,E>=J,J>=0,I>=0,H>=1,G>=0,F>=0,A>=0,H+1=C,G+1=B] 

### Cost equations --> "Loop" of assoc/6 
* CEs [30] --> Loop 27 
* CEs [29] --> Loop 28 

#### Loops of assoc/6 
* Loop 27: assoc(A,B,C,D,E,F)->  assoc(A,A',B',C',D',F)
                  [D>=A+C'+1,E>=D',D'>=0,C'>=0,B'>=1,A'>=0,F>=0,A>=0,B'+1=C,A'+1=B] 
* Loop 28: assoc(A,B,C,D,E,F) [E>=F,D>=A,F>=0,C>=2,B>=1,A>=0] 

### Ranking functions of CR assoc(A,B,C,D,E,F) 
* RF of phase [27]: [-A+D,B,C-1,D]

#### Partial ranking functions of CR assoc(A,B,C,D,E,F) 
* Partial RF of phase [27]:
  - RF of loop [27:1]:
    -A+D
    B
    C-1
    D

Discarded unfeasible chain [[27]]...(Non-terminating chain proved terminating)

### Resulting Chains:assoc(A,B,C,D,E,F) 
* [[27],28]
* [28]


### Merging Chains  assoc/6 into  External patterns of execution 
* [[28],[28,[27]]] --> 1 


### Specialization of cost equations concat/24 
* CE 8 is refined into CE [31] 
* CE 7 is refined into CE [32] 


#### Refined cost equations concat/24 
* CE 31: concat(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,I,J,K,L,M,N,O,P) = 2
     [P>=0,O>=0,N>=0,M>=0,L>=0,K>=0,J>=0,I>=0,E>=0,H=0,G=1,F=0,D=0,C=1,B=0,A=0] 
* CE 32: concat(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X) = 5+ concat(Y,Z,A1,B1,C1,D1,E1,F1,I,J,K,L,M,N,O,P,G1,H1,I1,J1,K1,L1,M1,N1)
     [X+F1>=N1,V+D1>=L1,U+C1>=K1,T+B1>=J1,R+Z>=H1,Q+Y>=G1,X>=N1+1,Q>=G1+1,M1>=1,I1>=1,E1>=1,A1>=1,X>=0,V>=0,U>=0,T>=0,R>=0,Q>=0,P>=0,O>=0,N>=0,M>=0,L>=0,K>=0,J>=0,I>=0,H+N1=X+F1,F+L1=V+D1,E+K1=U+C1,D+J1=T+B1,B+H1=R+Z,A+G1=Q+Y,M1+1=W,I1+1=S,E1+1=G,A1+1=C] 

### Cost equations --> "Loop" of concat/24 
* CEs [32] --> Loop 29 
* CEs [31] --> Loop 30 

#### Loops of concat/24 
* Loop 29: concat(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X)->  concat(A',B',C',D',E',F',G',H',I,J,K,L,M,N,O,P,I',J',K',L',M',N',O',P')
                  [X+H'>=P',V+F'>=N',U+E'>=M',T+D'>=L',R+B'>=J',Q+A'>=I',X>=P'+1,Q>=I'+1,O'>=1,K'>=1,G'>=1,C'>=1,X>=0,V>=0,U>=0,T>=0,R>=0,Q>=0,P>=0,O>=0,N>=0,M>=0,L>=0,K>=0,J>=0,I>=0,X+H'=H+P',V+F'=F+N',U+E'=E+M',T+D'=D+L',R+B'=B+J',Q+A'=A+I',O'+1=W,K'+1=S,G'+1=G,C'+1=C] 
* Loop 30: concat(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,I,J,K,L,M,N,O,P) [P>=0,O>=0,N>=0,M>=0,L>=0,K>=0,J>=0,I>=0,E>=0,H=0,G=1,F=0,D=0,C=1,B=0,A=0] 

### Ranking functions of CR concat(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X) 
* RF of phase [29]: [A+1,C-1,G-1,H+1]

#### Partial ranking functions of CR concat(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X) 
* Partial RF of phase [29]:
  - RF of loop [29:1]:
    A+1
    C-1
    G-1
    H+1

Discarded unfeasible chain [[29]]...(Non-terminating chain proved terminating)

### Resulting Chains:concat(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X) 
* [[29],30]
* [30]


### Merging Chains  concat/24 into  External patterns of execution 
* [[30]] --> 1 
* [[30,[29]]] --> 2 


### Specialization of cost equations and_op/3 
* CE 20 is refined into CE [33] 
* CE 19 is refined into CE [34] 


#### Refined cost equations and_op/3 
* CE 33: and_op(A,B,B) = 0
     [B>=0,A=1] 
* CE 34: and_op(A,B,C) = 0
     [B>=0,C=0,A=0] 

### Cost equations --> "Loop" of and_op/3 
* CEs [33] --> Loop 31 
* CEs [34] --> Loop 32 

#### Loops of and_op/3 
* Loop 31: and_op(A,B,B) [B>=0,A=1] 
* Loop 32: and_op(A,B,C) [B>=0,C=0,A=0] 

### Ranking functions of CR and_op(A,B,C) 

#### Partial ranking functions of CR and_op(A,B,C) 


### Resulting Chains:and_op(A,B,C) 
* [32]
* [31]


### Merging Chains  and_op/3 into  External patterns of execution 
* [[32]] --> 1 
* [[31]] --> 2 


### Specialization of cost equations neg/2 
* CE 22 is refined into CE [35] 
* CE 21 is refined into CE [36] 


#### Refined cost equations neg/2 
* CE 35: neg(A,B) = 0
     [B=0,A=1] 
* CE 36: neg(A,B) = 0
     [B=1,A=0] 

### Cost equations --> "Loop" of neg/2 
* CEs [35] --> Loop 33 
* CEs [36] --> Loop 34 

#### Loops of neg/2 
* Loop 33: neg(A,B) [B=0,A=1] 
* Loop 34: neg(A,B) [B=1,A=0] 

### Ranking functions of CR neg(A,B) 

#### Partial ranking functions of CR neg(A,B) 


### Resulting Chains:neg(A,B) 
* [34]
* [33]


### Merging Chains  neg/2 into  External patterns of execution 
* [[34]] --> 1 
* [[33]] --> 2 


### Specialization of cost equations or/3 
* CE 17 is refined into CE [37] 
* CE 18 is refined into CE [38] 


#### Refined cost equations or/3 
* CE 37: or(A,B,C) = 0
     [B>=0,C=1,A=1] 
* CE 38: or(A,B,B) = 0
     [B>=0,A=0] 

### Cost equations --> "Loop" of or/3 
* CEs [37] --> Loop 35 
* CEs [38] --> Loop 36 

#### Loops of or/3 
* Loop 35: or(A,B,C) [B>=0,C=1,A=1] 
* Loop 36: or(A,B,B) [B>=0,A=0] 

### Ranking functions of CR or(A,B,C) 

#### Partial ranking functions of CR or(A,B,C) 


### Resulting Chains:or(A,B,C) 
* [36]
* [35]


### Merging Chains  or/3 into  External patterns of execution 
* [[36]] --> 1 
* [[35]] --> 2 


### Specialization of cost equations eval/7 
* CE 14 is refined into CE [39] 
* CE 13 is refined into CE [40,41] 
* CE 11 is refined into CE [42,43] 
* CE 12 is refined into CE [44,45] 


#### Refined cost equations eval/7 
* CE 39: eval(A,B,C,D,E,F,G) = 3+ assoc(E,A,B,C,D,G):1
     [D>=G,C>=E,G>=0,B>=2,A>=1,E>=0,F=1] 
* CE 40: eval(A,B,C,D,E,F,G) = 5+ eval(A,B,C,D,E,H,I)+ neg(J,K):1
     [H>=1,E>=0,D>=0,C>=0,B>=0,A>=0,H+1=F,I=0,K=1,J=0,G=1] 
* CE 41: eval(A,B,C,D,E,F,G) = 5+ eval(A,B,C,D,E,H,I)+ neg(J,K):2
     [H>=1,E>=0,D>=0,C>=0,B>=0,A>=0,H+1=F,I=1,K=0,J=1,G=0] 
* CE 42: eval(A,B,C,D,E,F,G) = 8+ eval(A,B,C,D,H,I,J)+ eval(A,B,C,D,K,L,G)+ or(M,G,G):1
     [H+K>=0,L>=1,I>=1,G>=0,D>=0,C>=0,B>=0,A>=0,I+L+1=F,H+K=E,J=0,M=0] 
* CE 43: eval(A,B,C,D,E,F,G) = 8+ eval(A,B,C,D,H,I,J)+ eval(A,B,C,D,K,L,M)+ or(N,M,O):2
     [H+K>=0,L>=1,I>=1,M>=0,D>=0,C>=0,B>=0,A>=0,I+L+1=F,H+K=E,J=1,O=1,N=1,G=1] 
* CE 44: eval(A,B,C,D,E,F,G) = 7+ eval(A,B,C,D,H,I,J)+ eval(A,B,C,D,K,L,M)+ and_op(N,M,O):1
     [H+K>=0,L>=1,I>=1,M>=0,D>=0,C>=0,B>=0,A>=0,I+L+1=F,H+K=E,J=0,O=0,N=0,G=0] 
* CE 45: eval(A,B,C,D,E,F,G) = 7+ eval(A,B,C,D,H,I,J)+ eval(A,B,C,D,K,L,G)+ and_op(M,G,G):2
     [H+K>=0,L>=1,I>=1,G>=0,D>=0,C>=0,B>=0,A>=0,I+L+1=F,H+K=E,J=1,M=1] 

### Cost equations --> "Loop" of eval/7 
* CEs [45] --> Loop 37 
* CEs [42] --> Loop 38 
* CEs [43] --> Loop 39 
* CEs [44] --> Loop 40 
* CEs [40] --> Loop 41 
* CEs [41] --> Loop 42 
* CEs [39] --> Loop 43 

#### Loops of eval/7 
* Loop 37: eval(A,B,C,D,E,F,G)->  eval(A,B,C,D,A',B',C')  eval(A,B,C,D,A'2,B'2,G)
                  [F>=B'+2,B'>=1,G>=0,E>=0,D>=0,C>=0,B>=0,A>=0,E=A'+A'2,B'+B'2+1=F,C'=1] 
* Loop 38: eval(A,B,C,D,E,F,G)->  eval(A,B,C,D,A',B',C')  eval(A,B,C,D,A'2,B'2,G)
                  [F>=B'+2,B'>=1,G>=0,E>=0,D>=0,C>=0,B>=0,A>=0,E=A'+A'2,B'+B'2+1=F,C'=0] 
* Loop 39: eval(A,B,C,D,E,F,G)->  eval(A,B,C,D,A',B',C')  eval(A,B,C,D,A'2,B'2,C'2)
                  [F>=B'+2,C'2>=0,B'>=1,E>=0,D>=0,C>=0,B>=0,A>=0,E=A'+A'2,B'+B'2+1=F,C'=1,G=1] 
* Loop 40: eval(A,B,C,D,E,F,G)->  eval(A,B,C,D,A',B',C')  eval(A,B,C,D,A'2,B'2,C'2)
                  [F>=B'+2,C'2>=0,B'>=1,E>=0,D>=0,C>=0,B>=0,A>=0,E=A'+A'2,B'+B'2+1=F,C'=0,G=0] 
* Loop 41: eval(A,B,C,D,E,F,G)->  eval(A,B,C,D,E,A',B')
                  [F>=2,E>=0,D>=0,C>=0,B>=0,A>=0,F=A'+1,B'=0,G=1] 
* Loop 42: eval(A,B,C,D,E,F,G)->  eval(A,B,C,D,E,A',B')
                  [F>=2,E>=0,D>=0,C>=0,B>=0,A>=0,F=A'+1,B'=1,G=0] 
* Loop 43: eval(A,B,C,D,E,F,G) [D>=G,C>=E,G>=0,E>=0,B>=2,A>=1,F=1] 

### Ranking functions of CR eval(A,B,C,D,E,F,G) 
* RF of phase [37,38,39,40,41,42]: [F-1]

#### Partial ranking functions of CR eval(A,B,C,D,E,F,G) 
* Partial RF of phase [37,38,39,40,41,42]:
  - RF of loop [37:1,37:2,38:1,38:2,39:1,39:2,40:1,40:2]:
    F/2-1
  - RF of loop [41:1,42:1]:
    F-1

Discarded unfeasible chain [multiple([37,38,39,40,41,42],[[],[43]])]...(Non-terminating chain proved terminating)
Remaining chain: [multiple([37,38,39,40,41,42],[[43]])]

### Resulting Chains:eval(A,B,C,D,E,F,G) 
* [43]
* [multiple([37,38,39,40,41,42],[[43]])]


### Merging Chains  eval/7 into  External patterns of execution 
* [[43]] --> 1 
* [[multiple([37,38,39,40,41,42],[[43]])]] --> 2 


### Specialization of cost equations case_2/8 
* CE 27 is refined into CE [46] 
* CE 28 is refined into CE [47] 


#### Refined cost equations case_2/8 
* CE 46: case_2(A,B,C,D,C,E,C,D) = 1
     [C>=A+1,D>=0,B>=0,A>=0,E=1] 
* CE 47: case_2(A,B,C,D,E,F,E,G) = 2
     [E>=C+1,E>=A+1,D>=0,C>=0,B>=0,A>=0,G=0,F=1] 

### Cost equations --> "Loop" of case_2/8 
* CEs [46] --> Loop 44 
* CEs [47] --> Loop 45 

#### Loops of case_2/8 
* Loop 44: case_2(A,B,C,D,C,E,C,D) [C>=A+1,D>=0,B>=0,A>=0,E=1] 
* Loop 45: case_2(A,B,C,D,E,F,E,G) [E>=C+1,E>=A+1,D>=0,C>=0,B>=0,A>=0,G=0,F=1] 

### Ranking functions of CR case_2(A,B,C,D,E,F,G,H) 

#### Partial ranking functions of CR case_2(A,B,C,D,E,F,G,H) 


### Resulting Chains:case_2(A,B,C,D,E,F,G,H) 
* [45]
* [44]


### Merging Chains  case_2/8 into  External patterns of execution 
* [[45]] --> 1 
* [[44]] --> 2 


### Specialization of cost equations case_1/8 
* CE 24 is refined into CE [48,49] 
* CE 23 is refined into CE [50] 


#### Refined cost equations case_1/8 
* CE 48: case_1(A,B,C,D,E,F,E,G) = 2+ case_2(A,B,C,D,E,H,E,I):1
     [E>=C+1,E>=A+1,D>=0,C>=0,B>=0,A>=0,I=0,H=1,G=0,F=1] 
* CE 49: case_1(A,B,C,D,C,E,C,D) = 2+ case_2(A,B,C,D,C,F,C,D):2
     [C>=A+1,D>=0,B>=0,A>=0,F=1,E=1] 
* CE 50: case_1(A,B,C,D,A,E,A,B) = 1
     [A>=0,D>=0,C>=0,B>=0,E=1] 

### Cost equations --> "Loop" of case_1/8 
* CEs [49] --> Loop 46 
* CEs [50] --> Loop 47 
* CEs [48] --> Loop 48 

#### Loops of case_1/8 
* Loop 46: case_1(A,B,C,D,C,E,C,D) [C>=A+1,D>=0,B>=0,A>=0,E=1] 
* Loop 47: case_1(A,B,C,D,A,E,A,B) [D>=0,C>=0,B>=0,A>=0,E=1] 
* Loop 48: case_1(A,B,C,D,E,F,E,G) [E>=C+1,E>=A+1,D>=0,C>=0,B>=0,A>=0,G=0,F=1] 

### Ranking functions of CR case_1(A,B,C,D,E,F,G,H) 

#### Partial ranking functions of CR case_1(A,B,C,D,E,F,G,H) 


### Resulting Chains:case_1(A,B,C,D,E,F,G,H) 
* [48]
* [47]
* [46]


### Merging Chains  case_1/8 into  External patterns of execution 
* [[48]] --> 1 
* [[47]] --> 2 
* [[46]] --> 3 


### Specialization of cost equations eval2/7 
* CE 4 is refined into CE [51,52,53] 
* CE 3 is refined into CE [54,55] 
* CE 1 is refined into CE [56,57] 
* CE 2 is refined into CE [58,59] 


#### Refined cost equations eval2/7 
* CE 51: eval2(A,B,C,D,E,F,G) = 3+ case_1(A,B,C,D,E,H,E,I):1
     [E>=C+1,E>=A+1,D>=0,C>=0,B>=0,A>=0,I=0,H=1,G=0,F=1] 
* CE 52: eval2(A,B,C,D,A,E,B) = 3+ case_1(A,B,C,D,A,F,A,B):2
     [B>=0,A>=0,D>=0,C>=0,F=1,E=1] 
* CE 53: eval2(A,B,C,D,C,E,D) = 3+ case_1(A,B,C,D,C,F,C,D):3
     [C>=A+1,D>=0,B>=0,A>=0,F=1,E=1] 
* CE 54: eval2(A,B,C,D,E,F,G) = 5+ eval2(A,B,C,D,E,H,I)+ neg(J,K):1
     [H>=1,E>=0,D>=0,C>=0,B>=0,A>=0,H+1=F,I=0,K=1,J=0,G=1] 
* CE 55: eval2(A,B,C,D,E,F,G) = 5+ eval2(A,B,C,D,E,H,I)+ neg(J,K):2
     [H>=1,E>=0,D>=0,C>=0,B>=0,A>=0,H+1=F,I=1,K=0,J=1,G=0] 
* CE 56: eval2(A,B,C,D,E,F,G) = 8+ eval2(A,B,C,D,H,I,J)+ eval2(A,B,C,D,K,L,G)+ or(M,G,G):1
     [H+K>=0,L>=1,I>=1,G>=0,D>=0,C>=0,B>=0,A>=0,I+L+1=F,H+K=E,J=0,M=0] 
* CE 57: eval2(A,B,C,D,E,F,G) = 8+ eval2(A,B,C,D,H,I,J)+ eval2(A,B,C,D,K,L,M)+ or(N,M,O):2
     [H+K>=0,L>=1,I>=1,M>=0,D>=0,C>=0,B>=0,A>=0,I+L+1=F,H+K=E,J=1,O=1,N=1,G=1] 
* CE 58: eval2(A,B,C,D,E,F,G) = 7+ eval2(A,B,C,D,H,I,J)+ eval2(A,B,C,D,K,L,M)+ and_op(N,M,O):1
     [H+K>=0,L>=1,I>=1,M>=0,D>=0,C>=0,B>=0,A>=0,I+L+1=F,H+K=E,J=0,O=0,N=0,G=0] 
* CE 59: eval2(A,B,C,D,E,F,G) = 7+ eval2(A,B,C,D,H,I,J)+ eval2(A,B,C,D,K,L,G)+ and_op(M,G,G):2
     [H+K>=0,L>=1,I>=1,G>=0,D>=0,C>=0,B>=0,A>=0,I+L+1=F,H+K=E,J=1,M=1] 

### Cost equations --> "Loop" of eval2/7 
* CEs [59] --> Loop 49 
* CEs [56] --> Loop 50 
* CEs [57] --> Loop 51 
* CEs [58] --> Loop 52 
* CEs [54] --> Loop 53 
* CEs [55] --> Loop 54 
* CEs [53] --> Loop 55 
* CEs [52] --> Loop 56 
* CEs [51] --> Loop 57 

#### Loops of eval2/7 
* Loop 49: eval2(A,B,C,D,E,F,G)->  eval2(A,B,C,D,A',B',C')  eval2(A,B,C,D,A'2,B'2,G)
                  [F>=B'+2,B'>=1,G>=0,E>=0,D>=0,C>=0,B>=0,A>=0,E=A'+A'2,B'+B'2+1=F,C'=1] 
* Loop 50: eval2(A,B,C,D,E,F,G)->  eval2(A,B,C,D,A',B',C')  eval2(A,B,C,D,A'2,B'2,G)
                  [F>=B'+2,B'>=1,G>=0,E>=0,D>=0,C>=0,B>=0,A>=0,E=A'+A'2,B'+B'2+1=F,C'=0] 
* Loop 51: eval2(A,B,C,D,E,F,G)->  eval2(A,B,C,D,A',B',C')  eval2(A,B,C,D,A'2,B'2,C'2)
                  [F>=B'+2,C'2>=0,B'>=1,E>=0,D>=0,C>=0,B>=0,A>=0,E=A'+A'2,B'+B'2+1=F,C'=1,G=1] 
* Loop 52: eval2(A,B,C,D,E,F,G)->  eval2(A,B,C,D,A',B',C')  eval2(A,B,C,D,A'2,B'2,C'2)
                  [F>=B'+2,C'2>=0,B'>=1,E>=0,D>=0,C>=0,B>=0,A>=0,E=A'+A'2,B'+B'2+1=F,C'=0,G=0] 
* Loop 53: eval2(A,B,C,D,E,F,G)->  eval2(A,B,C,D,E,A',B')
                  [F>=2,E>=0,D>=0,C>=0,B>=0,A>=0,F=A'+1,B'=0,G=1] 
* Loop 54: eval2(A,B,C,D,E,F,G)->  eval2(A,B,C,D,E,A',B')
                  [F>=2,E>=0,D>=0,C>=0,B>=0,A>=0,F=A'+1,B'=1,G=0] 
* Loop 55: eval2(A,B,C,D,C,E,D) [C>=A+1,D>=0,B>=0,A>=0,E=1] 
* Loop 56: eval2(A,B,C,D,A,E,B) [D>=0,C>=0,B>=0,A>=0,E=1] 
* Loop 57: eval2(A,B,C,D,E,F,G) [E>=C+1,E>=A+1,D>=0,C>=0,B>=0,A>=0,G=0,F=1] 

### Ranking functions of CR eval2(A,B,C,D,E,F,G) 
* RF of phase [49,50,51,52,53,54]: [F-1]

#### Partial ranking functions of CR eval2(A,B,C,D,E,F,G) 
* Partial RF of phase [49,50,51,52,53,54]:
  - RF of loop [49:1,49:2,50:1,50:2,51:1,51:2,52:1,52:2]:
    F/2-1
  - RF of loop [53:1,54:1]:
    F-1

Discarded unfeasible chain [multiple([49,50,51,52,53,54],[[],[57],[56],[55]])]...(Non-terminating chain proved terminating)
Remaining chain: [multiple([49,50,51,52,53,54],[[57],[56],[55]])]

### Resulting Chains:eval2(A,B,C,D,E,F,G) 
* [57]
* [56]
* [55]
* [multiple([49,50,51,52,53,54],[[57],[56],[55]])]


### Merging Chains  eval2/7 into  External patterns of execution 
* [[57]] --> 1 
* [[56]] --> 2 
* [[55]] --> 3 
* [[multiple([49,50,51,52,53,54],[[57],[56],[55]])]] --> 4 


### Specialization of cost equations aux_rev/18 
* CE 26 is refined into CE [60] 
* CE 25 is refined into CE [61] 


#### Refined cost equations aux_rev/18 
* CE 60: aux_rev(A,B,C,D,B,E,F,G,H,I,J,K,A,B,C,D,B,E) = 2
     [E+1>=B,A+1>=B,H>=0,B>=1,D>=0,C>=0,K=0,J=1,I=0,G=1,F=0] 
* CE 61: aux_rev(A,B,C,D,B,E,F,G,H,I,J,K,L,M,N,O,P,Q) = 5+ aux_rev(R,S,T,U,V,W,X,Y,Z,A1,B1,C1,L,M,N,O,P,Q)
     [W+C1+1>=B+K,R+X+1>=B+F,U+A1>=I,T+Z>=H,K>=C1+1,F>=X+1,B1>=1,Y>=1,Q>=0,P>=0,O>=0,N>=0,M>=0,L>=0,K>=0,I>=0,H>=0,F>=0,B>=1,E+K=W+C1,D+I=U+A1,A+F=R+X,T+Z=C+H,B+1=V,B+1=S,B1+1=J,Y+1=G] 

### Cost equations --> "Loop" of aux_rev/18 
* CEs [61] --> Loop 58 
* CEs [60] --> Loop 59 

#### Loops of aux_rev/18 
* Loop 58: aux_rev(A,B,C,D,B,E,F,G,H,I,J,K,L,M,N,O,P,Q)->  aux_rev(A',B',C',D',E',F',G',H',I',J',K',L',L,M,N,O,P,Q)
                  [F'+L'+1>=B+K,A'+G'+1>=B+F,D'+J'>=I,C'+I'>=H,K>=L'+1,F>=G'+1,K'>=1,H'>=1,Q>=0,P>=0,O>=0,N>=0,M>=0,L>=0,K>=0,I>=0,H>=0,F>=0,B>=1,E+K=F'+L',D+I=D'+J',C+H=C'+I',A+F=A'+G',B+1=E',B+1=B',K'+1=J,H'+1=G] 
* Loop 59: aux_rev(A,B,C,D,B,E,F,G,H,I,J,K,A,B,C,D,B,E) [E+1>=B,A+1>=B,H>=0,D>=0,C>=0,B>=1,K=0,J=1,I=0,G=1,F=0] 

### Ranking functions of CR aux_rev(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R) 
* RF of phase [58]: [A-B+G+2,A-E+G+2,-B+F+L+2,-E+F+L+2,G+1,H-1,K-1,L+1]

#### Partial ranking functions of CR aux_rev(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R) 
* Partial RF of phase [58]:
  - RF of loop [58:1]:
    A-B+G+2
    A-E+G+2
    -B+F+L+2
    -E+F+L+2
    G+1
    H-1
    K-1
    L+1

Discarded unfeasible chain [[58]]...(Non-terminating chain proved terminating)

### Resulting Chains:aux_rev(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R) 
* [[58],59]
* [59]


### Merging Chains  aux_rev/18 into  External patterns of execution 
* [[59]] --> 1 
* [[59,[58]]] --> 2 


### Specialization of cost equations rev/12 
* CE 6 is refined into CE [62,63] 


#### Refined cost equations rev/12 
* CE 62: rev(A,B,C,D,E,F,G,H,I,J,K,L) = 2+ aux_rev(M,N,I,O,P,Q,R,S,C,T,U,V,W,X,I,Y,Z,A1):1
     [I>=0,C>=0,A1=0,Z=1,Y=0,X=1,W=0,V=0,U=1,T=0,S=1,R=0,Q=0,P=1,O=0,N=1,M=0,L=0,K=1,J=0,H=1,G=0,F=0,E=1,D=0,B=1,A=0] 
* CE 63: rev(A,B,C,D,B,E,A,B,F,D,B,E) = 2+ aux_rev(G,H,I,J,K,L,A,B,C,D,B,E,A,B,F,D,B,E):2
     [C+I>=F,E+1>=B,A+1>=B,D>=0,F>=0,B>=2,C>=0,I>=0,L=0,K=1,J=0,H=1,G=0] 

### Cost equations --> "Loop" of rev/12 
* CEs [63] --> Loop 60 
* CEs [62] --> Loop 61 

#### Loops of rev/12 
* Loop 60: rev(A,B,C,D,B,E,A,B,F,D,B,E) [E+1>=B,A+1>=B,F>=0,D>=0,C>=0,B>=2] 
* Loop 61: rev(A,B,C,D,E,F,G,H,I,J,K,L) [I>=0,C>=0,L=0,K=1,J=0,H=1,G=0,F=0,E=1,D=0,B=1,A=0] 

### Ranking functions of CR rev(A,B,C,D,E,F,G,H,I,J,K,L) 

#### Partial ranking functions of CR rev(A,B,C,D,E,F,G,H,I,J,K,L) 


### Resulting Chains:rev(A,B,C,D,E,F,G,H,I,J,K,L) 
* [61]
* [60]


### Merging Chains  rev/12 into  External patterns of execution 
* [[61]] --> 1 
* [[60]] --> 2 


### Specialization of cost equations table2/7 
* CE 5 is refined into CE [64,65,66,67] 


#### Refined cost equations table2/7 
* CE 64: table2(A,B,C,D,E,F,G) = 29+ eval2(A,H,B,I,C,J,K):1+ eval2(A,L,B,M,C,N,O):1+ eval2(A,P,B,Q,C,R,S):1+ eval2(A,T,B,U,C,V,W):1
     [C>=B+1,C>=A+1,B>=0,A>=0,W=0,V=1,U=0,T=0,S=0,R=1,Q=1,P=0,O=0,N=1,M=0,L=1,K=0,J=1,I=1,H=1,G=4,F=5,E=4,D=1] 
* CE 65: table2(A,B,A,C,D,E,F) = 29+ eval2(A,G,B,H,A,I,J):2+ eval2(A,K,B,L,A,M,N):2+ eval2(A,O,B,P,A,Q,R):2+ eval2(A,S,B,T,A,U,V):2
     [A>=0,B>=0,V=0,U=1,T=0,S=0,R=0,Q=1,P=1,O=0,N=1,M=1,L=0,K=1,J=1,I=1,H=1,G=1,F=6,E=5,D=4,C=1] 
* CE 66: table2(A,B,B,C,D,E,F) = 29+ eval2(A,G,B,H,B,I,J):3+ eval2(A,K,B,L,B,M,N):3+ eval2(A,O,B,P,B,Q,R):3+ eval2(A,S,B,T,B,U,V):3
     [B>=A+1,A>=0,V=0,U=1,T=0,S=0,R=1,Q=1,P=1,O=0,N=0,M=1,L=0,K=1,J=1,I=1,H=1,G=1,F=6,E=5,D=4,C=1] 
* CE 67: table2(A,B,C,D,E,F,G) = 29+ eval2(A,H,B,I,C,D,J):4+ eval2(A,K,B,L,C,D,M):4+ eval2(A,N,B,O,C,D,P):4+ eval2(A,Q,B,R,C,D,S):4
     [D+S>=3,D>=S+1,C>=A,D>=P,D>=M,D+1>=J,S>=0,B>=0,A>=0,P>=0,M>=0,J>=0,J+M+P+S+4=G,R=0,Q=0,O=1,N=0,L=0,K=1,I=1,H=1,F=5,E=4] 

### Cost equations --> "Loop" of table2/7 
* CEs [67] --> Loop 62 
* CEs [66] --> Loop 63 
* CEs [65] --> Loop 64 
* CEs [64] --> Loop 65 

#### Loops of table2/7 
* Loop 62: table2(A,B,C,D,E,F,G) [D+G>=7,4*D+4>=G,C>=A,G>=4,D>=2,B>=0,A>=0,F=5,E=4] 
* Loop 63: table2(A,B,B,C,D,E,F) [B>=A+1,A>=0,F=6,E=5,D=4,C=1] 
* Loop 64: table2(A,B,A,C,D,E,F) [B>=0,A>=0,F=6,E=5,D=4,C=1] 
* Loop 65: table2(A,B,C,D,E,F,G) [C>=B+1,C>=A+1,B>=0,A>=0,G=4,F=5,E=4,D=1] 

### Ranking functions of CR table2(A,B,C,D,E,F,G) 

#### Partial ranking functions of CR table2(A,B,C,D,E,F,G) 


### Resulting Chains:table2(A,B,C,D,E,F,G) 
* [65]
* [64]
* [63]
* [62]


### Merging Chains  table2/7 into  External patterns of execution 
* [[65]] --> 1 
* [[64]] --> 2 
* [[63]] --> 3 
* [[62]] --> 4 


### Specialization of cost equations table_make/14 
* CE 16 is refined into CE [68,69] 
* CE 15 is refined into CE [70,71] 


#### Refined cost equations table_make/14 
* CE 68: table_make(A,B,C,D,E,F,G,H,I,A,J,B,K,L) = 7+ rev(A,B,C,D,B,M,A,B,N,D,B,M):2+ eval(A,B,C,D,G,O,P):1
     [D>=P,C>=G,A+1>=B,M+1>=B,P>=0,G>=0,B>=2,N>=0,K>=0,F>=0,D+P=L,O=1,J=2,I=1,H=1,E=1] 
* CE 69: table_make(A,B,C,D,E,F,G,H,I,A,J,B,K,L) = 7+ rev(A,B,C,D,B,M,A,B,N,D,B,M):2+ eval(A,B,C,D,G,H,O):2
     [D+H+O>=3,D+H>=O+1,A+1>=B,M+1>=B,O>=0,H>=2,G>=0,D>=0,C>=0,B>=2,N>=0,K>=0,F>=0,D+O=L,J=2,I=1,E=1] 
* CE 70: table_make(A,B,C,D,E,F,G,H,I,J,K,L,M,N) = 12+ table_make(O,P,Q,R,S,T,G,H,U,V,W,X,Y,Z)+ table_make(A1,B1,Q,D,S,T,G,H,I,J,K,L,M,N)+ concat(C1,D1,E1,F1,Y,G1,H1,I1,I,J,K,L,M,N,J1,K1,I,J,K,L,M,N,J1,K1):1
     [Q+T>=C,S>=1,K1>=0,J1>=0,N>=0,M>=0,L>=0,K>=0,J>=0,I>=0,Y>=0,H>=0,G>=0,D>=0,C>=0,B>=1,A>=0,Q+T=C+F,B+1=B1,A+1=A1,D+1=R,B+1=P,A+1=O,S+1=E,Z=0,X=0,W=1,V=0,U=0,I1=0,H1=1,G1=0,F1=0,E1=1,D1=0,C1=0] 
* CE 71: table_make(A,B,C,D,E,F,G,H,I,J,K,L,M,N) = 12+ table_make(O,P,Q,R,S,T,G,H,U,V,W,X,Y,Z)+ table_make(A1,B1,Q,D,S,T,G,H,C1,D1,E1,F1,G1,H1)+ concat(U,V,W,X,Y,Z,W,I1,J1,K1,L1,M1,G1,N1,O1,P1,I,J,K,L,M,N,Q1,R1):2
     [Y+G1>=M,Q+T>=C,R1>=I1,Q1>=W,K>=W,I1+1>=W,U+1>=W,N>=Z,L>=X,J>=V,I>=U,S>=1,M>=0,G1>=0,W>=2,Z>=0,Y>=0,X>=0,V>=0,H>=0,G>=0,D>=0,C>=0,B>=1,A>=0,Q+T=C+F,W+O1=Q1+1,W+E1=K+1,W+L1=K+1,R1=I1+P1,N=Z+H1,N=Z+N1,L=X+F1,L=X+M1,J=V+D1,J=V+K1,I=U+C1,I=U+J1,B+1=B1,A+1=A1,D+1=R,B+1=P,A+1=O,S+1=E] 

### Cost equations --> "Loop" of table_make/14 
* CEs [71] --> Loop 66 
* CEs [70] --> Loop 67 
* CEs [69] --> Loop 68 
* CEs [68] --> Loop 69 

#### Loops of table_make/14 
* Loop 66: table_make(A,B,C,D,E,F,G,H,I,J,K,L,M,N)->  table_make(A',B',C',D',E',F',G,H,G',H',I',J',K',L')  table_make(A'2,B'2,C',D,C'2,D'2,G,H,E'2,F'2,G'2,H'2,I'2,J'2)
                  [K'+I'2>=M,N>=L',L>=J',G'+1>=I',K>=I',J>=H',I>=G',I'2>=0,L'>=0,K'>=0,J'>=0,I'>=2,H'>=0,M>=0,H>=0,G>=0,F>=0,E>=2,D>=0,C>=0,B>=1,A>=0,C+F=C'+D'2,C+F=C'+F',L'+J'2=N,J'+H'2=L,I'+G'2=K+1,H'+F'2=J,G'+E'2=I,E=C'2+1,B+1=B'2,A+1=A'2,E=E'+1,D+1=D',B+1=B',A+1=A'] 
* Loop 67: table_make(A,B,C,D,E,F,G,H,I,J,K,L,M,N)->  table_make(A',B',C',D',E',F',G,H,G',H',I',J',K',L')  table_make(A'2,B'2,C',D,C'2,D'2,G,H,I,J,K,L,M,N)
                  [K'>=0,N>=0,M>=0,L>=0,K>=0,J>=0,I>=0,H>=0,G>=0,F>=0,E>=2,D>=0,C>=0,B>=1,A>=0,C+F=C'+D'2,C+F=C'+F',E=C'2+1,B+1=B'2,A+1=A'2,E=E'+1,D+1=D',B+1=B',A+1=A',L'=0,J'=0,I'=1,H'=0,G'=0] 
* Loop 68: table_make(A,B,C,D,E,F,G,H,I,A,J,B,K,L) [H+2*D>=L+1,H+L>=3,L>=D,A+1>=B,K>=0,H>=2,G>=0,F>=0,D>=0,C>=0,B>=2,J=2,I=1,E=1] 
* Loop 69: table_make(A,B,C,D,E,F,G,H,I,A,J,B,K,L) [2*D>=L,C>=G,L>=D,A+1>=B,K>=0,G>=0,F>=0,B>=2,J=2,I=1,H=1,E=1] 

### Ranking functions of CR table_make(A,B,C,D,E,F,G,H,I,J,K,L,M,N) 
* RF of phase [66,67]: [E-1]

#### Partial ranking functions of CR table_make(A,B,C,D,E,F,G,H,I,J,K,L,M,N) 
* Partial RF of phase [66,67]:
  - RF of loop [66:1,66:2,67:1,67:2]:
    E-1

Discarded unfeasible chain [multiple([66,67],[[],[69],[68]])]...(Non-terminating chain proved terminating)
Remaining chain: [multiple([66,67],[[69],[68]])]

### Resulting Chains:table_make(A,B,C,D,E,F,G,H,I,J,K,L,M,N) 
* [69]
* [68]
* [multiple([66,67],[[69],[68]])]


### Merging Chains  table_make/14 into  External patterns of execution 
* [[69]] --> 1 
* [[68]] --> 2 
* [[multiple([66,67],[[69],[68]])]] --> 3 


Computing Bounds
=====================================

#### Simplifying cost structure of CE 29 

#### Computing cost of phase [27] 

#### Simplifying cost structure of CE 30 

#### Cost of loops [27] 

 * loop 27:assoc(A,B,C,D,E,F) -> [assoc(A',B',C',D',E',F')] 
5
##### Pending set assoc(A,B,C,D,E,F)
* Psum in Loop 27: [it(27)=<1]

###### Computing sum for it(27)=<1  in Loop 27 
   - Applying inductive sum strategy 
     - head Candidate: C-1 
     - head Candidate: D 
     - head Candidate: B 
     - head Candidate: -A+D 
     - head Candidate: B 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: D 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: -A+D 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
     - tail Candidate: D 
     - tail Candidate: B 
     - tail Candidate: -A+D 
     - tail Candidate: B 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: D 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: -A+D 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(27)=<C-1,it(27)=<D,it(27)=<B,it(27)=< -A+D,it(27)=<B,it(27)=<C-1,it(27)=<D,it(27)=< -A+D,it(27)=<C-C',it(27)=<D-D',it(27)=<B-B',it(27)=< -A+D+A'-D',it(27)=<B-B',it(27)=<C-C',it(27)=<D-D',it(27)=< -A+D+A'-D'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [27] 

#### Simplifying cost structure of phase [27] 

#### Cost of phase [27]:assoc(A,B,C,D,E,F) -> [assoc(A',B',C',D',E',F')] 
5*it(27)+0
  Such that:it(27) =< -A+D
it(27) =< -A+D+A'-D'
it(27) =< B
it(27) =< B-B'
it(27) =< C
it(27) =< C-C'
it(27) =< D
it(27) =< D-D'

#### Simplifying cost structure of chain [[27],28] 
 * Renamed intermediate variables: 
[ (ch([[27],28]),it(27))>>s(1)]

#### Cost of chains of assoc(A,B,C,D,E,F):
* Chain [[27],28]: 5*it(27)+4
  Such that:it(27) =< -2*A+D
it(27) =< C

  with precondition: [A>=0,B>=2,C>=3,F>=0,D>=2*A+1,E>=F] 

* Chain [28]: 4
  with precondition: [A>=0,B>=1,C>=2,F>=0,D>=A,E>=F] 


#### Simplifying cost structure of CE 31 

#### Computing cost of phase [29] 

#### Simplifying cost structure of CE 32 

#### Cost of loops [29] 

 * loop 29:concat(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X) -> [concat(A',B',C',D',E',F',G',H',I',J',K',L',M',N',O',P',Q',R',S',T',U',V',W',X')] 
5
##### Pending set concat(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X)
* Psum in Loop 29: [it(29)=<1]

###### Computing sum for it(29)=<1  in Loop 29 
   - Applying inductive sum strategy 
     - head Candidate: G-1 
     - head Candidate: H+1 
     - head Candidate: C-1 
     - head Candidate: A+1 
     - head Candidate: A+1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: G-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: H+1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: G-1 
     - tail Candidate: H+1 
     - tail Candidate: C-1 
     - tail Candidate: A+1 
     - tail Candidate: A+1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: G-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: H+1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(29)=<G-1,it(29)=<H+1,it(29)=<C-1,it(29)=<A+1,it(29)=<A+1,it(29)=<C-1,it(29)=<G-1,it(29)=<H+1,it(29)=<G-G',it(29)=<H-H',it(29)=<C-C',it(29)=<A-A',it(29)=<A-A',it(29)=<C-C',it(29)=<G-G',it(29)=<H-H'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [29] 

#### Simplifying cost structure of phase [29] 

#### Cost of phase [29]:concat(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X) -> [concat(A',B',C',D',E',F',G',H',I',J',K',L',M',N',O',P',Q',R',S',T',U',V',W',X')] 
5*it(29)+0
  Such that:it(29) =< A+1
it(29) =< A-A'
it(29) =< C
it(29) =< C-C'
it(29) =< G
it(29) =< G-G'
it(29) =< H+1
it(29) =< H-H'

#### Simplifying cost structure of chain [[29],30] 

#### Cost of chains of concat(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X):
* Chain [[29],30]: 5*it(29)+2
  Such that:it(29) =< -O+W

  with precondition: [C=G,Q=A+I,R=B+J,T=D+L,V=F+N,X=H+P,C+K=S+1,C+O=W+1,B>=0,C>=2,D>=0,E>=0,F>=0,K>=1,M>=0,O>=1,U>=0,Q>=A,R>=B,A+1>=C,H+1>=C,T>=D,V>=F,X>=H,E+M>=U] 

* Chain [30]: 2
  with precondition: [A=0,B=0,C=1,D=0,F=0,G=1,H=0,I=Q,J=R,K=S,L=T,M=U,N=V,O=W,P=X,E>=0,I>=0,J>=0,K>=0,L>=0,M>=0,N>=0,O>=0,P>=0] 


#### Simplifying cost structure of CE 34 

#### Simplifying cost structure of CE 33 

#### Cost of chains of and_op(A,B,C):
* Chain [32]: 0
  with precondition: [A=0,C=0,B>=0] 

* Chain [31]: 0
  with precondition: [A=1,C=B,C>=0] 


#### Simplifying cost structure of CE 36 

#### Simplifying cost structure of CE 35 

#### Cost of chains of neg(A,B):
* Chain [34]: 0
  with precondition: [A=0,B=1] 

* Chain [33]: 0
  with precondition: [A=1,B=0] 


#### Simplifying cost structure of CE 38 

#### Simplifying cost structure of CE 37 

#### Cost of chains of or(A,B,C):
* Chain [36]: 0
  with precondition: [A=0,C=B,C>=0] 

* Chain [35]: 0
  with precondition: [A=1,C=1,B>=0] 

 * Renamed intermediate variables: 
[ (eq(39,1),s(1))>>s(2)]

#### Simplifying cost structure of CE 39 

#### Computing cost of chain [multiple([37,38,39,40,41,42],[[43]])] with multiple recursion

#### Simplifying cost structure of CE 45 

#### Simplifying cost structure of CE 42 

#### Simplifying cost structure of CE 43 

#### Simplifying cost structure of CE 44 

#### Simplifying cost structure of CE 40 

#### Simplifying cost structure of CE 41 

#### Cost of loops [37,38,39,40,41,42] 

 * loop 37:eval(A,B,C,D,E,F,G) -> [eval(A',B',C',D',E',F',G'),eval(A'2,B'2,C'2,D'2,E'2,F'2,G'2)] 
7
 * loop 38:eval(A,B,C,D,E,F,G) -> [eval(A',B',C',D',E',F',G'),eval(A'2,B'2,C'2,D'2,E'2,F'2,G'2)] 
8
 * loop 39:eval(A,B,C,D,E,F,G) -> [eval(A',B',C',D',E',F',G'),eval(A'2,B'2,C'2,D'2,E'2,F'2,G'2)] 
8
 * loop 40:eval(A,B,C,D,E,F,G) -> [eval(A',B',C',D',E',F',G'),eval(A'2,B'2,C'2,D'2,E'2,F'2,G'2)] 
7
 * loop 41:eval(A,B,C,D,E,F,G) -> [eval(A',B',C',D',E',F',G')] 
5
 * loop 42:eval(A,B,C,D,E,F,G) -> [eval(A',B',C',D',E',F',G')] 
5
##### Pending set eval(A,B,C,D,E,F,G)
* Psum in Loop 37: [it(37)=<1]
* Psum in Loop 38: [it(38)=<1]
* Psum in Loop 39: [it(39)=<1]
* Psum in Loop 40: [it(40)=<1]
* Psum in Loop 41: [it(41)=<1]
* Psum in Loop 42: [it(42)=<1]
* Psum in Chain-Tail [43]: [it([43])=<1,s(3)=<B,s(3)=<C-2*E]

###### Computing sum for it(37)=<1  in Loop 37 
   - Applying inductive sum strategy 
     - head Candidate: F/2-1/2 
       - Loop 38 is collaborative and bounds [it(38)] 
       - Loop 39 is collaborative and bounds [it(39)] 
       - Loop 40 is collaborative and bounds [it(40)] 
       - Loop 41 is collaborative
       - Loop 42 is collaborative
       - Chain-Tail [43] is collaborative
     - tail Candidate: F/2-1/2 
       - Loop 38 is collaborative and bounds [it(38)] 
       - Loop 39 is collaborative and bounds [it(39)] 
       - Loop 40 is collaborative and bounds [it(40)] 
       - Loop 41 is collaborative
       - Loop 42 is collaborative
       - Chain-Tail [43] is collaborative
 * Adding constraints: [it(37)+it(38)+it(39)+it(40)=<F/2-1/2,it(37)+it(38)+it(39)+it(40)=<F/2-1/2] 

##### Pending set A
* Psum in Loop 38: [it(38)=<1]
* Psum in Loop 39: [it(39)=<1]
* Psum in Loop 40: [it(40)=<1]
* Psum in Loop 41: [it(41)=<1]
* Psum in Loop 42: [it(42)=<1]
* Psum in Chain-Tail [43]: [it([43])=<1,s(3)=<B,s(3)=<C-2*E]

###### Computing sum for it(38)=<1  in Loop 38 
   - Applying inductive sum strategy 
     - head Candidate: F/2-1/2 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: F/2-1/2 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(37)+it(38)+it(39)+it(40)=<F/2-1/2,it(37)+it(38)+it(39)+it(40)=<F/2-1/2] 

##### Pending set A
* Psum in Loop 39: [it(39)=<1]
* Psum in Loop 40: [it(40)=<1]
* Psum in Loop 41: [it(41)=<1]
* Psum in Loop 42: [it(42)=<1]
* Psum in Chain-Tail [43]: [it([43])=<1,s(3)=<B,s(3)=<C-2*E]

###### Computing sum for it(39)=<1  in Loop 39 
   - Applying inductive sum strategy 
     - head Candidate: F/2-1/2 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: F/2-1/2 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(37)+it(38)+it(39)+it(40)=<F/2-1/2,it(37)+it(38)+it(39)+it(40)=<F/2-1/2] 

##### Pending set A
* Psum in Loop 40: [it(40)=<1]
* Psum in Loop 41: [it(41)=<1]
* Psum in Loop 42: [it(42)=<1]
* Psum in Chain-Tail [43]: [it([43])=<1,s(3)=<B,s(3)=<C-2*E]

###### Computing sum for it(40)=<1  in Loop 40 
   - Applying inductive sum strategy 
     - head Candidate: F/2-1/2 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: F/2-1/2 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(37)+it(38)+it(39)+it(40)=<F/2-1/2,it(37)+it(38)+it(39)+it(40)=<F/2-1/2] 

##### Pending set A
* Psum in Loop 41: [it(41)=<1]
* Psum in Loop 42: [it(42)=<1]
* Psum in Chain-Tail [43]: [it([43])=<1,s(3)=<B,s(3)=<C-2*E]

###### Computing sum for it(41)=<1  in Loop 41 
   - Applying inductive sum strategy 
     - head Candidate: F-1 
       - Loop 37 is collaborative
       - Loop 38 is collaborative
       - Loop 39 is collaborative
       - Loop 40 is collaborative
       - Loop 42 is collaborative and bounds [it(42)] 
       - Chain-Tail [43] is collaborative
     - head Candidate: F-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: F-1 
       - Loop 37 is collaborative
       - Loop 38 is collaborative
       - Loop 39 is collaborative
       - Loop 40 is collaborative
       - Loop 42 is collaborative and bounds [it(42)] 
       - Chain-Tail [43] is collaborative
     - tail Candidate: F-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(41)+it(42)=<F-1,it(41)+it(42)=<F-1,it(41)+it(42)=<F-1,it(41)+it(42)=<F-1] 

##### Pending set A
* Psum in Loop 42: [it(42)=<1]
* Psum in Chain-Tail [43]: [it([43])=<1,s(3)=<B,s(3)=<C-2*E]

###### Computing sum for it(42)=<1  in Loop 42 
   - Applying inductive sum strategy 
     - head Candidate: F-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: F-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: F-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: F-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(41)+it(42)=<F-1,it(41)+it(42)=<F-1,it(41)+it(42)=<F-1,it(41)+it(42)=<F-1] 

##### Pending set A
* Psum in Chain-Tail [43]: [it([43])=<1,s(3)=<B,s(3)=<C-2*E]

###### Computing sum for it([43])=<1  in Chain-Tail [43] 
   - Applying inductive sum strategy 
     - head Candidate: F/2+1/2 
       - Loop 37 is collaborative
       - Loop 38 is collaborative
       - Loop 39 is collaborative
       - Loop 40 is collaborative
       - Loop 41 is collaborative
       - Loop 42 is collaborative
     - tail Candidate: F/2+1/2 
       - Loop 37 is collaborative
       - Loop 38 is collaborative
       - Loop 39 is collaborative
       - Loop 40 is collaborative
       - Loop 41 is collaborative
       - Loop 42 is collaborative
 * Adding constraints: [it([43])=<F/2+1/2,it([43])=<F/2+1/2] 

##### Pending set A
* Psum in Chain-Tail [43]: [s(3)=<B,s(3)=<C-2*E]

###### Computing sum for s(3)=<B  in Chain-Tail [43] 
   - Applying inductive sum strategy 
     - head Candidate: B 
       - Loop 37 has a reset to  [2*B]
       - Loop 38 has a reset to  [2*B]
       - Loop 39 has a reset to  [2*B]
       - Loop 40 has a reset to  [2*B]
       - Loop 41 is collaborative
       - Loop 42 is collaborative
     - tail Candidate: B 
       - Loop 37 has undefined behavior 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(6)=<B] 
 * Adding constraints: [s(3)=<it([43])*aux(6),s(3)=<aux(4)+aux(3)+aux(2)+aux(1)+aux(5),aux(5)=<B] 

##### Pending set eval(A,B,C,D,E,F,G)
* Pmax/min: [aux(6)=<B]
* Psum in Loop 37: [aux(1)=<2*B]
* Psum in Loop 38: [aux(2)=<2*B]
* Psum in Loop 39: [aux(3)=<2*B]
* Psum in Loop 40: [aux(4)=<2*B]
* Psum in Chain-Tail [43]: [s(3)=<C-2*E]

###### Computing max_min for aux(6)=<B  
   - Found a solution using transitive invariants 
 * Adding constraints:[aux(6)=<B] 

##### Pending set eval(A,B,C,D,E,F,G)
* Psum in Loop 37: [aux(1)=<2*B]
* Psum in Loop 38: [aux(2)=<2*B]
* Psum in Loop 39: [aux(3)=<2*B]
* Psum in Loop 40: [aux(4)=<2*B]
* Psum in Chain-Tail [43]: [s(3)=<C-2*E]

###### Computing sum for aux(1)=<2*B  in Loop 37 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(7)=<2*B] 
 * Adding constraints: [aux(1)=<it(37)*aux(7)] 

##### Pending set eval(A,B,C,D,E,F,G)
* Pmax/min: [aux(7)=<2*B]
* Psum in Loop 38: [aux(2)=<2*B]
* Psum in Loop 39: [aux(3)=<2*B]
* Psum in Loop 40: [aux(4)=<2*B]
* Psum in Chain-Tail [43]: [s(3)=<C-2*E]

###### Computing max_min for aux(7)=<2*B  
   - Found a solution using cacheing 
 * Adding constraints:[aux(7)=<aux(6)*2] 

##### Pending set eval(A,B,C,D,E,F,G)
* Psum in Loop 38: [aux(2)=<2*B]
* Psum in Loop 39: [aux(3)=<2*B]
* Psum in Loop 40: [aux(4)=<2*B]
* Psum in Chain-Tail [43]: [s(3)=<C-2*E]

###### Computing sum for aux(2)=<2*B  in Loop 38 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(8)=<2*B] 
 * Adding constraints: [aux(2)=<it(38)*aux(8)] 

##### Pending set eval(A,B,C,D,E,F,G)
* Pmax/min: [aux(8)=<2*B]
* Psum in Loop 39: [aux(3)=<2*B]
* Psum in Loop 40: [aux(4)=<2*B]
* Psum in Chain-Tail [43]: [s(3)=<C-2*E]

###### Computing max_min for aux(8)=<2*B  
   - Found a solution using cacheing 
 * Adding constraints:[aux(8)=<aux(6)*2] 

##### Pending set eval(A,B,C,D,E,F,G)
* Psum in Loop 39: [aux(3)=<2*B]
* Psum in Loop 40: [aux(4)=<2*B]
* Psum in Chain-Tail [43]: [s(3)=<C-2*E]

###### Computing sum for aux(3)=<2*B  in Loop 39 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(9)=<2*B] 
 * Adding constraints: [aux(3)=<it(39)*aux(9)] 

##### Pending set eval(A,B,C,D,E,F,G)
* Pmax/min: [aux(9)=<2*B]
* Psum in Loop 40: [aux(4)=<2*B]
* Psum in Chain-Tail [43]: [s(3)=<C-2*E]

###### Computing max_min for aux(9)=<2*B  
   - Found a solution using cacheing 
 * Adding constraints:[aux(9)=<aux(6)*2] 

##### Pending set eval(A,B,C,D,E,F,G)
* Psum in Loop 40: [aux(4)=<2*B]
* Psum in Chain-Tail [43]: [s(3)=<C-2*E]

###### Computing sum for aux(4)=<2*B  in Loop 40 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(10)=<2*B] 
 * Adding constraints: [aux(4)=<it(40)*aux(10)] 

##### Pending set eval(A,B,C,D,E,F,G)
* Pmax/min: [aux(10)=<2*B]
* Psum in Chain-Tail [43]: [s(3)=<C-2*E]

###### Computing max_min for aux(10)=<2*B  
   - Found a solution using cacheing 
 * Adding constraints:[aux(10)=<aux(6)*2] 

##### Pending set eval(A,B,C,D,E,F,G)
* Psum in Chain-Tail [43]: [s(3)=<C-2*E]

###### Computing sum for s(3)=<C-2*E  in Chain-Tail [43] 
   - Applying inductive sum strategy 
     - head Candidate: C-E 
       - Loop 37 has a reset to  [2*C-E]
       - Loop 38 has a reset to  [2*C-E]
       - Loop 39 has a reset to  [2*C-E]
       - Loop 40 has a reset to  [2*C-E]
       - Loop 41 is collaborative
       - Loop 42 is collaborative
     - tail Candidate: C-E 
       - Loop 37 has undefined behavior 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(16)=<C-2*E] 
 * Adding constraints: [s(3)=<it([43])*aux(16),s(3)=<aux(14)+aux(13)+aux(12)+aux(11)+aux(15),aux(15)=<C-E] 

##### Pending set eval(A,B,C,D,E,F,G)
* Pmax/min: [aux(16)=<C-2*E]
* Psum in Loop 37: [aux(11)=<2*C-E]
* Psum in Loop 38: [aux(12)=<2*C-E]
* Psum in Loop 39: [aux(13)=<2*C-E]
* Psum in Loop 40: [aux(14)=<2*C-E]

###### Computing max_min for aux(16)=<C-2*E  
   - Found a solution using transitive invariants 
 * Adding constraints:[aux(16)=<C] 

##### Pending set eval(A,B,C,D,E,F,G)
* Psum in Loop 37: [aux(11)=<2*C-E]
* Psum in Loop 38: [aux(12)=<2*C-E]
* Psum in Loop 39: [aux(13)=<2*C-E]
* Psum in Loop 40: [aux(14)=<2*C-E]

###### Computing sum for aux(11)=<2*C-E  in Loop 37 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(17)=<2*C-E] 
 * Adding constraints: [aux(11)=<it(37)*aux(17)] 

##### Pending set eval(A,B,C,D,E,F,G)
* Pmax/min: [aux(17)=<2*C-E]
* Psum in Loop 38: [aux(12)=<2*C-E]
* Psum in Loop 39: [aux(13)=<2*C-E]
* Psum in Loop 40: [aux(14)=<2*C-E]

###### Computing max_min for aux(17)=<2*C-E  
   - Found a solution using transitive invariants 
 * Adding constraints:[aux(17)=<2*C] 

##### Pending set eval(A,B,C,D,E,F,G)
* Psum in Loop 38: [aux(12)=<2*C-E]
* Psum in Loop 39: [aux(13)=<2*C-E]
* Psum in Loop 40: [aux(14)=<2*C-E]

###### Computing sum for aux(12)=<2*C-E  in Loop 38 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(18)=<2*C-E] 
 * Adding constraints: [aux(12)=<it(38)*aux(18)] 

##### Pending set eval(A,B,C,D,E,F,G)
* Pmax/min: [aux(18)=<2*C-E]
* Psum in Loop 39: [aux(13)=<2*C-E]
* Psum in Loop 40: [aux(14)=<2*C-E]

###### Computing max_min for aux(18)=<2*C-E  
   - Found a solution using cacheing 
 * Adding constraints:[aux(18)=<aux(17)] 

##### Pending set eval(A,B,C,D,E,F,G)
* Psum in Loop 39: [aux(13)=<2*C-E]
* Psum in Loop 40: [aux(14)=<2*C-E]

###### Computing sum for aux(13)=<2*C-E  in Loop 39 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(19)=<2*C-E] 
 * Adding constraints: [aux(13)=<it(39)*aux(19)] 

##### Pending set eval(A,B,C,D,E,F,G)
* Pmax/min: [aux(19)=<2*C-E]
* Psum in Loop 40: [aux(14)=<2*C-E]

###### Computing max_min for aux(19)=<2*C-E  
   - Found a solution using cacheing 
 * Adding constraints:[aux(19)=<aux(17)] 

##### Pending set eval(A,B,C,D,E,F,G)
* Psum in Loop 40: [aux(14)=<2*C-E]

###### Computing sum for aux(14)=<2*C-E  in Loop 40 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(20)=<2*C-E] 
 * Adding constraints: [aux(14)=<it(40)*aux(20)] 

##### Pending set eval(A,B,C,D,E,F,G)
* Pmax/min: [aux(20)=<2*C-E]

###### Computing max_min for aux(20)=<2*C-E  
   - Found a solution using cacheing 
 * Adding constraints:[aux(20)=<aux(17)] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [37,38,39,40,41,42,[43]] 

#### Simplifying cost structure of phase [37,38,39,40,41,42,[43]] 
 * Joined equivalent variables [aux(21),aux(5),aux(6)] into aux(21)
 * Joined equivalent variables [aux(18),aux(19),aux(20)] into aux(18)
 * Joined equivalent variables [aux(7),aux(8),aux(9),aux(10)] into aux(7)
 * Joined equivalent variables [it(41),it(42)] into it(41)
 * Joined equivalent variables [it(37),it(38),it(39),it(40)] into it(37)
 * Joined equivalent variables [aux(1),aux(2),aux(3),aux(4)] into aux(1)
 * Joined equivalent variables [aux(12),aux(13),aux(14)] into aux(12)

#### Cost of phase [37,38,39,40,41,42]:eval(A,B,C,D,E,F,G) -> [] 
30*it(37)+10*it(41)+7*it([43])+5*s(3)+0
  Such that:aux(16) =< C
aux(15) =< C-E
aux(17) =< 2*C
it([43]) =< F/2+1/2
aux(21) =< B
aux(22) =< F
aux(23) =< F/2
it(41) =< aux(22)
it(37) =< aux(23)
aux(18) =< aux(17)
aux(7) =< aux(21)*2
aux(11) =< it(37)*aux(17)
s(3) =< it([43])*aux(16)
s(3) =< it([43])*aux(21)
aux(12) =< it(37)*aux(18)
aux(1) =< it(37)*aux(7)
s(3) =< aux(12)+aux(12)+aux(12)+aux(11)+aux(15)
s(3) =< aux(1)+aux(1)+aux(1)+aux(1)+aux(21)

#### Cost of chains of eval(A,B,C,D,E,F,G):
* Chain [43]: 5*s(2)+7
  Such that:s(2) =< B
s(2) =< C-2*E

  with precondition: [F=1,A>=1,B>=2,E>=0,G>=0,C>=E,D>=G] 

* Chain [multiple([37,38,39,40,41,42],[[43]])]: 30*it(37)+10*it(41)+7*it([43])+5*s(3)+0
  Such that:aux(16) =< C
aux(15) =< C-E
aux(17) =< 2*C
it([43]) =< F/2+1/2
aux(21) =< B
aux(22) =< F
aux(23) =< F/2
it(41) =< aux(22)
it(37) =< aux(23)
aux(18) =< aux(17)
aux(7) =< aux(21)*2
aux(11) =< it(37)*aux(17)
s(3) =< it([43])*aux(16)
s(3) =< it([43])*aux(21)
aux(12) =< it(37)*aux(18)
aux(1) =< it(37)*aux(7)
s(3) =< aux(12)+aux(12)+aux(12)+aux(11)+aux(15)
s(3) =< aux(1)+aux(1)+aux(1)+aux(1)+aux(21)

  with precondition: [A>=1,B>=2,C>=0,D>=0,E>=0,F>=2,G>=0,D+F>=G+1,D+F+G>=3] 


#### Simplifying cost structure of CE 47 

#### Simplifying cost structure of CE 46 

#### Cost of chains of case_2(A,B,C,D,E,F,G,H):
* Chain [45]: 2
  with precondition: [F=1,H=0,G=E,A>=0,B>=0,C>=0,D>=0,G>=A+1,G>=C+1] 

* Chain [44]: 1
  with precondition: [F=1,E=C,E=G,D=H,A>=0,B>=0,D>=0,E>=A+1] 


#### Simplifying cost structure of CE 48 

#### Simplifying cost structure of CE 50 

#### Simplifying cost structure of CE 49 

#### Cost of chains of case_1(A,B,C,D,E,F,G,H):
* Chain [48]: 4
  with precondition: [F=1,H=0,G=E,A>=0,B>=0,C>=0,D>=0,G>=A+1,G>=C+1] 

* Chain [47]: 1
  with precondition: [F=1,E=A,E=G,B=H,B>=0,C>=0,D>=0,E>=0] 

* Chain [46]: 3
  with precondition: [F=1,E=C,E=G,D=H,A>=0,B>=0,D>=0,E>=A+1] 


#### Simplifying cost structure of CE 51 

#### Simplifying cost structure of CE 52 

#### Simplifying cost structure of CE 53 

#### Computing cost of chain [multiple([49,50,51,52,53,54],[[57],[56],[55]])] with multiple recursion

#### Simplifying cost structure of CE 59 

#### Simplifying cost structure of CE 56 

#### Simplifying cost structure of CE 57 

#### Simplifying cost structure of CE 58 

#### Simplifying cost structure of CE 54 

#### Simplifying cost structure of CE 55 

#### Cost of loops [49,50,51,52,53,54] 

 * loop 49:eval2(A,B,C,D,E,F,G) -> [eval2(A',B',C',D',E',F',G'),eval2(A'2,B'2,C'2,D'2,E'2,F'2,G'2)] 
7
 * loop 50:eval2(A,B,C,D,E,F,G) -> [eval2(A',B',C',D',E',F',G'),eval2(A'2,B'2,C'2,D'2,E'2,F'2,G'2)] 
8
 * loop 51:eval2(A,B,C,D,E,F,G) -> [eval2(A',B',C',D',E',F',G'),eval2(A'2,B'2,C'2,D'2,E'2,F'2,G'2)] 
8
 * loop 52:eval2(A,B,C,D,E,F,G) -> [eval2(A',B',C',D',E',F',G'),eval2(A'2,B'2,C'2,D'2,E'2,F'2,G'2)] 
7
 * loop 53:eval2(A,B,C,D,E,F,G) -> [eval2(A',B',C',D',E',F',G')] 
5
 * loop 54:eval2(A,B,C,D,E,F,G) -> [eval2(A',B',C',D',E',F',G')] 
5
##### Pending set eval2(A,B,C,D,E,F,G)
* Psum in Loop 49: [it(49)=<1]
* Psum in Loop 50: [it(50)=<1]
* Psum in Loop 51: [it(51)=<1]
* Psum in Loop 52: [it(52)=<1]
* Psum in Loop 53: [it(53)=<1]
* Psum in Loop 54: [it(54)=<1]
* Psum in Chain-Tail [55]: [it([55])=<1]
* Psum in Chain-Tail [56]: [it([56])=<1]
* Psum in Chain-Tail [57]: [it([57])=<1]

###### Computing sum for it(49)=<1  in Loop 49 
   - Applying inductive sum strategy 
     - head Candidate: F/2-1/2 
       - Loop 50 is collaborative and bounds [it(50)] 
       - Loop 51 is collaborative and bounds [it(51)] 
       - Loop 52 is collaborative and bounds [it(52)] 
       - Loop 53 is collaborative
       - Loop 54 is collaborative
       - Chain-Tail [57] is collaborative
       - Chain-Tail [56] is collaborative
       - Chain-Tail [55] is collaborative
     - tail Candidate: F/2-1/2 
       - Loop 50 is collaborative and bounds [it(50)] 
       - Loop 51 is collaborative and bounds [it(51)] 
       - Loop 52 is collaborative and bounds [it(52)] 
       - Loop 53 is collaborative
       - Loop 54 is collaborative
       - Chain-Tail [57] is collaborative
       - Chain-Tail [56] is collaborative
       - Chain-Tail [55] is collaborative
 * Adding constraints: [it(49)+it(50)+it(51)+it(52)=<F/2-1/2,it(49)+it(50)+it(51)+it(52)=<F/2-1/2] 

##### Pending set A
* Psum in Loop 50: [it(50)=<1]
* Psum in Loop 51: [it(51)=<1]
* Psum in Loop 52: [it(52)=<1]
* Psum in Loop 53: [it(53)=<1]
* Psum in Loop 54: [it(54)=<1]
* Psum in Chain-Tail [55]: [it([55])=<1]
* Psum in Chain-Tail [56]: [it([56])=<1]
* Psum in Chain-Tail [57]: [it([57])=<1]

###### Computing sum for it(50)=<1  in Loop 50 
   - Applying inductive sum strategy 
     - head Candidate: F/2-1/2 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: F/2-1/2 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(49)+it(50)+it(51)+it(52)=<F/2-1/2,it(49)+it(50)+it(51)+it(52)=<F/2-1/2] 

##### Pending set A
* Psum in Loop 51: [it(51)=<1]
* Psum in Loop 52: [it(52)=<1]
* Psum in Loop 53: [it(53)=<1]
* Psum in Loop 54: [it(54)=<1]
* Psum in Chain-Tail [55]: [it([55])=<1]
* Psum in Chain-Tail [56]: [it([56])=<1]
* Psum in Chain-Tail [57]: [it([57])=<1]

###### Computing sum for it(51)=<1  in Loop 51 
   - Applying inductive sum strategy 
     - head Candidate: F/2-1/2 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: F/2-1/2 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(49)+it(50)+it(51)+it(52)=<F/2-1/2,it(49)+it(50)+it(51)+it(52)=<F/2-1/2] 

##### Pending set A
* Psum in Loop 52: [it(52)=<1]
* Psum in Loop 53: [it(53)=<1]
* Psum in Loop 54: [it(54)=<1]
* Psum in Chain-Tail [55]: [it([55])=<1]
* Psum in Chain-Tail [56]: [it([56])=<1]
* Psum in Chain-Tail [57]: [it([57])=<1]

###### Computing sum for it(52)=<1  in Loop 52 
   - Applying inductive sum strategy 
     - head Candidate: F/2-1/2 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: F/2-1/2 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(49)+it(50)+it(51)+it(52)=<F/2-1/2,it(49)+it(50)+it(51)+it(52)=<F/2-1/2] 

##### Pending set A
* Psum in Loop 53: [it(53)=<1]
* Psum in Loop 54: [it(54)=<1]
* Psum in Chain-Tail [55]: [it([55])=<1]
* Psum in Chain-Tail [56]: [it([56])=<1]
* Psum in Chain-Tail [57]: [it([57])=<1]

###### Computing sum for it(53)=<1  in Loop 53 
   - Applying inductive sum strategy 
     - head Candidate: F-1 
       - Loop 49 is collaborative
       - Loop 50 is collaborative
       - Loop 51 is collaborative
       - Loop 52 is collaborative
       - Loop 54 is collaborative and bounds [it(54)] 
       - Chain-Tail [57] is collaborative
       - Chain-Tail [56] is collaborative
       - Chain-Tail [55] is collaborative
     - head Candidate: F-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: F-1 
       - Loop 49 is collaborative
       - Loop 50 is collaborative
       - Loop 51 is collaborative
       - Loop 52 is collaborative
       - Loop 54 is collaborative and bounds [it(54)] 
       - Chain-Tail [57] is collaborative
       - Chain-Tail [56] is collaborative
       - Chain-Tail [55] is collaborative
     - tail Candidate: F-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(53)+it(54)=<F-1,it(53)+it(54)=<F-1,it(53)+it(54)=<F-1,it(53)+it(54)=<F-1] 

##### Pending set A
* Psum in Loop 54: [it(54)=<1]
* Psum in Chain-Tail [55]: [it([55])=<1]
* Psum in Chain-Tail [56]: [it([56])=<1]
* Psum in Chain-Tail [57]: [it([57])=<1]

###### Computing sum for it(54)=<1  in Loop 54 
   - Applying inductive sum strategy 
     - head Candidate: F-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: F-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: F-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: F-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(53)+it(54)=<F-1,it(53)+it(54)=<F-1,it(53)+it(54)=<F-1,it(53)+it(54)=<F-1] 

##### Pending set A
* Psum in Chain-Tail [55]: [it([55])=<1]
* Psum in Chain-Tail [56]: [it([56])=<1]
* Psum in Chain-Tail [57]: [it([57])=<1]

###### Computing sum for it([55])=<1  in Chain-Tail [55] 
   - Applying inductive sum strategy 
     - head Candidate: -A+E 
       - Loop 49 is collaborative
       - Loop 50 is collaborative
       - Loop 51 is collaborative
       - Loop 52 is collaborative
       - Loop 53 is collaborative
       - Loop 54 is collaborative
       - Chain-Tail [57] is collaborative and bounds [it([57])] 
       - Chain-Tail [56] is collaborative
     - head Candidate: E 
       - Loop 49 is collaborative
       - Loop 50 is collaborative
       - Loop 51 is collaborative
       - Loop 52 is collaborative
       - Loop 53 is collaborative
       - Loop 54 is collaborative
       - Chain-Tail [57] is collaborative and bounds [it([57])] 
       - Chain-Tail [56] is collaborative
     - tail Candidate: -A+E 
       - Loop 49 is collaborative
       - Loop 50 is collaborative
       - Loop 51 is collaborative
       - Loop 52 is collaborative
       - Loop 53 is collaborative
       - Loop 54 is collaborative
       - Chain-Tail [57] is collaborative and bounds [it([57])] 
       - Chain-Tail [56] is collaborative
     - tail Candidate: E 
       - Loop 49 is collaborative
       - Loop 50 is collaborative
       - Loop 51 is collaborative
       - Loop 52 is collaborative
       - Loop 53 is collaborative
       - Loop 54 is collaborative
       - Chain-Tail [57] is collaborative and bounds [it([57])] 
       - Chain-Tail [56] is collaborative
 * Adding constraints: [it([55])+it([57])=< -A+E,it([55])+it([57])=<E,it([55])+it([57])=< -A+E,it([55])+it([57])=<E] 

##### Pending set A
* Psum in Chain-Tail [56]: [it([56])=<1]
* Psum in Chain-Tail [57]: [it([57])=<1]

###### Computing sum for it([56])=<1  in Chain-Tail [56] 
   - Applying inductive sum strategy 
     - head Candidate: F/2+1/2 
       - Loop 49 is collaborative
       - Loop 50 is collaborative
       - Loop 51 is collaborative
       - Loop 52 is collaborative
       - Loop 53 is collaborative
       - Loop 54 is collaborative
       - Chain-Tail [57] is collaborative and bounds [it([57])] 
       - Chain-Tail [55] is collaborative
     - tail Candidate: F/2+1/2 
       - Loop 49 is collaborative
       - Loop 50 is collaborative
       - Loop 51 is collaborative
       - Loop 52 is collaborative
       - Loop 53 is collaborative
       - Loop 54 is collaborative
       - Chain-Tail [57] is collaborative and bounds [it([57])] 
       - Chain-Tail [55] is collaborative
 * Adding constraints: [it([56])+it([57])=<F/2+1/2,it([56])+it([57])=<F/2+1/2] 

##### Pending set A
* Psum in Chain-Tail [57]: [it([57])=<1]

###### Computing sum for it([57])=<1  in Chain-Tail [57] 
   - Applying inductive sum strategy 
     - head Candidate: E 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: E 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: E 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: E 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it([55])+it([57])=<E,it([55])+it([57])=<E,it([55])+it([57])=<E,it([55])+it([57])=<E] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [49,50,51,52,53,54,[57],[56],[55]] 

#### Simplifying cost structure of phase [49,50,51,52,53,54,[57],[56],[55]] 
 * Joined equivalent variables [it(53),it(54)] into it(53)
 * Joined equivalent variables [it(49),it(50),it(51),it(52)] into it(49)

#### Cost of phase [49,50,51,52,53,54]:eval2(A,B,C,D,E,F,G) -> [] 
30*it(49)+10*it(53)+6*it([55])+4*it([56])+7*it([57])+0
  Such that:aux(24) =< -A+E
aux(25) =< E
aux(26) =< F
aux(27) =< F/2
aux(28) =< F/2+1/2
it([55]) =< aux(24)
it([57]) =< aux(24)
it([55]) =< aux(25)
it([57]) =< aux(25)
it(53) =< aux(26)
it(49) =< aux(27)
it([56]) =< aux(28)
it([57]) =< aux(28)

#### Cost of chains of eval2(A,B,C,D,E,F,G):
* Chain [57]: 7
  with precondition: [F=1,G=0,A>=0,B>=0,C>=0,D>=0,E>=A+1,E>=C+1] 

* Chain [56]: 4
  with precondition: [F=1,A=E,B=G,A>=0,B>=0,C>=0,D>=0] 

* Chain [55]: 6
  with precondition: [F=1,C=E,D=G,A>=0,B>=0,D>=0,C>=A+1] 

* Chain [multiple([49,50,51,52,53,54],[[57],[56],[55]])]: 30*it(49)+10*it(53)+6*it([55])+4*it([56])+7*it([57])+0
  Such that:aux(24) =< -A+E
aux(25) =< E
aux(26) =< F
aux(27) =< F/2
aux(28) =< F/2+1/2
it([55]) =< aux(24)
it([57]) =< aux(24)
it([55]) =< aux(25)
it([57]) =< aux(25)
it(53) =< aux(26)
it(49) =< aux(27)
it([56]) =< aux(28)
it([57]) =< aux(28)

  with precondition: [A>=0,B>=0,C>=0,D>=0,F>=2,G>=0,E>=A,B+D+F>=G+1,B+D+F+G>=3] 


#### Simplifying cost structure of CE 60 

#### Computing cost of phase [58] 

#### Simplifying cost structure of CE 61 

#### Cost of loops [58] 

 * loop 58:aux_rev(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R) -> [aux_rev(A',B',C',D',E',F',G',H',I',J',K',L',M',N',O',P',Q',R')] 
5
##### Pending set aux_rev(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R)
* Psum in Loop 58: [it(58)=<1]

###### Computing sum for it(58)=<1  in Loop 58 
   - Applying inductive sum strategy 
     - head Candidate: G+1 
     - head Candidate: L+1 
     - head Candidate: H-1 
     - head Candidate: -B+F+L+2 
     - head Candidate: A-B+G+2 
     - head Candidate: K-1 
     - head Candidate: A-E+G+2 
     - head Candidate: -E+F+L+2 
     - head Candidate: G+1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: H-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: K-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: L+1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: -B+F+L+2 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: -E+F+L+2 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A-B+G+2 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A-E+G+2 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: G+1 
     - tail Candidate: L+1 
     - tail Candidate: H-1 
     - tail Candidate: -B+F+L+2 
     - tail Candidate: A-B+G+2 
     - tail Candidate: K-1 
     - tail Candidate: A-E+G+2 
     - tail Candidate: -E+F+L+2 
     - tail Candidate: G+1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: H-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: K-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: L+1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: -B+F+L+2 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: -E+F+L+2 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-B+G+2 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-E+G+2 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(58)=<G+1,it(58)=<L+1,it(58)=<H-1,it(58)=< -B+F+L+2,it(58)=<A-B+G+2,it(58)=<K-1,it(58)=<A-E+G+2,it(58)=< -E+F+L+2,it(58)=<G+1,it(58)=<H-1,it(58)=<K-1,it(58)=<L+1,it(58)=< -B+F+L+2,it(58)=< -E+F+L+2,it(58)=<A-B+G+2,it(58)=<A-E+G+2,it(58)=<G-G',it(58)=<L-L',it(58)=<H-H',it(58)=< -B+F+L+B'-F'-L',it(58)=<A-B+G-A'+B'-G',it(58)=<K-K',it(58)=<A-E+G-A'+E'-G',it(58)=< -E+F+L+E'-F'-L',it(58)=<G-G',it(58)=<H-H',it(58)=<K-K',it(58)=<L-L',it(58)=< -B+F+L+B'-F'-L',it(58)=< -E+F+L+E'-F'-L',it(58)=<A-B+G-A'+B'-G',it(58)=<A-E+G-A'+E'-G'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [58] 

#### Simplifying cost structure of phase [58] 

#### Cost of phase [58]:aux_rev(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R) -> [aux_rev(A',B',C',D',E',F',G',H',I',J',K',L',M',N',O',P',Q',R')] 
5*it(58)+0
  Such that:it(58) =< A-B+G+2
it(58) =< A-B+G-A'+B'-G'
it(58) =< A-E+G+2
it(58) =< A-E+G-A'+E'-G'
it(58) =< -B+F+L+2
it(58) =< -B+F+L+B'-F'-L'
it(58) =< -E+F+L+2
it(58) =< -E+F+L+E'-F'-L'
it(58) =< G+1
it(58) =< G-G'
it(58) =< H
it(58) =< H-H'
it(58) =< K
it(58) =< K-K'
it(58) =< L+1
it(58) =< L-L'

#### Simplifying cost structure of chain [[58],59] 

#### Cost of chains of aux_rev(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R):
* Chain [[58],59]: 5*it(58)+2
  Such that:it(58) =< H

  with precondition: [B=E,H=K,A+G=M,B+H=N+1,D+J=P,B+H=Q+1,F+L=R,B>=1,C>=0,D>=0,H>=2,I>=0,J>=0,O>=0,A+1>=B,F+1>=B,G+1>=H,L+1>=H,C+I>=O] 

* Chain [59]: 2
  with precondition: [G=0,H=1,J=0,K=1,L=0,E=B,O=C,P=D,A=M,E=N,E=Q,F=R,E>=1,I>=0,O>=0,P>=0,A+1>=E,F+1>=E] 


#### Simplifying cost structure of CE 62 
 * Renamed intermediate variables: 
[ (eq(63,1),it(58))>>s(4)]

#### Simplifying cost structure of CE 63 

#### Cost of chains of rev(A,B,C,D,E,F,G,H,I,J,K,L):
* Chain [61]: 4
  with precondition: [A=0,B=1,D=0,E=1,F=0,G=0,H=1,J=0,K=1,L=0,C>=0,I>=0] 

* Chain [60]: 5*s(4)+4
  Such that:s(4) =< E

  with precondition: [B=E,A=G,B=H,D=J,B=K,F=L,B>=2,C>=0,D>=0,I>=0,A+1>=B,F+1>=B] 


#### Simplifying cost structure of CE 64 

#### Simplifying cost structure of CE 65 

#### Simplifying cost structure of CE 66 
 * Renamed intermediate variables: 
[ (eq(67,1),aux(24))>>s(5), (eq(67,1),aux(25))>>s(6), (eq(67,1),aux(26))>>s(7), (eq(67,1),aux(27))>>s(8), (eq(67,1),aux(28))>>s(9), (eq(67,1),it([55]))>>s(10), (eq(67,1),it([57]))>>s(11), (eq(67,1),it(53))>>s(12), (eq(67,1),it(49))>>s(13), (eq(67,1),it([56]))>>s(14)]
 * Renamed intermediate variables: 
[ (eq(67,2),aux(24))>>s(15), (eq(67,2),aux(25))>>s(16), (eq(67,2),aux(26))>>s(17), (eq(67,2),aux(27))>>s(18), (eq(67,2),aux(28))>>s(19), (eq(67,2),it([55]))>>s(20), (eq(67,2),it([57]))>>s(21), (eq(67,2),it(53))>>s(22), (eq(67,2),it(49))>>s(23), (eq(67,2),it([56]))>>s(24)]
 * Renamed intermediate variables: 
[ (eq(67,3),aux(24))>>s(25), (eq(67,3),aux(25))>>s(26), (eq(67,3),aux(26))>>s(27), (eq(67,3),aux(27))>>s(28), (eq(67,3),aux(28))>>s(29), (eq(67,3),it([55]))>>s(30), (eq(67,3),it([57]))>>s(31), (eq(67,3),it(53))>>s(32), (eq(67,3),it(49))>>s(33), (eq(67,3),it([56]))>>s(34)]
 * Renamed intermediate variables: 
[ (eq(67,4),aux(24))>>s(35), (eq(67,4),aux(25))>>s(36), (eq(67,4),aux(26))>>s(37), (eq(67,4),aux(27))>>s(38), (eq(67,4),aux(28))>>s(39), (eq(67,4),it([55]))>>s(40), (eq(67,4),it([57]))>>s(41), (eq(67,4),it(53))>>s(42), (eq(67,4),it(49))>>s(43), (eq(67,4),it([56]))>>s(44)]

#### Simplifying cost structure of CE 67 
 * Joined equivalent variables [aux(29),s(5),s(15),s(25),s(35)] into aux(29)
 * Joined equivalent variables [aux(30),s(6),s(16),s(26),s(36)] into aux(30)
 * Joined equivalent variables [aux(31),s(7),s(17),s(27),s(37)] into aux(31)
 * Joined equivalent variables [aux(32),s(8),s(18),s(28),s(38)] into aux(32)
 * Joined equivalent variables [aux(33),s(9),s(19),s(29),s(39)] into aux(33)
 * Joined equivalent variables [s(10),s(20),s(30),s(40)] into s(10)
 * Joined equivalent variables [s(11),s(21),s(31),s(41)] into s(11)
 * Joined equivalent variables [s(12),s(22),s(32),s(42)] into s(12)
 * Joined equivalent variables [s(13),s(23),s(33),s(43)] into s(13)
 * Joined equivalent variables [s(14),s(24),s(34),s(44)] into s(14)

#### Cost of chains of table2(A,B,C,D,E,F,G):
* Chain [65]: 57
  with precondition: [D=1,E=4,F=5,G=4,A>=0,B>=0,C>=A+1,C>=B+1] 

* Chain [64]: 45
  with precondition: [D=1,E=4,F=5,G=6,A=C,A>=0,B>=0] 

* Chain [63]: 53
  with precondition: [D=1,E=4,F=5,G=6,B=C,A>=0,B>=A+1] 

* Chain [62]: 24*s(10)+28*s(11)+40*s(12)+120*s(13)+16*s(14)+29
  Such that:aux(29) =< -A+C
aux(30) =< C
aux(31) =< D
aux(32) =< D/2
aux(33) =< D/2+1/2
s(10) =< aux(29)
s(11) =< aux(29)
s(10) =< aux(30)
s(11) =< aux(30)
s(12) =< aux(31)
s(13) =< aux(32)
s(14) =< aux(33)
s(11) =< aux(33)

  with precondition: [E=4,F=5,A>=0,B>=0,D>=2,G>=4,C>=A,4*D+4>=G,D+G>=7] 

 * Renamed intermediate variables: 
[ (eq(68,1),s(4))>>s(45)]
 * Renamed intermediate variables: 
[ (eq(68,2),s(2))>>s(46)]

#### Simplifying cost structure of CE 68 
 * Renamed intermediate variables: 
[ (eq(69,1),s(4))>>s(47)]
 * Renamed intermediate variables: 
[ (eq(69,2),aux(16))>>s(48), (eq(69,2),aux(15))>>s(49), (eq(69,2),aux(17))>>s(50), (eq(69,2),it([43]))>>s(51), (eq(69,2),aux(21))>>s(52), (eq(69,2),aux(22))>>s(53), (eq(69,2),aux(23))>>s(54), (eq(69,2),it(41))>>s(55), (eq(69,2),it(37))>>s(56), (eq(69,2),aux(18))>>s(57), (eq(69,2),aux(7))>>s(58), (eq(69,2),aux(11))>>s(59), (eq(69,2),s(3))>>s(60), (eq(69,2),aux(12))>>s(61), (eq(69,2),aux(1))>>s(62)]

#### Simplifying cost structure of CE 69 
 * Joined equivalent variables [aux(35),s(52)] into aux(35)

#### Computing cost of chain [multiple([66,67],[[69],[68]])] with multiple recursion
 * The following loops are unfeasible in this instance of the phase [66,67] : [67] 
 * Renamed intermediate variables: 
[ (eq(71,1),it(29))>>s(63)]

#### Simplifying cost structure of CE 71 
 * Renamed intermediate variables: 
[ (it(66),s(63))>>s(64)]

#### Cost of loops [66] 

 * loop 66:table_make(A,B,C,D,E,F,G,H,I,J,K,L,M,N) -> [table_make(A',B',C',D',E',F',G',H',I',J',K',L',M',N'),table_make(A'2,B'2,C'2,D'2,E'2,F'2,G'2,H'2,I'2,J'2,K'2,L'2,M'2,N'2)] 
5*s(64)+14
Unbounded itvars
s(64) :  it(66),s(63)

##### Pending set table_make(A,B,C,D,E,F,G,H,I,J,K,L,M,N)
* Pmax/min: [aux(35)=<B,s(48)=<C,s(50)=<2*C]
* Psum in Loop 66: [it(66)=<1]
* Psum in Chain-Tail [68]: [it([68])=<1,s(74)=<B,s(76)=<C-G,s(80)=<H,s(79)=<H/2,s(70)=<H/2+1/2]
* Psum in Chain-Tail [69]: [it([69])=<1,s(68)=<B,s(67)=<C-2*G]

###### Computing max_min for aux(35)=<B  
   - Found a solution using transitive invariants 
 * Adding constraints:[aux(35)=<B+E-2] 

##### Pending set table_make(A,B,C,D,E,F,G,H,I,J,K,L,M,N)
* Pmax/min: [s(48)=<C,s(50)=<2*C]
* Psum in Loop 66: [it(66)=<1]
* Psum in Chain-Tail [68]: [it([68])=<1,s(74)=<B,s(76)=<C-G,s(80)=<H,s(79)=<H/2,s(70)=<H/2+1/2]
* Psum in Chain-Tail [69]: [it([69])=<1,s(68)=<B,s(67)=<C-2*G]

###### Computing max_min for s(48)=<C  
   - Found a solution using transitive invariants 
 * Adding constraints:[s(48)=<C+F] 

##### Pending set table_make(A,B,C,D,E,F,G,H,I,J,K,L,M,N)
* Pmax/min: [s(50)=<2*C]
* Psum in Loop 66: [it(66)=<1]
* Psum in Chain-Tail [68]: [it([68])=<1,s(74)=<B,s(76)=<C-G,s(80)=<H,s(79)=<H/2,s(70)=<H/2+1/2]
* Psum in Chain-Tail [69]: [it([69])=<1,s(68)=<B,s(67)=<C-2*G]

###### Computing max_min for s(50)=<2*C  
   - Found a solution using cacheing 
 * Adding constraints:[s(50)=<s(48)*2] 

##### Pending set table_make(A,B,C,D,E,F,G,H,I,J,K,L,M,N)
* Psum in Loop 66: [it(66)=<1]
* Psum in Chain-Tail [68]: [it([68])=<1,s(74)=<B,s(76)=<C-G,s(80)=<H,s(79)=<H/2,s(70)=<H/2+1/2]
* Psum in Chain-Tail [69]: [it([69])=<1,s(68)=<B,s(67)=<C-2*G]

###### Computing sum for it(66)=<1  in Loop 66 
   - Applying inductive sum strategy 
   - No strategy succeeded 
 * Adding constraints: [] 

##### Pending set table_make(A,B,C,D,E,F,G,H,I,J,K,L,M,N)
* Psum in Chain-Tail [68]: [it([68])=<1,s(74)=<B,s(76)=<C-G,s(80)=<H,s(79)=<H/2,s(70)=<H/2+1/2]
* Psum in Chain-Tail [69]: [it([69])=<1,s(68)=<B,s(67)=<C-2*G]

###### Computing sum for it([68])=<1  in Chain-Tail [68] 
   - Applying inductive sum strategy 
     - head Candidate: 1 
       - Loop 66 adds a constant 1/1 
       - Chain-Tail [69] is collaborative and bounds [it([69])] 
     - tail Candidate: 1 
       - Loop 66 adds a constant 1/1 
       - Chain-Tail [69] is collaborative and bounds [it([69])] 
 * Adding constraints: [it([68])+it([69])=<it(66)+aux(36),it([68])+it([69])=<it(66)+aux(37),aux(36)=<1,aux(37)=<1] 

##### Pending set table_make(A,B,C,D,E,F,G,H,I,J,K,L,M,N)
* Psum in Chain-Tail [68]: [s(74)=<B,s(76)=<C-G,s(80)=<H,s(79)=<H/2,s(70)=<H/2+1/2]
* Psum in Chain-Tail [69]: [it([69])=<1,s(68)=<B,s(67)=<C-2*G]

###### Computing sum for s(74)=<B  in Chain-Tail [68] 
   - Applying inductive sum strategy 
     - head Candidate: B 
       - Loop 66 adds an expression [-3*I'2+L'2+4,-3*I+L+3*I'2-L'2+4]
       - Chain-Tail [69] is collaborative and bounds [it([69])] 
     - tail Candidate: B 
       - Loop 66 adds an expression [-3*I'2+L'2+4,-3*I+L+3*I'2-L'2+4]
       - Chain-Tail [69] is collaborative and bounds [it([69])] 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(42)=<B] 
 * Adding constraints: [s(74)=<it([68])*aux(42),it([69])+s(74)=<aux(38)+aux(39),it([69])+s(74)=<aux(40)+aux(41),aux(39)=<B,aux(41)=<B] 

##### Pending set table_make(A,B,C,D,E,F,G,H,I,J,K,L,M,N)
* Pmax/min: [aux(42)=<B]
* Psum in Loop 66: [aux(38)=< -3*I+L+3*I'2-L'2+4,aux(40)=< -3*I+L+3*I'2-L'2+4,aux(38)=< -3*I'2+L'2+4,aux(40)=< -3*I'2+L'2+4]
* Psum in Chain-Tail [68]: [s(76)=<C-G,s(80)=<H,s(79)=<H/2,s(70)=<H/2+1/2]
* Psum in Chain-Tail [69]: [it([69])=<1,s(68)=<B,s(67)=<C-2*G]

###### Computing max_min for aux(42)=<B  
   - Found a solution using cacheing 
 * Adding constraints:[aux(42)=<aux(35)] 

##### Pending set table_make(A,B,C,D,E,F,G,H,I,J,K,L,M,N)
* Psum in Loop 66: [aux(38)=< -3*I+L+3*I'2-L'2+4,aux(40)=< -3*I+L+3*I'2-L'2+4,aux(38)=< -3*I'2+L'2+4,aux(40)=< -3*I'2+L'2+4]
* Psum in Chain-Tail [68]: [s(76)=<C-G,s(80)=<H,s(79)=<H/2,s(70)=<H/2+1/2]
* Psum in Chain-Tail [69]: [it([69])=<1,s(68)=<B,s(67)=<C-2*G]

###### Computing sum for aux(38)=< -3*I+L+3*I'2-L'2+4  in Loop 66 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [] 
 * Adding constraints: [aux(38)=<it(66)*aux(43)] 

##### Pending set table_make(A,B,C,D,E,F,G,H,I,J,K,L,M,N)
* Psum in Loop 66: [aux(40)=< -3*I+L+3*I'2-L'2+4,aux(38)=< -3*I'2+L'2+4,aux(40)=< -3*I'2+L'2+4]
* Psum in Chain-Tail [68]: [s(76)=<C-G,s(80)=<H,s(79)=<H/2,s(70)=<H/2+1/2]
* Psum in Chain-Tail [69]: [it([69])=<1,s(68)=<B,s(67)=<C-2*G]

###### Computing sum for aux(40)=< -3*I+L+3*I'2-L'2+4  in Loop 66 
   - Found a solution using cacheing 
 * Adding constraints: [aux(40)=<aux(44),aux(44)=<it(66)*aux(43)] 

##### Pending set table_make(A,B,C,D,E,F,G,H,I,J,K,L,M,N)
* Psum in Loop 66: [aux(38)=< -3*I'2+L'2+4,aux(40)=< -3*I'2+L'2+4]
* Psum in Chain-Tail [68]: [s(76)=<C-G,s(80)=<H,s(79)=<H/2,s(70)=<H/2+1/2]
* Psum in Chain-Tail [69]: [it([69])=<1,s(68)=<B,s(67)=<C-2*G]

###### Computing sum for aux(38)=< -3*I'2+L'2+4  in Loop 66 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [] 
 * Adding constraints: [aux(38)=<it(66)*aux(45)] 

##### Pending set table_make(A,B,C,D,E,F,G,H,I,J,K,L,M,N)
* Psum in Loop 66: [aux(40)=< -3*I'2+L'2+4]
* Psum in Chain-Tail [68]: [s(76)=<C-G,s(80)=<H,s(79)=<H/2,s(70)=<H/2+1/2]
* Psum in Chain-Tail [69]: [it([69])=<1,s(68)=<B,s(67)=<C-2*G]

###### Computing sum for aux(40)=< -3*I'2+L'2+4  in Loop 66 
   - Found a solution using cacheing 
 * Adding constraints: [aux(40)=<aux(46),aux(46)=<it(66)*aux(45)] 

##### Pending set table_make(A,B,C,D,E,F,G,H,I,J,K,L,M,N)
* Psum in Chain-Tail [68]: [s(76)=<C-G,s(80)=<H,s(79)=<H/2,s(70)=<H/2+1/2]
* Psum in Chain-Tail [69]: [it([69])=<1,s(68)=<B,s(67)=<C-2*G]

###### Computing sum for s(76)=<C-G  in Chain-Tail [68] 
   - Applying inductive sum strategy 
     - head Candidate: C 
       - Loop 66 has a reset to  [2*C+2*F]
       - Chain-Tail [69] is collaborative and bounds [s(67)] 
     - tail Candidate: C 
       - Loop 66 has undefined behavior 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(49)=<C-G] 
 * Adding constraints: [s(76)=<it([68])*aux(49),s(67)+s(76)=<aux(47)+aux(48),aux(48)=<C] 

##### Pending set table_make(A,B,C,D,E,F,G,H,I,J,K,L,M,N)
* Pmax/min: [aux(49)=<C-G]
* Psum in Loop 66: [aux(47)=<2*C+2*F]
* Psum in Chain-Tail [68]: [s(80)=<H,s(79)=<H/2,s(70)=<H/2+1/2]
* Psum in Chain-Tail [69]: [it([69])=<1,s(68)=<B]

###### Computing max_min for aux(49)=<C-G  
   - Found a solution using transitive invariants 
 * Adding constraints:[aux(49)=<C+F-G] 

##### Pending set table_make(A,B,C,D,E,F,G,H,I,J,K,L,M,N)
* Psum in Loop 66: [aux(47)=<2*C+2*F]
* Psum in Chain-Tail [68]: [s(80)=<H,s(79)=<H/2,s(70)=<H/2+1/2]
* Psum in Chain-Tail [69]: [it([69])=<1,s(68)=<B]

###### Computing sum for aux(47)=<2*C+2*F  in Loop 66 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(50)=<2*C+2*F] 
 * Adding constraints: [aux(47)=<it(66)*aux(50)] 

##### Pending set table_make(A,B,C,D,E,F,G,H,I,J,K,L,M,N)
* Pmax/min: [aux(50)=<2*C+2*F]
* Psum in Chain-Tail [68]: [s(80)=<H,s(79)=<H/2,s(70)=<H/2+1/2]
* Psum in Chain-Tail [69]: [it([69])=<1,s(68)=<B]

###### Computing max_min for aux(50)=<2*C+2*F  
   - Found a solution using transitive invariants 
 * Adding constraints:[aux(50)=<2*C+2*F] 

##### Pending set table_make(A,B,C,D,E,F,G,H,I,J,K,L,M,N)
* Psum in Chain-Tail [68]: [s(80)=<H,s(79)=<H/2,s(70)=<H/2+1/2]
* Psum in Chain-Tail [69]: [it([69])=<1,s(68)=<B]

###### Computing sum for s(80)=<H  in Chain-Tail [68] 
   - Applying inductive sum strategy 
     - head Candidate: H 
       - Loop 66 has a reset to  [2*H]
       - Chain-Tail [69] is collaborative and bounds [it([69])] 
     - tail Candidate: H 
       - Loop 66 has undefined behavior 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(53)=<H] 
 * Adding constraints: [s(80)=<it([68])*aux(53),it([69])+s(80)=<aux(51)+aux(52),aux(52)=<H] 

##### Pending set table_make(A,B,C,D,E,F,G,H,I,J,K,L,M,N)
* Pmax/min: [aux(53)=<H]
* Psum in Loop 66: [aux(51)=<2*H]
* Psum in Chain-Tail [68]: [s(79)=<H/2,s(70)=<H/2+1/2]
* Psum in Chain-Tail [69]: [s(68)=<B]

###### Computing max_min for aux(53)=<H  
   - Found a solution using transitive invariants 
 * Adding constraints:[aux(53)=<H] 

##### Pending set table_make(A,B,C,D,E,F,G,H,I,J,K,L,M,N)
* Psum in Loop 66: [aux(51)=<2*H]
* Psum in Chain-Tail [68]: [s(79)=<H/2,s(70)=<H/2+1/2]
* Psum in Chain-Tail [69]: [s(68)=<B]

###### Computing sum for aux(51)=<2*H  in Loop 66 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(54)=<2*H] 
 * Adding constraints: [aux(51)=<it(66)*aux(54)] 

##### Pending set table_make(A,B,C,D,E,F,G,H,I,J,K,L,M,N)
* Pmax/min: [aux(54)=<2*H]
* Psum in Chain-Tail [68]: [s(79)=<H/2,s(70)=<H/2+1/2]
* Psum in Chain-Tail [69]: [s(68)=<B]

###### Computing max_min for aux(54)=<2*H  
   - Found a solution using cacheing 
 * Adding constraints:[aux(54)=<aux(53)*2] 

##### Pending set table_make(A,B,C,D,E,F,G,H,I,J,K,L,M,N)
* Psum in Chain-Tail [68]: [s(79)=<H/2,s(70)=<H/2+1/2]
* Psum in Chain-Tail [69]: [s(68)=<B]

###### Computing sum for s(79)=<H/2  in Chain-Tail [68] 
   - Found a solution using cacheing 
 * Adding constraints: [s(79)=<aux(55)* (1/2),aux(55)=<it([68])*aux(53),aux(55)+it([69])=<aux(51)+aux(52)] 

##### Pending set table_make(A,B,C,D,E,F,G,H,I,J,K,L,M,N)
* Psum in Chain-Tail [68]: [s(70)=<H/2+1/2]
* Psum in Chain-Tail [69]: [s(68)=<B]

###### Computing sum for s(70)=<H/2+1/2  in Chain-Tail [68] 
   - Applying inductive sum strategy 
     - head Candidate: H/2+1/2 
       - Loop 66 has a reset to  [H+1]
       - Chain-Tail [69] is collaborative
     - tail Candidate: H/2+1/2 
       - Loop 66 has undefined behavior 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(58)=<H/2+1/2] 
 * Adding constraints: [s(70)=<it([68])*aux(58),s(70)=<aux(56)+aux(57),aux(57)=<H/2+1/2] 

##### Pending set table_make(A,B,C,D,E,F,G,H,I,J,K,L,M,N)
* Pmax/min: [aux(58)=<H/2+1/2]
* Psum in Loop 66: [aux(56)=<H+1]
* Psum in Chain-Tail [69]: [s(68)=<B]

###### Computing max_min for aux(58)=<H/2+1/2  
   - Found a solution using cacheing 
 * Adding constraints:[aux(58)=<aux(53)* (1/2)+1/2] 

##### Pending set table_make(A,B,C,D,E,F,G,H,I,J,K,L,M,N)
* Psum in Loop 66: [aux(56)=<H+1]
* Psum in Chain-Tail [69]: [s(68)=<B]

###### Computing sum for aux(56)=<H+1  in Loop 66 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(59)=<H+1] 
 * Adding constraints: [aux(56)=<it(66)*aux(59)] 

##### Pending set table_make(A,B,C,D,E,F,G,H,I,J,K,L,M,N)
* Pmax/min: [aux(59)=<H+1]
* Psum in Chain-Tail [69]: [s(68)=<B]

###### Computing max_min for aux(59)=<H+1  
   - Found a solution using cacheing 
 * Adding constraints:[aux(59)=<aux(53)+1] 

##### Pending set table_make(A,B,C,D,E,F,G,H,I,J,K,L,M,N)
* Psum in Chain-Tail [69]: [s(68)=<B]

###### Computing sum for s(68)=<B  in Chain-Tail [69] 
   - Applying inductive sum strategy 
     - head Candidate: B 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B 
       - The candidate was classified before. We reuse its previous classification 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(62)=<B] 
 * Adding constraints: [s(68)=<it([69])*aux(62),s(68)+s(74)=<aux(38)+aux(60),s(68)+s(74)=<aux(40)+aux(61),aux(60)=<B,aux(61)=<B] 

##### Pending set table_make(A,B,C,D,E,F,G,H,I,J,K,L,M,N)
* Pmax/min: [aux(62)=<B]

###### Computing max_min for aux(62)=<B  
   - Found a solution using cacheing 
 * Adding constraints:[aux(62)=<aux(35)] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [66,[69],[68]] 

#### Simplifying cost structure of phase [66,[69],[68]] 
 * Joined equivalent variables [aux(63),aux(36),aux(37)] into aux(63)
 * Joined equivalent variables [aux(64),aux(39),aux(41),aux(60),aux(61)] into aux(64)
 * Joined equivalent variables [aux(65),aux(52),aux(53)] into aux(65)
 * Joined equivalent variables [aux(42),aux(62)] into aux(42)
 * Joined equivalent variables [aux(55),s(80)] into aux(55)
 * Joined equivalent variables [it(66),s(65)] into it(66)

#### Cost of phase [66,67]:table_make(A,B,C,D,E,F,G,H,I,J,K,L,M,N) -> [] 
19*it(66)+11*it([68])+18*it([69])+5*s(66)+5*s(67)+5*s(69)+7*s(70)+10*s(71)+30*s(72)+5*s(73)+0
Unbounded itvars
it(66) :  it(66)
it([68]) :  it([68])
it([69]) :  it([69])
s(66) :  sum([69]),s(45)
s(67) :  sum([69]),s(46)
s(69) :  sum([68]),s(47)
s(70) :  sum([68]),s(51)
s(71) :  sum([68]),s(55)
s(72) :  sum([68]),s(56)
s(73) :  sum([68]),s(60)

#### Cost of chains of table_make(A,B,C,D,E,F,G,H,I,J,K,L,M,N):
* Chain [69]: 5*s(45)+5*s(46)+18
  Such that:s(46) =< C-2*G
aux(34) =< B
s(45) =< aux(34)
s(46) =< aux(34)

  with precondition: [E=1,H=1,I=1,K=2,A=J,B=L,B>=2,F>=0,G>=0,M>=0,A+1>=B,N>=D,C>=G,2*D>=N] 

* Chain [68]: 5*s(47)+7*s(51)+10*s(55)+30*s(56)+5*s(60)+11
  Such that:s(48) =< C
s(49) =< C-G
s(50) =< 2*C
s(53) =< H
s(54) =< H/2
s(51) =< H/2+1/2
aux(35) =< B
s(47) =< aux(35)
s(55) =< s(53)
s(56) =< s(54)
s(57) =< s(50)
s(58) =< aux(35)*2
s(59) =< s(56)*s(50)
s(60) =< s(51)*s(48)
s(60) =< s(51)*aux(35)
s(61) =< s(56)*s(57)
s(62) =< s(56)*s(58)
s(60) =< s(61)+s(61)+s(61)+s(59)+s(49)
s(60) =< s(62)+s(62)+s(62)+s(62)+aux(35)

  with precondition: [E=1,I=1,K=2,A=J,B=L,B>=2,C>=0,D>=0,F>=0,G>=0,H>=2,M>=0,A+1>=B,N>=D,H+N>=3,H+2*D>=N+1] 

* Chain [multiple([66,67],[[69],[68]])]: 19*it(66)+11*it([68])+18*it([69])+5*s(66)+5*s(67)+5*s(69)+7*s(70)+10*s(71)+30*s(72)+5*s(73)+0
Unbounded itvars
it(66) :  it(66)
it([68]) :  it([68])
it([69]) :  it([69])
s(66) :  sum([69]),s(45)
s(67) :  sum([69]),s(46)
s(69) :  sum([68]),s(47)
s(70) :  sum([68]),s(51)
s(71) :  sum([68]),s(55)
s(72) :  sum([68]),s(56)
s(73) :  sum([68]),s(60)

  with precondition: [K=I+1,A>=0,B>=1,C>=0,D>=0,E>=2,F>=0,G>=0,H>=1,M>=0,K+23>=8*E,K+7>=4*E,K+1>=2*E,L+7>=3*K+2*B,J+4>=2*A+2*K,N+2>=2*D+K] 


Closed-form bounds of eval2(A,B,C,D,E,F,G): 
-------------------------------------
* Chain [57] with precondition: [F=1,G=0,A>=0,B>=0,C>=0,D>=0,E>=A+1,E>=C+1] 
    - Upper bound: 7 
    - Complexity: constant 
* Chain [56] with precondition: [F=1,A=E,B=G,A>=0,B>=0,C>=0,D>=0] 
    - Upper bound: 4 
    - Complexity: constant 
* Chain [55] with precondition: [F=1,C=E,D=G,A>=0,B>=0,D>=0,C>=A+1] 
    - Upper bound: 6 
    - Complexity: constant 
* Chain [multiple([49,50,51,52,53,54],[[57],[56],[55]])] with precondition: [A>=0,B>=0,C>=0,D>=0,F>=2,G>=0,E>=A,B+D+F>=G+1,B+D+F+G>=3] 
    - Upper bound: -13*A+13*E+27*F+2 
    - Complexity: n 

### Maximum cost of eval2(A,B,C,D,E,F,G): -13*A+13*E+27*F+2 
Asymptotic class: n 

Closed-form bounds of table2(A,B,C,D,E,F,G): 
-------------------------------------
* Chain [65] with precondition: [D=1,E=4,F=5,G=4,A>=0,B>=0,C>=A+1,C>=B+1] 
    - Upper bound: 57 
    - Complexity: constant 
* Chain [64] with precondition: [D=1,E=4,F=5,G=6,A=C,A>=0,B>=0] 
    - Upper bound: 45 
    - Complexity: constant 
* Chain [63] with precondition: [D=1,E=4,F=5,G=6,B=C,A>=0,B>=A+1] 
    - Upper bound: 53 
    - Complexity: constant 
* Chain [62] with precondition: [E=4,F=5,A>=0,B>=0,D>=2,G>=4,C>=A,4*D+4>=G,D+G>=7] 
    - Upper bound: -52*A+52*C+108*D+37 
    - Complexity: n 

### Maximum cost of table2(A,B,C,D,E,F,G): -52*A+52*C+108*D+37 
Asymptotic class: n 

Closed-form bounds of rev(A,B,C,D,E,F,G,H,I,J,K,L): 
-------------------------------------
* Chain [61] with precondition: [A=0,B=1,D=0,E=1,F=0,G=0,H=1,J=0,K=1,L=0,C>=0,I>=0] 
    - Upper bound: 4 
    - Complexity: constant 
* Chain [60] with precondition: [B=E,A=G,B=H,D=J,B=K,F=L,B>=2,C>=0,D>=0,I>=0,A+1>=B,F+1>=B] 
    - Upper bound: 5*E+4 
    - Complexity: n 

### Maximum cost of rev(A,B,C,D,E,F,G,H,I,J,K,L): 5*E+4 
Asymptotic class: n 

Closed-form bounds of concat(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X): 
-------------------------------------
* Chain [[29],30] with precondition: [C=G,Q=A+I,R=B+J,T=D+L,V=F+N,X=H+P,C+K=S+1,C+O=W+1,B>=0,C>=2,D>=0,E>=0,F>=0,K>=1,M>=0,O>=1,U>=0,Q>=A,R>=B,A+1>=C,H+1>=C,T>=D,V>=F,X>=H,E+M>=U] 
    - Upper bound: 5*C+2 
    - Complexity: n 
* Chain [30] with precondition: [A=0,B=0,C=1,D=0,F=0,G=1,H=0,I=Q,J=R,K=S,L=T,M=U,N=V,O=W,P=X,E>=0,I>=0,J>=0,K>=0,L>=0,M>=0,N>=0,O>=0,P>=0] 
    - Upper bound: 2 
    - Complexity: constant 

### Maximum cost of concat(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X): 5*C+2 
Asymptotic class: n 

Closed-form bounds of assoc(A,B,C,D,E,F): 
-------------------------------------
* Chain [[27],28] with precondition: [A>=0,B>=2,C>=3,F>=0,D>=2*A+1,E>=F] 
    - Upper bound: -10*A+5*D+4 
    - Complexity: n 
* Chain [28] with precondition: [A>=0,B>=1,C>=2,F>=0,D>=A,E>=F] 
    - Upper bound: 4 
    - Complexity: constant 

### Maximum cost of assoc(A,B,C,D,E,F): nat(-2*A+D)*5+4 
Asymptotic class: n 

Closed-form bounds of eval(A,B,C,D,E,F,G): 
-------------------------------------
* Chain [43] with precondition: [F=1,A>=1,B>=2,E>=0,G>=0,C>=E,D>=G] 
    - Upper bound: 5*B+7 
    - Complexity: n 
* Chain [multiple([37,38,39,40,41,42],[[43]])] with precondition: [A>=1,B>=2,C>=0,D>=0,E>=0,F>=2,G>=0,D+F>=G+1,D+F+G>=3] 
    - Upper bound: 7/2*F+7/2+ ((F/2+1/2)* (5*C)+10*F)+15*F 
    - Complexity: n^2 

### Maximum cost of eval(A,B,C,D,E,F,G): max([5*B+7,7/2*F+7/2+ ((F/2+1/2)* (5*C)+10*F)+15*F]) 
Asymptotic class: n^2 
 * Joined equivalent variables [it(66),it([68]),it([69]),s(66),s(67),s(69),s(70),s(71),s(72),s(73)] into it(66)

Closed-form bounds of table_make(A,B,C,D,E,F,G,H,I,J,K,L,M,N): 
-------------------------------------
* Chain [69] with precondition: [E=1,H=1,I=1,K=2,A=J,B=L,B>=2,F>=0,G>=0,M>=0,A+1>=B,N>=D,C>=G,2*D>=N] 
    - Upper bound: 5*B+18+nat(C-2*G)*5 
    - Complexity: n 
* Chain [68] with precondition: [E=1,I=1,K=2,A=J,B=L,B>=2,C>=0,D>=0,F>=0,G>=0,H>=2,M>=0,A+1>=B,N>=D,H+N>=3,H+2*D>=N+1] 
    - Upper bound: 5*B+11+ (H/2+1/2)* (5*C)+10*H+ (7/2*H+7/2)+15*H 
    - Complexity: n^2 
* Chain [multiple([66,67],[[69],[68]])] with precondition: [K=I+1,A>=0,B>=1,C>=0,D>=0,E>=2,F>=0,G>=0,H>=1,M>=0,K+23>=8*E,K+7>=4*E,K+1>=2*E,L+7>=3*K+2*B,J+4>=2*A+2*K,N+2>=2*D+K] 
    - Upper bound: inf 
    - Complexity: infinity 

### Maximum cost of table_make(A,B,C,D,E,F,G,H,I,J,K,L,M,N): inf 
Asymptotic class: infinity 
* Total analysis performed in 7146 ms.


Cost relation system solved by CoFloCo in 7154 ms.

Method eval2 terminates?: YES

 - a_1: size of a wrt. Rat
 - val_a_1: size of val_a wrt. Bool
 - b_1: size of b wrt. Rat
 - val_b_1: size of val_b wrt. Bool
 - exp_1: size of exp wrt. Rat
 - exp_2: size of exp wrt. Bool_expr
UB for eval2(a_1,val_a_1,b_1,val_b_1,exp_1,exp_2) = -13*a_1+13*exp_1+27*exp_2+2

Method table2 terminates?: YES

 - a_1: size of a wrt. Rat
 - b_1: size of b wrt. Rat
 - expr_1: size of expr wrt. Rat
 - expr_2: size of expr wrt. Bool_expr
UB for table2(a_1,b_1,expr_1,expr_2) = -52*a_1+52*expr_1+108*expr_2+37

Method rev terminates?: YES

 - l_1: size of l wrt. Pair<Rat, Bool>
 - l_2: size of l wrt. List<Pair<Rat, Bool>>
 - l_3: size of l wrt. Rat
 - l_4: size of l wrt. Bool
 - l_5: size of l wrt. List<A>
 - l_6: size of l wrt. A
UB for rev(l_1,l_2,l_3,l_4,l_5,l_6) = 5*l_5+4

Method concat terminates?: YES

 - l1_1: size of l1 wrt. Pair<List<Pair<Rat, Bool>>, Bool>
 - l1_2: size of l1 wrt. Pair<Rat, Bool>
 - l1_3: size of l1 wrt. List<Pair<List<Pair<Rat, Bool>>, Bool>>
 - l1_4: size of l1 wrt. List<Pair<Rat, Bool>>
 - l1_5: size of l1 wrt. Rat
 - l1_6: size of l1 wrt. Bool
 - l1_7: size of l1 wrt. List<A>
 - l1_8: size of l1 wrt. A
 - l2_1: size of l2 wrt. Pair<List<Pair<Rat, Bool>>, Bool>
 - l2_2: size of l2 wrt. Pair<Rat, Bool>
 - l2_3: size of l2 wrt. List<Pair<List<Pair<Rat, Bool>>, Bool>>
 - l2_4: size of l2 wrt. List<Pair<Rat, Bool>>
 - l2_5: size of l2 wrt. Rat
 - l2_6: size of l2 wrt. Bool
 - l2_7: size of l2 wrt. List<A>
 - l2_8: size of l2 wrt. A
UB for concat(l1_1,l1_2,l1_3,l1_4,l1_5,l1_6,l1_7,l1_8,l2_1,l2_2,l2_3,l2_4,l2_5,l2_6,l2_7,l2_8) = 5*l1_3+2

Method assoc terminates?: YES

 - k_1: size of k wrt. Rat
 - l_1: size of l wrt. Pair<Rat, Bool>
 - l_2: size of l wrt. List<Pair<Rat, Bool>>
 - l_3: size of l wrt. Rat
 - l_4: size of l wrt. Bool
UB for assoc(k_1,l_1,l_2,l_3,l_4) = nat(-2*k_1+l_3)*5+4

Method eval terminates?: YES

 - val_vars_1: size of val_vars wrt. Pair<Rat, Bool>
 - val_vars_2: size of val_vars wrt. List<Pair<Rat, Bool>>
 - val_vars_3: size of val_vars wrt. Rat
 - val_vars_4: size of val_vars wrt. Bool
 - exp_1: size of exp wrt. Rat
 - exp_2: size of exp wrt. Bool_expr
UB for eval(val_vars_1,val_vars_2,val_vars_3,val_vars_4,exp_1,exp_2) = max([5*val_vars_2+7,7/2*exp_2+7/2+ ((exp_2/2+1/2)* (5*val_vars_3)+10*exp_2)+15*exp_2])

Method table_make terminates?: YES

 - val_vars_1: size of val_vars wrt. Pair<Rat, Bool>
 - val_vars_2: size of val_vars wrt. List<Pair<Rat, Bool>>
 - val_vars_3: size of val_vars wrt. Rat
 - val_vars_4: size of val_vars wrt. Bool
 - vars_1: size of vars wrt. List<Rat>
 - vars_2: size of vars wrt. Rat
 - expr_1: size of expr wrt. Rat
 - expr_2: size of expr wrt. Bool_expr
UB for table_make(val_vars_1,val_vars_2,val_vars_3,val_vars_4,vars_1,vars_2,expr_1,expr_2) = inf
