
Abs program loaded in 20 ms.

Rule based representation generated in 3 ms.

Rule based representation stored in /tmp/costabs/rbr.rbr

RBR properties stored in /tmp/costabs/rbr.properties

Class invariants generated and loaded in 0 ms.

Abstract compilation performed in 20 ms.

Cost relation system stored in /tmp/costabs/crs.crs

Generated 35 equations 
entry('leqL'(A,B,C,D,E):[]).
entry('insertL'(A,B,C,D,E,F,G,H):[]).
entry('isortlist'(A,B,C,D,E,F):[]).
input_output_vars('and_op'(A,B,C),[A,B],[C]).
input_output_vars('case_0'(A,B,C,D,E),[A,B,C,D],[E]).
input_output_vars('case_1'(A,B,C,D,E,F,G,H),[A,B,C,D,E,F,G],[H]).
input_output_vars('case_2'(A,B,C,D,E,F,G,H),[A,B,C,D,E],[F,G,H]).
input_output_vars('case_3'(A,B,C,D,E,F,G,H,I,J,K,L,M,N),[A,B,C,D,E,F,G,H,I,J,K],[L,M,N]).
input_output_vars('case_4'(A,B,C,D,E,F),[A,B,C],[D,E,F]).
input_output_vars('eq'(A,B,C),[A,B],[C]).
input_output_vars('geq'(A,B,C),[A,B],[C]).
input_output_vars('gt'(A,B,C),[A,B],[C]).
input_output_vars('insertL'(A,B,C,D,E,F,G,H),[A,B,C,D,E],[F,G,H]).
input_output_vars('isortlist'(A,B,C,D,E,F),[A,B,C],[D,E,F]).
input_output_vars('leq'(A,B,C),[A,B],[C]).
input_output_vars('leqL'(A,B,C,D,E),[A,B,C,D],[E]).
input_output_vars('lt'(A,B,C),[A,B],[C]).
input_output_vars('maxNorm'(A,B,C),[A,B],[C]).
input_output_vars('neg'(A,B),[A],[B]).
input_output_vars('neq'(A,B,C),[A,B],[C]).
input_output_vars('or'(A,B,C),[A,B],[C]).
eq('eq',[A,B,C],0,[],[A=B,C=1,A>=0,B>=0,C>=0]).
eq('eq',[A,B,C],0,[],[A>=B+1,C=0,A>=0,B>=0,C>=0]).
eq('eq',[A,B,C],0,[],[B>=A+1,C=0,A>=0,B>=0,C>=0]).
eq('neq',[A,B,C],0,[],[A=B,C=0,A>=0,B>=0,C>=0]).
eq('neq',[A,B,C],0,[],[A>=B+1,C=1,A>=0,B>=0,C>=0]).
eq('neq',[A,B,C],0,[],[B>=A+1,C=1,A>=0,B>=0,C>=0]).
eq('lt',[A,B,C],0,[],[B-A>=1,C=1,A>=0,B>=0,C>=0]).
eq('lt',[A,B,C],0,[],[B=<A,C=0,A>=0,B>=0,C>=0]).
eq('leq',[A,B,C],0,[],[A=<B,C=1,A>=0,B>=0,C>=0]).
eq('leq',[A,B,C],0,[],[A-B>=1,C=0,A>=0,B>=0,C>=0]).
eq('gt',[A,B,C],0,[],[A-B>=1,C=1,A>=0,B>=0,C>=0]).
eq('gt',[A,B,C],0,[],[A=<B,C=0,A>=0,B>=0,C>=0]).
eq('geq',[A,B,C],0,[],[B=<A,C=1,A>=0,B>=0,C>=0]).
eq('geq',[A,B,C],0,[],[B-A>=1,C=0,A>=0,B>=0,C>=0]).
eq('neg',[A,B],0,[],[A=0,B=1,A>=0,B>=0]).
eq('neg',[A,B],0,[],[A=1,B=0,A>=0,B>=0]).
eq('and_op',[A,B,C],0,[],[A=0,C=0,A>=0,B>=0,C>=0]).
eq('and_op',[A,B,C],0,[],[A=1,C=B,A>=0,B>=0,C>=0]).
eq('or',[A,B,C],0,[],[A=1,C=1,A>=0,B>=0,C>=0]).
eq('or',[A,B,C],0,[],[A=0,C=B,A>=0,B>=0,C>=0]).
eq('maxNorm',[A,B,A],0,[],[A>=1+B,A>=0,B>=0,A>=0]).
eq('maxNorm',[A,B,B],0,[],[A=<B,A>=0,B>=0,B>=0]).
eq('case_0',[A,B,C,D,E],2,[],[A=1,E=1,A>=0,B>=0,C>=0,D>=0,E>=0]).
eq('case_1',[A,B,C,D,E,F,G,H],2,[],[C=1,H=0,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0]).
eq('case_1',[A,B,C,D,E,F,G,H],5,['leq'(E,I,J),'leqL'(F,G,K,L,M),'and_op'(J,M,H)],[D=I+L,C=K+1,K>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0]).
eq('case_0',[A,B,C,D,E],3,['case_1'(A,B,C,D,F,G,H,E)],[B=F+H,A=G+1,G>=1,A>=0,B>=0,C>=0,D>=0,E>=0]).
eq('leqL',[A,B,C,D,E],1,['case_0'(A,B,C,D,E)],[A>=0,B>=0,C>=0,D>=0,E>=0]).
eq('case_2',[A,B,C,D,E,F,G,H],3,[],[D=0,C=1,I=0,J=1,H=B+K,G=A+I,F=J+1,J>=1,A>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0]).
eq('case_3',[A,B,C,D,E,F,G,H,I,J,K,L,M,N],3,['insertL'(B,C,I,J,K,O,P,Q)],[A=1,N=H+Q,M=G+P,L=O+1,O>=1,G>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0,M>=0,N>=0]).
eq('case_3',[A,B,C,D,E,F,G,H,I,J,K,L,M,N],4,[],[A=0,O=H+K,P=G+J,Q=I+1,I>=1,G>=1,N=C+O,M=B+P,L=Q+1,Q>=1,B>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0,K>=0,L>=0,M>=0,N>=0]).
eq('case_2',[A,B,C,D,E,F,G,H],4,['leqL'(I,J,A,B,K),'case_3'(K,A,B,C,D,E,I,J,L,M,N,F,G,H)],[E=J+N,D=I+M,C=L+1,L>=1,I>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0]).
eq('insertL',[A,B,C,D,E,F,G,H],1,['case_2'(A,B,C,D,E,F,G,H)],[A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0]).
eq('case_4',[A,B,C,D,E,F],2,[],[B=0,A=1,E=0,D=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0]).
eq('case_4',[A,B,C,D,E,F],4,['isortlist'(G,H,I,J,K,L),'insertL'(M,N,J,K,L,D,E,F)],[C=N+I,B=M+H,A=G+1,G>=1,M>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0]).
eq('isortlist',[A,B,C,D,E,F],1,['case_4'(A,B,C,D,E,F)],[A>=0,B>=0,C>=0,D>=0,E>=0,F>=0]).

Preprocessing Cost Relations
=====================================

#### Computed strongly connected components 
0. non_recursive  : [and_op/3]
1. non_recursive  : [leq/3]
2. recursive [non_tail] : [case_0/5,case_1/8,leqL/5]
3. recursive  : [case_2/8,case_3/14,insertL/8]
4. recursive [non_tail] : [case_4/6,isortlist/6]
Warning: the following predicates are never called:[eq/3,geq/3,gt/3,lt/3,maxNorm/3,neg/2,neq/3,or/3]

#### Obtained direct recursion through partial evaluation 
0. SCC is partially evaluated into and_op/3
1. SCC is partially evaluated into leq/3
2. SCC is partially evaluated into leqL/5
3. SCC is partially evaluated into insertL/8
4. SCC is partially evaluated into isortlist/6

Control-Flow Refinement of Cost Relations
=====================================

### Specialization of cost equations and_op/3 
* CE 12 is refined into CE [13] 
* CE 11 is refined into CE [14] 


#### Refined cost equations and_op/3 
* CE 13: and_op(A,B,B) = 0
     [B>=0,A=1] 
* CE 14: and_op(A,B,C) = 0
     [B>=0,C=0,A=0] 

### Cost equations --> "Loop" of and_op/3 
* CEs [13] --> Loop 13 
* CEs [14] --> Loop 14 

#### Loops of and_op/3 
* Loop 13: and_op(A,B,B) [B>=0,A=1] 
* Loop 14: and_op(A,B,C) [B>=0,C=0,A=0] 

### Ranking functions of CR and_op(A,B,C) 

#### Partial ranking functions of CR and_op(A,B,C) 


### Resulting Chains:and_op(A,B,C) 
* [14]
* [13]


### Merging Chains  and_op/3 into  External patterns of execution 
* [[14]] --> 1 
* [[13]] --> 2 


### Specialization of cost equations leq/3 
* CE 9 is refined into CE [15] 
* CE 10 is refined into CE [16] 


#### Refined cost equations leq/3 
* CE 15: leq(A,B,C) = 0
     [B>=A,A>=0,C=1] 
* CE 16: leq(A,B,C) = 0
     [A>=B+1,B>=0,C=0] 

### Cost equations --> "Loop" of leq/3 
* CEs [15] --> Loop 15 
* CEs [16] --> Loop 16 

#### Loops of leq/3 
* Loop 15: leq(A,B,C) [B>=A,A>=0,C=1] 
* Loop 16: leq(A,B,C) [A>=B+1,B>=0,C=0] 

### Ranking functions of CR leq(A,B,C) 

#### Partial ranking functions of CR leq(A,B,C) 


### Resulting Chains:leq(A,B,C) 
* [16]
* [15]


### Merging Chains  leq/3 into  External patterns of execution 
* [[16]] --> 1 
* [[15]] --> 2 


### Specialization of cost equations leqL/5 
* CE 3 is refined into CE [17,18] 
* CE 2 is refined into CE [19] 
* CE 1 is refined into CE [20] 


#### Refined cost equations leqL/5 
* CE 17: leqL(A,B,C,D,E) = 9+ leq(F,G,H):1+ leqL(I,J,K,L,M)+ and_op(N,M,O):1
     [G+L>=0,F>=G+1,K>=1,J>=0,I>=1,M>=0,G>=0,G+L=D,F+J=B,K+1=C,I+1=A,O=0,N=0,H=0,E=0] 
* CE 18: leqL(A,B,C,D,E) = 9+ leq(F,G,H):2+ leqL(I,J,K,L,E)+ and_op(M,E,E):2
     [G+L>=0,G>=F,K>=1,J>=0,I>=1,E>=0,F>=0,G+L=D,F+J=B,K+1=C,I+1=A,M=1,H=1] 
* CE 19: leqL(A,B,C,D,E) = 6
     [D>=0,B>=0,A>=2,E=0,C=1] 
* CE 20: leqL(A,B,C,D,E) = 3
     [D>=0,C>=0,B>=0,E=1,A=1] 

### Cost equations --> "Loop" of leqL/5 
* CEs [19] --> Loop 17 
* CEs [20] --> Loop 18 
* CEs [18] --> Loop 19 
* CEs [17] --> Loop 20 

#### Loops of leqL/5 
* Loop 17: leqL(A,B,C,D,E) [D>=0,B>=0,A>=2,E=0,C=1] 
* Loop 18: leqL(A,B,C,D,E) [D>=0,C>=0,B>=0,E=1,A=1] 
* Loop 19: leqL(A,B,C,D,E)->  leqL(A',B',C',D',E)
                  [D+B'>=B+D',B>=B',B'>=0,E>=0,D>=0,C>=2,A>=2,C=C'+1,A=A'+1] 
* Loop 20: leqL(A,B,C,D,E)->  leqL(A',B',C',D',E')
                  [B+D'>=D+B'+1,D>=D',E'>=0,B'>=0,D>=0,C>=2,A>=2,C=C'+1,A=A'+1,E=0] 

### Ranking functions of CR leqL(A,B,C,D,E) 
* RF of phase [19,20]: [A-1,C-1]

#### Partial ranking functions of CR leqL(A,B,C,D,E) 
* Partial RF of phase [19,20]:
  - RF of loop [19:1,20:1]:
    A-1
    C-1
  - RF of loop [20:1]:
    B

Discarded unfeasible chain [[19,20]]...(Non-terminating chain proved terminating)

### Resulting Chains:leqL(A,B,C,D,E) 
* [[19,20],18]
* [[19,20],17]
* [18]
* [17]


### Merging Chains  leqL/5 into  External patterns of execution 
* [[18]] --> 1 
* [[17]] --> 2 
* [[17,[19,20]]] --> 3 
* [[18,[19,20]]] --> 4 


### Specialization of cost equations insertL/8 
* CE 6 is refined into CE [21,22,23] 
* CE 4 is refined into CE [24] 
* CE 5 is refined into CE [25,26] 


#### Refined cost equations insertL/8 
* CE 21: insertL(A,B,C,D,E,F,G,H) = 9+ leqL(I,J,K,B,L):2
     [E>=J,D>=I,B>=0,J>=0,I>=2,F>=3,B+E=H,D+1=G,F=C+1,L=0,K=1,A=1] 
* CE 22: insertL(A,B,C,D,E,F,G,H) = 9+ leqL(I,J,A,B,K):3
     [I>=A+1,E>=J,D>=I,B>=0,A>=2,J>=0,F>=3,B+E=H,A+D=G,F=C+1,K=0] 
* CE 23: insertL(A,B,C,D,E,F,G,H) = 9+ leqL(I,J,A,B,K):4
     [E>=J,A>=I,D>=I,B>=0,J>=1,I>=2,F>=3,B+E=H,A+D=G,F=C+1,K=0] 
* CE 24: insertL(A,B,C,D,E,F,A,G) = 4
     [G>=0,E>=0,B>=0,A>=1,F=2,D=0,C=1] 
* CE 25: insertL(A,B,C,D,E,F,G,H) = 8+ leqL(I,J,A,B,K):1+ insertL(A,B,L,M,N,O,P,Q)
     [J+Q>=0,P+1>=0,O>=1,N>=0,M>=0,L>=1,B>=0,A>=0,J>=0,J+Q=H,J+N=E,P+1=G,O+1=F,M+1=D,L+1=C,K=1,I=1] 
* CE 26: insertL(A,B,C,D,E,F,G,H) = 8+ leqL(I,J,A,B,K):4+ insertL(A,B,L,M,N,O,P,Q)
     [J+Q>=0,I+P>=0,A>=I,O>=1,N>=0,M>=0,L>=1,B>=0,J>=0,I>=2,J+Q=H,I+P=G,J+N=E,I+M=D,O+1=F,L+1=C,K=1] 

### Cost equations --> "Loop" of insertL/8 
* CEs [26] --> Loop 21 
* CEs [25] --> Loop 22 
* CEs [22] --> Loop 23 
* CEs [23] --> Loop 24 
* CEs [24] --> Loop 25 
* CEs [21] --> Loop 26 

#### Loops of insertL/8 
* Loop 21: insertL(A,B,C,D,E,F,G,H)->  insertL(A,B,A',B',C',D',E',F')
                  [A+B'>=D,E>=C',D>=B'+2,C'>=0,B'>=0,H>=0,G>=0,F>=2,C>=2,B>=0,D+E'=G+B',H+C'=E+F',F=D'+1,C=A'+1] 
* Loop 22: insertL(A,B,C,D,E,F,G,H)->  insertL(A,B,A',B',C',D',E',F')
                  [E>=C',C'>=0,H>=0,G>=0,F>=2,D>=1,C>=2,B>=0,A>=0,H+C'=E+F',G=E'+1,F=D'+1,D=B'+1,C=A'+1] 
* Loop 23: insertL(A,B,C,D,E,F,G,H) [D>=A+1,E>=0,C>=2,B>=0,A>=2,B+E=H,A+D=G,C+1=F] 
* Loop 24: insertL(A,B,C,D,E,F,G,H) [E>=1,D>=2,C>=2,B>=0,A>=2,B+E=H,A+D=G,C+1=F] 
* Loop 25: insertL(A,B,C,D,E,F,A,G) [G>=0,E>=0,B>=0,A>=1,F=2,D=0,C=1] 
* Loop 26: insertL(A,B,C,D,E,F,G,H) [E>=0,D>=2,C>=2,B>=0,B+E=H,D+1=G,C+1=F,A=1] 

### Ranking functions of CR insertL(A,B,C,D,E,F,G,H) 
* RF of phase [21,22]: [C-1,D]

#### Partial ranking functions of CR insertL(A,B,C,D,E,F,G,H) 
* Partial RF of phase [21,22]:
  - RF of loop [21:1]:
    D/2-1/2
  - RF of loop [21:1,22:1]:
    C-1
  - RF of loop [22:1]:
    D

Discarded unfeasible chain [[21,22]]...(Non-terminating chain proved terminating)

### Resulting Chains:insertL(A,B,C,D,E,F,G,H) 
* [[21,22],26]
* [[21,22],25]
* [[21,22],24]
* [[21,22],23]
* [26]
* [25]
* [24]
* [23]


### Merging Chains  insertL/8 into  External patterns of execution 
* [[26],[26,[21,22]]] --> 1 
* [[25]] --> 2 
* [[24],[24,[21,22]]] --> 3 
* [[23],[23,[21,22]]] --> 4 
* [[25,[21,22]]] --> 5 


### Specialization of cost equations isortlist/6 
* CE 8 is refined into CE [27] 
* CE 7 is refined into CE [28,29,30,31,32] 


#### Refined cost equations isortlist/6 
* CE 27: isortlist(A,B,C,D,E,F) = 3
     [F>=0,C>=0,E=0,D=1,B=0,A=1] 
* CE 28: isortlist(A,B,C,D,E,F) = 5+ isortlist(G,H,I,J,K,L)+ insertL(M,N,O,P,Q,D,E,F):1
     [N+I>=0,F>=N,H+1>=0,G>=1,E>=3,D>=3,N>=0,F=N+L,F=N+Q,N+I=C,E=K+1,D=J+1,E=P+1,D=O+1,H+1=B,G+1=A,M=1] 
* CE 29: isortlist(A,B,C,D,E,F) = 5+ isortlist(G,H,I,J,K,L)+ insertL(E,M,N,O,L,P,E,F):2
     [E+H>=0,M+I>=0,G>=1,F>=0,E>=1,L>=0,M>=0,M+I=C,E+H=B,G+1=A,K=0,J=1,P=2,O=0,N=1,D=2] 
* CE 30: isortlist(A,B,C,D,E,F) = 5+ isortlist(G,H,I,J,K,L)+ insertL(M,N,O,P,Q,D,E,F):3
     [N+I>=0,M+H>=0,F>=N+1,E>=M+2,G>=1,D>=3,N>=0,M>=2,F=N+L,F=N+Q,E=M+K,E=M+P,N+I=C,M+H=B,D=J+1,D=O+1,G+1=A] 
* CE 31: isortlist(A,B,C,D,E,F) = 5+ isortlist(G,H,I,J,K,L)+ insertL(M,N,O,P,Q,D,E,F):4
     [N+I>=0,M+H>=0,F>=N,E>=2*M+1,G>=1,D>=3,N>=0,M>=2,F=N+L,F=N+Q,E=M+K,E=M+P,N+I=C,M+H=B,D=J+1,D=O+1,G+1=A] 
* CE 32: isortlist(A,B,C,D,E,F) = 5+ isortlist(G,H,I,J,K,L)+ insertL(M,N,O,P,L,D,E,F):5
     [E+2>=D+M,N+I>=0,M+H>=0,G>=1,F>=0,D>=3,L>=0,N>=0,M>=1,E=M+K,E=M+P,N+I=C,M+H=B,D=J+1,D=O+1,G+1=A] 

### Cost equations --> "Loop" of isortlist/6 
* CEs [32] --> Loop 27 
* CEs [31] --> Loop 28 
* CEs [30] --> Loop 29 
* CEs [28] --> Loop 30 
* CEs [29] --> Loop 31 
* CEs [27] --> Loop 32 

#### Loops of isortlist/6 
* Loop 27: isortlist(A,B,C,D,E,F)->  isortlist(A',B',C',D',E',F')
                  [E+B'+2>=B+D,C>=C',B>=B'+1,F'>=0,F>=0,D>=3,C>=0,B>=0,A>=2,B+E'=E+B',D=D'+1,A=A'+1] 
* Loop 28: isortlist(A,B,C,D,E,F)->  isortlist(A',B',C',D',E',F')
                  [F+C'>=C,E+2*B'>=2*B+1,C>=C',B>=B'+2,D>=3,C>=0,B>=0,A>=2,C+F'=F+C',B+E'=E+B',D=D'+1,A=A'+1] 
* Loop 29: isortlist(A,B,C,D,E,F)->  isortlist(A',B',C',D',E',F')
                  [F+C'>=C+1,E+B'>=B+2,C>=C',B>=B'+2,D>=3,C>=0,B>=0,A>=2,C+F'=F+C',B+E'=E+B',D=D'+1,A=A'+1] 
* Loop 30: isortlist(A,B,C,D,E,F)->  isortlist(A',B',C',D',E',F')
                  [F+C'>=C,C>=C',E>=3,D>=3,C>=0,B>=0,A>=2,C+F'=F+C',E=E'+1,D=D'+1,B=B'+1,A=A'+1] 
* Loop 31: isortlist(A,B,C,D,E,F)->  isortlist(A',B',C',D',E',F')
                  [C>=C',F'>=0,F>=0,E>=1,C>=0,B>=0,A>=2,B=E+B',A=A'+1,E'=0,D'=1,D=2] 
* Loop 32: isortlist(A,B,C,D,E,F) [F>=0,C>=0,E=0,D=1,B=0,A=1] 

### Ranking functions of CR isortlist(A,B,C,D,E,F) 
* RF of phase [27,28,29,30]: [A-1,B+1]

#### Partial ranking functions of CR isortlist(A,B,C,D,E,F) 
* Partial RF of phase [27,28,29,30]:
  - RF of loop [27:1,28:1,29:1,30:1]:
    A-1
  - RF of loop [27:1,30:1]:
    B+1
  - RF of loop [28:1,29:1]:
    B/2+1/2

Discarded unfeasible chain [[27,28,29,30]]...(Non-terminating chain proved terminating)

### Resulting Chains:isortlist(A,B,C,D,E,F) 
* [[27,28,29,30],31,32]
* [32]
* [31,32]


### Merging Chains  isortlist/6 into  External patterns of execution 
* [[32]] --> 1 
* [[32,31]] --> 2 
* [[32,31,[27,28,29,30]]] --> 3 


Computing Bounds
=====================================

#### Simplifying cost structure of CE 14 

#### Simplifying cost structure of CE 13 

#### Cost of chains of and_op(A,B,C):
* Chain [14]: 0
  with precondition: [A=0,C=0,B>=0] 

* Chain [13]: 0
  with precondition: [A=1,C=B,C>=0] 


#### Simplifying cost structure of CE 16 

#### Simplifying cost structure of CE 15 

#### Cost of chains of leq(A,B,C):
* Chain [16]: 0
  with precondition: [C=0,B>=0,A>=B+1] 

* Chain [15]: 0
  with precondition: [C=1,A>=0,B>=A] 


#### Simplifying cost structure of CE 20 

#### Computing cost of phase [19,20] 

#### Simplifying cost structure of CE 18 

#### Simplifying cost structure of CE 17 

#### Cost of loops [19,20] 

 * loop 19:leqL(A,B,C,D,E) -> [leqL(A',B',C',D',E')] 
9
 * loop 20:leqL(A,B,C,D,E) -> [leqL(A',B',C',D',E')] 
9
##### Pending set leqL(A,B,C,D,E)
* Psum in Loop 19: [it(19)=<1]
* Psum in Loop 20: [it(20)=<1]

###### Computing sum for it(19)=<1  in Loop 19 
   - Applying inductive sum strategy 
     - head Candidate: C-1 
       - Loop 20 is collaborative and bounds [it(20)] 
     - head Candidate: A-1 
       - Loop 20 is collaborative and bounds [it(20)] 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - Loop 20 is collaborative and bounds [it(20)] 
     - tail Candidate: A-1 
       - Loop 20 is collaborative and bounds [it(20)] 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(19)+it(20)=<C-1,it(19)+it(20)=<A-1,it(19)+it(20)=<A-1,it(19)+it(20)=<C-1,it(19)+it(20)=<C-C',it(19)+it(20)=<A-A',it(19)+it(20)=<A-A',it(19)+it(20)=<C-C'] 

##### Pending set A
* Psum in Loop 20: [it(20)=<1]

###### Computing sum for it(20)=<1  in Loop 20 
   - Applying inductive sum strategy 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: B 
       - Loop 19 is collaborative
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B 
       - Loop 19 is collaborative
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(19)+it(20)=<C-1,it(19)+it(20)=<A-1,it(19)+it(20)=<A-1,it(20)=<B,it(19)+it(20)=<C-1,it(19)+it(20)=<C-C',it(19)+it(20)=<A-A',it(19)+it(20)=<A-A',it(20)=<B-B',it(19)+it(20)=<C-C'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [19,20] 

#### Simplifying cost structure of phase [19,20] 

#### Cost of phase [19,20]:leqL(A,B,C,D,E) -> [leqL(A',B',C',D',E')] 
9*it(19)+9*it(20)+0
  Such that:it(20) =< B
it(20) =< B-B'
aux(1) =< A
aux(2) =< A-A'
aux(3) =< C
aux(4) =< C-C'
it(19) =< aux(1)
it(20) =< aux(1)
it(19) =< aux(2)
it(20) =< aux(2)
it(19) =< aux(3)
it(20) =< aux(3)
it(19) =< aux(4)
it(20) =< aux(4)

#### Simplifying cost structure of chain [[19,20],18] 
 * Joined equivalent variables [aux(5),aux(1),aux(2),aux(4)] into aux(5)

#### Simplifying cost structure of CE 19 

#### Found solution for phase  [19,20] in the cache 

#### Cost of phase [19,20]:leqL(A,B,C,D,E) -> [leqL(A',B',C',D',E')] 
9*it(19)+9*it(20)+0
  Such that:it(20) =< B
it(20) =< B-B'
aux(1) =< A
aux(2) =< A-A'
aux(3) =< C
aux(4) =< C-C'
it(19) =< aux(1)
it(20) =< aux(1)
it(19) =< aux(2)
it(20) =< aux(2)
it(19) =< aux(3)
it(20) =< aux(3)
it(19) =< aux(4)
it(20) =< aux(4)

#### Simplifying cost structure of chain [[19,20],17] 
 * Joined equivalent variables [aux(6),aux(2),aux(3),aux(4)] into aux(6)

#### Cost of chains of leqL(A,B,C,D,E):
* Chain [[19,20],18]: 9*it(19)+9*it(20)+3
  Such that:it(20) =< B
aux(3) =< C
aux(5) =< A
it(19) =< aux(5)
it(20) =< aux(5)
it(19) =< aux(3)
it(20) =< aux(3)

  with precondition: [1>=E,A>=2,D>=0,E>=0,C>=A,B+E>=1] 

* Chain [[19,20],17]: 9*it(19)+9*it(20)+6
  Such that:aux(1) =< A
it(20) =< B
aux(6) =< C
it(19) =< aux(1)
it(20) =< aux(1)
it(19) =< aux(6)
it(20) =< aux(6)

  with precondition: [E=0,B>=0,C>=2,D>=0,A>=C+1] 

* Chain [18]: 3
  with precondition: [A=1,E=1,B>=0,C>=0,D>=0] 

* Chain [17]: 6
  with precondition: [C=1,E=0,A>=2,B>=0,D>=0] 


#### Simplifying cost structure of CE 21 

#### Computing cost of phase [21,22] 
 * Renamed intermediate variables: 
[ (eq(26,1),it(20))>>s(1), (eq(26,1),aux(3))>>s(2), (eq(26,1),aux(5))>>s(3), (eq(26,1),it(19))>>s(4)]

#### Simplifying cost structure of CE 26 
 * Renamed intermediate variables: 
[ (it(21),s(3))>>s(5), (it(21),s(1))>>s(6), (it(21),s(2))>>s(7), (it(21),s(4))>>s(8)]

#### Simplifying cost structure of CE 25 

#### Cost of loops [21,22] 

 * loop 21:insertL(A,B,C,D,E,F,G,H) -> [insertL(A',B',C',D',E',F',G',H')] 
9*s(6)+9*s(8)+11
  Such that:s(5) =< D-D'
s(6) =< E-E'
s(7) =< A'
s(8) =< s(5)
s(6) =< s(5)
s(8) =< s(7)
s(6) =< s(7)

 * loop 22:insertL(A,B,C,D,E,F,G,H) -> [insertL(A',B',C',D',E',F',G',H')] 
11
##### Pending set insertL(A,B,C,D,E,F,G,H)
* Psum in Loop 21: [it(21)=<1,s(12)=<D-D',s(9)=<E-E',s(11)=<A']
* Psum in Loop 22: [it(22)=<1]

###### Computing sum for it(21)=<1  in Loop 21 
   - Applying inductive sum strategy 
     - head Candidate: C-1 
       - Loop 22 is collaborative and bounds [it(22)] 
     - head Candidate: D 
       - Loop 22 is collaborative and bounds [it(22)] 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: D/2-1/2 
       - Loop 22 is collaborative
     - tail Candidate: C-1 
       - Loop 22 is collaborative and bounds [it(22)] 
     - tail Candidate: D 
       - Loop 22 is collaborative and bounds [it(22)] 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: D/2-1/2 
       - Loop 22 is collaborative
 * Adding constraints: [it(21)+it(22)=<C-1,it(21)+it(22)=<D,it(21)+it(22)=<C-1,it(21)=<D/2-1/2,it(21)+it(22)=<C-C',it(21)+it(22)=<D-D',it(21)+it(22)=<C-C',it(21)=<D/2-D'/2] 

##### Pending set A
* Psum in Loop 21: [s(12)=<D-D',s(9)=<E-E',s(11)=<A']
* Psum in Loop 22: [it(22)=<1]

###### Computing sum for s(12)=<D-D'  in Loop 21 
   - Applying inductive sum strategy 
     - head Candidate: D 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: D 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(22)+s(12)=<D,it(22)+s(12)=<D-D'] 

##### Pending set A
* Psum in Loop 21: [s(9)=<E-E',s(11)=<A']
* Psum in Loop 22: [it(22)=<1]

###### Computing sum for s(9)=<E-E'  in Loop 21 
   - Applying inductive sum strategy 
     - head Candidate: E 
       - Loop 22 is collaborative
     - tail Candidate: E 
       - Loop 22 is collaborative
 * Adding constraints: [s(9)=<E,s(9)=<E-E'] 

##### Pending set A
* Psum in Loop 21: [s(11)=<A']
* Psum in Loop 22: [it(22)=<1]

###### Computing sum for s(11)=<A'  in Loop 21 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(7)=<A] 
 * Adding constraints: [s(11)=<it(21)*aux(7)] 

##### Pending set insertL(A,B,C,D,E,F,G,H)
* Pmax/min: [aux(7)=<A]
* Psum in Loop 22: [it(22)=<1]

###### Computing max_min for aux(7)=<A  
   - Found a solution using transitive invariants 
 * Adding constraints:[aux(7)=<A] 

##### Pending set insertL(A,B,C,D,E,F,G,H)
* Psum in Loop 22: [it(22)=<1]

###### Computing sum for it(22)=<1  in Loop 22 
   - Applying inductive sum strategy 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: D 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: D 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: D 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: D 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(21)+it(22)=<C-1,it(21)+it(22)=<D,it(21)+it(22)=<C-1,it(21)+it(22)=<D,it(21)+it(22)=<C-C',it(21)+it(22)=<D-D',it(21)+it(22)=<C-C',it(21)+it(22)=<D-D'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [21,22] 

#### Simplifying cost structure of phase [21,22] 

#### Cost of phase [21,22]:insertL(A,B,C,D,E,F,G,H) -> [insertL(A',B',C',D',E',F',G',H')] 
11*it(21)+11*it(22)+9*s(9)+9*s(10)+0
  Such that:aux(7) =< A
it(21) =< D/2
it(21) =< D/2-D'/2
s(9) =< E
s(9) =< E-E'
aux(8) =< C
aux(9) =< C-C'
aux(10) =< D
aux(11) =< D-D'
it(21) =< aux(8)
it(22) =< aux(8)
it(21) =< aux(9)
it(22) =< aux(9)
it(21) =< aux(10)
it(22) =< aux(10)
s(12) =< aux(10)
it(21) =< aux(11)
it(22) =< aux(11)
s(12) =< aux(11)
s(11) =< it(21)*aux(7)
s(10) =< s(12)
s(9) =< s(12)
s(10) =< s(11)
s(9) =< s(11)

#### Simplifying cost structure of chain [[21,22],26] 
 * Joined equivalent variables [aux(12),aux(8)] into aux(12)
 * Joined equivalent variables [aux(13),aux(10),aux(11)] into aux(13)
 * Joined equivalent variables [aux(13),s(12)] into aux(13)

#### Simplifying cost structure of CE 24 

#### Found solution for phase  [21,22] in the cache 

#### Cost of phase [21,22]:insertL(A,B,C,D,E,F,G,H) -> [insertL(A',B',C',D',E',F',G',H')] 
11*it(21)+11*it(22)+9*s(9)+9*s(10)+0
  Such that:aux(7) =< A
it(21) =< D/2
it(21) =< D/2-D'/2
s(9) =< E
s(9) =< E-E'
aux(8) =< C
aux(9) =< C-C'
aux(10) =< D
aux(11) =< D-D'
it(21) =< aux(8)
it(22) =< aux(8)
it(21) =< aux(9)
it(22) =< aux(9)
it(21) =< aux(10)
it(22) =< aux(10)
s(12) =< aux(10)
it(21) =< aux(11)
it(22) =< aux(11)
s(12) =< aux(11)
s(11) =< it(21)*aux(7)
s(10) =< s(12)
s(9) =< s(12)
s(10) =< s(11)
s(9) =< s(11)

#### Simplifying cost structure of chain [[21,22],25] 
 * Joined equivalent variables [aux(14),aux(10),aux(11)] into aux(14)
 * Joined equivalent variables [aux(15),aux(8),aux(9)] into aux(15)
 * Joined equivalent variables [aux(14),s(12)] into aux(14)
 * Renamed intermediate variables: 
[ (eq(23,1),it(20))>>s(13), (eq(23,1),aux(3))>>s(14), (eq(23,1),aux(5))>>s(15), (eq(23,1),it(19))>>s(16)]

#### Simplifying cost structure of CE 23 
 * Joined equivalent variables [aux(16),s(14)] into aux(16)

#### Found solution for phase  [21,22] in the cache 

#### Cost of phase [21,22]:insertL(A,B,C,D,E,F,G,H) -> [insertL(A',B',C',D',E',F',G',H')] 
11*it(21)+11*it(22)+9*s(9)+9*s(10)+0
  Such that:aux(7) =< A
it(21) =< D/2
it(21) =< D/2-D'/2
s(9) =< E
s(9) =< E-E'
aux(8) =< C
aux(9) =< C-C'
aux(10) =< D
aux(11) =< D-D'
it(21) =< aux(8)
it(22) =< aux(8)
it(21) =< aux(9)
it(22) =< aux(9)
it(21) =< aux(10)
it(22) =< aux(10)
s(12) =< aux(10)
it(21) =< aux(11)
it(22) =< aux(11)
s(12) =< aux(11)
s(11) =< it(21)*aux(7)
s(10) =< s(12)
s(9) =< s(12)
s(10) =< s(11)
s(9) =< s(11)

#### Simplifying cost structure of chain [[21,22],24] 
 * Joined equivalent variables [aux(17),aux(10),aux(11)] into aux(17)
 * Joined equivalent variables [aux(18),aux(7),aux(16)] into aux(18)
 * Joined equivalent variables [aux(19),aux(8)] into aux(19)
 * Joined equivalent variables [aux(17),s(12)] into aux(17)
 * Renamed intermediate variables: 
[ (eq(22,1),aux(1))>>s(17), (eq(22,1),it(20))>>s(18), (eq(22,1),aux(6))>>s(19), (eq(22,1),it(19))>>s(20)]

#### Simplifying cost structure of CE 22 

#### Found solution for phase  [21,22] in the cache 

#### Cost of phase [21,22]:insertL(A,B,C,D,E,F,G,H) -> [insertL(A',B',C',D',E',F',G',H')] 
11*it(21)+11*it(22)+9*s(9)+9*s(10)+0
  Such that:aux(7) =< A
it(21) =< D/2
it(21) =< D/2-D'/2
s(9) =< E
s(9) =< E-E'
aux(8) =< C
aux(9) =< C-C'
aux(10) =< D
aux(11) =< D-D'
it(21) =< aux(8)
it(22) =< aux(8)
it(21) =< aux(9)
it(22) =< aux(9)
it(21) =< aux(10)
it(22) =< aux(10)
s(12) =< aux(10)
it(21) =< aux(11)
it(22) =< aux(11)
s(12) =< aux(11)
s(11) =< it(21)*aux(7)
s(10) =< s(12)
s(9) =< s(12)
s(10) =< s(11)
s(9) =< s(11)

#### Simplifying cost structure of chain [[21,22],23] 
 * Joined equivalent variables [aux(21),aux(10),s(17)] into aux(21)
 * Joined equivalent variables [aux(22),aux(7),s(19)] into aux(22)
 * Joined equivalent variables [aux(23),aux(8)] into aux(23)
 * Renamed intermediate variables: 
[ (ch([[21,22],26]),aux(7))>>s(21), (ch([[21,22],26]),s(9))>>s(22), (ch([[21,22],26]),it(21))>>s(23), (ch([[21,22],26]),aux(12))>>s(24), (ch([[21,22],26]),aux(13))>>s(25), (ch([[21,22],26]),aux(9))>>s(26), (ch([[21,22],26]),it(22))>>s(27), (ch([[21,22],26]),s(11))>>s(28), (ch([[21,22],26]),s(10))>>s(29)]
 * Renamed intermediate variables: 
[ (ch([24]),s(15))>>s(30), (ch([24]),s(13))>>s(31), (ch([24]),aux(16))>>s(32), (ch([24]),s(16))>>s(33)]
 * Renamed intermediate variables: 
[ (ch([[21,22],24]),it(21))>>s(34), (ch([[21,22],24]),aux(17))>>s(35), (ch([[21,22],24]),aux(18))>>s(36), (ch([[21,22],24]),aux(19))>>s(37), (ch([[21,22],24]),aux(20))>>s(38), (ch([[21,22],24]),aux(9))>>s(39), (ch([[21,22],24]),s(15))>>s(40), (ch([[21,22],24]),s(9))>>s(41), (ch([[21,22],24]),s(13))>>s(42), (ch([[21,22],24]),s(16))>>s(43), (ch([[21,22],24]),it(22))>>s(44), (ch([[21,22],24]),s(11))>>s(45), (ch([[21,22],24]),s(10))>>s(46)]
 * Joined equivalent variables [aux(25),s(32),s(36)] into aux(25)
 * Joined equivalent variables [aux(26),s(38)] into aux(26)
 * Renamed intermediate variables: 
[ (ch([23]),s(19))>>s(47), (ch([23]),s(17))>>s(48), (ch([23]),s(18))>>s(49), (ch([23]),s(20))>>s(50)]
 * Renamed intermediate variables: 
[ (ch([[21,22],23]),aux(11))>>s(51), (ch([[21,22],23]),it(21))>>s(52), (ch([[21,22],23]),aux(21))>>s(53), (ch([[21,22],23]),aux(22))>>s(54), (ch([[21,22],23]),aux(23))>>s(55), (ch([[21,22],23]),aux(24))>>s(56), (ch([[21,22],23]),aux(9))>>s(57), (ch([[21,22],23]),s(9))>>s(58), (ch([[21,22],23]),s(18))>>s(59), (ch([[21,22],23]),s(20))>>s(60), (ch([[21,22],23]),it(22))>>s(61), (ch([[21,22],23]),s(12))>>s(62), (ch([[21,22],23]),s(11))>>s(63), (ch([[21,22],23]),s(10))>>s(64)]
 * Joined equivalent variables [aux(27),s(47),s(54)] into aux(27)
 * Joined equivalent variables [aux(28),s(56)] into aux(28)

#### Cost of chains of insertL(A,B,C,D,E,F,G,H):
* Chain [[21,22],26]: 11*it(21)+11*it(22)+9*s(9)+9*s(10)+15
  Such that:aux(7) =< 1
s(9) =< E
it(21) =< G/2
aux(12) =< C
aux(13) =< G
aux(9) =< aux(12)
aux(9) =< aux(13)
it(21) =< aux(12)
it(22) =< aux(12)
it(21) =< aux(9)
it(22) =< aux(9)
it(21) =< aux(13)
it(22) =< aux(13)
s(11) =< it(21)*aux(7)
s(10) =< aux(13)
s(9) =< aux(13)
s(10) =< s(11)
s(9) =< s(11)

  with precondition: [A=1,C+1=F,D+1=G,B+E=H,B>=0,C>=3,D>=3,H>=B] 

* Chain [[21,22],25]: 11*it(21)+11*it(22)+9*s(9)+9*s(10)+4
  Such that:aux(7) =< A
it(21) =< -A/2+G/2
s(9) =< E
s(9) =< H
aux(14) =< -A+G
aux(15) =< F
it(21) =< aux(15)
it(22) =< aux(15)
it(21) =< aux(14)
it(22) =< aux(14)
s(11) =< it(21)*aux(7)
s(10) =< aux(14)
s(9) =< aux(14)
s(10) =< s(11)
s(9) =< s(11)

  with precondition: [C+1=F,A+D=G,A>=0,B>=0,C>=2,E>=0,H>=0,D+1>=C] 

* Chain [[21,22],24]: 11*it(21)+11*it(22)+9*s(9)+9*s(10)+9*s(13)+9*s(16)+12
  Such that:it(21) =< -A/2+G/2
aux(17) =< -A+G
aux(18) =< A
aux(19) =< C
aux(20) =< E
aux(9) =< aux(17)
it(21) =< aux(17)
s(15) =< aux(17)
aux(9) =< aux(19)
s(9) =< aux(20)
s(13) =< aux(20)
s(15) =< aux(18)
s(16) =< s(15)
s(13) =< s(15)
s(16) =< aux(18)
s(13) =< aux(18)
it(21) =< aux(19)
it(22) =< aux(19)
it(21) =< aux(9)
it(22) =< aux(9)
it(22) =< aux(17)
s(11) =< it(21)*aux(18)
s(10) =< aux(17)
s(9) =< aux(17)
s(10) =< s(11)
s(9) =< s(11)

  with precondition: [C+1=F,A+D=G,B+E=H,A>=2,B>=0,C>=3,D>=3,H>=B+1] 

* Chain [[21,22],23]: 11*it(21)+11*it(22)+9*s(9)+9*s(10)+9*s(18)+9*s(20)+15
  Such that:aux(11) =< -2*A+G
it(21) =< -A+G/2
aux(21) =< -A+G
aux(22) =< A
aux(23) =< C
aux(24) =< E
aux(9) =< aux(21)
aux(11) =< aux(21)
it(21) =< aux(21)
aux(9) =< aux(23)
s(9) =< aux(24)
s(18) =< aux(24)
s(20) =< aux(21)
s(18) =< aux(21)
s(20) =< aux(22)
s(18) =< aux(22)
it(21) =< aux(23)
it(22) =< aux(23)
it(21) =< aux(9)
it(22) =< aux(9)
it(22) =< aux(21)
s(12) =< aux(21)
it(21) =< aux(11)
it(22) =< aux(11)
s(12) =< aux(11)
s(11) =< it(21)*aux(22)
s(10) =< s(12)
s(9) =< s(12)
s(10) =< s(11)
s(9) =< s(11)

  with precondition: [C+1=F,A+D=G,B+E=H,A>=2,B>=0,C>=3,D>=A+2,H>=B] 

* Chain [26]: 15
  with precondition: [A=1,C+1=F,D+1=G,B+E=H,B>=0,C>=2,D>=2,E>=0] 

* Chain [25]: 4
  with precondition: [C=1,D=0,F=2,A=G,A>=1,B>=0,E>=0,H>=0] 

* Chain [24]: 9*s(13)+9*s(16)+12
  Such that:s(15) =< D
s(13) =< E
aux(16) =< A
s(15) =< aux(16)
s(16) =< s(15)
s(13) =< s(15)
s(16) =< aux(16)
s(13) =< aux(16)

  with precondition: [C+1=F,A+D=G,B+E=H,A>=2,B>=0,C>=2,D>=2,E>=1] 

* Chain [23]: 9*s(18)+9*s(20)+15
  Such that:s(19) =< A
s(17) =< D
s(18) =< E
s(20) =< s(17)
s(18) =< s(17)
s(20) =< s(19)
s(18) =< s(19)

  with precondition: [C+1=F,A+D=G,B+E=H,A>=2,B>=0,C>=2,E>=0,D>=A+1] 


#### Simplifying cost structure of CE 27 

#### Simplifying cost structure of CE 29 

#### Simplifying cost structure of chain [31,32] 

#### Computing cost of phase [27,28,29,30] 
 * Renamed intermediate variables: 
[ (eq(32,1),aux(7))>>s(65), (eq(32,1),it(21))>>s(66), (eq(32,1),s(9))>>s(67), (eq(32,1),aux(14))>>s(68), (eq(32,1),aux(15))>>s(69), (eq(32,1),it(22))>>s(70), (eq(32,1),s(11))>>s(71), (eq(32,1),s(10))>>s(72)]

#### Simplifying cost structure of CE 32 
 * Joined equivalent variables [s(67),s(72)] into s(67)
 * Renamed intermediate variables: 
[ (it(27),s(69))>>s(73), (it(27),s(65))>>s(74), (it(27),s(68))>>s(75), (it(27),s(66))>>s(76), (it(27),s(70))>>s(77), (it(27),s(71))>>s(78), (it(27),s(67))>>s(79)]
 * Renamed intermediate variables: 
[ (eq(31,1),s(51))>>s(80), (eq(31,1),s(53))>>s(81), (eq(31,1),s(52))>>s(82), (eq(31,1),s(55))>>s(83), (eq(31,1),s(48))>>s(84), (eq(31,1),aux(27))>>s(85), (eq(31,1),aux(28))>>s(86), (eq(31,1),s(49))>>s(87), (eq(31,1),s(57))>>s(88), (eq(31,1),s(58))>>s(89), (eq(31,1),s(59))>>s(90), (eq(31,1),s(60))>>s(91), (eq(31,1),s(61))>>s(92), (eq(31,1),s(62))>>s(93), (eq(31,1),s(63))>>s(94), (eq(31,1),s(64))>>s(95), (eq(31,1),s(50))>>s(96)]

#### Simplifying cost structure of CE 31 
 * Joined equivalent variables [aux(29),s(81),s(84)] into aux(29)
 * Joined equivalent variables [s(91),s(96)] into s(91)
 * Joined equivalent variables [s(87),s(90)] into s(87)
 * Renamed intermediate variables: 
[ (it(28),s(83))>>s(97), (it(28),s(80))>>s(98), (it(28),s(85))>>s(99), (it(28),s(82))>>s(100), (it(28),aux(29))>>s(101), (it(28),s(88))>>s(102), (it(28),s(91))>>s(103), (it(28),s(87))>>s(104), (it(28),s(92))>>s(105), (it(28),s(93))>>s(106), (it(28),s(94))>>s(107), (it(28),s(95))>>s(108), (it(28),s(89))>>s(109)]
 * Renamed intermediate variables: 
[ (eq(30,1),s(35))>>s(110), (eq(30,1),s(34))>>s(111), (eq(30,1),s(37))>>s(112), (eq(30,1),s(30))>>s(113), (eq(30,1),aux(25))>>s(114), (eq(30,1),aux(26))>>s(115), (eq(30,1),s(31))>>s(116), (eq(30,1),s(39))>>s(117), (eq(30,1),s(40))>>s(118), (eq(30,1),s(41))>>s(119), (eq(30,1),s(42))>>s(120), (eq(30,1),s(43))>>s(121), (eq(30,1),s(44))>>s(122), (eq(30,1),s(45))>>s(123), (eq(30,1),s(46))>>s(124), (eq(30,1),s(33))>>s(125)]

#### Simplifying cost structure of CE 30 
 * Joined equivalent variables [aux(30),s(110)] into aux(30)
 * Joined equivalent variables [s(113),s(118)] into s(113)
 * Joined equivalent variables [s(121),s(125)] into s(121)
 * Joined equivalent variables [s(116),s(120)] into s(116)
 * Renamed intermediate variables: 
[ (it(29),s(112))>>s(126), (it(29),s(114))>>s(127), (it(29),s(111))>>s(128), (it(29),aux(30))>>s(129), (it(29),s(113))>>s(130), (it(29),s(117))>>s(131), (it(29),s(121))>>s(132), (it(29),s(116))>>s(133), (it(29),s(122))>>s(134), (it(29),s(123))>>s(135), (it(29),s(124))>>s(136), (it(29),s(119))>>s(137)]
 * Renamed intermediate variables: 
[ (eq(28,1),s(21))>>s(138), (eq(28,1),s(24))>>s(139), (eq(28,1),s(22))>>s(140), (eq(28,1),s(25))>>s(141), (eq(28,1),s(23))>>s(142), (eq(28,1),s(26))>>s(143), (eq(28,1),s(27))>>s(144), (eq(28,1),s(28))>>s(145), (eq(28,1),s(29))>>s(146)]

#### Simplifying cost structure of CE 28 
 * Joined equivalent variables [s(140),s(146)] into s(140)
 * Renamed intermediate variables: 
[ (it(30),s(138))>>s(147), (it(30),s(139))>>s(148), (it(30),s(141))>>s(149), (it(30),s(142))>>s(150), (it(30),s(143))>>s(151), (it(30),s(144))>>s(152), (it(30),s(145))>>s(153), (it(30),s(140))>>s(154)]

#### Cost of loops [27,28,29,30] 

 * loop 27:isortlist(A,B,C,D,E,F) -> [isortlist(A',B',C',D',E',F')] 
11*s(76)+18*s(79)+11*s(77)+9
  Such that:s(73) =< A
s(74) =< B-B'
s(75) =< B'
s(76) =< B'/2
s(76) =< s(73)
s(77) =< s(73)
s(76) =< s(75)
s(77) =< s(75)
s(78) =< s(76)*s(74)
s(79) =< s(75)
s(79) =< s(78)

 * loop 28:isortlist(A,B,C,D,E,F) -> [isortlist(A',B',C',D',E',F')] 
11*s(100)+18*s(104)+9*s(109)+18*s(103)+11*s(105)+9*s(108)+20
  Such that:s(97) =< A
s(98) =< -B+2*B'
s(99) =< B-B'
s(100) =< -B/2+B'
s(101) =< B'
s(102) =< s(101)
s(98) =< s(101)
s(100) =< s(101)
s(102) =< s(97)
s(103) =< s(101)
s(104) =< s(101)
s(103) =< s(99)
s(104) =< s(99)
s(100) =< s(97)
s(105) =< s(97)
s(100) =< s(102)
s(105) =< s(102)
s(105) =< s(101)
s(106) =< s(101)
s(100) =< s(98)
s(105) =< s(98)
s(106) =< s(98)
s(107) =< s(100)*s(99)
s(108) =< s(106)
s(109) =< s(106)
s(108) =< s(107)
s(109) =< s(107)

 * loop 29:isortlist(A,B,C,D,E,F) -> [isortlist(A',B',C',D',E',F')] 
11*s(128)+18*s(133)+9*s(137)+18*s(132)+11*s(134)+9*s(136)+17
  Such that:s(126) =< A
s(127) =< B-B'
s(128) =< B'/2
s(129) =< B'
s(130) =< s(129)
s(131) =< s(129)
s(128) =< s(129)
s(131) =< s(126)
s(130) =< s(127)
s(132) =< s(130)
s(133) =< s(130)
s(132) =< s(127)
s(133) =< s(127)
s(128) =< s(126)
s(134) =< s(126)
s(128) =< s(131)
s(134) =< s(131)
s(134) =< s(129)
s(135) =< s(128)*s(127)
s(136) =< s(129)
s(137) =< s(129)
s(136) =< s(135)
s(137) =< s(135)

 * loop 30:isortlist(A,B,C,D,E,F) -> [isortlist(A',B',C',D',E',F')] 
18*s(154)+11*s(150)+11*s(152)+20
  Such that:s(147) =< 1
s(148) =< A
s(149) =< B
s(150) =< B/2
s(151) =< s(148)
s(151) =< s(149)
s(150) =< s(148)
s(152) =< s(148)
s(150) =< s(151)
s(152) =< s(151)
s(150) =< s(149)
s(152) =< s(149)
s(153) =< s(150)*s(147)
s(154) =< s(149)
s(154) =< s(153)

##### Pending set isortlist(A,B,C,D,E,F)
* Pmax/min: [s(147)=<1,s(127)=<B-2,s(74)=<B-1,s(99)=<B/2-1/2]
* Psum in Loop 27: [it(27)=<1,s(160)=<A,s(159)=<B',s(155)=<B'/2]
* Psum in Loop 28: [it(28)=<1,s(172)=<A,s(169)=< -B+2*B',s(173)=<B-B',s(161)=< -B/2+B',s(170)=<B']
* Psum in Loop 29: [it(29)=<1,s(183)=<A,s(184)=<B-B',s(181)=<B',s(174)=<B'/2]
* Psum in Loop 30: [it(30)=<1,s(192)=<A,s(190)=<B,s(187)=<B/2]

###### Computing max_min for s(147)=<1  
 * Adding constraints:[s(147)=<1] 

##### Pending set isortlist(A,B,C,D,E,F)
* Pmax/min: [s(127)=<B-2,s(74)=<B-1,s(99)=<B/2-1/2]
* Psum in Loop 27: [it(27)=<1,s(160)=<A,s(159)=<B',s(155)=<B'/2]
* Psum in Loop 28: [it(28)=<1,s(172)=<A,s(169)=< -B+2*B',s(173)=<B-B',s(161)=< -B/2+B',s(170)=<B']
* Psum in Loop 29: [it(29)=<1,s(183)=<A,s(184)=<B-B',s(181)=<B',s(174)=<B'/2]
* Psum in Loop 30: [it(30)=<1,s(192)=<A,s(190)=<B,s(187)=<B/2]

###### Computing max_min for s(127)=<B-2  
   - Found a solution using transitive invariants 
 * Adding constraints:[s(127)=<B-2] 

##### Pending set isortlist(A,B,C,D,E,F)
* Pmax/min: [s(74)=<B-1,s(99)=<B/2-1/2]
* Psum in Loop 27: [it(27)=<1,s(160)=<A,s(159)=<B',s(155)=<B'/2]
* Psum in Loop 28: [it(28)=<1,s(172)=<A,s(169)=< -B+2*B',s(173)=<B-B',s(161)=< -B/2+B',s(170)=<B']
* Psum in Loop 29: [it(29)=<1,s(183)=<A,s(184)=<B-B',s(181)=<B',s(174)=<B'/2]
* Psum in Loop 30: [it(30)=<1,s(192)=<A,s(190)=<B,s(187)=<B/2]

###### Computing max_min for s(74)=<B-1  
   - Found a solution using cacheing 
 * Adding constraints:[s(74)=<s(127)+1] 

##### Pending set isortlist(A,B,C,D,E,F)
* Pmax/min: [s(99)=<B/2-1/2]
* Psum in Loop 27: [it(27)=<1,s(160)=<A,s(159)=<B',s(155)=<B'/2]
* Psum in Loop 28: [it(28)=<1,s(172)=<A,s(169)=< -B+2*B',s(173)=<B-B',s(161)=< -B/2+B',s(170)=<B']
* Psum in Loop 29: [it(29)=<1,s(183)=<A,s(184)=<B-B',s(181)=<B',s(174)=<B'/2]
* Psum in Loop 30: [it(30)=<1,s(192)=<A,s(190)=<B,s(187)=<B/2]

###### Computing max_min for s(99)=<B/2-1/2  
   - Found a solution using cacheing 
 * Adding constraints:[s(99)=<s(127)* (1/2)+1/2] 

##### Pending set isortlist(A,B,C,D,E,F)
* Psum in Loop 27: [it(27)=<1,s(160)=<A,s(159)=<B',s(155)=<B'/2]
* Psum in Loop 28: [it(28)=<1,s(172)=<A,s(169)=< -B+2*B',s(173)=<B-B',s(161)=< -B/2+B',s(170)=<B']
* Psum in Loop 29: [it(29)=<1,s(183)=<A,s(184)=<B-B',s(181)=<B',s(174)=<B'/2]
* Psum in Loop 30: [it(30)=<1,s(192)=<A,s(190)=<B,s(187)=<B/2]

###### Computing sum for it(27)=<1  in Loop 27 
   - Applying inductive sum strategy 
     - head Candidate: A-1 
       - Loop 28 is collaborative and bounds [it(28)] 
       - Loop 29 is collaborative and bounds [it(29)] 
       - Loop 30 is collaborative and bounds [it(30)] 
     - head Candidate: B+1 
       - Loop 28 is collaborative and bounds [it(28)] 
       - Loop 29 is collaborative and bounds [it(29)] 
       - Loop 30 is collaborative and bounds [it(30)] 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: B+1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
       - Loop 28 is collaborative and bounds [it(28)] 
       - Loop 29 is collaborative and bounds [it(29)] 
       - Loop 30 is collaborative and bounds [it(30)] 
     - tail Candidate: B+1 
       - Loop 28 is collaborative and bounds [it(28)] 
       - Loop 29 is collaborative and bounds [it(29)] 
       - Loop 30 is collaborative and bounds [it(30)] 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B+1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(27)+it(28)+it(29)+it(30)=<A-1,it(27)+it(28)+it(29)+it(30)=<B+1,it(27)+it(28)+it(29)+it(30)=<A-1,it(27)+it(28)+it(29)+it(30)=<B+1,it(27)+it(28)+it(29)+it(30)=<A-A',it(27)+it(28)+it(29)+it(30)=<B-B',it(27)+it(28)+it(29)+it(30)=<A-A',it(27)+it(28)+it(29)+it(30)=<B-B'] 

##### Pending set isortlist(A,B,C,D,E,F)
* Psum in Loop 27: [s(160)=<A,s(159)=<B',s(155)=<B'/2]
* Psum in Loop 28: [it(28)=<1,s(172)=<A,s(169)=< -B+2*B',s(173)=<B-B',s(161)=< -B/2+B',s(170)=<B']
* Psum in Loop 29: [it(29)=<1,s(183)=<A,s(184)=<B-B',s(181)=<B',s(174)=<B'/2]
* Psum in Loop 30: [it(30)=<1,s(192)=<A,s(190)=<B,s(187)=<B/2]

###### Computing sum for s(160)=<A  in Loop 27 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(31)=<A] 
 * Adding constraints: [s(160)=<it(27)*aux(31)] 

##### Pending set isortlist(A,B,C,D,E,F)
* Pmax/min: [aux(31)=<A]
* Psum in Loop 27: [s(159)=<B',s(155)=<B'/2]
* Psum in Loop 28: [it(28)=<1,s(172)=<A,s(169)=< -B+2*B',s(173)=<B-B',s(161)=< -B/2+B',s(170)=<B']
* Psum in Loop 29: [it(29)=<1,s(183)=<A,s(184)=<B-B',s(181)=<B',s(174)=<B'/2]
* Psum in Loop 30: [it(30)=<1,s(192)=<A,s(190)=<B,s(187)=<B/2]

###### Computing max_min for aux(31)=<A  
   - Found a solution using transitive invariants 
 * Adding constraints:[aux(31)=<A] 

##### Pending set isortlist(A,B,C,D,E,F)
* Psum in Loop 27: [s(159)=<B',s(155)=<B'/2]
* Psum in Loop 28: [it(28)=<1,s(172)=<A,s(169)=< -B+2*B',s(173)=<B-B',s(161)=< -B/2+B',s(170)=<B']
* Psum in Loop 29: [it(29)=<1,s(183)=<A,s(184)=<B-B',s(181)=<B',s(174)=<B'/2]
* Psum in Loop 30: [it(30)=<1,s(192)=<A,s(190)=<B,s(187)=<B/2]

###### Computing sum for s(159)=<B'  in Loop 27 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(32)=<B-1] 
 * Adding constraints: [s(159)=<it(27)*aux(32)] 

##### Pending set isortlist(A,B,C,D,E,F)
* Pmax/min: [aux(32)=<B-1]
* Psum in Loop 27: [s(155)=<B'/2]
* Psum in Loop 28: [it(28)=<1,s(172)=<A,s(169)=< -B+2*B',s(173)=<B-B',s(161)=< -B/2+B',s(170)=<B']
* Psum in Loop 29: [it(29)=<1,s(183)=<A,s(184)=<B-B',s(181)=<B',s(174)=<B'/2]
* Psum in Loop 30: [it(30)=<1,s(192)=<A,s(190)=<B,s(187)=<B/2]

###### Computing max_min for aux(32)=<B-1  
   - Found a solution using cacheing 
 * Adding constraints:[aux(32)=<s(127)+1] 

##### Pending set isortlist(A,B,C,D,E,F)
* Psum in Loop 27: [s(155)=<B'/2]
* Psum in Loop 28: [it(28)=<1,s(172)=<A,s(169)=< -B+2*B',s(173)=<B-B',s(161)=< -B/2+B',s(170)=<B']
* Psum in Loop 29: [it(29)=<1,s(183)=<A,s(184)=<B-B',s(181)=<B',s(174)=<B'/2]
* Psum in Loop 30: [it(30)=<1,s(192)=<A,s(190)=<B,s(187)=<B/2]

###### Computing sum for s(155)=<B'/2  in Loop 27 
   - Found a solution using cacheing 
 * Adding constraints: [s(155)=<aux(33)* (1/2),aux(33)=<it(27)*aux(32)] 

##### Pending set isortlist(A,B,C,D,E,F)
* Psum in Loop 28: [it(28)=<1,s(172)=<A,s(169)=< -B+2*B',s(173)=<B-B',s(161)=< -B/2+B',s(170)=<B']
* Psum in Loop 29: [it(29)=<1,s(183)=<A,s(184)=<B-B',s(181)=<B',s(174)=<B'/2]
* Psum in Loop 30: [it(30)=<1,s(192)=<A,s(190)=<B,s(187)=<B/2]

###### Computing sum for it(28)=<1  in Loop 28 
   - Applying inductive sum strategy 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: B+1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: B/2+1/2 
       - Loop 27 is collaborative
       - Loop 29 is collaborative and bounds [it(29)] 
       - Loop 30 is collaborative
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B+1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B/2+1/2 
       - Loop 27 is collaborative
       - Loop 29 is collaborative and bounds [it(29)] 
       - Loop 30 is collaborative
 * Adding constraints: [it(27)+it(28)+it(29)+it(30)=<A-1,it(27)+it(28)+it(29)+it(30)=<B+1,it(27)+it(28)+it(29)+it(30)=<A-1,it(28)+it(29)=<B/2+1/2,it(27)+it(28)+it(29)+it(30)=<A-A',it(27)+it(28)+it(29)+it(30)=<B-B',it(27)+it(28)+it(29)+it(30)=<A-A',it(28)+it(29)=<B/2-B'/2] 

##### Pending set isortlist(A,B,C,D,E,F)
* Psum in Loop 28: [s(172)=<A,s(169)=< -B+2*B',s(173)=<B-B',s(161)=< -B/2+B',s(170)=<B']
* Psum in Loop 29: [it(29)=<1,s(183)=<A,s(184)=<B-B',s(181)=<B',s(174)=<B'/2]
* Psum in Loop 30: [it(30)=<1,s(192)=<A,s(190)=<B,s(187)=<B/2]

###### Computing sum for s(172)=<A  in Loop 28 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(34)=<A] 
 * Adding constraints: [s(172)=<it(28)*aux(34)] 

##### Pending set isortlist(A,B,C,D,E,F)
* Pmax/min: [aux(34)=<A]
* Psum in Loop 28: [s(169)=< -B+2*B',s(173)=<B-B',s(161)=< -B/2+B',s(170)=<B']
* Psum in Loop 29: [it(29)=<1,s(183)=<A,s(184)=<B-B',s(181)=<B',s(174)=<B'/2]
* Psum in Loop 30: [it(30)=<1,s(192)=<A,s(190)=<B,s(187)=<B/2]

###### Computing max_min for aux(34)=<A  
   - Found a solution using cacheing 
 * Adding constraints:[aux(34)=<aux(31)] 

##### Pending set isortlist(A,B,C,D,E,F)
* Psum in Loop 28: [s(169)=< -B+2*B',s(173)=<B-B',s(161)=< -B/2+B',s(170)=<B']
* Psum in Loop 29: [it(29)=<1,s(183)=<A,s(184)=<B-B',s(181)=<B',s(174)=<B'/2]
* Psum in Loop 30: [it(30)=<1,s(192)=<A,s(190)=<B,s(187)=<B/2]

###### Computing sum for s(169)=< -B+2*B'  in Loop 28 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(35)=<B-4] 
 * Adding constraints: [s(169)=<it(28)*aux(35)] 

##### Pending set isortlist(A,B,C,D,E,F)
* Pmax/min: [aux(35)=<B-4]
* Psum in Loop 28: [s(173)=<B-B',s(161)=< -B/2+B',s(170)=<B']
* Psum in Loop 29: [it(29)=<1,s(183)=<A,s(184)=<B-B',s(181)=<B',s(174)=<B'/2]
* Psum in Loop 30: [it(30)=<1,s(192)=<A,s(190)=<B,s(187)=<B/2]

###### Computing max_min for aux(35)=<B-4  
   - Found a solution using cacheing 
 * Adding constraints:[aux(35)=<s(127)-2] 

##### Pending set isortlist(A,B,C,D,E,F)
* Psum in Loop 28: [s(173)=<B-B',s(161)=< -B/2+B',s(170)=<B']
* Psum in Loop 29: [it(29)=<1,s(183)=<A,s(184)=<B-B',s(181)=<B',s(174)=<B'/2]
* Psum in Loop 30: [it(30)=<1,s(192)=<A,s(190)=<B,s(187)=<B/2]

###### Computing sum for s(173)=<B-B'  in Loop 28 
   - Applying inductive sum strategy 
     - head Candidate: -2*A+2*B+2 
       - Loop 27 is collaborative
       - Loop 29 is collaborative and bounds [it(29)] 
       - Loop 30 is collaborative
     - head Candidate: B-1 
       - Loop 27 is collaborative
       - Loop 29 is collaborative and bounds [it(29)] 
       - Loop 30 is collaborative and bounds [it(30)] 
     - tail Candidate: -2*A+2*B+2 
       - Loop 27 is collaborative
       - Loop 29 is collaborative and bounds [it(29)] 
       - Loop 30 is collaborative
     - tail Candidate: B-1 
       - Loop 27 is collaborative
       - Loop 29 is collaborative and bounds [it(29)] 
       - Loop 30 is collaborative and bounds [it(30)] 
 * Adding constraints: [it(29)+s(173)=< -2*A+2*B+2,it(29)+it(30)+s(173)=<B-1,it(29)+s(173)=< -2*A+2*B+2*A'-2*B',it(29)+it(30)+s(173)=<B-B'] 

##### Pending set isortlist(A,B,C,D,E,F)
* Psum in Loop 28: [s(161)=< -B/2+B',s(170)=<B']
* Psum in Loop 29: [it(29)=<1,s(183)=<A,s(184)=<B-B',s(181)=<B',s(174)=<B'/2]
* Psum in Loop 30: [it(30)=<1,s(192)=<A,s(190)=<B,s(187)=<B/2]

###### Computing sum for s(161)=< -B/2+B'  in Loop 28 
   - Found a solution using cacheing 
 * Adding constraints: [s(161)=<aux(36)* (1/2),aux(36)=<it(28)*aux(35)] 

##### Pending set isortlist(A,B,C,D,E,F)
* Psum in Loop 28: [s(170)=<B']
* Psum in Loop 29: [it(29)=<1,s(183)=<A,s(184)=<B-B',s(181)=<B',s(174)=<B'/2]
* Psum in Loop 30: [it(30)=<1,s(192)=<A,s(190)=<B,s(187)=<B/2]

###### Computing sum for s(170)=<B'  in Loop 28 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(37)=<B-2] 
 * Adding constraints: [s(170)=<it(28)*aux(37)] 

##### Pending set isortlist(A,B,C,D,E,F)
* Pmax/min: [aux(37)=<B-2]
* Psum in Loop 29: [it(29)=<1,s(183)=<A,s(184)=<B-B',s(181)=<B',s(174)=<B'/2]
* Psum in Loop 30: [it(30)=<1,s(192)=<A,s(190)=<B,s(187)=<B/2]

###### Computing max_min for aux(37)=<B-2  
   - Found a solution using cacheing 
 * Adding constraints:[aux(37)=<s(127)] 

##### Pending set isortlist(A,B,C,D,E,F)
* Psum in Loop 29: [it(29)=<1,s(183)=<A,s(184)=<B-B',s(181)=<B',s(174)=<B'/2]
* Psum in Loop 30: [it(30)=<1,s(192)=<A,s(190)=<B,s(187)=<B/2]

###### Computing sum for it(29)=<1  in Loop 29 
   - Applying inductive sum strategy 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: B+1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: B/2+1/2 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B+1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B/2+1/2 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(27)+it(28)+it(29)+it(30)=<A-1,it(27)+it(28)+it(29)+it(30)=<B+1,it(27)+it(28)+it(29)+it(30)=<A-1,it(28)+it(29)=<B/2+1/2,it(27)+it(28)+it(29)+it(30)=<A-A',it(27)+it(28)+it(29)+it(30)=<B-B',it(27)+it(28)+it(29)+it(30)=<A-A',it(28)+it(29)=<B/2-B'/2] 

##### Pending set isortlist(A,B,C,D,E,F)
* Psum in Loop 29: [s(183)=<A,s(184)=<B-B',s(181)=<B',s(174)=<B'/2]
* Psum in Loop 30: [it(30)=<1,s(192)=<A,s(190)=<B,s(187)=<B/2]

###### Computing sum for s(183)=<A  in Loop 29 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(38)=<A] 
 * Adding constraints: [s(183)=<it(29)*aux(38)] 

##### Pending set isortlist(A,B,C,D,E,F)
* Pmax/min: [aux(38)=<A]
* Psum in Loop 29: [s(184)=<B-B',s(181)=<B',s(174)=<B'/2]
* Psum in Loop 30: [it(30)=<1,s(192)=<A,s(190)=<B,s(187)=<B/2]

###### Computing max_min for aux(38)=<A  
   - Found a solution using cacheing 
 * Adding constraints:[aux(38)=<aux(31)] 

##### Pending set isortlist(A,B,C,D,E,F)
* Psum in Loop 29: [s(184)=<B-B',s(181)=<B',s(174)=<B'/2]
* Psum in Loop 30: [it(30)=<1,s(192)=<A,s(190)=<B,s(187)=<B/2]

###### Computing sum for s(184)=<B-B'  in Loop 29 
   - Applying inductive sum strategy 
     - head Candidate: -2*A+2*B+2 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: -2*A+2*B+2 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [s(173)+s(184)=< -2*A+2*B+2,it(30)+s(173)+s(184)=<B-1,s(173)+s(184)=< -2*A+2*B+2*A'-2*B',it(30)+s(173)+s(184)=<B-B'] 

##### Pending set isortlist(A,B,C,D,E,F)
* Psum in Loop 29: [s(181)=<B',s(174)=<B'/2]
* Psum in Loop 30: [it(30)=<1,s(192)=<A,s(190)=<B,s(187)=<B/2]

###### Computing sum for s(181)=<B'  in Loop 29 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(39)=<B-2] 
 * Adding constraints: [s(181)=<it(29)*aux(39)] 

##### Pending set isortlist(A,B,C,D,E,F)
* Pmax/min: [aux(39)=<B-2]
* Psum in Loop 29: [s(174)=<B'/2]
* Psum in Loop 30: [it(30)=<1,s(192)=<A,s(190)=<B,s(187)=<B/2]

###### Computing max_min for aux(39)=<B-2  
   - Found a solution using cacheing 
 * Adding constraints:[aux(39)=<s(127)] 

##### Pending set isortlist(A,B,C,D,E,F)
* Psum in Loop 29: [s(174)=<B'/2]
* Psum in Loop 30: [it(30)=<1,s(192)=<A,s(190)=<B,s(187)=<B/2]

###### Computing sum for s(174)=<B'/2  in Loop 29 
   - Found a solution using cacheing 
 * Adding constraints: [s(174)=<aux(40)* (1/2),aux(40)=<it(29)*aux(39)] 

##### Pending set isortlist(A,B,C,D,E,F)
* Psum in Loop 30: [it(30)=<1,s(192)=<A,s(190)=<B,s(187)=<B/2]

###### Computing sum for it(30)=<1  in Loop 30 
   - Applying inductive sum strategy 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: B+1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: B+1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B+1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B+1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(27)+it(28)+it(29)+it(30)=<A-1,it(27)+it(28)+it(29)+it(30)=<B+1,it(27)+it(28)+it(29)+it(30)=<A-1,it(27)+it(28)+it(29)+it(30)=<B+1,it(27)+it(28)+it(29)+it(30)=<A-A',it(27)+it(28)+it(29)+it(30)=<B-B',it(27)+it(28)+it(29)+it(30)=<A-A',it(27)+it(28)+it(29)+it(30)=<B-B'] 

##### Pending set isortlist(A,B,C,D,E,F)
* Psum in Loop 30: [s(192)=<A,s(190)=<B,s(187)=<B/2]

###### Computing sum for s(192)=<A  in Loop 30 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(41)=<A] 
 * Adding constraints: [s(192)=<it(30)*aux(41)] 

##### Pending set isortlist(A,B,C,D,E,F)
* Pmax/min: [aux(41)=<A]
* Psum in Loop 30: [s(190)=<B,s(187)=<B/2]

###### Computing max_min for aux(41)=<A  
   - Found a solution using cacheing 
 * Adding constraints:[aux(41)=<aux(31)] 

##### Pending set isortlist(A,B,C,D,E,F)
* Psum in Loop 30: [s(190)=<B,s(187)=<B/2]

###### Computing sum for s(190)=<B  in Loop 30 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(42)=<B] 
 * Adding constraints: [s(190)=<it(30)*aux(42)] 

##### Pending set isortlist(A,B,C,D,E,F)
* Pmax/min: [aux(42)=<B]
* Psum in Loop 30: [s(187)=<B/2]

###### Computing max_min for aux(42)=<B  
   - Found a solution using cacheing 
 * Adding constraints:[aux(42)=<s(127)+2] 

##### Pending set isortlist(A,B,C,D,E,F)
* Psum in Loop 30: [s(187)=<B/2]

###### Computing sum for s(187)=<B/2  in Loop 30 
   - Found a solution using cacheing 
 * Adding constraints: [s(187)=<aux(43)* (1/2),aux(43)=<it(30)*aux(42)] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [27,28,29,30] 

#### Simplifying cost structure of phase [27,28,29,30] 
 * Joined equivalent variables [aux(46),aux(31)] into aux(46)
 * Joined equivalent variables [aux(48),s(127)] into aux(48)
 * Joined equivalent variables [aux(34),aux(38),aux(41)] into aux(34)
 * Joined equivalent variables [aux(37),aux(39)] into aux(37)
 * Joined equivalent variables [aux(32),s(74)] into aux(32)
 * Joined equivalent variables [aux(43),s(190)] into aux(43)
 * Joined equivalent variables [aux(40),s(181)] into aux(40)
 * Joined equivalent variables [aux(33),s(159)] into aux(33)
 * Joined equivalent variables [s(163),s(166)] into s(163)
 * Joined equivalent variables [s(162),s(164)] into s(162)
 * Joined equivalent variables [s(176),s(179)] into s(176)
 * Joined equivalent variables [s(175),s(177)] into s(175)
 * Joined equivalent variables [s(173),s(184)] into s(173)

#### Cost of phase [27,28,29,30]:isortlist(A,B,C,D,E,F) -> [isortlist(A',B',C',D',E',F')] 
9*it(27)+20*it(28)+17*it(29)+20*it(30)+11*s(155)+18*s(156)+11*s(157)+11*s(161)+36*s(162)+18*s(163)+11*s(165)+11*s(174)+36*s(175)+18*s(176)+11*s(178)+18*s(186)+11*s(187)+11*s(188)+0
  Such that:s(147) =< 1
aux(44) =< -2*A+2*B+2
aux(45) =< -2*A+2*B+2*A'-2*B'
aux(46) =< A
aux(47) =< A-A'
aux(48) =< B
aux(49) =< B+1
aux(50) =< B-B'
aux(51) =< B/2+1/2
aux(52) =< B/2-B'/2
it(29) =< aux(44)
s(173) =< aux(44)
it(29) =< aux(45)
s(173) =< aux(45)
it(27) =< aux(46)
it(28) =< aux(46)
it(29) =< aux(46)
it(30) =< aux(46)
it(27) =< aux(47)
it(28) =< aux(47)
it(29) =< aux(47)
it(30) =< aux(47)
it(29) =< aux(48)
it(30) =< aux(48)
s(173) =< aux(48)
it(27) =< aux(49)
it(28) =< aux(49)
it(29) =< aux(49)
it(30) =< aux(49)
it(27) =< aux(50)
it(28) =< aux(50)
it(29) =< aux(50)
it(30) =< aux(50)
s(173) =< aux(50)
it(28) =< aux(51)
it(29) =< aux(51)
it(28) =< aux(52)
it(29) =< aux(52)
aux(42) =< aux(48)+2
aux(34) =< aux(46)
aux(37) =< aux(48)
aux(35) =< aux(48)-2
aux(32) =< aux(48)+1
s(99) =< aux(48)* (1/2)+1/2
s(160) =< it(27)*aux(46)
aux(43) =< it(30)*aux(42)
s(192) =< it(30)*aux(34)
aux(40) =< it(29)*aux(37)
s(183) =< it(29)*aux(34)
s(170) =< it(28)*aux(37)
aux(36) =< it(28)*aux(35)
s(169) =< it(28)*aux(35)
s(172) =< it(28)*aux(34)
aux(33) =< it(27)*aux(32)
s(187) =< aux(43)* (1/2)
s(174) =< aux(40)* (1/2)
s(161) =< aux(36)* (1/2)
s(155) =< aux(33)* (1/2)
s(191) =< s(192)
s(191) =< aux(43)
s(187) =< s(192)
s(188) =< s(192)
s(187) =< s(191)
s(188) =< s(191)
s(187) =< aux(43)
s(188) =< aux(43)
s(189) =< s(187)*s(147)
s(186) =< aux(43)
s(186) =< s(189)
s(185) =< aux(40)
s(182) =< aux(40)
s(174) =< aux(40)
s(182) =< s(183)
s(185) =< s(173)
s(175) =< s(185)
s(175) =< s(173)
s(174) =< s(183)
s(178) =< s(183)
s(174) =< s(182)
s(178) =< s(182)
s(178) =< aux(40)
s(180) =< s(174)*aux(48)
s(176) =< aux(40)
s(176) =< s(180)
s(171) =< s(170)
s(169) =< s(170)
s(161) =< s(170)
s(171) =< s(172)
s(162) =< s(170)
s(162) =< s(173)
s(161) =< s(172)
s(165) =< s(172)
s(161) =< s(171)
s(165) =< s(171)
s(165) =< s(170)
s(168) =< s(170)
s(161) =< s(169)
s(165) =< s(169)
s(168) =< s(169)
s(167) =< s(161)*s(99)
s(163) =< s(168)
s(163) =< s(167)
s(155) =< s(160)
s(157) =< s(160)
s(155) =< aux(33)
s(157) =< aux(33)
s(158) =< s(155)*aux(32)
s(156) =< aux(33)
s(156) =< s(158)

#### Simplifying cost structure of chain [[27,28,29,30],31,32] 
 * Joined equivalent variables [aux(53),aux(44),aux(45)] into aux(53)
 * Joined equivalent variables [aux(54),aux(46),aux(47)] into aux(54)
 * Joined equivalent variables [aux(55),aux(48),aux(50)] into aux(55)
 * Joined equivalent variables [it(27),it(30)] into it(27)

#### Cost of chains of isortlist(A,B,C,D,E,F):
* Chain [[27,28,29,30],31,32]: 29*it(27)+20*it(28)+17*it(29)+11*s(155)+18*s(156)+11*s(157)+11*s(161)+36*s(162)+18*s(163)+11*s(165)+11*s(174)+36*s(175)+18*s(176)+11*s(178)+18*s(186)+11*s(187)+11*s(188)+12
  Such that:s(147) =< 1
aux(49) =< E+1
aux(52) =< E/2
aux(51) =< E/2+1/2
aux(53) =< -2*A+2*E+2
aux(54) =< A
aux(55) =< E
it(29) =< aux(53)
s(173) =< aux(53)
it(27) =< aux(54)
it(28) =< aux(54)
it(29) =< aux(54)
it(29) =< aux(55)
it(27) =< aux(55)
s(173) =< aux(55)
it(27) =< aux(49)
it(28) =< aux(49)
it(29) =< aux(49)
it(28) =< aux(55)
it(28) =< aux(51)
it(29) =< aux(51)
it(28) =< aux(52)
it(29) =< aux(52)
aux(42) =< aux(55)+2
aux(34) =< aux(54)
aux(37) =< aux(55)
aux(35) =< aux(55)-2
aux(32) =< aux(55)+1
s(99) =< aux(55)* (1/2)+1/2
s(160) =< it(27)*aux(54)
aux(43) =< it(27)*aux(42)
s(192) =< it(27)*aux(34)
aux(40) =< it(29)*aux(37)
s(183) =< it(29)*aux(34)
s(170) =< it(28)*aux(37)
aux(36) =< it(28)*aux(35)
s(169) =< it(28)*aux(35)
s(172) =< it(28)*aux(34)
aux(33) =< it(27)*aux(32)
s(187) =< aux(43)* (1/2)
s(174) =< aux(40)* (1/2)
s(161) =< aux(36)* (1/2)
s(155) =< aux(33)* (1/2)
s(191) =< s(192)
s(191) =< aux(43)
s(187) =< s(192)
s(188) =< s(192)
s(187) =< s(191)
s(188) =< s(191)
s(187) =< aux(43)
s(188) =< aux(43)
s(189) =< s(187)*s(147)
s(186) =< aux(43)
s(186) =< s(189)
s(185) =< aux(40)
s(182) =< aux(40)
s(174) =< aux(40)
s(182) =< s(183)
s(185) =< s(173)
s(175) =< s(185)
s(175) =< s(173)
s(174) =< s(183)
s(178) =< s(183)
s(174) =< s(182)
s(178) =< s(182)
s(178) =< aux(40)
s(180) =< s(174)*aux(55)
s(176) =< aux(40)
s(176) =< s(180)
s(171) =< s(170)
s(169) =< s(170)
s(161) =< s(170)
s(171) =< s(172)
s(162) =< s(170)
s(162) =< s(173)
s(161) =< s(172)
s(165) =< s(172)
s(161) =< s(171)
s(165) =< s(171)
s(165) =< s(170)
s(168) =< s(170)
s(161) =< s(169)
s(165) =< s(169)
s(168) =< s(169)
s(167) =< s(161)*s(99)
s(163) =< s(168)
s(163) =< s(167)
s(155) =< s(160)
s(157) =< s(160)
s(155) =< aux(33)
s(157) =< aux(33)
s(158) =< s(155)*aux(32)
s(156) =< aux(33)
s(156) =< s(158)

  with precondition: [E=B,A=D,A>=3,C>=0,F>=0,E+1>=A] 

* Chain [32]: 3
  with precondition: [A=1,B=0,D=1,E=0,C>=0,F>=0] 

* Chain [31,32]: 12
  with precondition: [A=2,D=2,B=E,B>=1,C>=0,F>=0] 


Closed-form bounds of leqL(A,B,C,D,E): 
-------------------------------------
* Chain [[19,20],18] with precondition: [1>=E,A>=2,D>=0,E>=0,C>=A,B+E>=1] 
    - Upper bound: 9*A+9*B+3 
    - Complexity: n 
* Chain [[19,20],17] with precondition: [E=0,B>=0,C>=2,D>=0,A>=C+1] 
    - Upper bound: 9*A+9*B+6 
    - Complexity: n 
* Chain [18] with precondition: [A=1,E=1,B>=0,C>=0,D>=0] 
    - Upper bound: 3 
    - Complexity: constant 
* Chain [17] with precondition: [C=1,E=0,A>=2,B>=0,D>=0] 
    - Upper bound: 6 
    - Complexity: constant 

### Maximum cost of leqL(A,B,C,D,E): 9*A+9*B+6 
Asymptotic class: n 
 * Joined equivalent variables [aux(56),aux(21)] into aux(56)
 * Joined equivalent variables [aux(56),aux(11)] into aux(56)
 * Joined equivalent variables [aux(56),s(12)] into aux(56)

Closed-form bounds of insertL(A,B,C,D,E,F,G,H): 
-------------------------------------
* Chain [[21,22],26] with precondition: [A=1,C+1=F,D+1=G,B+E=H,B>=0,C>=3,D>=3,H>=B] 
    - Upper bound: 11*C+29/2*D+9*E+59/2 
    - Complexity: n 
* Chain [[21,22],25] with precondition: [C+1=F,A+D=G,A>=0,B>=0,C>=2,E>=0,H>=0,D+1>=C] 
    - Upper bound: 11*C+29/2*D+9*E+15 
    - Complexity: n 
* Chain [[21,22],24] with precondition: [C+1=F,A+D=G,B+E=H,A>=2,B>=0,C>=3,D>=3,H>=B+1] 
    - Upper bound: 11*C+47/2*D+18*E+12 
    - Complexity: n 
* Chain [[21,22],23] with precondition: [C+1=F,A+D=G,B+E=H,A>=2,B>=0,C>=3,D>=A+2,H>=B] 
    - Upper bound: 11*C+47/2*D+18*E+15 
    - Complexity: n 
* Chain [26] with precondition: [A=1,C+1=F,D+1=G,B+E=H,B>=0,C>=2,D>=2,E>=0] 
    - Upper bound: 15 
    - Complexity: constant 
* Chain [25] with precondition: [C=1,D=0,F=2,A=G,A>=1,B>=0,E>=0,H>=0] 
    - Upper bound: 4 
    - Complexity: constant 
* Chain [24] with precondition: [C+1=F,A+D=G,B+E=H,A>=2,B>=0,C>=2,D>=2,E>=1] 
    - Upper bound: 9*D+9*E+12 
    - Complexity: n 
* Chain [23] with precondition: [C+1=F,A+D=G,B+E=H,A>=2,B>=0,C>=2,E>=0,D>=A+1] 
    - Upper bound: 9*D+9*E+15 
    - Complexity: n 

### Maximum cost of insertL(A,B,C,D,E,F,G,H): max([11,9*E+max([11*C+47/2*D+9*E+11,11*C+29/2*D+51/2])])+4 
Asymptotic class: n 

Closed-form bounds of isortlist(A,B,C,D,E,F): 
-------------------------------------
* Chain [[27,28,29,30],31,32] with precondition: [E=B,A=D,A>=3,C>=0,F>=0,E+1>=A] 
    - Upper bound: 239/2*A+12+33*A*A+11*A* (2*B)+65*B*A+47/2*B* (2*B)+ (11/2*B-11)*A+178*B 
    - Complexity: n^2 
* Chain [32] with precondition: [A=1,B=0,D=1,E=0,C>=0,F>=0] 
    - Upper bound: 3 
    - Complexity: constant 
* Chain [31,32] with precondition: [A=2,D=2,B=E,B>=1,C>=0,F>=0] 
    - Upper bound: 12 
    - Complexity: constant 

### Maximum cost of isortlist(A,B,C,D,E,F): max([9,239/2*A+9+33*A*A+11*A* (2*B)+65*B*A+47/2*B* (2*B)+11/2*nat(B-2)*A+178*B])+3 
Asymptotic class: n^2 
* Total analysis performed in 1888 ms.


Cost relation system solved by CoFloCo in 1893 ms.

Method leqL terminates?: YES

 - l1_1: size of l1 wrt. List<Rat>
 - l1_2: size of l1 wrt. Rat
 - l2_1: size of l2 wrt. List<Rat>
 - l2_2: size of l2 wrt. Rat
UB for leqL(l1_1,l1_2,l2_1,l2_2) = 9*l1_1+9*l1_2+6

Method insertL terminates?: YES

 - x_1: size of x wrt. List<Rat>
 - x_2: size of x wrt. Rat
 - l_1: size of l wrt. List<List<Rat>>
 - l_2: size of l wrt. List<Rat>
 - l_3: size of l wrt. Rat
UB for insertL(x_1,x_2,l_1,l_2,l_3) = max([11,9*l_3+max([11*l_1+47/2*l_2+9*l_3+11,11*l_1+29/2*l_2+51/2])])+4

Method isortlist terminates?: YES

 - l_1: size of l wrt. List<List<Rat>>
 - l_2: size of l wrt. List<Rat>
 - l_3: size of l wrt. Rat
UB for isortlist(l_1,l_2,l_3) = max([9,239/2*l_1+9+33*l_1*l_1+11*l_1* (2*l_2)+65*l_2*l_1+47/2*l_2* (2*l_2)+11/2*nat(l_2-2)*l_1+178*l_2])+3
