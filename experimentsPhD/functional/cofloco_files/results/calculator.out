
Abs program loaded in 15 ms.

Rule based representation generated in 1 ms.

Rule based representation stored in /tmp/costabs/rbr.rbr

RBR properties stored in /tmp/costabs/rbr.properties

Class invariants generated and loaded in 0 ms.

Abstract compilation performed in 10 ms.

Cost relation system stored in /tmp/costabs/crs.crs

Generated 50 equations 
entry('add'(A,B,C):[]).
entry('sub'(A,B,C):[]).
entry('mult'(A,B,C):[]).
entry('eval_simpl'(A,B,C):[]).
entry('eval'(A,B,C):[]).
entry('nat_to_int'(A,B):[]).
input_output_vars('add'(A,B,C),[A,B],[C]).
input_output_vars('and_op'(A,B,C),[A,B],[C]).
input_output_vars('case_0'(A,B,C),[A,B],[C]).
input_output_vars('case_1'(A,B,C),[A,B],[C]).
input_output_vars('case_2'(A,B,C,D),[A,B,C],[D]).
input_output_vars('case_3'(A,B,C),[A,B],[C]).
input_output_vars('case_4'(A,B,C),[A,B],[C]).
input_output_vars('case_5'(A,B,C),[A,B],[C]).
input_output_vars('case_6'(A,B,C,D,E,F,G,H),[A,B,C,D,E,F,G],[H]).
input_output_vars('case_7'(A,B,C,D,E,F,G,H),[A,B,C,D,E,F,G],[H]).
input_output_vars('case_8'(A,B,C,D,E,F,G,H,I,J),[A,B,C,D,E,F,G,H,I],[J]).
input_output_vars('case_9'(A,B),[A],[B]).
input_output_vars('eq'(A,B,C),[A,B],[C]).
input_output_vars('eval'(A,B,C),[A,B],[C]).
input_output_vars('eval_simpl'(A,B,C),[A,B],[C]).
input_output_vars('geq'(A,B,C),[A,B],[C]).
input_output_vars('gt'(A,B,C),[A,B],[C]).
input_output_vars('leq'(A,B,C),[A,B],[C]).
input_output_vars('lt'(A,B,C),[A,B],[C]).
input_output_vars('maxNorm'(A,B,C),[A,B],[C]).
input_output_vars('mult'(A,B,C),[A,B],[C]).
input_output_vars('nat_to_int'(A,B),[A],[B]).
input_output_vars('neg'(A,B),[A],[B]).
input_output_vars('neq'(A,B,C),[A,B],[C]).
input_output_vars('or'(A,B,C),[A,B],[C]).
input_output_vars('sub'(A,B,C),[A,B],[C]).
eq('eq',[A,B,C],0,[],[A=B,C=1,A>=0,B>=0,C>=0]).
eq('eq',[A,B,C],0,[],[A>=B+1,C=0,A>=0,B>=0,C>=0]).
eq('eq',[A,B,C],0,[],[B>=A+1,C=0,A>=0,B>=0,C>=0]).
eq('neq',[A,B,C],0,[],[A=B,C=0,A>=0,B>=0,C>=0]).
eq('neq',[A,B,C],0,[],[A>=B+1,C=1,A>=0,B>=0,C>=0]).
eq('neq',[A,B,C],0,[],[B>=A+1,C=1,A>=0,B>=0,C>=0]).
eq('lt',[A,B,C],0,[],[B-A>=1,C=1,A>=0,B>=0,C>=0]).
eq('lt',[A,B,C],0,[],[B=<A,C=0,A>=0,B>=0,C>=0]).
eq('leq',[A,B,C],0,[],[A=<B,C=1,A>=0,B>=0,C>=0]).
eq('leq',[A,B,C],0,[],[A-B>=1,C=0,A>=0,B>=0,C>=0]).
eq('gt',[A,B,C],0,[],[A-B>=1,C=1,A>=0,B>=0,C>=0]).
eq('gt',[A,B,C],0,[],[A=<B,C=0,A>=0,B>=0,C>=0]).
eq('geq',[A,B,C],0,[],[B=<A,C=1,A>=0,B>=0,C>=0]).
eq('geq',[A,B,C],0,[],[B-A>=1,C=0,A>=0,B>=0,C>=0]).
eq('neg',[A,B],0,[],[A=0,B=1,A>=0,B>=0]).
eq('neg',[A,B],0,[],[A=1,B=0,A>=0,B>=0]).
eq('and_op',[A,B,C],0,[],[A=0,C=0,A>=0,B>=0,C>=0]).
eq('and_op',[A,B,C],0,[],[A=1,C=B,A>=0,B>=0,C>=0]).
eq('or',[A,B,C],0,[],[A=1,C=1,A>=0,B>=0,C>=0]).
eq('or',[A,B,C],0,[],[A=0,C=B,A>=0,B>=0,C>=0]).
eq('maxNorm',[A,B,A],0,[],[A>=1+B,A>=0,B>=0,A>=0]).
eq('maxNorm',[A,B,B],0,[],[A=<B,A>=0,B>=0,B>=0]).
eq('case_0',[A,B,B],1,[],[A=1,A>=0,B>=0,B>=0]).
eq('case_0',[A,B,C],4,['add'(D,B,E)],[A=D+1,D>=1,C=E+1,E>=1,A>=0,B>=0,C>=0]).
eq('add',[A,B,C],1,['case_0'(A,B,C)],[A>=0,B>=0,C>=0]).
eq('case_1',[A,B,A],1,[],[B=1,A>=0,B>=0,A>=0]).
eq('case_2',[A,B,C,D],2,[],[A=1,D=1,A>=0,B>=0,C>=0,D>=0]).
eq('case_2',[A,B,C,D],3,['sub'(E,C,D)],[A=E+1,E>=1,A>=0,B>=0,C>=0,D>=0]).
eq('case_1',[A,B,C],3,['case_2'(A,B,D,C)],[B=D+1,D>=1,A>=0,B>=0,C>=0]).
eq('sub',[A,B,C],1,['case_1'(A,B,C)],[A>=0,B>=0,C>=0]).
eq('case_3',[A,B,C],2,[],[A=1,C=1,A>=0,B>=0,C>=0]).
eq('case_3',[A,B,C],4,['mult'(D,B,E),'add'(D,E,C)],[A=D+1,D>=1,A>=0,B>=0,C>=0]).
eq('mult',[A,B,C],1,['case_3'(A,B,C)],[A>=0,B>=0,C>=0]).
eq('case_4',[A,B,C],1,[],[B=1,A=C,C>=1,A>=0,B>=0,C>=0]).
eq('case_4',[A,B,C],5,['eval_simpl'(D,E,F),'eval_simpl'(G,H,I),'add'(F,I,C)],[B=H+E+1,A=D+G,H>=1,E>=1,A>=0,B>=0,C>=0]).
eq('case_4',[A,B,C],6,['eval_simpl'(D,E,F),'eval_simpl'(G,H,I),'sub'(F,I,C)],[B=H+E+1,A=D+G,H>=1,E>=1,A>=0,B>=0,C>=0]).
eq('eval_simpl',[A,B,C],1,['case_4'(A,B,C)],[A>=0,B>=0,C>=0]).
eq('case_5',[A,B,C],1,[],[B=1,A=C,C>=1,A>=0,B>=0,C>=0]).
eq('case_6',[A,B,C,D,E,F,G,H],2,['eval'(F,G,H)],[A=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0]).
eq('case_6',[A,B,C,D,E,F,G,H],6,['eval'(I,J,K)],[A=L+1,L>=1,M=1,N=L,L>=1,J=G+M+1,I=N+F,G>=1,M>=1,H=K+1,K>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0]).
eq('case_5',[A,B,C],6,['eval'(D,E,F),'case_6'(G,A,B,D,E,H,I,J)],[B=I+E+1,A=D+H,I>=1,E>=1,G=F,F>=1,C=J,J>=1,A>=0,B>=0,C>=0]).
eq('case_7',[A,B,C,D,E,F,G,H],2,['eval'(D,E,H)],[A=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0]).
eq('case_8',[A,B,C,D,E,F,G,H,I,J],2,[],[A=1,J=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0]).
eq('case_8',[A,B,C,D,E,F,G,H,I,J],6,['eval'(K,L,J)],[A=M+1,M>=1,N=1,O=M,M>=1,P=1,Q=I,I>=1,L=P+N+1,K=O+Q,P>=1,N>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0,J>=0]).
eq('case_7',[A,B,C,D,E,F,G,H],6,['eval'(D,E,I),'case_8'(J,A,B,C,D,E,F,G,K,L)],[A=K+1,K>=1,J=I,I>=1,H=L,L>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0]).
eq('case_5',[A,B,C],7,['eval'(D,E,F),'case_7'(G,A,B,H,I,D,E,J)],[B=E+I+1,A=H+D,E>=1,I>=1,G=F,F>=1,C=J,J>=1,A>=0,B>=0,C>=0]).
eq('eval',[A,B,C],1,['case_5'(A,B,C)],[A>=0,B>=0,C>=0]).
eq('case_9',[A,B],2,[],[A=1,B=0,A>=0,B>=0]).
eq('case_9',[A,B],5,['nat_to_int'(C,D)],[A=C+1,C>=1,E=1,B=D+E,A>=0,B>=0]).
eq('nat_to_int',[A,B],1,['case_9'(A,B)],[A>=0,B>=0]).

Preprocessing Cost Relations
=====================================

#### Computed strongly connected components 
0. recursive  : [add/3,case_0/3]
1. recursive [multiple] : [case_5/3,case_6/8,case_7/8,case_8/10,eval/3]
2. recursive  : [case_1/3,case_2/4,sub/3]
3. recursive [non_tail,multiple] : [case_4/3,eval_simpl/3]
4. recursive [non_tail] : [case_3/3,mult/3]
5. recursive  : [case_9/2,nat_to_int/2]
Warning: the following predicates are never called:[and_op/3,eq/3,geq/3,gt/3,leq/3,lt/3,maxNorm/3,neg/2,neq/3,or/3]

#### Obtained direct recursion through partial evaluation 
0. SCC is partially evaluated into add/3
1. SCC is partially evaluated into eval/3
2. SCC is partially evaluated into sub/3
3. SCC is partially evaluated into eval_simpl/3
4. SCC is partially evaluated into mult/3
5. SCC is partially evaluated into nat_to_int/2

Control-Flow Refinement of Cost Relations
=====================================

### Specialization of cost equations add/3 
* CE 2 is refined into CE [19] 
* CE 1 is refined into CE [20] 


#### Refined cost equations add/3 
* CE 19: add(A,B,B) = 2
     [B>=0,A=1] 
* CE 20: add(A,B,C) = 5+ add(D,B,E)
     [E>=1,D>=1,B>=0,E+1=C,D+1=A] 

### Cost equations --> "Loop" of add/3 
* CEs [20] --> Loop 17 
* CEs [19] --> Loop 18 

#### Loops of add/3 
* Loop 17: add(A,B,C)->  add(A',B,B')
                  [B'>=1,A'>=1,B>=0,B'+1=C,A'+1=A] 
* Loop 18: add(A,B,B) [B>=0,A=1] 

### Ranking functions of CR add(A,B,C) 
* RF of phase [17]: [A-1]

#### Partial ranking functions of CR add(A,B,C) 
* Partial RF of phase [17]:
  - RF of loop [17:1]:
    A-1

Discarded unfeasible chain [[17]]...(Non-terminating chain proved terminating)

### Resulting Chains:add(A,B,C) 
* [[17],18]
* [18]


### Merging Chains  add/3 into  External patterns of execution 
* [[18]] --> 1 
* [[18,[17]]] --> 2 


### Specialization of cost equations eval/3 
* CE 13 is refined into CE [21] 
* CE 12 is refined into CE [22] 
* CE 16 is refined into CE [23] 
* CE 15 is refined into CE [24] 
* CE 14 is refined into CE [25] 
* CE 11 is refined into CE [26] 


#### Refined cost equations eval/3 
* CE 21: eval(A,B,C) = 13+ eval(D,E,F)+ eval(G,H,I)
     [B>=H,G+1>=F,I>=1,H>=3,F>=2,D>=0,D+G+1=A+F,E+H=B+1,I+1=C] 
* CE 22: eval(A,B,C) = 9+ eval(D,E,F)+ eval(G,H,C)
     [B>=E+2,G>=0,E>=1,D>=0,C>=1,E+H+1=B,D+G=A,F=1] 
* CE 23: eval(A,B,C) = 10+ eval(D,E,F)+ eval(G,H,C)
     [B>=E+2,G>=0,E>=1,D>=0,C>=1,E+H+1=B,D+G=A,F=1] 
* CE 24: eval(A,B,C) = 16+ eval(D,E,F)+ eval(G,H,I)
     [B>=E+2,G>=0,F>=2,E>=1,D>=0,E+H+1=B,D+G=A,I=1,C=1] 
* CE 25: eval(A,B,C) = 20+ eval(D,E,F)+ eval(G,H,I)+ eval(J,K,C)
     [B>=E+2,I>=2,G>=0,F>=2,E>=1,D>=0,C>=1,F+I=J+2,E+H+1=B,D+G=A,K=3] 
* CE 26: eval(A,B,A) = 2
     [A>=1,B=1] 

### Cost equations --> "Loop" of eval/3 
* CEs [26] --> Loop 19 
* CEs [25] --> Loop 20 
* CEs [21] --> Loop 21 
* CEs [22,23] --> Loop 22 
* CEs [24] --> Loop 23 

#### Loops of eval/3 
* Loop 19: eval(A,B,A) [A>=1,B=1] 
* Loop 20: eval(A,B,C)->  eval(A',B',C')  eval(A'2,B'2,C'2)  eval(A'3,B'3,C)
                  [B>=B'+2,C'2>=2,A'2>=0,C'>=2,B'>=1,A'>=0,C>=1,C'+C'2=A'3+2,B=B'+B'2+1,A'+A'2=A,B'3=3] 
* Loop 21: eval(A,B,C)->  eval(A',B',C')  eval(A'2,B'2,C'2)
                  [B>=B'+2,A>=A',C'>=2,B'>=1,A'>=0,C>=2,A'+A'2+1=A+C',B'+B'2=B+1,C=C'2+1] 
* Loop 22: eval(A,B,C)->  eval(A',B',C')  eval(A'2,B'2,C)
                  [B>=B'+2,A>=A',B'>=1,A'>=0,C>=1,B=B'+B'2+1,A'+A'2=A,C'=1] 
* Loop 23: eval(A,B,C)->  eval(A',B',C')  eval(A'2,B'2,C'2)
                  [B>=B'+2,A>=A',C'>=2,B'>=1,A'>=0,B=B'+B'2+1,A'+A'2=A,C'2=1,C=1] 

### Ranking functions of CR eval(A,B,C) 

#### Partial ranking functions of CR eval(A,B,C) 
* Partial RF of phase [20,21,22,23]:
  - RF of loop [20:1,20:2,21:1,22:1,22:2,23:1,23:2]:
    B/2-1


### Resulting Chains:eval(A,B,C) 
* [multiple([20,21,22,23],[[],[19]])]...
* [19]


### Merging Chains  eval/3 into  External patterns of execution 
* [[19]] --> 1 
* [[multiple([20,21,22,23],[[],[19]])]] --> 2 


### Specialization of cost equations sub/3 
* CE 5 is refined into CE [27] 
* CE 3 is refined into CE [28] 
* CE 4 is refined into CE [29] 


#### Refined cost equations sub/3 
* CE 27: sub(A,B,C) = 7+ sub(D,E,C)
     [E>=1,D>=1,C>=0,E+1=B,D+1=A] 
* CE 28: sub(A,B,A) = 2
     [A>=0,B=1] 
* CE 29: sub(A,B,C) = 6
     [B>=2,C=1,A=1] 

### Cost equations --> "Loop" of sub/3 
* CEs [28] --> Loop 24 
* CEs [29] --> Loop 25 
* CEs [27] --> Loop 26 

#### Loops of sub/3 
* Loop 24: sub(A,B,A) [A>=0,B=1] 
* Loop 25: sub(A,B,C) [B>=2,C=1,A=1] 
* Loop 26: sub(A,B,C)->  sub(A',B',C)
                  [B'>=1,A'>=1,C>=0,B'+1=B,A'+1=A] 

### Ranking functions of CR sub(A,B,C) 
* RF of phase [26]: [A-1,B-1]

#### Partial ranking functions of CR sub(A,B,C) 
* Partial RF of phase [26]:
  - RF of loop [26:1]:
    A-1
    B-1

Discarded unfeasible chain [[26]]...(Non-terminating chain proved terminating)

### Resulting Chains:sub(A,B,C) 
* [[26],25]
* [[26],24]
* [25]
* [24]


### Merging Chains  sub/3 into  External patterns of execution 
* [[25]] --> 1 
* [[24]] --> 2 
* [[25,[26]]] --> 3 
* [[24,[26]]] --> 4 


### Specialization of cost equations eval_simpl/3 
* CE 10 is refined into CE [30] 
* CE 8 is refined into CE [31,32,33,34] 
* CE 9 is refined into CE [35,36] 


#### Refined cost equations eval_simpl/3 
* CE 30: eval_simpl(A,B,A) = 2
     [A>=1,B=1] 
* CE 31: eval_simpl(A,B,C) = 7+ eval_simpl(D,E,F)+ eval_simpl(G,H,I)+ sub(J,I,K):1
     [D+G>=0,H>=1,E>=1,I>=2,E+H+1=B,D+G=A,F=1,K=1,J=1,C=1] 
* CE 32: eval_simpl(A,B,C) = 7+ eval_simpl(D,E,C)+ eval_simpl(F,G,H)+ sub(C,I,C):2
     [D+F>=0,G>=1,E>=1,C>=0,E+G+1=B,D+F=A,H=1,I=1] 
* CE 33: eval_simpl(A,B,C) = 7+ eval_simpl(D,E,F)+ eval_simpl(G,H,I)+ sub(F,I,J):3
     [D+G>=0,I>=F+1,H>=1,E>=1,F>=2,E+H+1=B,D+G=A,J=1,C=1] 
* CE 34: eval_simpl(A,B,C) = 7+ eval_simpl(D,E,F)+ eval_simpl(G,H,I)+ sub(J,I,C):4
     [D+G>=0,H>=1,E>=1,C>=1,I>=2,C+I=F+1,C+I=J+1,E+H+1=B,D+G=A] 
* CE 35: eval_simpl(A,B,C) = 6+ eval_simpl(D,E,F)+ eval_simpl(G,H,C)+ add(I,C,C):1
     [D+G>=0,H>=1,E>=1,C>=0,E+H+1=B,D+G=A,F=1,I=1] 
* CE 36: eval_simpl(A,B,C) = 6+ eval_simpl(D,E,F)+ eval_simpl(G,H,I)+ add(F,J,C):2
     [D+G>=0,C>=F,H>=1,E>=1,F>=2,C+1=F+I,C+1=F+J,E+H+1=B,D+G=A] 

### Cost equations --> "Loop" of eval_simpl/3 
* CEs [34] --> Loop 27 
* CEs [36] --> Loop 28 
* CEs [32] --> Loop 29 
* CEs [35] --> Loop 30 
* CEs [33] --> Loop 31 
* CEs [31] --> Loop 32 
* CEs [30] --> Loop 33 

#### Loops of eval_simpl/3 
* Loop 27: eval_simpl(A,B,C)->  eval_simpl(A',B',C')  eval_simpl(A'2,B'2,C'2)
                  [B>=B'+2,C'>=C+1,B'>=1,C>=1,A>=0,C+C'2=C'+1,A=A'+A'2,B'+B'2+1=B] 
* Loop 28: eval_simpl(A,B,C)->  eval_simpl(A',B',C')  eval_simpl(A'2,B'2,C'2)
                  [C>=C',B>=B'+2,C'>=2,B'>=1,A>=0,A=A'+A'2,C'+C'2=C+1,B'+B'2+1=B] 
* Loop 29: eval_simpl(A,B,C)->  eval_simpl(A',B',C)  eval_simpl(A'2,B'2,C'2)
                  [B>=B'+2,B'>=1,C>=0,A>=0,A=A'+A'2,B'+B'2+1=B,C'2=1] 
* Loop 30: eval_simpl(A,B,C)->  eval_simpl(A',B',C')  eval_simpl(A'2,B'2,C)
                  [B>=B'+2,B'>=1,C>=0,A>=0,A=A'+A'2,B'+B'2+1=B,C'=1] 
* Loop 31: eval_simpl(A,B,C)->  eval_simpl(A',B',C')  eval_simpl(A'2,B'2,C'2)
                  [C'2>=C'+1,B>=B'+2,C'>=2,B'>=1,A>=0,A=A'+A'2,B'+B'2+1=B,C=1] 
* Loop 32: eval_simpl(A,B,C)->  eval_simpl(A',B',C')  eval_simpl(A'2,B'2,C'2)
                  [B>=B'+2,C'2>=2,B'>=1,A>=0,A=A'+A'2,B'+B'2+1=B,C'=1,C=1] 
* Loop 33: eval_simpl(A,B,A) [A>=1,B=1] 

### Ranking functions of CR eval_simpl(A,B,C) 
* RF of phase [27,28,29,30,31,32]: [B/2-1]

#### Partial ranking functions of CR eval_simpl(A,B,C) 
* Partial RF of phase [27,28,29,30,31,32]:
  - RF of loop [27:1,27:2,28:1,28:2,29:1,29:2,30:1,30:2,31:1,31:2,32:1,32:2]:
    B/2-1

Discarded unfeasible chain [multiple([27,28,29,30,31,32],[[],[33]])]...(Non-terminating chain proved terminating)
Remaining chain: [multiple([27,28,29,30,31,32],[[33]])]

### Resulting Chains:eval_simpl(A,B,C) 
* [33]
* [multiple([27,28,29,30,31,32],[[33]])]


### Merging Chains  eval_simpl/3 into  External patterns of execution 
* [[33]] --> 1 
* [[multiple([27,28,29,30,31,32],[[33]])]] --> 2 


### Specialization of cost equations mult/3 
* CE 7 is refined into CE [37] 
* CE 6 is refined into CE [38,39] 


#### Refined cost equations mult/3 
* CE 37: mult(A,B,C) = 3
     [B>=0,C=1,A=1] 
* CE 38: mult(A,B,C) = 5+ mult(D,B,C)+ add(E,C,C):1
     [C>=0,B>=0,D=1,E=1,A=2] 
* CE 39: mult(A,B,C) = 5+ mult(D,B,E)+ add(D,F,C):2
     [C>=D,D>=2,B>=0,C+1=D+E,C+1=D+F,D+1=A] 

### Cost equations --> "Loop" of mult/3 
* CEs [39] --> Loop 34 
* CEs [38] --> Loop 35 
* CEs [37] --> Loop 36 

#### Loops of mult/3 
* Loop 34: mult(A,B,C)->  mult(A',B,B')
                  [C+1>=A,B>=0,A>=3,A+B'=C+2,A=A'+1] 
* Loop 35: mult(A,B,C)->  mult(A',B,C)
                  [C>=0,B>=0,A'=1,A=2] 
* Loop 36: mult(A,B,C) [B>=0,C=1,A=1] 

### Ranking functions of CR mult(A,B,C) 
* RF of phase [34]: [A-2]

#### Partial ranking functions of CR mult(A,B,C) 
* Partial RF of phase [34]:
  - RF of loop [34:1]:
    A-2

Discarded unfeasible chain [[34]]...(Non-terminating chain proved terminating)

### Resulting Chains:mult(A,B,C) 
* [[34],35,36]
* [36]
* [35,36]


### Merging Chains  mult/3 into  External patterns of execution 
* [[36]] --> 1 
* [[36,35]] --> 2 
* [[36,35,[34]]] --> 3 


### Specialization of cost equations nat_to_int/2 
* CE 18 is refined into CE [40] 
* CE 17 is refined into CE [41] 


#### Refined cost equations nat_to_int/2 
* CE 40: nat_to_int(A,B) = 3
     [B=0,A=1] 
* CE 41: nat_to_int(A,B) = 6+ nat_to_int(C,D)
     [D+1>=0,C>=1,D+1=B,C+1=A] 

### Cost equations --> "Loop" of nat_to_int/2 
* CEs [41] --> Loop 37 
* CEs [40] --> Loop 38 

#### Loops of nat_to_int/2 
* Loop 37: nat_to_int(A,B)->  nat_to_int(A',B')
                  [B'+1>=0,A'>=1,B'+1=B,A'+1=A] 
* Loop 38: nat_to_int(A,B) [B=0,A=1] 

### Ranking functions of CR nat_to_int(A,B) 
* RF of phase [37]: [A-1]

#### Partial ranking functions of CR nat_to_int(A,B) 
* Partial RF of phase [37]:
  - RF of loop [37:1]:
    A-1

Discarded unfeasible chain [[37]]...(Non-terminating chain proved terminating)

### Resulting Chains:nat_to_int(A,B) 
* [[37],38]
* [38]


### Merging Chains  nat_to_int/2 into  External patterns of execution 
* [[38]] --> 1 
* [[38,[37]]] --> 2 


Computing Bounds
=====================================

#### Simplifying cost structure of CE 19 

#### Computing cost of phase [17] 

#### Simplifying cost structure of CE 20 

#### Cost of loops [17] 

 * loop 17:add(A,B,C) -> [add(A',B',C')] 
5
##### Pending set add(A,B,C)
* Psum in Loop 17: [it(17)=<1]

###### Computing sum for it(17)=<1  in Loop 17 
   - Applying inductive sum strategy 
     - head Candidate: A-1 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(17)=<A-1,it(17)=<A-1,it(17)=<A-A',it(17)=<A-A'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [17] 

#### Simplifying cost structure of phase [17] 

#### Cost of phase [17]:add(A,B,C) -> [add(A',B',C')] 
5*it(17)+0
  Such that:it(17) =< A
it(17) =< A-A'

#### Simplifying cost structure of chain [[17],18] 

#### Cost of chains of add(A,B,C):
* Chain [[17],18]: 5*it(17)+2
  Such that:it(17) =< -B+C

  with precondition: [A+B=C+1,A>=2,B>=1] 

* Chain [18]: 2
  with precondition: [A=1,B=C,B>=0] 


#### Simplifying cost structure of CE 26 

#### Computing cost of chain [multiple([20,21,22,23],[[],[19]])] with multiple recursion

#### Simplifying cost structure of CE 25 

#### Simplifying cost structure of CE 21 

#### Simplifying cost structure of CE 22 

#### Simplifying cost structure of CE 23 

#### Simplifying cost structure of CE 24 

#### Cost of loops [20,21,22,23] 

 * loop 20:eval(A,B,C) -> [eval(A',B',C'),eval(A'2,B'2,C'2),eval(A'3,B'3,C'3)] 
20
 * loop 21:eval(A,B,C) -> [eval(A',B',C'),eval(A'2,B'2,C'2)] 
13
 * loop 22:eval(A,B,C) -> [eval(A',B',C'),eval(A'2,B'2,C'2)] 
10
 * loop 23:eval(A,B,C) -> [eval(A',B',C'),eval(A'2,B'2,C'2)] 
16
##### Pending set eval(A,B,C)
* Psum in Loop 20: [it(20)=<1]
* Psum in Loop 21: [it(21)=<1]
* Psum in Loop 22: [it(22)=<1]
* Psum in Loop 23: [it(23)=<1]
* Psum in Chain-Tail [19]: [it([19])=<1]

###### Computing sum for it(20)=<1  in Loop 20 
   - Applying inductive sum strategy 
     - head Candidate: 3/4*B-5/4 
       - Loop 21 is collaborative
       - Loop 22 is collaborative and bounds [it(22)] 
       - Loop 23 is collaborative and bounds [it(23)] 
       - Chain [19] is ignored
 * Adding constraints: [it(20)+it(22)+it(23)=<3/4*B-5/4] 

##### Pending set A
* Psum in Loop 21: [it(21)=<1]
* Psum in Chain-Tail [19]: [it([19])=<1]

###### Computing sum for it(21)=<1  in Loop 21 
   - Applying inductive sum strategy 
     - head Candidate: B-2 
       - Loop 20 is collaborative
       - Loop 22 is collaborative
       - Loop 23 is collaborative
       - Chain [19] is ignored
 * Adding constraints: [it(21)=<B-2] 

##### Pending set A
* Psum in Chain-Tail [19]: [it([19])=<1]

###### Computing sum for it([19])=<1  in Chain-Tail [19] 
   - Applying inductive sum strategy 
     - head Candidate: 1 
       - Loop 20 adds a constant 2/1 
       - Loop 21 adds a constant 1/1 
       - Loop 22 adds a constant 1/1 
       - Loop 23 adds a constant 1/1 
 * Adding constraints: [it([19])=<it(23)+it(22)+it(21)+it(20)*2+aux(1),aux(1)=<1] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [20,21,22,23,[19]] 

#### Simplifying cost structure of phase [20,21,22,23,[19]] 
 * Joined equivalent variables [it(20),it(22),it(23)] into it(20)

#### Cost of phase [20,21,22,23]:eval(A,B,C) -> [] 
46*it(20)+13*it(21)+2*it([19])+0
  Such that:aux(1) =< 1
it(21) =< B
aux(2) =< 3/4*B
it(20) =< aux(2)
it([19]) =< it(20)+it(20)+it(21)+it(20)*2+aux(1)

#### Cost of chains of eval(A,B,C):
* Chain [multiple([20,21,22,23],[[],[19]])]...: 46*it(20)+13*it(21)+2*it([19])+0
  Such that:aux(1) =< 1
it(21) =< B
aux(2) =< 3/4*B
it(20) =< aux(2)
it([19]) =< it(20)+it(20)+it(21)+it(20)*2+aux(1)

  with precondition: [A>=0,C>=1,B>=3] 

* Chain [19]: 2
  with precondition: [B=1,A=C,A>=1] 


#### Simplifying cost structure of CE 29 

#### Computing cost of phase [26] 

#### Simplifying cost structure of CE 27 

#### Cost of loops [26] 

 * loop 26:sub(A,B,C) -> [sub(A',B',C')] 
7
##### Pending set sub(A,B,C)
* Psum in Loop 26: [it(26)=<1]

###### Computing sum for it(26)=<1  in Loop 26 
   - Applying inductive sum strategy 
     - head Candidate: B-1 
     - head Candidate: A-1 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B-1 
     - tail Candidate: A-1 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(26)=<B-1,it(26)=<A-1,it(26)=<A-1,it(26)=<B-1,it(26)=<B-B',it(26)=<A-A',it(26)=<A-A',it(26)=<B-B'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [26] 

#### Simplifying cost structure of phase [26] 

#### Cost of phase [26]:sub(A,B,C) -> [sub(A',B',C')] 
7*it(26)+0
  Such that:it(26) =< A
it(26) =< A-A'
it(26) =< B
it(26) =< B-B'

#### Simplifying cost structure of chain [[26],25] 

#### Simplifying cost structure of CE 28 

#### Found solution for phase  [26] in the cache 

#### Cost of phase [26]:sub(A,B,C) -> [sub(A',B',C')] 
7*it(26)+0
  Such that:it(26) =< A
it(26) =< A-A'
it(26) =< B
it(26) =< B-B'

#### Simplifying cost structure of chain [[26],24] 

#### Cost of chains of sub(A,B,C):
* Chain [[26],25]: 7*it(26)+6
  Such that:it(26) =< A

  with precondition: [C=1,A>=2,B>=A+1] 

* Chain [[26],24]: 7*it(26)+2
  Such that:it(26) =< B

  with precondition: [A+1=B+C,B>=2,A>=B] 

* Chain [25]: 6
  with precondition: [A=1,C=1,B>=2] 

* Chain [24]: 2
  with precondition: [B=1,A=C,A>=0] 


#### Simplifying cost structure of CE 30 

#### Computing cost of chain [multiple([27,28,29,30,31,32],[[33]])] with multiple recursion
 * Renamed intermediate variables: 
[ (eq(34,1),it(26))>>s(1)]

#### Simplifying cost structure of CE 34 
 * Renamed intermediate variables: 
[ (it(27),s(1))>>s(2)]
 * Renamed intermediate variables: 
[ (eq(36,1),it(17))>>s(3)]

#### Simplifying cost structure of CE 36 
 * Renamed intermediate variables: 
[ (it(28),s(3))>>s(4)]

#### Simplifying cost structure of CE 32 

#### Simplifying cost structure of CE 35 
 * Renamed intermediate variables: 
[ (eq(33,1),it(26))>>s(5)]

#### Simplifying cost structure of CE 33 
 * Renamed intermediate variables: 
[ (it(31),s(5))>>s(6)]

#### Simplifying cost structure of CE 31 

#### Cost of loops [27,28,29,30,31,32] 

 * loop 27:eval_simpl(A,B,C) -> [eval_simpl(A',B',C'),eval_simpl(A'2,B'2,C'2)] 
7*s(2)+9
  Such that:s(2) =< A-B'/2-A'2+1/2
s(2) =< A'2-B'2/2+1/2

 * loop 28:eval_simpl(A,B,C) -> [eval_simpl(A',B',C'),eval_simpl(A'2,B'2,C'2)] 
5*s(4)+8
  Such that:s(4) =< A-B'/2-A'2

 * loop 29:eval_simpl(A,B,C) -> [eval_simpl(A',B',C'),eval_simpl(A'2,B'2,C'2)] 
9
 * loop 30:eval_simpl(A,B,C) -> [eval_simpl(A',B',C'),eval_simpl(A'2,B'2,C'2)] 
8
 * loop 31:eval_simpl(A,B,C) -> [eval_simpl(A',B',C'),eval_simpl(A'2,B'2,C'2)] 
7*s(6)+13
  Such that:s(6) =< A-B'/2-A'2+1/2
s(6) =< A'2-B'2/2

 * loop 32:eval_simpl(A,B,C) -> [eval_simpl(A',B',C'),eval_simpl(A'2,B'2,C'2)] 
13
##### Pending set eval_simpl(A,B,C)
* Psum in Loop 27: [it(27)=<1,s(7)=<A-B'/2-A'2+1/2,s(7)=<A'2-B'2/2+1/2]
* Psum in Loop 28: [it(28)=<1,s(8)=<A-B'/2-A'2]
* Psum in Loop 29: [it(29)=<1]
* Psum in Loop 30: [it(30)=<1]
* Psum in Loop 31: [it(31)=<1,s(9)=<A-B'/2-A'2+1/2,s(9)=<A'2-B'2/2]
* Psum in Loop 32: [it(32)=<1]
* Psum in Chain-Tail [33]: [it([33])=<1]

###### Computing sum for it(27)=<1  in Loop 27 
   - Applying inductive sum strategy 
     - head Candidate: A/2-1 
       - Loop 28 is collaborative
       - Loop 29 is collaborative
       - Loop 30 is collaborative
       - Loop 31 is collaborative and bounds [it(31)] 
       - Loop 32 is collaborative
       - Chain [33] is ignored
     - head Candidate: A-B/2-3/2 
       - Loop 28 is collaborative
       - Loop 29 is collaborative
       - Loop 30 is collaborative
       - Loop 31 is collaborative and bounds [it(31)] 
       - Loop 32 is collaborative
       - Chain [33] is ignored
     - tail Candidate: A/2-1 
       - Loop 28 is collaborative and bounds [it(28)] 
       - Loop 29 is collaborative and bounds [it(29)] 
       - Loop 30 is collaborative and bounds [it(30)] 
       - Loop 31 is collaborative and bounds [it(31)] 
       - Loop 32 is collaborative and bounds [it(32)] 
       - Chain-Tail [33] adds a constant 1/2 
     - tail Candidate: A-B/2-3/2 
       - Loop 28 is collaborative and bounds [it(28)] 
       - Loop 29 is collaborative and bounds [it(29)] 
       - Loop 30 is collaborative and bounds [it(30)] 
       - Loop 31 is collaborative and bounds [it(31)] 
       - Loop 32 is collaborative and bounds [it(32)] 
       - Chain-Tail [33] adds a constant 1/1 
 * Adding constraints: [it(27)+it(28)+it(29)+it(30)+it(31)+it(32)=<it([33])* (1/2)+aux(3),it(27)+it(28)+it(29)+it(30)+it(31)+it(32)=<it([33])+aux(4),it(27)+it(31)=<A/2-1,it(27)+it(31)=<A-B/2-3/2,aux(3)=<A/2-1,aux(4)=<A-B/2-3/2] 

##### Pending set A
* Psum in Loop 27: [s(7)=<A-B'/2-A'2+1/2,s(7)=<A'2-B'2/2+1/2]
* Psum in Loop 28: [it(28)=<1,s(8)=<A-B'/2-A'2]
* Psum in Loop 29: [it(29)=<1]
* Psum in Loop 30: [it(30)=<1]
* Psum in Loop 31: [it(31)=<1,s(9)=<A-B'/2-A'2+1/2,s(9)=<A'2-B'2/2]
* Psum in Loop 32: [it(32)=<1]
* Psum in Chain-Tail [33]: [it([33])=<1]

###### Computing sum for s(7)=<A-B'/2-A'2+1/2  in Loop 27 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(5)=<A-B/2-1/2] 
 * Adding constraints: [s(7)=<it(27)*aux(5)] 

##### Pending set eval_simpl(A,B,C)
* Pmax/min: [aux(5)=<A-B/2-1/2]
* Psum in Loop 27: [s(7)=<A'2-B'2/2+1/2]
* Psum in Loop 28: [it(28)=<1,s(8)=<A-B'/2-A'2]
* Psum in Loop 29: [it(29)=<1]
* Psum in Loop 30: [it(30)=<1]
* Psum in Loop 31: [it(31)=<1,s(9)=<A-B'/2-A'2+1/2,s(9)=<A'2-B'2/2]
* Psum in Loop 32: [it(32)=<1]
* Psum in Chain-Tail [33]: [it([33])=<1]

###### Computing max_min for aux(5)=<A-B/2-1/2  
   - Applying max/min strategy 
     - Loop 27 does not increase the expression
     - Loop 28 does not increase the expression
     - Loop 29 does not increase the expression
     - Loop 30 does not increase the expression
     - Loop 31 does not increase the expression
     - Loop 32 does not increase the expression
 * Adding constraints:[aux(5)=<aux(6),aux(6)=<A-B/2-1/2] 

##### Pending set eval_simpl(A,B,C)
* Psum in Loop 27: [s(7)=<A'2-B'2/2+1/2]
* Psum in Loop 28: [it(28)=<1,s(8)=<A-B'/2-A'2]
* Psum in Loop 29: [it(29)=<1]
* Psum in Loop 30: [it(30)=<1]
* Psum in Loop 31: [it(31)=<1,s(9)=<A-B'/2-A'2+1/2,s(9)=<A'2-B'2/2]
* Psum in Loop 32: [it(32)=<1]
* Psum in Chain-Tail [33]: [it([33])=<1]

###### Computing sum for s(7)=<A'2-B'2/2+1/2  in Loop 27 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(7)=<A-B/2-1/2] 
 * Adding constraints: [s(7)=<it(27)*aux(7)] 

##### Pending set eval_simpl(A,B,C)
* Pmax/min: [aux(7)=<A-B/2-1/2]
* Psum in Loop 28: [it(28)=<1,s(8)=<A-B'/2-A'2]
* Psum in Loop 29: [it(29)=<1]
* Psum in Loop 30: [it(30)=<1]
* Psum in Loop 31: [it(31)=<1,s(9)=<A-B'/2-A'2+1/2,s(9)=<A'2-B'2/2]
* Psum in Loop 32: [it(32)=<1]
* Psum in Chain-Tail [33]: [it([33])=<1]

###### Computing max_min for aux(7)=<A-B/2-1/2  
   - Found a solution using cacheing 
 * Adding constraints:[aux(7)=<aux(5)] 

##### Pending set eval_simpl(A,B,C)
* Psum in Loop 28: [it(28)=<1,s(8)=<A-B'/2-A'2]
* Psum in Loop 29: [it(29)=<1]
* Psum in Loop 30: [it(30)=<1]
* Psum in Loop 31: [it(31)=<1,s(9)=<A-B'/2-A'2+1/2,s(9)=<A'2-B'2/2]
* Psum in Loop 32: [it(32)=<1]
* Psum in Chain-Tail [33]: [it([33])=<1]

###### Computing sum for it(28)=<1  in Loop 28 
   - Applying inductive sum strategy 
     - head Candidate: B/2-1/2 
       - Loop 27 is collaborative
       - Loop 29 is collaborative and bounds [it(29)] 
       - Loop 30 is collaborative and bounds [it(30)] 
       - Loop 31 is collaborative and bounds [it(31)] 
       - Loop 32 is collaborative and bounds [it(32)] 
       - Chain-Tail [33] is collaborative
     - head Candidate: 2/3*A-1 
       - Loop 27 is collaborative
       - Loop 29 is collaborative
       - Loop 30 is collaborative
       - Loop 31 is collaborative and bounds [it(31)] 
       - Loop 32 is collaborative and bounds [it(32)] 
       - Chain [33] is ignored
     - tail Candidate: B/2-1/2 
       - Loop 27 is collaborative
       - Loop 29 is collaborative and bounds [it(29)] 
       - Loop 30 is collaborative and bounds [it(30)] 
       - Loop 31 is collaborative and bounds [it(31)] 
       - Loop 32 is collaborative and bounds [it(32)] 
       - Chain-Tail [33] is collaborative
     - tail Candidate: 2/3*A-1 
       - Loop 27 is collaborative
       - Loop 29 is collaborative and bounds [it(29)] 
       - Loop 30 is collaborative and bounds [it(30)] 
       - Loop 31 is collaborative and bounds [it(31)] 
       - Loop 32 is collaborative and bounds [it(32)] 
       - Chain-Tail [33] adds a constant 1/3 
 * Adding constraints: [it(28)+it(29)+it(30)+it(31)+it(32)=<it([33])* (1/3)+aux(8),it(28)+it(29)+it(30)+it(31)+it(32)=<B/2-1/2,it(28)+it(31)+it(32)=<2/3*A-1,it(28)+it(29)+it(30)+it(31)+it(32)=<B/2-1/2,aux(8)=<2/3*A-1] 

##### Pending set eval_simpl(A,B,C)
* Psum in Loop 28: [s(8)=<A-B'/2-A'2]
* Psum in Loop 29: [it(29)=<1]
* Psum in Loop 30: [it(30)=<1]
* Psum in Loop 31: [it(31)=<1,s(9)=<A-B'/2-A'2+1/2,s(9)=<A'2-B'2/2]
* Psum in Loop 32: [it(32)=<1]
* Psum in Chain-Tail [33]: [it([33])=<1]

###### Computing sum for s(8)=<A-B'/2-A'2  in Loop 28 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(9)=<A-B/2] 
 * Adding constraints: [s(8)=<it(28)*aux(9)] 

##### Pending set eval_simpl(A,B,C)
* Pmax/min: [aux(9)=<A-B/2]
* Psum in Loop 29: [it(29)=<1]
* Psum in Loop 30: [it(30)=<1]
* Psum in Loop 31: [it(31)=<1,s(9)=<A-B'/2-A'2+1/2,s(9)=<A'2-B'2/2]
* Psum in Loop 32: [it(32)=<1]
* Psum in Chain-Tail [33]: [it([33])=<1]

###### Computing max_min for aux(9)=<A-B/2  
   - Found a solution using cacheing 
 * Adding constraints:[aux(9)=<aux(5)+1/2] 

##### Pending set eval_simpl(A,B,C)
* Psum in Loop 29: [it(29)=<1]
* Psum in Loop 30: [it(30)=<1]
* Psum in Loop 31: [it(31)=<1,s(9)=<A-B'/2-A'2+1/2,s(9)=<A'2-B'2/2]
* Psum in Loop 32: [it(32)=<1]
* Psum in Chain-Tail [33]: [it([33])=<1]

###### Computing sum for it(29)=<1  in Loop 29 
   - Applying inductive sum strategy 
     - head Candidate: B/2-1/2 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A-1 
       - Loop 27 is collaborative
       - Loop 28 is collaborative
       - Loop 30 is collaborative and bounds [it(30)] 
       - Loop 31 is collaborative and bounds [it(31)] 
       - Loop 32 is collaborative and bounds [it(32)] 
       - Chain-Tail [33] is collaborative
     - tail Candidate: B/2-1/2 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
       - Loop 27 is collaborative
       - Loop 28 is collaborative
       - Loop 30 is collaborative and bounds [it(30)] 
       - Loop 31 is collaborative and bounds [it(31)] 
       - Loop 32 is collaborative and bounds [it(32)] 
       - Chain-Tail [33] is collaborative
 * Adding constraints: [it(28)+it(29)+it(30)+it(31)+it(32)=<B/2-1/2,it(29)+it(30)+it(31)+it(32)=<A-1,it(28)+it(29)+it(30)+it(31)+it(32)=<B/2-1/2,it(29)+it(30)+it(31)+it(32)=<A-1] 

##### Pending set eval_simpl(A,B,C)
* Psum in Loop 30: [it(30)=<1]
* Psum in Loop 31: [it(31)=<1,s(9)=<A-B'/2-A'2+1/2,s(9)=<A'2-B'2/2]
* Psum in Loop 32: [it(32)=<1]
* Psum in Chain-Tail [33]: [it([33])=<1]

###### Computing sum for it(30)=<1  in Loop 30 
   - Applying inductive sum strategy 
     - head Candidate: B/2-1/2 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B/2-1/2 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(28)+it(29)+it(30)+it(31)+it(32)=<B/2-1/2,it(29)+it(30)+it(31)+it(32)=<A-1,it(28)+it(29)+it(30)+it(31)+it(32)=<B/2-1/2,it(29)+it(30)+it(31)+it(32)=<A-1] 

##### Pending set eval_simpl(A,B,C)
* Psum in Loop 31: [it(31)=<1,s(9)=<A-B'/2-A'2+1/2,s(9)=<A'2-B'2/2]
* Psum in Loop 32: [it(32)=<1]
* Psum in Chain-Tail [33]: [it([33])=<1]

###### Computing sum for it(31)=<1  in Loop 31 
   - Applying inductive sum strategy 
     - head Candidate: 2/3*A-B/3-4/3 
       - Loop 27 is collaborative
       - Loop 28 is collaborative
       - Loop 29 is collaborative
       - Loop 30 is collaborative
       - Loop 32 is collaborative
       - Chain [33] is ignored
     - head Candidate: B/2-1/2 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: 2/3*A-B/3-4/3 
       - Loop 27 is collaborative
       - Loop 28 is collaborative
       - Loop 29 is collaborative
       - Loop 30 is collaborative
       - Loop 32 is collaborative and bounds [it(32)] 
       - Chain-Tail [33] adds a constant 1/1 
     - tail Candidate: B/2-1/2 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(31)+it(32)=<it([33])+aux(10),it(31)=<2/3*A-B/3-4/3,it(28)+it(29)+it(30)+it(31)+it(32)=<B/2-1/2,aux(10)=<2/3*A-B/3-4/3,it(28)+it(29)+it(30)+it(31)+it(32)=<B/2-1/2] 

##### Pending set eval_simpl(A,B,C)
* Psum in Loop 31: [s(9)=<A-B'/2-A'2+1/2,s(9)=<A'2-B'2/2]
* Psum in Loop 32: [it(32)=<1]
* Psum in Chain-Tail [33]: [it([33])=<1]

###### Computing sum for s(9)=<A-B'/2-A'2+1/2  in Loop 31 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(11)=<A-B/2-3/2] 
 * Adding constraints: [s(9)=<it(31)*aux(11)] 

##### Pending set eval_simpl(A,B,C)
* Pmax/min: [aux(11)=<A-B/2-3/2]
* Psum in Loop 31: [s(9)=<A'2-B'2/2]
* Psum in Loop 32: [it(32)=<1]
* Psum in Chain-Tail [33]: [it([33])=<1]

###### Computing max_min for aux(11)=<A-B/2-3/2  
   - Found a solution using cacheing 
 * Adding constraints:[aux(11)=<aux(5)-1] 

##### Pending set eval_simpl(A,B,C)
* Psum in Loop 31: [s(9)=<A'2-B'2/2]
* Psum in Loop 32: [it(32)=<1]
* Psum in Chain-Tail [33]: [it([33])=<1]

###### Computing sum for s(9)=<A'2-B'2/2  in Loop 31 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(12)=<A-B/2-1] 
 * Adding constraints: [s(9)=<it(31)*aux(12)] 

##### Pending set eval_simpl(A,B,C)
* Pmax/min: [aux(12)=<A-B/2-1]
* Psum in Loop 32: [it(32)=<1]
* Psum in Chain-Tail [33]: [it([33])=<1]

###### Computing max_min for aux(12)=<A-B/2-1  
   - Found a solution using cacheing 
 * Adding constraints:[aux(12)=<aux(5)-1/2] 

##### Pending set eval_simpl(A,B,C)
* Psum in Loop 32: [it(32)=<1]
* Psum in Chain-Tail [33]: [it([33])=<1]

###### Computing sum for it(32)=<1  in Loop 32 
   - Applying inductive sum strategy 
     - head Candidate: B/2-1/2 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: 2/3*A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B/2-1/2 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: 2/3*A-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(28)+it(29)+it(30)+it(31)+it(32)=<it([33])* (1/3)+aux(13),it(28)+it(29)+it(30)+it(31)+it(32)=<B/2-1/2,it(28)+it(31)+it(32)=<2/3*A-1,it(28)+it(29)+it(30)+it(31)+it(32)=<B/2-1/2,aux(13)=<2/3*A-1] 

##### Pending set eval_simpl(A,B,C)
* Psum in Chain-Tail [33]: [it([33])=<1]

###### Computing sum for it([33])=<1  in Chain-Tail [33] 
   - Applying inductive sum strategy 
     - head Candidate: A 
       - Loop 27 is collaborative
       - Loop 28 is collaborative
       - Loop 29 is collaborative
       - Loop 30 is collaborative
       - Loop 31 is collaborative
       - Loop 32 is collaborative
     - head Candidate: B/2+1/2 
       - Loop 27 is collaborative
       - Loop 28 is collaborative
       - Loop 29 is collaborative
       - Loop 30 is collaborative
       - Loop 31 is collaborative
       - Loop 32 is collaborative
     - tail Candidate: A 
       - Loop 27 is collaborative
       - Loop 28 is collaborative
       - Loop 29 is collaborative
       - Loop 30 is collaborative
       - Loop 31 is collaborative
       - Loop 32 is collaborative
     - tail Candidate: B/2+1/2 
       - Loop 27 is collaborative
       - Loop 28 is collaborative
       - Loop 29 is collaborative
       - Loop 30 is collaborative
       - Loop 31 is collaborative
       - Loop 32 is collaborative
 * Adding constraints: [it([33])=<A,it([33])=<B/2+1/2,it([33])=<A,it([33])=<B/2+1/2] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [27,28,29,30,31,32,[33]] 

#### Simplifying cost structure of phase [27,28,29,30,31,32,[33]] 
 * Joined equivalent variables [aux(6),aux(5)] into aux(6)
 * Joined equivalent variables [aux(15),aux(4),aux(6)] into aux(15)
 * Joined equivalent variables [aux(16),aux(3)] into aux(16)
 * Joined equivalent variables [aux(17),aux(8),aux(13)] into aux(17)
 * Joined equivalent variables [aux(18),aux(10)] into aux(18)
 * Joined equivalent variables [it(29),it(30)] into it(29)

#### Cost of phase [27,28,29,30,31,32]:eval_simpl(A,B,C) -> [] 
9*it(27)+8*it(28)+17*it(29)+13*it(31)+13*it(32)+2*it([33])+7*s(7)+5*s(8)+7*s(9)+0
  Such that:it([33]) =< B/2+1/2
aux(14) =< A
aux(15) =< A-B/2
aux(16) =< A/2
aux(17) =< 2/3*A
aux(18) =< 2/3*A-B/3
aux(19) =< B/2
it(29) =< aux(14)
it(31) =< aux(14)
it(32) =< aux(14)
it([33]) =< aux(14)
it(27) =< aux(15)
it(31) =< aux(15)
it(27) =< aux(16)
it(31) =< aux(16)
it(28) =< aux(17)
it(31) =< aux(17)
it(32) =< aux(17)
it(31) =< aux(18)
it(28) =< aux(19)
it(29) =< aux(19)
it(31) =< aux(19)
it(32) =< aux(19)
it(28) =< it([33])* (1/3)+aux(17)
it(29) =< it([33])* (1/3)+aux(17)
it(31) =< it([33])* (1/3)+aux(17)
it(32) =< it([33])* (1/3)+aux(17)
it(31) =< it([33])+aux(18)
it(32) =< it([33])+aux(18)
it(27) =< it([33])+aux(15)
it(28) =< it([33])+aux(15)
it(29) =< it([33])+aux(15)
it(31) =< it([33])+aux(15)
it(32) =< it([33])+aux(15)
it(27) =< it([33])* (1/2)+aux(16)
it(28) =< it([33])* (1/2)+aux(16)
it(29) =< it([33])* (1/2)+aux(16)
it(31) =< it([33])* (1/2)+aux(16)
it(32) =< it([33])* (1/2)+aux(16)
aux(12) =< aux(15)-1/2
aux(11) =< aux(15)-1
aux(9) =< aux(15)+1/2
aux(7) =< aux(15)
s(7) =< it(27)*aux(15)
s(9) =< it(31)*aux(12)
s(9) =< it(31)*aux(11)
s(8) =< it(28)*aux(9)
s(7) =< it(27)*aux(7)

#### Cost of chains of eval_simpl(A,B,C):
* Chain [33]: 2
  with precondition: [B=1,A=C,A>=1] 

* Chain [multiple([27,28,29,30,31,32],[[33]])]: 9*it(27)+8*it(28)+17*it(29)+13*it(31)+13*it(32)+2*it([33])+7*s(7)+5*s(8)+7*s(9)+0
  Such that:it([33]) =< B/2+1/2
aux(14) =< A
aux(15) =< A-B/2
aux(16) =< A/2
aux(17) =< 2/3*A
aux(18) =< 2/3*A-B/3
aux(19) =< B/2
it(29) =< aux(14)
it(31) =< aux(14)
it(32) =< aux(14)
it([33]) =< aux(14)
it(27) =< aux(15)
it(31) =< aux(15)
it(27) =< aux(16)
it(31) =< aux(16)
it(28) =< aux(17)
it(31) =< aux(17)
it(32) =< aux(17)
it(31) =< aux(18)
it(28) =< aux(19)
it(29) =< aux(19)
it(31) =< aux(19)
it(32) =< aux(19)
it(28) =< it([33])* (1/3)+aux(17)
it(29) =< it([33])* (1/3)+aux(17)
it(31) =< it([33])* (1/3)+aux(17)
it(32) =< it([33])* (1/3)+aux(17)
it(31) =< it([33])+aux(18)
it(32) =< it([33])+aux(18)
it(27) =< it([33])+aux(15)
it(28) =< it([33])+aux(15)
it(29) =< it([33])+aux(15)
it(31) =< it([33])+aux(15)
it(32) =< it([33])+aux(15)
it(27) =< it([33])* (1/2)+aux(16)
it(28) =< it([33])* (1/2)+aux(16)
it(29) =< it([33])* (1/2)+aux(16)
it(31) =< it([33])* (1/2)+aux(16)
it(32) =< it([33])* (1/2)+aux(16)
aux(12) =< aux(15)-1/2
aux(11) =< aux(15)-1
aux(9) =< aux(15)+1/2
aux(7) =< aux(15)
s(7) =< it(27)*aux(15)
s(9) =< it(31)*aux(12)
s(9) =< it(31)*aux(11)
s(8) =< it(28)*aux(9)
s(7) =< it(27)*aux(7)

  with precondition: [B>=3,C>=1,2*A+1>=2*C+B] 


#### Simplifying cost structure of CE 37 

#### Simplifying cost structure of CE 38 

#### Simplifying cost structure of chain [35,36] 

#### Computing cost of phase [34] 
 * Renamed intermediate variables: 
[ (eq(39,1),it(17))>>s(10)]

#### Simplifying cost structure of CE 39 
 * Renamed intermediate variables: 
[ (it(34),s(10))>>s(11)]

#### Cost of loops [34] 

 * loop 34:mult(A,B,C) -> [mult(A',B',C')] 
5*s(11)+7
  Such that:s(11) =< A'

##### Pending set mult(A,B,C)
* Psum in Loop 34: [it(34)=<1,s(12)=<A']

###### Computing sum for it(34)=<1  in Loop 34 
   - Applying inductive sum strategy 
     - head Candidate: A-2 
     - head Candidate: A-2 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-2 
     - tail Candidate: A-2 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(34)=<A-2,it(34)=<A-2,it(34)=<A-A',it(34)=<A-A'] 

##### Pending set A
* Psum in Loop 34: [s(12)=<A']

###### Computing sum for s(12)=<A'  in Loop 34 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(20)=<A-1] 
 * Adding constraints: [s(12)=<it(34)*aux(20)] 

##### Pending set mult(A,B,C)
* Pmax/min: [aux(20)=<A-1]

###### Computing max_min for aux(20)=<A-1  
   - Found a solution using transitive invariants 
 * Adding constraints:[aux(20)=<A-1] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [34] 

#### Simplifying cost structure of phase [34] 
 * Joined equivalent variables [aux(21),aux(20)] into aux(21)

#### Cost of phase [34]:mult(A,B,C) -> [mult(A',B',C')] 
7*it(34)+5*s(12)+0
  Such that:it(34) =< A-A'
aux(21) =< A
it(34) =< aux(21)
s(12) =< it(34)*aux(21)

#### Simplifying cost structure of chain [[34],35,36] 
 * Joined equivalent variables [aux(22),aux(21)] into aux(22)

#### Cost of chains of mult(A,B,C):
* Chain [[34],35,36]: 7*it(34)+5*s(12)+10
  Such that:aux(22) =< A
it(34) =< aux(22)
s(12) =< it(34)*aux(22)

  with precondition: [A>=3,B>=0,C+1>=A] 

* Chain [36]: 3
  with precondition: [A=1,C=1,B>=0] 

* Chain [35,36]: 10
  with precondition: [A=2,C=1,B>=0] 


#### Simplifying cost structure of CE 40 

#### Computing cost of phase [37] 

#### Simplifying cost structure of CE 41 

#### Cost of loops [37] 

 * loop 37:nat_to_int(A,B) -> [nat_to_int(A',B')] 
6
##### Pending set nat_to_int(A,B)
* Psum in Loop 37: [it(37)=<1]

###### Computing sum for it(37)=<1  in Loop 37 
   - Applying inductive sum strategy 
     - head Candidate: A-1 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(37)=<A-1,it(37)=<A-1,it(37)=<A-A',it(37)=<A-A'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [37] 

#### Simplifying cost structure of phase [37] 

#### Cost of phase [37]:nat_to_int(A,B) -> [nat_to_int(A',B')] 
6*it(37)+0
  Such that:it(37) =< A
it(37) =< A-A'

#### Simplifying cost structure of chain [[37],38] 

#### Cost of chains of nat_to_int(A,B):
* Chain [[37],38]: 6*it(37)+3
  Such that:it(37) =< B

  with precondition: [A=B+1,A>=2] 

* Chain [38]: 3
  with precondition: [A=1,B=0] 


Closed-form bounds of add(A,B,C): 
-------------------------------------
* Chain [[17],18] with precondition: [A+B=C+1,A>=2,B>=1] 
    - Upper bound: 5*A+2 
    - Complexity: n 
* Chain [18] with precondition: [A=1,B=C,B>=0] 
    - Upper bound: 2 
    - Complexity: constant 

### Maximum cost of add(A,B,C): 5*A+2 
Asymptotic class: n 

Closed-form bounds of sub(A,B,C): 
-------------------------------------
* Chain [[26],25] with precondition: [C=1,A>=2,B>=A+1] 
    - Upper bound: 7*A+6 
    - Complexity: n 
* Chain [[26],24] with precondition: [A+1=B+C,B>=2,A>=B] 
    - Upper bound: 7*B+2 
    - Complexity: n 
* Chain [25] with precondition: [A=1,C=1,B>=2] 
    - Upper bound: 6 
    - Complexity: constant 
* Chain [24] with precondition: [B=1,A=C,A>=0] 
    - Upper bound: 2 
    - Complexity: constant 

### Maximum cost of sub(A,B,C): max([7*A+4,7*B])+2 
Asymptotic class: n 

Closed-form bounds of mult(A,B,C): 
-------------------------------------
* Chain [[34],35,36] with precondition: [A>=3,B>=0,C+1>=A] 
    - Upper bound: 7*A+10+5*A*A 
    - Complexity: n^2 
* Chain [36] with precondition: [A=1,C=1,B>=0] 
    - Upper bound: 3 
    - Complexity: constant 
* Chain [35,36] with precondition: [A=2,C=1,B>=0] 
    - Upper bound: 10 
    - Complexity: constant 

### Maximum cost of mult(A,B,C): max([7,7*A+7+5*A*A])+3 
Asymptotic class: n^2 

Closed-form bounds of eval_simpl(A,B,C): 
-------------------------------------
* Chain [33] with precondition: [B=1,A=C,A>=1] 
    - Upper bound: 2 
    - Complexity: constant 
* Chain [multiple([27,28,29,30,31,32],[[33]])] with precondition: [B>=3,C>=1,2*A+1>=2*C+B] 
    - Upper bound: 9*A-9/2*B+ ((7*A-7/2*B-7/2)*A+43*A+7*A+ (B+1))+ (5*A-5/2*B)* (2/3*A)+ (7*A-7/2*B)* (A-B/2) 
    - Complexity: n^2 

### Maximum cost of eval_simpl(A,B,C): max([2,9*A-9/2*B+ ((7*A-7/2*B-7/2)*A+43*A+7*A+ (B+1))+ (5*A-5/2*B)* (2/3*A)+ (7*A-7/2*B)* (A-B/2)]) 
Asymptotic class: n^2 

Closed-form bounds of eval(A,B,C): 
-------------------------------------
* Chain [multiple([20,21,22,23],[[],[19]])]... with precondition: [A>=0,C>=1,B>=3] 
    - Upper bound: 111/2*B+2 
    - Complexity: n 
* Chain [19] with precondition: [B=1,A=C,A>=1] 
    - Upper bound: 2 
    - Complexity: constant 

### Maximum cost of eval(A,B,C): 111/2*B+2 
Asymptotic class: n 

Closed-form bounds of nat_to_int(A,B): 
-------------------------------------
* Chain [[37],38] with precondition: [A=B+1,A>=2] 
    - Upper bound: 6*A+3 
    - Complexity: n 
* Chain [38] with precondition: [A=1,B=0] 
    - Upper bound: 3 
    - Complexity: constant 

### Maximum cost of nat_to_int(A,B): 6*A+3 
Asymptotic class: n 
* Total analysis performed in 716 ms.


Cost relation system solved by CoFloCo in 718 ms.

Method add terminates?: YES

 - n1_1: size of n1 wrt. Nat
 - n2_1: size of n2 wrt. Nat
UB for add(n1_1,n2_1) = 5*n1_1+2

Method sub terminates?: YES

 - n1_1: size of n1 wrt. Nat
 - n2_1: size of n2 wrt. Nat
UB for sub(n1_1,n2_1) = max([7*n1_1+4,7*n2_1])+2

Method mult terminates?: YES

 - n1_1: size of n1 wrt. Nat
 - n2_1: size of n2 wrt. Nat
UB for mult(n1_1,n2_1) = max([7,7*n1_1+7+5*n1_1*n1_1])+3

Method eval_simpl terminates?: YES

 - expr_1: size of expr wrt. Nat
 - expr_2: size of expr wrt. Expr
UB for eval_simpl(expr_1,expr_2) = max([2,9*expr_1-9/2*expr_2+ ((7*expr_1-7/2*expr_2-7/2)*expr_1+43*expr_1+7*expr_1+ (expr_2+1))+ (5*expr_1-5/2*expr_2)* (2/3*expr_1)+ (7*expr_1-7/2*expr_2)* (expr_1-expr_2/2)])

Method eval terminates?: YES

 - expr_1: size of expr wrt. Nat
 - expr_2: size of expr wrt. Expr
UB for eval(expr_1,expr_2) = 111/2*expr_2+2

Method nat_to_int terminates?: YES

 - n_1: size of n wrt. Nat
UB for nat_to_int(n_1) = 6*n_1+3
