
Abs program loaded in 24 ms.

Rule based representation generated in 8 ms.

Rule based representation stored in /tmp/costabs/rbr.rbr

RBR properties stored in /tmp/costabs/rbr.properties

Class invariants generated and loaded in 0 ms.

Abstract compilation performed in 44 ms.

Cost relation system stored in /tmp/costabs/crs.crs

Generated 59 equations 
entry('r1'(A,B,C,D,E,F):[]).
entry('rev'(A,B,C,D):[]).
entry('append'(A,B,C,D,E,F):[]).
entry('f'(A,B,C,D,E,F):[]).
entry('g'(A,B,C,D,E,F,G,H):[]).
entry('p'(A,B,C,D,E,F,G,H):[]).
entry('f2'(A,B,C,D,E,F):[]).
entry('last'(A,B,C,D):[]).
entry('f2p'(A,B,C,D,E,F):[]).
entry('g3'(A,B,C,D,E,F):[]).
entry('f3'(A,B,C,D,E,F):[]).
input_output_vars('and_op'(A,B,C),[A,B],[C]).
input_output_vars('append'(A,B,C,D,E,F),[A,B,C,D],[E,F]).
input_output_vars('case_0'(A,B,C,D,E,F),[A,B,C,D],[E,F]).
input_output_vars('case_1'(A,B,C,D,E,F),[A,B,C,D],[E,F]).
input_output_vars('case_10'(A,B,C,D,E,F,G,H,I),[A,B,C,D,E,F,G],[H,I]).
input_output_vars('case_11'(A,B,C,D,E,F),[A,B,C,D],[E,F]).
input_output_vars('case_12'(A,B,C,D,E,F),[A,B,C,D],[E,F]).
input_output_vars('case_2'(A,B,C,D,E,F),[A,B,C,D],[E,F]).
input_output_vars('case_3'(A,B,C,D,E,F,G,H),[A,B,C,D,E,F],[G,H]).
input_output_vars('case_4'(A,B,C,D,E,F,G,H),[A,B,C,D,E,F],[G,H]).
input_output_vars('case_5'(A,B,C,D,E,F),[A,B,C,D],[E,F]).
input_output_vars('case_6'(A,B,C,D,E,F,G,H,I),[A,B,C,D,E,F,G],[H,I]).
input_output_vars('case_7'(A,B,C,D),[A,B],[C,D]).
input_output_vars('case_8'(A,B,C,D,E,F,G,H,I),[A,B,C,D,E,F,G],[H,I]).
input_output_vars('case_9'(A,B,C,D,E,F),[A,B,C,D],[E,F]).
input_output_vars('eq'(A,B,C),[A,B],[C]).
input_output_vars('f'(A,B,C,D,E,F),[A,B,C,D],[E,F]).
input_output_vars('f2'(A,B,C,D,E,F),[A,B,C,D],[E,F]).
input_output_vars('f2p'(A,B,C,D,E,F),[A,B,C,D],[E,F]).
input_output_vars('f3'(A,B,C,D,E,F),[A,B,C,D],[E,F]).
input_output_vars('g'(A,B,C,D,E,F,G,H),[A,B,C,D,E,F],[G,H]).
input_output_vars('g3'(A,B,C,D,E,F),[A,B,C,D],[E,F]).
input_output_vars('geq'(A,B,C),[A,B],[C]).
input_output_vars('gt'(A,B,C),[A,B],[C]).
input_output_vars('last'(A,B,C,D),[A,B],[C,D]).
input_output_vars('leq'(A,B,C),[A,B],[C]).
input_output_vars('lt'(A,B,C),[A,B],[C]).
input_output_vars('maxNorm'(A,B,C),[A,B],[C]).
input_output_vars('neg'(A,B),[A],[B]).
input_output_vars('neq'(A,B,C),[A,B],[C]).
input_output_vars('or'(A,B,C),[A,B],[C]).
input_output_vars('p'(A,B,C,D,E,F,G,H),[A,B,C,D,E,F],[G,H]).
input_output_vars('r1'(A,B,C,D,E,F),[A,B,C,D],[E,F]).
input_output_vars('rev'(A,B,C,D),[A,B],[C,D]).
eq('eq',[A,B,C],0,[],[A=B,C=1,A>=0,B>=0,C>=0]).
eq('eq',[A,B,C],0,[],[A>=B+1,C=0,A>=0,B>=0,C>=0]).
eq('eq',[A,B,C],0,[],[B>=A+1,C=0,A>=0,B>=0,C>=0]).
eq('neq',[A,B,C],0,[],[A=B,C=0,A>=0,B>=0,C>=0]).
eq('neq',[A,B,C],0,[],[A>=B+1,C=1,A>=0,B>=0,C>=0]).
eq('neq',[A,B,C],0,[],[B>=A+1,C=1,A>=0,B>=0,C>=0]).
eq('lt',[A,B,C],0,[],[B-A>=1,C=1,A>=0,B>=0,C>=0]).
eq('lt',[A,B,C],0,[],[B=<A,C=0,A>=0,B>=0,C>=0]).
eq('leq',[A,B,C],0,[],[A=<B,C=1,A>=0,B>=0,C>=0]).
eq('leq',[A,B,C],0,[],[A-B>=1,C=0,A>=0,B>=0,C>=0]).
eq('gt',[A,B,C],0,[],[A-B>=1,C=1,A>=0,B>=0,C>=0]).
eq('gt',[A,B,C],0,[],[A=<B,C=0,A>=0,B>=0,C>=0]).
eq('geq',[A,B,C],0,[],[B=<A,C=1,A>=0,B>=0,C>=0]).
eq('geq',[A,B,C],0,[],[B-A>=1,C=0,A>=0,B>=0,C>=0]).
eq('neg',[A,B],0,[],[A=0,B=1,A>=0,B>=0]).
eq('neg',[A,B],0,[],[A=1,B=0,A>=0,B>=0]).
eq('and_op',[A,B,C],0,[],[A=0,C=0,A>=0,B>=0,C>=0]).
eq('and_op',[A,B,C],0,[],[A=1,C=B,A>=0,B>=0,C>=0]).
eq('or',[A,B,C],0,[],[A=1,C=1,A>=0,B>=0,C>=0]).
eq('or',[A,B,C],0,[],[A=0,C=B,A>=0,B>=0,C>=0]).
eq('maxNorm',[A,B,A],0,[],[A>=1+B,A>=0,B>=0,A>=0]).
eq('maxNorm',[A,B,B],0,[],[A=<B,A>=0,B>=0,B>=0]).
eq('case_0',[A,B,C,D,C,D],1,[],[B=0,A=1,A>=0,B>=0,C>=0,D>=0,C>=0,D>=0]).
eq('case_0',[A,B,C,D,E,F],4,['r1'(G,H,I,J,E,F)],[B=K+H,A=G+1,G>=1,K>=1,J=K+D,I=C+1,C>=1,K>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0]).
eq('r1',[A,B,C,D,E,F],1,['case_0'(A,B,C,D,E,F)],[A>=0,B>=0,C>=0,D>=0,E>=0,F>=0]).
eq('rev',[A,B,C,D],2,['r1'(A,B,E,F,C,D)],[F=0,E=1,A>=0,B>=0,C>=0,D>=0]).
eq('case_1',[A,B,C,D,C,D],1,[],[B=0,A=1,A>=0,B>=0,C>=0,D>=0,C>=0,D>=0]).
eq('case_1',[A,B,C,D,E,F],4,['append'(G,H,C,D,I,J)],[B=K+H,A=G+1,G>=1,K>=1,F=K+J,E=I+1,I>=1,K>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0]).
eq('append',[A,B,C,D,E,F],1,['case_1'(A,B,C,D,E,F)],[A>=0,B>=0,C>=0,D>=0,E>=0,F>=0]).
eq('case_2',[A,B,C,D,C,D],1,[],[B=0,A=1,A>=0,B>=0,C>=0,D>=0,C>=0,D>=0]).
eq('case_2',[A,B,C,D,E,F],3,['g'(G,H,C,D,A,B,E,F)],[B=I+H,A=G+1,G>=1,I>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0]).
eq('f',[A,B,C,D,E,F],1,['case_2'(A,B,C,D,E,F)],[A>=0,B>=0,C>=0,D>=0,E>=0,F>=0]).
eq('g',[A,B,C,D,E,F,G,H],2,['append'(C,D,E,F,I,J),'f'(A,B,I,J,G,H)],[A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0]).
eq('case_3',[A,B,C,D,E,F,G,H],2,['p'(A,B,I,J,C,D,G,H)],[F=K+J,K>=1,E=I+1,I>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0]).
eq('case_4',[A,B,C,D,E,F,G,H],3,['p'(I,J,K,L,A,B,G,H)],[D=M+L,M>=1,C=K+1,K>=1,J=0,I=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0]).
eq('case_4',[A,B,C,D,E,F,A,B],2,[],[D=0,C=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,A>=0,B>=0]).
eq('case_3',[A,B,C,D,E,F,G,H],3,['case_4'(A,B,C,D,E,F,G,H)],[F=0,E=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0]).
eq('p',[A,B,C,D,E,F,G,H],1,['case_3'(A,B,C,D,E,F,G,H)],[A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0]).
eq('case_5',[A,B,C,D,A,B],1,[],[D=0,C=1,A>=0,B>=0,C>=0,D>=0,A>=0,B>=0]).
eq('case_6',[A,B,C,D,E,F,G,H,I],2,['f2'(C,D,F,G,H,I)],[B=0,A=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0]).
eq('case_6',[A,B,C,D,E,F,G,H,I],3,['f2'(C,D,J,K,H,I)],[B=L+K,A=J+1,J>=1,L>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0]).
eq('case_5',[A,B,C,D,E,F],3,['case_6'(A,B,C,D,G,H,I,E,F)],[D=G+I,C=H+1,H>=1,G>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0]).
eq('f2',[A,B,C,D,E,F],1,['case_5'(A,B,C,D,E,F)],[A>=0,B>=0,C>=0,D>=0,E>=0,F>=0]).
eq('case_7',[A,B,C,D],2,[],[B=0,A=1,D=0,C=1,A>=0,B>=0,C>=0,D>=0]).
eq('case_8',[A,B,C,D,E,F,G,H,I],3,[],[B=0,A=1,J=0,K=1,I=E+J,H=K+1,K>=1,E>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0]).
eq('case_8',[A,B,C,D,E,F,G,A,B],2,[],[B=H+I,A=J+1,J>=1,H>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,A>=0,B>=0]).
eq('case_7',[A,B,C,D],6,['last'(E,F,G,H),'case_8'(I,J,A,B,K,E,F,L,M)],[B=K+F,A=E+1,E>=1,K>=1,J=H,I=G,G>=1,D=M,C=L,L>=1,A>=0,B>=0,C>=0,D>=0]).
eq('last',[A,B,C,D],1,['case_7'(A,B,C,D)],[A>=0,B>=0,C>=0,D>=0]).
eq('case_9',[A,B,C,D,A,B],1,[],[D=0,C=1,A>=0,B>=0,C>=0,D>=0,A>=0,B>=0]).
eq('case_10',[A,B,C,D,E,F,G,H,I],2,['last'(C,D,H,I)],[B=0,A=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0]).
eq('case_10',[A,B,C,D,E,F,G,H,I],3,['f2p'(C,D,J,K,H,I)],[B=L+K,A=J+1,J>=1,L>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0,G>=0,H>=0,I>=0]).
eq('case_9',[A,B,C,D,E,F],3,['case_10'(A,B,C,D,G,H,I,E,F)],[D=G+I,C=H+1,H>=1,G>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0]).
eq('f2p',[A,B,C,D,E,F],1,['case_9'(A,B,C,D,E,F)],[A>=0,B>=0,C>=0,D>=0,E>=0,F>=0]).
eq('case_11',[A,B,C,D,C,D],1,[],[B=0,A=1,A>=0,B>=0,C>=0,D>=0,C>=0,D>=0]).
eq('case_11',[A,B,C,D,E,F],4,['g3'(G,H,I,J,E,F)],[B=K+H,A=G+1,G>=1,K>=1,J=K+D,I=C+1,C>=1,K>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0]).
eq('g3',[A,B,C,D,E,F],1,['case_11'(A,B,C,D,E,F)],[A>=0,B>=0,C>=0,D>=0,E>=0,F>=0]).
eq('case_12',[A,B,C,D,E,F],3,['g3'(A,B,G,H,E,F)],[D=0,C=1,H=0,G=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0]).
eq('case_12',[A,B,C,D,E,F],4,['f3'(G,H,I,J,E,F)],[D=K+J,C=I+1,I>=1,K>=1,H=K+B,G=A+1,A>=1,K>=1,A>=0,B>=0,C>=0,D>=0,E>=0,F>=0]).
eq('f3',[A,B,C,D,E,F],1,['case_12'(A,B,C,D,E,F)],[A>=0,B>=0,C>=0,D>=0,E>=0,F>=0]).

Preprocessing Cost Relations
=====================================

#### Computed strongly connected components 
0. recursive  : [append/6,case_1/6]
1. recursive  : [case_2/6,f/6,g/8]
2. recursive  : [case_5/6,case_6/9,f2/6]
3. non_recursive  : [case_8/9]
4. recursive [non_tail] : [case_7/4,last/4]
5. recursive  : [case_10/9,case_9/6,f2p/6]
6. recursive  : [case_11/6,g3/6]
7. recursive  : [case_12/6,f3/6]
8. recursive  : [case_3/8,case_4/8,p/8]
9. recursive  : [case_0/6,r1/6]
10. non_recursive  : [rev/4]
* The entry g/8 is not a cutpoint so it becomes a new SCC 11
Warning: the following predicates are never called:[and_op/3,eq/3,geq/3,gt/3,leq/3,lt/3,maxNorm/3,neg/2,neq/3,or/3]

#### Obtained direct recursion through partial evaluation 
0. SCC is partially evaluated into append/6
1. SCC is partially evaluated into f/6
2. SCC is partially evaluated into f2/6
3. SCC is partially evaluated into case_8/9
4. SCC is partially evaluated into last/4
5. SCC is partially evaluated into f2p/6
6. SCC is partially evaluated into g3/6
7. SCC is partially evaluated into f3/6
8. SCC is partially evaluated into p/8
9. SCC is partially evaluated into r1/6
10. SCC is partially evaluated into rev/4
11. SCC is partially evaluated into g/8

Control-Flow Refinement of Cost Relations
=====================================

### Specialization of cost equations append/6 
* CE 5 is refined into CE [26] 
* CE 4 is refined into CE [27] 


#### Refined cost equations append/6 
* CE 26: append(A,B,C,D,C,D) = 2
     [D>=0,C>=0,B=0,A=1] 
* CE 27: append(A,B,C,D,E,F) = 5+ append(G,H,C,D,I,J)
     [F+H>=J,F>=J+1,I>=1,G>=1,F>=0,D>=0,C>=0,B+J=F+H,I+1=E,G+1=A] 

### Cost equations --> "Loop" of append/6 
* CEs [27] --> Loop 26 
* CEs [26] --> Loop 27 

#### Loops of append/6 
* Loop 26: append(A,B,C,D,E,F)->  append(A',B',C,D,C',D')
                  [F+B'>=D',F>=D'+1,C'>=1,A'>=1,F>=0,D>=0,C>=0,F+B'=B+D',C'+1=E,A'+1=A] 
* Loop 27: append(A,B,C,D,C,D) [D>=0,C>=0,B=0,A=1] 

### Ranking functions of CR append(A,B,C,D,E,F) 
* RF of phase [26]: [A-1,B+1]

#### Partial ranking functions of CR append(A,B,C,D,E,F) 
* Partial RF of phase [26]:
  - RF of loop [26:1]:
    A-1
    B+1

Discarded unfeasible chain [[26]]...(Non-terminating chain proved terminating)

### Resulting Chains:append(A,B,C,D,E,F) 
* [[26],27]
* [27]


### Merging Chains  append/6 into  External patterns of execution 
* [[27]] --> 1 
* [[27,[26]]] --> 2 


### Specialization of cost equations f/6 
* CE 7 is refined into CE [28] 
* CE 6 is refined into CE [29,30] 


#### Refined cost equations f/6 
* CE 28: f(A,B,C,D,C,D) = 2
     [D>=0,C>=0,B=0,A=1] 
* CE 29: f(A,B,C,D,E,F) = 6+ append(G,H,A,B,A,B):1+ f(I,J,A,B,E,F)
     [B>=J+1,J>=0,A>=2,F>=0,E>=0,A=I+1,H=0,G=1,D=0,C=1] 
* CE 30: f(A,B,C,D,E,F) = 6+ append(C,D,G,H,I,J):2+ f(K,L,I,J,E,F)
     [J>=D+L+1,I>=C+1,D+1>=C,L>=0,C>=2,F>=0,E>=0,J=D+H,I=C+K,I+1=C+G,J=B+D,I+1=A+C] 

### Cost equations --> "Loop" of f/6 
* CEs [30] --> Loop 28 
* CEs [29] --> Loop 29 
* CEs [28] --> Loop 30 

#### Loops of f/6 
* Loop 28: f(A,B,C,D,E,F)->  f(A',B',C',D',E,F)
                  [B>=B'+1,D+1>=C,B'>=0,F>=0,E>=0,C>=2,A>=2,B+D=D',A+C=C'+1,A=A'+1] 
* Loop 29: f(A,B,C,D,E,F)->  f(A',B',A,B,E,F)
                  [B>=B'+1,B'>=0,F>=0,E>=0,A>=2,A=A'+1,D=0,C=1] 
* Loop 30: f(A,B,C,D,C,D) [D>=0,C>=0,B=0,A=1] 

### Ranking functions of CR f(A,B,C,D,E,F) 
* RF of phase [28]: [A-1,B]

#### Partial ranking functions of CR f(A,B,C,D,E,F) 
* Partial RF of phase [28]:
  - RF of loop [28:1]:
    A-1
    B

Discarded unfeasible chain [[28]]...(Non-terminating chain proved terminating)
Discarded unfeasible chain [29,[28]](Non-terminating chain proved terminating)

### Resulting Chains:f(A,B,C,D,E,F) 
* [[28],30]
* [30]
* [29,[28],30]
* [29,30]


### Merging Chains  f/6 into  External patterns of execution 
* [[30]] --> 1 
* [[30,29]] --> 2 
* [[30,[28],29]] --> 3 
* [[30,[28]]] --> 4 


### Specialization of cost equations f2/6 
* CE 14 is refined into CE [31] 
* CE 13 is refined into CE [32] 
* CE 12 is refined into CE [33] 


#### Refined cost equations f2/6 
* CE 31: f2(A,B,C,D,E,F) = 7+ f2(C,D,G,H,E,F)
     [B>=H+1,G>=1,F>=0,E>=0,D>=1,C>=2,B>=0,G+1=A] 
* CE 32: f2(A,B,C,D,E,F) = 6+ f2(C,D,G,H,E,F)
     [D>=H+1,H>=0,F>=0,E>=0,C>=2,C=G+1,B=0,A=1] 
* CE 33: f2(A,B,C,D,A,B) = 2
     [B>=0,A>=0,D=0,C=1] 

### Cost equations --> "Loop" of f2/6 
* CEs [33] --> Loop 31 
* CEs [31] --> Loop 32 
* CEs [32] --> Loop 33 

#### Loops of f2/6 
* Loop 31: f2(A,B,C,D,A,B) [B>=0,A>=0,D=0,C=1] 
* Loop 32: f2(A,B,C,D,E,F)->  f2(C,D,A',B',E,F)
                  [B>=B'+1,F>=0,E>=0,D>=1,C>=2,B>=0,A>=2,A=A'+1] 
* Loop 33: f2(A,B,C,D,E,F)->  f2(C,D,A',B',E,F)
                  [D>=B'+1,B'>=0,F>=0,E>=0,C>=2,C=A'+1,B=0,A=1] 

### Ranking functions of CR f2(A,B,C,D,E,F) 
* RF of phase [32]: [A+C-3,B+D]

#### Partial ranking functions of CR f2(A,B,C,D,E,F) 
* Partial RF of phase [32]:
  - RF of loop [32:1]:
    A+C-3
    B+D

Discarded unfeasible chain [[32]]...(Non-terminating chain proved terminating)
Discarded unfeasible chain [33,[32]](Non-terminating chain proved terminating)

### Resulting Chains:f2(A,B,C,D,E,F) 
* [[32],31]
* [33,[32],31]
* [33,31]
* [31]


### Merging Chains  f2/6 into  External patterns of execution 
* [[31,33]] --> 1 
* [[31,[32],33]] --> 2 
* [[31]] --> 3 
* [[31,[32]]] --> 4 


### Specialization of cost equations case_8/9 
* CE 25 is refined into CE [34] 
* CE 24 is refined into CE [35] 


#### Refined cost equations case_8/9 
* CE 34: case_8(A,B,C,D,E,F,G,A,B) = 2
     [G>=0,F>=1,E>=1,B>=0,A>=2,E+G=D,F+1=C] 
* CE 35: case_8(A,B,C,D,E,F,G,H,E) = 3
     [G>=0,F>=1,E>=1,E+G=D,F+1=C,H=2,B=0,A=1] 

### Cost equations --> "Loop" of case_8/9 
* CEs [34] --> Loop 34 
* CEs [35] --> Loop 35 

#### Loops of case_8/9 
* Loop 34: case_8(A,B,C,D,E,F,G,A,B) [D>=E,E>=1,C>=2,B>=0,A>=2,E+G=D,C=F+1] 
* Loop 35: case_8(A,B,C,D,E,F,G,H,E) [D>=E,E>=1,C>=2,E+G=D,C=F+1,H=2,B=0,A=1] 

### Ranking functions of CR case_8(A,B,C,D,E,F,G,H,I) 

#### Partial ranking functions of CR case_8(A,B,C,D,E,F,G,H,I) 


### Resulting Chains:case_8(A,B,C,D,E,F,G,H,I) 
* [35]
* [34]


### Merging Chains  case_8/9 into  External patterns of execution 
* [[35]] --> 1 
* [[34]] --> 2 


### Specialization of cost equations last/4 
* CE 16 is refined into CE [36] 
* CE 15 is refined into CE [37,38] 


#### Refined cost equations last/4 
* CE 36: last(A,B,C,D) = 3
     [D=0,C=1,B=0,A=1] 
* CE 37: last(A,B,C,D) = 7+ last(E,F,G,H)+ case_8(I,J,K,L,D,E,F,M,D):1
     [D>=1,F>=0,E>=1,D+F=L,D+F=B,E+1=K,E+1=A,H=0,G=1,M=2,J=0,I=1,C=2] 
* CE 38: last(A,B,C,D) = 7+ last(E,F,C,D)+ case_8(C,D,G,H,I,E,F,C,D):2
     [D>=0,C>=2,F>=0,E>=1,I>=1,I+F=H,I+F=B,E+1=G,E+1=A] 

### Cost equations --> "Loop" of last/4 
* CEs [38] --> Loop 36 
* CEs [37] --> Loop 37 
* CEs [36] --> Loop 38 

#### Loops of last/4 
* Loop 36: last(A,B,C,D)->  last(A',B',C,D)
                  [B>=B'+1,B'>=0,D>=0,C>=2,A>=2,A=A'+1] 
* Loop 37: last(A,B,C,D)->  last(A',B',C',D')
                  [B>=D,D>=1,A>=2,D+B'=B,A=A'+1,D'=0,C'=1,C=2] 
* Loop 38: last(A,B,C,D) [D=0,C=1,B=0,A=1] 

### Ranking functions of CR last(A,B,C,D) 
* RF of phase [36]: [A-1,B]

#### Partial ranking functions of CR last(A,B,C,D) 
* Partial RF of phase [36]:
  - RF of loop [36:1]:
    A-1
    B

Discarded unfeasible chain [[36]]...(Non-terminating chain proved terminating)

### Resulting Chains:last(A,B,C,D) 
* [[36],37,38]
* [38]
* [37,38]


### Merging Chains  last/4 into  External patterns of execution 
* [[38]] --> 1 
* [[38,37]] --> 2 
* [[38,37,[36]]] --> 3 


### Specialization of cost equations f2p/6 
* CE 19 is refined into CE [39] 
* CE 18 is refined into CE [40,41] 
* CE 17 is refined into CE [42] 


#### Refined cost equations f2p/6 
* CE 39: f2p(A,B,C,D,A,B) = 2
     [B>=0,A>=0,D=0,C=1] 
* CE 40: f2p(A,B,C,D,E,D) = 6+ last(F,D,G,D):2
     [D>=1,G=2,F=2,E=2,C=2,B=0,A=1] 
* CE 41: f2p(A,B,C,D,E,F) = 6+ last(C,D,G,F):3
     [D+2>=C+F,F>=1,C>=3,G=2,E=2,B=0,A=1] 
* CE 42: f2p(A,B,C,D,E,F) = 7+ f2p(C,D,G,H,E,F)
     [B>=H+1,G>=1,F>=0,E>=0,D>=1,C>=2,B>=0,G+1=A] 

### Cost equations --> "Loop" of f2p/6 
* CEs [42] --> Loop 39 
* CEs [39] --> Loop 40 
* CEs [41] --> Loop 41 
* CEs [40] --> Loop 42 

#### Loops of f2p/6 
* Loop 39: f2p(A,B,C,D,E,F)->  f2p(C,D,A',B',E,F)
                  [B>=B'+1,A'>=1,F>=0,E>=0,D>=1,C>=2,B>=0,A'+1=A] 
* Loop 40: f2p(A,B,C,D,A,B) [B>=0,A>=0,D=0,C=1] 
* Loop 41: f2p(A,B,C,D,E,F) [D+2>=C+F,F>=1,C>=3,E=2,B=0,A=1] 
* Loop 42: f2p(A,B,C,D,E,D) [D>=1,E=2,C=2,B=0,A=1] 

### Ranking functions of CR f2p(A,B,C,D,E,F) 
* RF of phase [39]: [A+C-3,B+D]

#### Partial ranking functions of CR f2p(A,B,C,D,E,F) 
* Partial RF of phase [39]:
  - RF of loop [39:1]:
    A+C-3
    B+D

Discarded unfeasible chain [[39]]...(Non-terminating chain proved terminating)

### Resulting Chains:f2p(A,B,C,D,E,F) 
* [[39],40]
* [42]
* [41]
* [40]


### Merging Chains  f2p/6 into  External patterns of execution 
* [[42]] --> 1 
* [[41]] --> 2 
* [[40]] --> 3 
* [[40,[39]]] --> 4 


### Specialization of cost equations g3/6 
* CE 21 is refined into CE [43] 
* CE 20 is refined into CE [44] 


#### Refined cost equations g3/6 
* CE 43: g3(A,B,C,D,C,D) = 2
     [D>=0,C>=0,B=0,A=1] 
* CE 44: g3(A,B,C,D,E,F) = 5+ g3(G,H,I,J,E,F)
     [H+J>=D,J>=D+1,G>=1,F>=0,E>=0,D>=0,C>=1,H+J=B+D,C+1=I,G+1=A] 

### Cost equations --> "Loop" of g3/6 
* CEs [44] --> Loop 43 
* CEs [43] --> Loop 44 

#### Loops of g3/6 
* Loop 43: g3(A,B,C,D,E,F)->  g3(A',B',C',D',E,F)
                  [B'+D'>=D,D'>=D+1,A'>=1,F>=0,E>=0,D>=0,C>=1,B+D=B'+D',C+1=C',A'+1=A] 
* Loop 44: g3(A,B,C,D,C,D) [D>=0,C>=0,B=0,A=1] 

### Ranking functions of CR g3(A,B,C,D,E,F) 
* RF of phase [43]: [A-1,B+1]

#### Partial ranking functions of CR g3(A,B,C,D,E,F) 
* Partial RF of phase [43]:
  - RF of loop [43:1]:
    A-1
    B+1

Discarded unfeasible chain [[43]]...(Non-terminating chain proved terminating)

### Resulting Chains:g3(A,B,C,D,E,F) 
* [[43],44]
* [44]


### Merging Chains  g3/6 into  External patterns of execution 
* [[44]] --> 1 
* [[44,[43]]] --> 2 


### Specialization of cost equations f3/6 
* CE 23 is refined into CE [45,46] 
* CE 22 is refined into CE [47] 


#### Refined cost equations f3/6 
* CE 45: f3(A,B,C,D,E,F) = 4+ g3(G,H,I,J,K,L):1
     [L=0,K=1,J=0,I=1,H=0,G=1,F=0,E=1,D=0,C=1,B=0,A=1] 
* CE 46: f3(A,B,C,D,A,B) = 4+ g3(A,B,E,F,A,B):2
     [B+1>=A,A>=2,F=0,E=1,D=0,C=1] 
* CE 47: f3(A,B,C,D,E,F) = 5+ f3(G,H,I,J,E,F)
     [H+J>=D,D>=J+1,I>=1,F>=0,E>=0,D>=0,A>=1,H+J=B+D,A+1=G,I+1=C] 

### Cost equations --> "Loop" of f3/6 
* CEs [47] --> Loop 45 
* CEs [46] --> Loop 46 
* CEs [45] --> Loop 47 

#### Loops of f3/6 
* Loop 45: f3(A,B,C,D,E,F)->  f3(A',B',C',D',E,F)
                  [B'+D'>=D,D>=D'+1,C'>=1,F>=0,E>=0,D>=0,A>=1,B+D=B'+D',A+1=A',C'+1=C] 
* Loop 46: f3(A,B,C,D,A,B) [B+1>=A,A>=2,D=0,C=1] 
* Loop 47: f3(A,B,C,D,E,F) [F=0,E=1,D=0,C=1,B=0,A=1] 

### Ranking functions of CR f3(A,B,C,D,E,F) 
* RF of phase [45]: [C-1,D+1]

#### Partial ranking functions of CR f3(A,B,C,D,E,F) 
* Partial RF of phase [45]:
  - RF of loop [45:1]:
    C-1
    D+1

Discarded unfeasible chain [[45]]...(Non-terminating chain proved terminating)

### Resulting Chains:f3(A,B,C,D,E,F) 
* [[45],46]
* [47]
* [46]


### Merging Chains  f3/6 into  External patterns of execution 
* [[47]] --> 1 
* [[46]] --> 2 
* [[46,[45]]] --> 3 


### Specialization of cost equations p/8 
* CE 11 is refined into CE [48] 
* CE 9 is refined into CE [49] 
* CE 10 is refined into CE [50] 


#### Refined cost equations p/8 
* CE 48: p(A,B,C,D,E,F,A,B) = 6
     [B>=0,A>=0,F=0,E=1,D=0,C=1] 
* CE 49: p(A,B,C,D,E,F,G,H) = 3+ p(A,B,I,J,C,D,G,H)
     [F>=J+1,I>=1,H>=0,G>=0,F>=0,D>=0,C>=0,B>=0,A>=0,I+1=E] 
* CE 50: p(A,B,C,D,E,F,G,H) = 7+ p(I,J,K,L,A,B,G,H)
     [D>=L+1,K>=1,H>=0,G>=0,D>=0,B>=0,A>=0,K+1=C,J=0,I=1,F=0,E=1] 

### Cost equations --> "Loop" of p/8 
* CEs [49] --> Loop 48 
* CEs [50] --> Loop 49 
* CEs [48] --> Loop 50 

#### Loops of p/8 
* Loop 48: p(A,B,C,D,E,F,G,H)->  p(A,B,A',B',C,D,G,H)
                  [F>=B'+1,H>=0,G>=0,F>=0,E>=2,D>=0,C>=0,B>=0,A>=0,E=A'+1] 
* Loop 49: p(A,B,C,D,E,F,G,H)->  p(A',B',C',D',A,B,G,H)
                  [D>=D'+1,H>=0,G>=0,D>=0,C>=2,B>=0,A>=0,C=C'+1,B'=0,A'=1,F=0,E=1] 
* Loop 50: p(A,B,C,D,E,F,A,B) [B>=0,A>=0,F=0,E=1,D=0,C=1] 

### Ranking functions of CR p(A,B,C,D,E,F,G,H) 
* RF of phase [48,49]: [A+C+E-1,B+D+F+1]

#### Partial ranking functions of CR p(A,B,C,D,E,F,G,H) 
* Partial RF of phase [48,49]:
  - RF of loop [48:1]:
    C+E-1 depends on loops [49:1] 
    D+F+1 depends on loops [49:1] 
  - RF of loop [49:1]:
    C-1 depends on loops [48:1] 
    D+1 depends on loops [48:1] 

Discarded unfeasible chain [[48,49]]...(Non-terminating chain proved terminating)

### Resulting Chains:p(A,B,C,D,E,F,G,H) 
* [[48,49],50]
* [50]


### Merging Chains  p/8 into  External patterns of execution 
* [[50]] --> 1 
* [[50,[48,49]]] --> 2 


### Specialization of cost equations r1/6 
* CE 2 is refined into CE [51] 
* CE 1 is refined into CE [52] 


#### Refined cost equations r1/6 
* CE 51: r1(A,B,C,D,C,D) = 2
     [D>=0,C>=0,B=0,A=1] 
* CE 52: r1(A,B,C,D,E,F) = 5+ r1(G,H,I,J,E,F)
     [H+J>=D,J>=D+1,G>=1,F>=0,E>=0,D>=0,C>=1,H+J=B+D,C+1=I,G+1=A] 

### Cost equations --> "Loop" of r1/6 
* CEs [52] --> Loop 51 
* CEs [51] --> Loop 52 

#### Loops of r1/6 
* Loop 51: r1(A,B,C,D,E,F)->  r1(A',B',C',D',E,F)
                  [B'+D'>=D,D'>=D+1,A'>=1,F>=0,E>=0,D>=0,C>=1,B+D=B'+D',C+1=C',A'+1=A] 
* Loop 52: r1(A,B,C,D,C,D) [D>=0,C>=0,B=0,A=1] 

### Ranking functions of CR r1(A,B,C,D,E,F) 
* RF of phase [51]: [A-1,B+1]

#### Partial ranking functions of CR r1(A,B,C,D,E,F) 
* Partial RF of phase [51]:
  - RF of loop [51:1]:
    A-1
    B+1

Discarded unfeasible chain [[51]]...(Non-terminating chain proved terminating)

### Resulting Chains:r1(A,B,C,D,E,F) 
* [[51],52]
* [52]


### Merging Chains  r1/6 into  External patterns of execution 
* [[52]] --> 1 
* [[52,[51]]] --> 2 


### Specialization of cost equations rev/4 
* CE 3 is refined into CE [53,54] 


#### Refined cost equations rev/4 
* CE 53: rev(A,B,C,D) = 2+ r1(E,F,G,H,I,J):1
     [J=0,I=1,H=0,G=1,F=0,E=1,D=0,C=1,B=0,A=1] 
* CE 54: rev(A,B,A,B) = 2+ r1(A,B,C,D,A,B):2
     [B+1>=A,A>=2,D=0,C=1] 

### Cost equations --> "Loop" of rev/4 
* CEs [54] --> Loop 53 
* CEs [53] --> Loop 54 

#### Loops of rev/4 
* Loop 53: rev(A,B,A,B) [B+1>=A,A>=2] 
* Loop 54: rev(A,B,C,D) [D=0,C=1,B=0,A=1] 

### Ranking functions of CR rev(A,B,C,D) 

#### Partial ranking functions of CR rev(A,B,C,D) 


### Resulting Chains:rev(A,B,C,D) 
* [54]
* [53]


### Merging Chains  rev/4 into  External patterns of execution 
* [[54]] --> 1 
* [[53]] --> 2 


### Specialization of cost equations g/8 
* CE 8 is refined into CE [55,56,57,58,59,60] 


#### Refined cost equations g/8 
* CE 55: g(A,B,C,D,E,F,E,F) = 2+ append(G,H,E,F,E,F):1+ f(I,J,E,F,E,F):1
     [F>=0,E>=0,J=0,I=1,H=0,G=1,D=0,C=1,B=0,A=1] 
* CE 56: g(A,B,C,D,E,F,G,B) = 2+ append(H,I,J,K,L,M):1+ f(N,B,O,P,Q,B):2
     [B>=1,Q=2,P=0,O=1,N=2,M=0,L=1,K=0,J=1,I=0,H=1,G=2,F=0,E=1,D=0,C=1,A=2] 
* CE 57: g(A,B,C,D,E,F,G,H) = 2+ append(I,J,K,L,M,N):1+ f(A,B,O,P,G,H):3
     [B+1>=A,H>=0,G>=0,A>=3,P=0,O=1,N=0,M=1,L=0,K=1,J=0,I=1,F=0,E=1,D=0,C=1] 
* CE 58: g(A,B,C,D,E,F,G,H) = 2+ append(I,J,E,F,E,F):1+ f(A,B,E,F,G,H):4
     [F+1>=E,H>=0,G>=0,E>=2,B>=1,A>=2,J=0,I=1,D=0,C=1] 
* CE 59: g(A,B,C,D,E,F,G,H) = 2+ append(C,D,I,J,G,H):2+ f(K,L,G,H,G,H):1
     [H>=D,G>=C,D+1>=C,C>=2,H=D+J,G+1=C+I,H=D+F,G+1=C+E,L=0,K=1,B=0,A=1] 
* CE 60: g(A,B,C,D,E,F,G,H) = 2+ append(C,D,I,J,K,L):2+ f(A,B,K,L,G,H):4
     [L+1>=K,L>=D,K>=C,D+1>=C,H>=0,G>=0,B>=1,A>=2,C>=2,L=D+J,K+1=C+I,L=D+F,K+1=C+E] 

### Cost equations --> "Loop" of g/8 
* CEs [60] --> Loop 55 
* CEs [58] --> Loop 56 
* CEs [57] --> Loop 57 
* CEs [56] --> Loop 58 
* CEs [59] --> Loop 59 
* CEs [55] --> Loop 60 

#### Loops of g/8 
* Loop 55: g(A,B,C,D,E,F,G,H) [D+F+2>=C+E,D+1>=C,H>=0,G>=0,F>=0,E>=1,C>=2,B>=1,A>=2] 
* Loop 56: g(A,B,C,D,E,F,G,H) [F+1>=E,H>=0,G>=0,E>=2,B>=1,A>=2,D=0,C=1] 
* Loop 57: g(A,B,C,D,E,F,G,H) [B+1>=A,H>=0,G>=0,A>=3,F=0,E=1,D=0,C=1] 
* Loop 58: g(A,B,C,D,E,F,G,B) [B>=1,G=2,F=0,E=1,D=0,C=1,A=2] 
* Loop 59: g(A,B,C,D,E,F,G,H) [D+1>=C,F>=0,E>=1,C>=2,D+F=H,C+E=G+1,B=0,A=1] 
* Loop 60: g(A,B,C,D,E,F,E,F) [F>=0,E>=0,D=0,C=1,B=0,A=1] 

### Ranking functions of CR g(A,B,C,D,E,F,G,H) 

#### Partial ranking functions of CR g(A,B,C,D,E,F,G,H) 


### Resulting Chains:g(A,B,C,D,E,F,G,H) 
* [60]
* [59]
* [58]
* [57]
* [56]
* [55]


### Merging Chains  g/8 into  External patterns of execution 
* [[60]] --> 1 
* [[59]] --> 2 
* [[58]] --> 3 
* [[57]] --> 4 
* [[56]] --> 5 
* [[55]] --> 6 


Computing Bounds
=====================================

#### Simplifying cost structure of CE 26 

#### Computing cost of phase [26] 

#### Simplifying cost structure of CE 27 

#### Cost of loops [26] 

 * loop 26:append(A,B,C,D,E,F) -> [append(A',B',C',D',E',F')] 
5
##### Pending set append(A,B,C,D,E,F)
* Psum in Loop 26: [it(26)=<1]

###### Computing sum for it(26)=<1  in Loop 26 
   - Applying inductive sum strategy 
     - head Candidate: A-1 
     - head Candidate: B+1 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: B+1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
     - tail Candidate: B+1 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B+1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(26)=<A-1,it(26)=<B+1,it(26)=<A-1,it(26)=<B+1,it(26)=<A-A',it(26)=<B-B',it(26)=<A-A',it(26)=<B-B'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [26] 

#### Simplifying cost structure of phase [26] 

#### Cost of phase [26]:append(A,B,C,D,E,F) -> [append(A',B',C',D',E',F')] 
5*it(26)+0
  Such that:it(26) =< A
it(26) =< A-A'
it(26) =< B+1
it(26) =< B-B'

#### Simplifying cost structure of chain [[26],27] 

#### Cost of chains of append(A,B,C,D,E,F):
* Chain [[26],27]: 5*it(26)+2
  Such that:it(26) =< -C+E

  with precondition: [F=B+D,A+C=E+1,A>=2,C>=1,B+1>=A,F>=B] 

* Chain [27]: 2
  with precondition: [A=1,B=0,C=E,D=F,C>=0,D>=0] 


#### Simplifying cost structure of CE 28 

#### Computing cost of phase [28] 
 * Renamed intermediate variables: 
[ (eq(30,1),it(26))>>s(1)]

#### Simplifying cost structure of CE 30 
 * Renamed intermediate variables: 
[ (it(28),s(1))>>s(2)]

#### Cost of loops [28] 

 * loop 28:f(A,B,C,D,E,F) -> [f(A',B',C',D',E',F')] 
5*s(2)+8
  Such that:s(2) =< -A+C'

##### Pending set f(A,B,C,D,E,F)
* Psum in Loop 28: [it(28)=<1,s(3)=< -A+C']

###### Computing sum for it(28)=<1  in Loop 28 
   - Applying inductive sum strategy 
     - head Candidate: A-1 
     - head Candidate: B 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: B 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
     - tail Candidate: B 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(28)=<A-1,it(28)=<B,it(28)=<A-1,it(28)=<B,it(28)=<A-A',it(28)=<B-B',it(28)=<A-A',it(28)=<B-B'] 

##### Pending set A
* Psum in Loop 28: [s(3)=< -A+C']

###### Computing sum for s(3)=< -A+C'  in Loop 28 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(1)=<D,aux(1)=<C-1] 
 * Adding constraints: [s(3)=<it(28)*aux(1)] 

##### Pending set f(A,B,C,D,E,F)
* Pmax/min: [aux(1)=<C-1,aux(1)=<D]

###### Computing max_min for aux(1)=<C-1  
   - Applying max/min strategy 
     - Loop 28  increases the expression by [A',A-1] 
 * Adding constraints:[aux(1)=<aux(2)+aux(3),aux(2)=<C-1] 

##### Pending set f(A,B,C,D,E,F)
* Pmax/min: [aux(1)=<D]
* Psum in Loop 28: [aux(3)=<A-1,aux(3)=<A']

###### Computing max_min for aux(1)=<D  
   - Applying max/min strategy 
     - Loop 28  increases the expression by [B,-C+D'+1] 
 * Adding constraints:[aux(1)=<aux(4)+aux(5),aux(4)=<D] 

##### Pending set f(A,B,C,D,E,F)
* Psum in Loop 28: [aux(3)=<A-1,aux(5)=<B,aux(5)=< -C+D'+1,aux(3)=<A']

###### Computing sum for aux(3)=<A-1  in Loop 28 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(6)=<A-1] 
 * Adding constraints: [aux(3)=<it(28)*aux(6)] 

##### Pending set f(A,B,C,D,E,F)
* Pmax/min: [aux(6)=<A-1]
* Psum in Loop 28: [aux(5)=<B,aux(5)=< -C+D'+1,aux(3)=<A']

###### Computing max_min for aux(6)=<A-1  
   - Found a solution using transitive invariants 
 * Adding constraints:[aux(6)=<A-1] 

##### Pending set f(A,B,C,D,E,F)
* Psum in Loop 28: [aux(5)=<B,aux(5)=< -C+D'+1,aux(3)=<A']

###### Computing sum for aux(5)=<B  in Loop 28 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(7)=<B] 
 * Adding constraints: [aux(5)=<it(28)*aux(7)] 

##### Pending set f(A,B,C,D,E,F)
* Pmax/min: [aux(7)=<B]
* Psum in Loop 28: [aux(5)=< -C+D'+1,aux(3)=<A']

###### Computing max_min for aux(7)=<B  
   - Found a solution using transitive invariants 
 * Adding constraints:[aux(7)=<B] 

##### Pending set f(A,B,C,D,E,F)
* Psum in Loop 28: [aux(5)=< -C+D'+1,aux(3)=<A']

###### Computing sum for aux(5)=< -C+D'+1  in Loop 28 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(8)=<B-C+D+1] 
 * Adding constraints: [aux(5)=<it(28)*aux(8)] 

##### Pending set f(A,B,C,D,E,F)
* Pmax/min: [aux(8)=<B-C+D+1]
* Psum in Loop 28: [aux(3)=<A']

###### Computing max_min for aux(8)=<B-C+D+1  
   - Applying max/min strategy 
     - Loop 28  increases the expression by [-A'+B',-A+B'+1] 
 * Adding constraints:[aux(8)=<aux(9)+aux(10),aux(9)=<B-C+D+1] 

##### Pending set f(A,B,C,D,E,F)
* Psum in Loop 28: [aux(3)=<A']

###### Computing sum for aux(3)=<A'  in Loop 28 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(11)=<A-1] 
 * Adding constraints: [aux(3)=<it(28)*aux(11)] 

##### Pending set f(A,B,C,D,E,F)
* Pmax/min: [aux(11)=<A-1]

###### Computing max_min for aux(11)=<A-1  
   - Found a solution using cacheing 
 * Adding constraints:[aux(11)=<aux(6)] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [28] 

#### Simplifying cost structure of phase [28] 
 * Joined equivalent variables [aux(12),aux(6)] into aux(12)
 * Joined equivalent variables [aux(13),aux(7)] into aux(13)

#### Cost of phase [28]:f(A,B,C,D,E,F) -> [f(A',B',C',D',E',F')] 
8*it(28)+5*s(3)+0
  Such that:it(28) =< A-A'
it(28) =< B-B'
aux(2) =< C
aux(4) =< D
aux(12) =< A
aux(13) =< B
it(28) =< aux(12)
it(28) =< aux(13)
aux(11) =< aux(12)
aux(5) =< it(28)*aux(13)
aux(3) =< it(28)*aux(12)
aux(3) =< it(28)*aux(11)
aux(1) =< aux(4)+aux(5)
aux(1) =< aux(2)+aux(3)
s(3) =< it(28)*aux(1)

#### Simplifying cost structure of chain [[28],30] 
 * Joined equivalent variables [aux(14),aux(12)] into aux(14)

#### Simplifying cost structure of CE 29 

#### Simplifying cost structure of chain [29,[28],30] 
 * Joined equivalent variables [aux(15),aux(2),aux(14)] into aux(15)
 * Joined equivalent variables [aux(16),aux(4)] into aux(16)

#### Simplifying cost structure of chain [29,30] 

#### Cost of chains of f(A,B,C,D,E,F):
* Chain [[28],30]: 8*it(28)+5*s(3)+2
  Such that:aux(13) =< B
aux(2) =< C
aux(4) =< D
aux(14) =< A
it(28) =< aux(14)
it(28) =< aux(13)
aux(11) =< aux(14)
aux(5) =< it(28)*aux(13)
aux(3) =< it(28)*aux(14)
aux(3) =< it(28)*aux(11)
aux(1) =< aux(4)+aux(5)
aux(1) =< aux(2)+aux(3)
s(3) =< it(28)*aux(1)

  with precondition: [A>=2,B>=1,C>=2,E>=0,F>=0,D+1>=C] 

* Chain [30]: 2
  with precondition: [A=1,B=0,C=E,D=F,C>=0,D>=0] 

* Chain [29,[28],30]: 8*it(28)+5*s(3)+10
  Such that:aux(13) =< -A-B+F+3
aux(15) =< A
aux(16) =< B
aux(13) =< aux(16)
it(28) =< aux(15)
it(28) =< aux(13)
aux(11) =< aux(15)
aux(5) =< it(28)*aux(13)
aux(3) =< it(28)*aux(15)
aux(3) =< it(28)*aux(11)
aux(1) =< aux(16)+aux(5)
aux(1) =< aux(15)+aux(3)
s(3) =< it(28)*aux(1)

  with precondition: [C=1,D=0,A>=3,E>=0,F>=0,B+1>=A] 

* Chain [29,30]: 10
  with precondition: [A=2,C=1,D=0,E=2,B=F,B>=1] 


#### Simplifying cost structure of CE 33 

#### Computing cost of phase [32] 

#### Simplifying cost structure of CE 31 

#### Cost of loops [32] 

 * loop 32:f2(A,B,C,D,E,F) -> [f2(A',B',C',D',E',F')] 
7
##### Pending set f2(A,B,C,D,E,F)
* Psum in Loop 32: [it(32)=<1]

###### Computing sum for it(32)=<1  in Loop 32 
   - Applying inductive sum strategy 
     - head Candidate: B+D 
     - head Candidate: A+C-3 
     - head Candidate: A+C-3 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: B+D 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B+D 
     - tail Candidate: A+C-3 
     - tail Candidate: A+C-3 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B+D 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(32)=<B+D,it(32)=<A+C-3,it(32)=<A+C-3,it(32)=<B+D,it(32)=<B+D-B'-D',it(32)=<A+C-A'-C',it(32)=<A+C-A'-C',it(32)=<B+D-B'-D'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [32] 

#### Simplifying cost structure of phase [32] 

#### Cost of phase [32]:f2(A,B,C,D,E,F) -> [f2(A',B',C',D',E',F')] 
7*it(32)+0
  Such that:it(32) =< A+C
it(32) =< A+C-A'-C'
it(32) =< B+D
it(32) =< B+D-B'-D'

#### Simplifying cost structure of chain [[32],31] 

#### Simplifying cost structure of CE 32 

#### Simplifying cost structure of chain [33,[32],31] 

#### Simplifying cost structure of chain [33,31] 

#### Cost of chains of f2(A,B,C,D,E,F):
* Chain [[32],31]: 7*it(32)+2
  Such that:it(32) =< A+C-E

  with precondition: [A>=2,B>=0,C>=2,D>=1,E>=0,F>=1,A+C>=E+2,B+D+E+1>=A+C+F] 

* Chain [33,[32],31]: 7*it(32)+8
  Such that:it(32) =< 2*C-E

  with precondition: [A=1,B=0,C>=3,D>=2,E>=0,F>=1,2*C>=E+3,E+2*D+1>=2*C+F] 

* Chain [33,31]: 8
  with precondition: [A=1,B=0,C=2,E=2,D=F,D>=1] 

* Chain [31]: 2
  with precondition: [C=1,D=0,A=E,B=F,A>=0,B>=0] 


#### Simplifying cost structure of CE 35 

#### Simplifying cost structure of CE 34 

#### Cost of chains of case_8(A,B,C,D,E,F,G,H,I):
* Chain [35]: 3
  with precondition: [A=1,B=0,H=2,F+1=C,E=I,E+G=D,E>=1,F>=1,D>=E] 

* Chain [34]: 2
  with precondition: [I=B,F+1=C,A=H,D=E+G,A>=2,E>=1,F>=1,I>=0,D>=E] 


#### Simplifying cost structure of CE 36 

#### Simplifying cost structure of CE 37 

#### Simplifying cost structure of chain [37,38] 

#### Computing cost of phase [36] 

#### Simplifying cost structure of CE 38 

#### Cost of loops [36] 

 * loop 36:last(A,B,C,D) -> [last(A',B',C',D')] 
9
##### Pending set last(A,B,C,D)
* Psum in Loop 36: [it(36)=<1]

###### Computing sum for it(36)=<1  in Loop 36 
   - Applying inductive sum strategy 
     - head Candidate: A-1 
     - head Candidate: B 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: B 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
     - tail Candidate: B 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(36)=<A-1,it(36)=<B,it(36)=<A-1,it(36)=<B,it(36)=<A-A',it(36)=<B-B',it(36)=<A-A',it(36)=<B-B'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [36] 

#### Simplifying cost structure of phase [36] 

#### Cost of phase [36]:last(A,B,C,D) -> [last(A',B',C',D')] 
9*it(36)+0
  Such that:it(36) =< A
it(36) =< A-A'
it(36) =< B
it(36) =< B-B'

#### Simplifying cost structure of chain [[36],37,38] 

#### Cost of chains of last(A,B,C,D):
* Chain [[36],37,38]: 9*it(36)+13
  Such that:it(36) =< A

  with precondition: [C=2,A>=3,D>=1,B+2>=A+D] 

* Chain [38]: 3
  with precondition: [A=1,B=0,C=1,D=0] 

* Chain [37,38]: 13
  with precondition: [A=2,C=2,B=D,B>=1] 


#### Simplifying cost structure of CE 39 

#### Computing cost of phase [39] 

#### Simplifying cost structure of CE 42 

#### Cost of loops [39] 

 * loop 39:f2p(A,B,C,D,E,F) -> [f2p(A',B',C',D',E',F')] 
7
##### Pending set f2p(A,B,C,D,E,F)
* Psum in Loop 39: [it(39)=<1]

###### Computing sum for it(39)=<1  in Loop 39 
   - Applying inductive sum strategy 
     - head Candidate: B+D 
     - head Candidate: A+C-3 
     - head Candidate: A+C-3 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: B+D 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B+D 
     - tail Candidate: A+C-3 
     - tail Candidate: A+C-3 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B+D 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(39)=<B+D,it(39)=<A+C-3,it(39)=<A+C-3,it(39)=<B+D,it(39)=<B+D-B'-D',it(39)=<A+C-A'-C',it(39)=<A+C-A'-C',it(39)=<B+D-B'-D'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [39] 

#### Simplifying cost structure of phase [39] 

#### Cost of phase [39]:f2p(A,B,C,D,E,F) -> [f2p(A',B',C',D',E',F')] 
7*it(39)+0
  Such that:it(39) =< A+C
it(39) =< A+C-A'-C'
it(39) =< B+D
it(39) =< B+D-B'-D'

#### Simplifying cost structure of chain [[39],40] 

#### Simplifying cost structure of CE 40 
 * Renamed intermediate variables: 
[ (eq(41,1),it(36))>>s(4)]

#### Simplifying cost structure of CE 41 

#### Cost of chains of f2p(A,B,C,D,E,F):
* Chain [[39],40]: 7*it(39)+2
  Such that:it(39) =< A+C-E

  with precondition: [A>=2,B>=0,C>=2,D>=1,E>=0,F>=1,A+C>=E+2,B+D+E+1>=A+C+F] 

* Chain [42]: 19
  with precondition: [A=1,B=0,C=2,E=2,D=F,D>=1] 

* Chain [41]: 9*s(4)+19
  Such that:s(4) =< C

  with precondition: [A=1,B=0,E=2,C>=3,F>=1,D+2>=C+F] 

* Chain [40]: 2
  with precondition: [C=1,D=0,A=E,B=F,A>=0,B>=0] 


#### Simplifying cost structure of CE 43 

#### Computing cost of phase [43] 

#### Simplifying cost structure of CE 44 

#### Cost of loops [43] 

 * loop 43:g3(A,B,C,D,E,F) -> [g3(A',B',C',D',E',F')] 
5
##### Pending set g3(A,B,C,D,E,F)
* Psum in Loop 43: [it(43)=<1]

###### Computing sum for it(43)=<1  in Loop 43 
   - Applying inductive sum strategy 
     - head Candidate: A-1 
     - head Candidate: B+1 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: B+1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
     - tail Candidate: B+1 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B+1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(43)=<A-1,it(43)=<B+1,it(43)=<A-1,it(43)=<B+1,it(43)=<A-A',it(43)=<B-B',it(43)=<A-A',it(43)=<B-B'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [43] 

#### Simplifying cost structure of phase [43] 

#### Cost of phase [43]:g3(A,B,C,D,E,F) -> [g3(A',B',C',D',E',F')] 
5*it(43)+0
  Such that:it(43) =< A
it(43) =< A-A'
it(43) =< B+1
it(43) =< B-B'

#### Simplifying cost structure of chain [[43],44] 

#### Cost of chains of g3(A,B,C,D,E,F):
* Chain [[43],44]: 5*it(43)+2
  Such that:it(43) =< -C+E

  with precondition: [A+C=E+1,B+D=F,A>=2,C>=1,D>=0,B+1>=A] 

* Chain [44]: 2
  with precondition: [A=1,B=0,C=E,D=F,C>=0,D>=0] 

 * Renamed intermediate variables: 
[ (eq(46,1),it(43))>>s(5)]

#### Simplifying cost structure of CE 46 

#### Computing cost of phase [45] 

#### Simplifying cost structure of CE 47 

#### Cost of loops [45] 

 * loop 45:f3(A,B,C,D,E,F) -> [f3(A',B',C',D',E',F')] 
5
##### Pending set f3(A,B,C,D,E,F)
* Psum in Loop 45: [it(45)=<1]

###### Computing sum for it(45)=<1  in Loop 45 
   - Applying inductive sum strategy 
     - head Candidate: D+1 
     - head Candidate: C-1 
     - head Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: D+1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: D+1 
     - tail Candidate: C-1 
     - tail Candidate: C-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: D+1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(45)=<D+1,it(45)=<C-1,it(45)=<C-1,it(45)=<D+1,it(45)=<D-D',it(45)=<C-C',it(45)=<C-C',it(45)=<D-D'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [45] 

#### Simplifying cost structure of phase [45] 

#### Cost of phase [45]:f3(A,B,C,D,E,F) -> [f3(A',B',C',D',E',F')] 
5*it(45)+0
  Such that:it(45) =< C
it(45) =< C-C'
it(45) =< D+1
it(45) =< D-D'

#### Simplifying cost structure of chain [[45],46] 

#### Simplifying cost structure of CE 45 

#### Cost of chains of f3(A,B,C,D,E,F):
* Chain [[45],46]: 5*it(45)+5*s(5)+6
  Such that:it(45) =< C
s(5) =< E

  with precondition: [A+C=E+1,B+D=F,A>=1,B>=0,C>=2,D+1>=C,B+D+2>=A+C] 

* Chain [47]: 6
  with precondition: [A=1,B=0,C=1,D=0,E=1,F=0] 

* Chain [46]: 5*s(5)+6
  Such that:s(5) =< A

  with precondition: [C=1,D=0,A=E,B=F,A>=2,B+1>=A] 


#### Simplifying cost structure of CE 48 

#### Computing cost of phase [48,49] 

#### Simplifying cost structure of CE 49 

#### Simplifying cost structure of CE 50 

#### Cost of loops [48,49] 

 * loop 48:p(A,B,C,D,E,F,G,H) -> [p(A',B',C',D',E',F',G',H')] 
3
 * loop 49:p(A,B,C,D,E,F,G,H) -> [p(A',B',C',D',E',F',G',H')] 
7
##### Pending set p(A,B,C,D,E,F,G,H)
* Psum in Loop 48: [it(48)=<1]
* Psum in Loop 49: [it(49)=<1]

###### Computing sum for it(48)=<1  in Loop 48 
   - Applying inductive sum strategy 
     - head Candidate: A+C+E-1 
       - Loop 49 is collaborative and bounds [it(49)] 
     - head Candidate: B+D+F+1 
       - Loop 49 is collaborative and bounds [it(49)] 
     - head Candidate: C+E-1 
       - Loop 49 adds an expression [A-2,B-1]
     - head Candidate: D+F+1 
       - Loop 49 adds an expression [B-1]
     - tail Candidate: A+C+E-1 
       - Loop 49 is collaborative and bounds [it(49)] 
     - tail Candidate: B+D+F+1 
       - Loop 49 is collaborative and bounds [it(49)] 
     - tail Candidate: C+E-1 
       - Loop 49 adds an expression [A-2,B-1]
     - tail Candidate: D+F+1 
       - Loop 49 adds an expression [B-1]
 * Adding constraints: [it(48)=<aux(17)+aux(18),it(48)=<aux(19)+aux(20),it(48)=<aux(21)+aux(22),it(48)=<aux(23)+aux(24),it(48)+it(49)=<A+C+E-1,it(48)+it(49)=<B+D+F+1,aux(18)=<C+E-1,aux(20)=<D+F+1,it(48)+it(49)=<A+C+E-A'-C'-E',it(48)+it(49)=<B+D+F-B'-D'-F',aux(22)=<C+E-C'-E',aux(24)=<D+F-D'-F'] 

##### Pending set A
* Psum in Loop 49: [it(49)=<1,aux(17)=<A-2,aux(21)=<A-2,aux(17)=<B-1,aux(19)=<B-1,aux(21)=<B-1,aux(23)=<B-1]

###### Computing sum for it(49)=<1  in Loop 49 
   - Applying inductive sum strategy 
     - head Candidate: A+C+E-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: B+D+F+1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: C-1 
       - Loop 48 adds an expression [D'-E'+1,E-E'-1]
     - head Candidate: D+1 
       - Loop 48 adds an expression [F-F'-1]
     - tail Candidate: A+C+E-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B+D+F+1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: C-1 
       - Loop 48 adds an expression [D'-E'+1,E-E'-1]
     - tail Candidate: D+1 
       - Loop 48 adds an expression [F-F'-1]
 * Adding constraints: [it(49)=<aux(25)+aux(26),it(49)=<aux(27)+aux(28),it(49)=<aux(29)+aux(30),it(49)=<aux(31)+aux(32),it(48)+it(49)=<A+C+E-1,it(48)+it(49)=<B+D+F+1,aux(26)=<C-1,aux(28)=<D+1,it(48)+it(49)=<A+C+E-A'-C'-E',it(48)+it(49)=<B+D+F-B'-D'-F',aux(30)=<C-C',aux(32)=<D-D'] 

##### Pending set A
* Psum in Loop 48: [aux(25)=<E-E'-1,aux(29)=<E-E'-1,aux(27)=<F-F'-1,aux(31)=<F-F'-1,aux(25)=<D'-E'+1,aux(29)=<D'-E'+1]
* Psum in Loop 49: [aux(17)=<A-2,aux(21)=<A-2,aux(17)=<B-1,aux(19)=<B-1,aux(21)=<B-1,aux(23)=<B-1]

###### Computing sum for aux(25)=<E-E'-1  in Loop 48 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(33)=<E-2,aux(33)=< -C+E-1] 
 * Adding constraints: [aux(25)=<it(48)*aux(33)] 

##### Pending set p(A,B,C,D,E,F,G,H)
* Pmax/min: [aux(33)=< -C+E-1,aux(33)=<E-2]
* Psum in Loop 48: [aux(29)=<E-E'-1,aux(27)=<F-F'-1,aux(31)=<F-F'-1,aux(25)=<D'-E'+1,aux(29)=<D'-E'+1]
* Psum in Loop 49: [aux(17)=<A-2,aux(21)=<A-2,aux(17)=<B-1,aux(19)=<B-1,aux(21)=<B-1,aux(23)=<B-1]

###### Computing max_min for aux(33)=< -C+E-1  
   - Found a solution using transitive invariants 
 * Adding constraints:[aux(33)=<A+C+E-1,aux(33)=<A+C+5*E-9] 

##### Pending set p(A,B,C,D,E,F,G,H)
* Pmax/min: [aux(33)=<E-2]
* Psum in Loop 48: [aux(29)=<E-E'-1,aux(27)=<F-F'-1,aux(31)=<F-F'-1,aux(25)=<D'-E'+1,aux(29)=<D'-E'+1]
* Psum in Loop 49: [aux(17)=<A-2,aux(21)=<A-2,aux(17)=<B-1,aux(19)=<B-1,aux(21)=<B-1,aux(23)=<B-1]

###### Computing max_min for aux(33)=<E-2  
   - Found a solution using transitive invariants 
 * Adding constraints:[aux(33)=<A+C+E-2,aux(33)=<A+C+3*E-6] 

##### Pending set p(A,B,C,D,E,F,G,H)
* Psum in Loop 48: [aux(29)=<E-E'-1,aux(27)=<F-F'-1,aux(31)=<F-F'-1,aux(25)=<D'-E'+1,aux(29)=<D'-E'+1]
* Psum in Loop 49: [aux(17)=<A-2,aux(21)=<A-2,aux(17)=<B-1,aux(19)=<B-1,aux(21)=<B-1,aux(23)=<B-1]

###### Computing sum for aux(29)=<E-E'-1  in Loop 48 
   - Found a solution using cacheing 
 * Adding constraints: [aux(29)=<aux(34),aux(34)=<it(48)*aux(33)] 

##### Pending set p(A,B,C,D,E,F,G,H)
* Psum in Loop 48: [aux(27)=<F-F'-1,aux(31)=<F-F'-1,aux(25)=<D'-E'+1,aux(29)=<D'-E'+1]
* Psum in Loop 49: [aux(17)=<A-2,aux(21)=<A-2,aux(17)=<B-1,aux(19)=<B-1,aux(21)=<B-1,aux(23)=<B-1]

###### Computing sum for aux(27)=<F-F'-1  in Loop 48 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(35)=< -C+F,aux(35)=< -D+F-1] 
 * Adding constraints: [aux(27)=<it(48)*aux(35)] 

##### Pending set p(A,B,C,D,E,F,G,H)
* Pmax/min: [aux(35)=< -C+F,aux(35)=< -D+F-1]
* Psum in Loop 48: [aux(31)=<F-F'-1,aux(25)=<D'-E'+1,aux(29)=<D'-E'+1]
* Psum in Loop 49: [aux(17)=<A-2,aux(21)=<A-2,aux(17)=<B-1,aux(19)=<B-1,aux(21)=<B-1,aux(23)=<B-1]

###### Computing max_min for aux(35)=< -C+F  
   - Found a solution using transitive invariants 
 * Adding constraints:[aux(35)=<B+D+F,aux(35)=<B+D+2*E+F-4] 

##### Pending set p(A,B,C,D,E,F,G,H)
* Pmax/min: [aux(35)=< -D+F-1]
* Psum in Loop 48: [aux(31)=<F-F'-1,aux(25)=<D'-E'+1,aux(29)=<D'-E'+1]
* Psum in Loop 49: [aux(17)=<A-2,aux(21)=<A-2,aux(17)=<B-1,aux(19)=<B-1,aux(21)=<B-1,aux(23)=<B-1]

###### Computing max_min for aux(35)=< -D+F-1  
   - Found a solution using transitive invariants 
 * Adding constraints:[aux(35)=<B+D+F-1] 

##### Pending set p(A,B,C,D,E,F,G,H)
* Psum in Loop 48: [aux(31)=<F-F'-1,aux(25)=<D'-E'+1,aux(29)=<D'-E'+1]
* Psum in Loop 49: [aux(17)=<A-2,aux(21)=<A-2,aux(17)=<B-1,aux(19)=<B-1,aux(21)=<B-1,aux(23)=<B-1]

###### Computing sum for aux(31)=<F-F'-1  in Loop 48 
   - Found a solution using cacheing 
 * Adding constraints: [aux(31)=<aux(36),aux(36)=<it(48)*aux(35)] 

##### Pending set p(A,B,C,D,E,F,G,H)
* Psum in Loop 48: [aux(25)=<D'-E'+1,aux(29)=<D'-E'+1]
* Psum in Loop 49: [aux(17)=<A-2,aux(21)=<A-2,aux(17)=<B-1,aux(19)=<B-1,aux(21)=<B-1,aux(23)=<B-1]

###### Computing sum for aux(25)=<D'-E'+1  in Loop 48 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [aux(37)=< -C+F,aux(37)=<F-1] 
 * Adding constraints: [aux(25)=<it(48)*aux(37)] 

##### Pending set p(A,B,C,D,E,F,G,H)
* Pmax/min: [aux(37)=< -C+F,aux(37)=<F-1]
* Psum in Loop 48: [aux(29)=<D'-E'+1]
* Psum in Loop 49: [aux(17)=<A-2,aux(21)=<A-2,aux(17)=<B-1,aux(19)=<B-1,aux(21)=<B-1,aux(23)=<B-1]

###### Computing max_min for aux(37)=< -C+F  
   - Found a solution using cacheing 
 * Adding constraints:[aux(37)=<aux(35)] 

##### Pending set p(A,B,C,D,E,F,G,H)
* Pmax/min: [aux(37)=<F-1]
* Psum in Loop 48: [aux(29)=<D'-E'+1]
* Psum in Loop 49: [aux(17)=<A-2,aux(21)=<A-2,aux(17)=<B-1,aux(19)=<B-1,aux(21)=<B-1,aux(23)=<B-1]

###### Computing max_min for aux(37)=<F-1  
   - Found a solution using transitive invariants 
 * Adding constraints:[aux(37)=<B+D+F-1] 

##### Pending set p(A,B,C,D,E,F,G,H)
* Psum in Loop 48: [aux(29)=<D'-E'+1]
* Psum in Loop 49: [aux(17)=<A-2,aux(21)=<A-2,aux(17)=<B-1,aux(19)=<B-1,aux(21)=<B-1,aux(23)=<B-1]

###### Computing sum for aux(29)=<D'-E'+1  in Loop 48 
   - Found a solution using cacheing 
 * Adding constraints: [aux(29)=<aux(38),aux(38)=<it(48)*aux(37)] 

##### Pending set p(A,B,C,D,E,F,G,H)
* Psum in Loop 49: [aux(17)=<A-2,aux(21)=<A-2,aux(17)=<B-1,aux(19)=<B-1,aux(21)=<B-1,aux(23)=<B-1]

###### Computing sum for aux(17)=<A-2  in Loop 49 
   - Applying inductive sum strategy 
     - head Candidate: B-1 
       - Loop 48 is collaborative
     - head Candidate: A-2 
       - Loop 48 is collaborative
     - tail Candidate: B-1 
       - Loop 48 is collaborative
     - tail Candidate: A-2 
       - Loop 48 is collaborative
 * Adding constraints: [aux(17)=<B-1,aux(17)=<A-2,aux(17)=<B-B',aux(17)=<A-A'] 

##### Pending set p(A,B,C,D,E,F,G,H)
* Psum in Loop 49: [aux(21)=<A-2,aux(17)=<B-1,aux(19)=<B-1,aux(21)=<B-1,aux(23)=<B-1]

###### Computing sum for aux(21)=<A-2  in Loop 49 
   - Found a solution using cacheing 
 * Adding constraints: [aux(21)=<aux(39),aux(39)=<B-1,aux(39)=<A-2,aux(39)=<B-B',aux(39)=<A-A'] 

##### Pending set p(A,B,C,D,E,F,G,H)
* Psum in Loop 49: [aux(17)=<B-1,aux(19)=<B-1,aux(21)=<B-1,aux(23)=<B-1]

###### Computing sum for aux(17)=<B-1  in Loop 49 
   - Applying inductive sum strategy 
     - head Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B-1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [aux(17)=<B-1,aux(17)=<B-B'] 

##### Pending set p(A,B,C,D,E,F,G,H)
* Psum in Loop 49: [aux(19)=<B-1,aux(21)=<B-1,aux(23)=<B-1]

###### Computing sum for aux(19)=<B-1  in Loop 49 
   - Found a solution using cacheing 
 * Adding constraints: [aux(19)=<aux(40),aux(40)=<B-1,aux(40)=<B-B'] 

##### Pending set p(A,B,C,D,E,F,G,H)
* Psum in Loop 49: [aux(21)=<B-1,aux(23)=<B-1]

###### Computing sum for aux(21)=<B-1  in Loop 49 
   - Found a solution using cacheing 
 * Adding constraints: [aux(21)=<aux(41),aux(41)=<B-1,aux(41)=<B-B'] 

##### Pending set p(A,B,C,D,E,F,G,H)
* Psum in Loop 49: [aux(23)=<B-1]

###### Computing sum for aux(23)=<B-1  in Loop 49 
   - Found a solution using cacheing 
 * Adding constraints: [aux(23)=<aux(42),aux(42)=<B-1,aux(42)=<B-B'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [48,49] 

#### Simplifying cost structure of phase [48,49] 
 * Joined equivalent variables [aux(36),aux(31)] into aux(36)
 * Joined equivalent variables [aux(40),aux(19)] into aux(40)
 * Joined equivalent variables [aux(42),aux(23)] into aux(42)
 * Joined equivalent variables [aux(27),aux(36)] into aux(27)
 * Joined equivalent variables [aux(17),aux(39)] into aux(17)
 * Joined equivalent variables [aux(40),aux(41),aux(42)] into aux(40)

#### Cost of phase [48,49]:p(A,B,C,D,E,F,G,H) -> [p(A',B',C',D',E',F',G',H')] 
3*it(48)+7*it(49)+0
  Such that:aux(33) =< A+C+3*E
aux(33) =< A+C+5*E
aux(35) =< B+D+2*E+F
aux(26) =< C
aux(18) =< C+E
aux(22) =< C+E-C'-E'
aux(30) =< C-C'
aux(28) =< D+1
aux(20) =< D+F+1
aux(24) =< D+F-D'-F'
aux(32) =< D-D'
aux(43) =< A
aux(44) =< A+C+E
aux(45) =< A+C+E-A'-C'-E'
aux(46) =< A-A'
aux(47) =< B
aux(48) =< B+D+F
aux(49) =< B+D+F+1
aux(50) =< B+D+F-B'-D'-F'
aux(51) =< B-B'
aux(17) =< aux(43)
aux(33) =< aux(44)
it(48) =< aux(44)
it(49) =< aux(44)
it(48) =< aux(45)
it(49) =< aux(45)
aux(17) =< aux(46)
aux(17) =< aux(47)
aux(40) =< aux(47)
aux(35) =< aux(48)
aux(37) =< aux(48)
it(48) =< aux(49)
it(49) =< aux(49)
it(48) =< aux(50)
it(49) =< aux(50)
aux(17) =< aux(51)
aux(40) =< aux(51)
aux(37) =< aux(35)
aux(21) =< aux(40)
aux(21) =< aux(17)
it(48) =< aux(17)+aux(18)
it(48) =< aux(40)+aux(24)
it(48) =< aux(21)+aux(22)
it(48) =< aux(40)+aux(20)
aux(38) =< it(48)*aux(37)
aux(25) =< it(48)*aux(37)
aux(27) =< it(48)*aux(35)
aux(34) =< it(48)*aux(33)
aux(25) =< it(48)*aux(33)
aux(29) =< aux(38)
aux(29) =< aux(34)
it(49) =< aux(27)+aux(28)
it(49) =< aux(25)+aux(26)
it(49) =< aux(27)+aux(32)
it(49) =< aux(29)+aux(30)

#### Simplifying cost structure of chain [[48,49],50] 
 * Joined equivalent variables [aux(52),aux(26)] into aux(52)
 * Joined equivalent variables [aux(53),aux(18),aux(22)] into aux(53)

#### Cost of chains of p(A,B,C,D,E,F,G,H):
* Chain [[48,49],50]: 3*it(48)+7*it(49)+6
  Such that:aux(30) =< -A+B+D-E+F+G-H+1
aux(43) =< A
aux(44) =< A+C+E
aux(45) =< A+C+E-G
aux(33) =< A+C+3*E
aux(46) =< A-G
aux(47) =< B
aux(46) =< B-C+D-E+F-H+2
aux(35) =< B+D+2*E+F
aux(48) =< B+D+F
aux(49) =< B+D+F+1
aux(50) =< B+D+F-H
aux(51) =< B-H
aux(32) =< D
aux(28) =< D+1
aux(24) =< D+F
aux(20) =< D+F+1
aux(52) =< C
aux(53) =< C+E
aux(30) =< aux(52)
aux(17) =< aux(43)
aux(33) =< aux(44)
it(48) =< aux(44)
it(49) =< aux(44)
it(48) =< aux(45)
it(49) =< aux(45)
aux(17) =< aux(46)
aux(17) =< aux(47)
aux(40) =< aux(47)
aux(35) =< aux(48)
aux(37) =< aux(48)
it(48) =< aux(49)
it(49) =< aux(49)
it(48) =< aux(50)
it(49) =< aux(50)
aux(17) =< aux(51)
aux(40) =< aux(51)
aux(37) =< aux(35)
aux(21) =< aux(40)
aux(21) =< aux(17)
it(48) =< aux(17)+aux(53)
it(48) =< aux(40)+aux(24)
it(48) =< aux(21)+aux(53)
it(48) =< aux(40)+aux(20)
aux(38) =< it(48)*aux(37)
aux(25) =< it(48)*aux(37)
aux(27) =< it(48)*aux(35)
aux(34) =< it(48)*aux(33)
aux(25) =< it(48)*aux(33)
aux(29) =< aux(38)
aux(29) =< aux(34)
it(49) =< aux(27)+aux(28)
it(49) =< aux(25)+aux(52)
it(49) =< aux(27)+aux(32)
it(49) =< aux(29)+aux(30)

  with precondition: [C>=0,D>=0,E>=1,G>=0,H>=0,D+1>=C,F+1>=E,A>=G,C+E>=3,E+G>=2,B+G>=A+H] 

* Chain [50]: 6
  with precondition: [C=1,D=0,E=1,F=0,A=G,B=H,A>=0,B>=0] 


#### Simplifying cost structure of CE 51 

#### Computing cost of phase [51] 

#### Simplifying cost structure of CE 52 

#### Cost of loops [51] 

 * loop 51:r1(A,B,C,D,E,F) -> [r1(A',B',C',D',E',F')] 
5
##### Pending set r1(A,B,C,D,E,F)
* Psum in Loop 51: [it(51)=<1]

###### Computing sum for it(51)=<1  in Loop 51 
   - Applying inductive sum strategy 
     - head Candidate: A-1 
     - head Candidate: B+1 
     - head Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - head Candidate: B+1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: A-1 
     - tail Candidate: B+1 
     - tail Candidate: A-1 
       - The candidate was classified before. We reuse its previous classification 
     - tail Candidate: B+1 
       - The candidate was classified before. We reuse its previous classification 
 * Adding constraints: [it(51)=<A-1,it(51)=<B+1,it(51)=<A-1,it(51)=<B+1,it(51)=<A-A',it(51)=<B-B',it(51)=<A-A',it(51)=<B-B'] 

##### Empy Pending set: Done 

#### Sorting generated constraints of phase [51] 

#### Simplifying cost structure of phase [51] 

#### Cost of phase [51]:r1(A,B,C,D,E,F) -> [r1(A',B',C',D',E',F')] 
5*it(51)+0
  Such that:it(51) =< A
it(51) =< A-A'
it(51) =< B+1
it(51) =< B-B'

#### Simplifying cost structure of chain [[51],52] 

#### Cost of chains of r1(A,B,C,D,E,F):
* Chain [[51],52]: 5*it(51)+2
  Such that:it(51) =< -C+E

  with precondition: [A+C=E+1,B+D=F,A>=2,C>=1,D>=0,B+1>=A] 

* Chain [52]: 2
  with precondition: [A=1,B=0,C=E,D=F,C>=0,D>=0] 


#### Simplifying cost structure of CE 53 
 * Renamed intermediate variables: 
[ (eq(54,1),it(51))>>s(6)]

#### Simplifying cost structure of CE 54 

#### Cost of chains of rev(A,B,C,D):
* Chain [54]: 4
  with precondition: [A=1,B=0,C=1,D=0] 

* Chain [53]: 5*s(6)+4
  Such that:s(6) =< A

  with precondition: [A=C,B=D,A>=2,B+1>=A] 


#### Simplifying cost structure of CE 55 
 * Renamed intermediate variables: 
[ (eq(59,1),it(26))>>s(7)]

#### Simplifying cost structure of CE 59 

#### Simplifying cost structure of CE 56 
 * Renamed intermediate variables: 
[ (eq(57,2),aux(13))>>s(8), (eq(57,2),aux(15))>>s(9), (eq(57,2),aux(16))>>s(10), (eq(57,2),it(28))>>s(11), (eq(57,2),aux(11))>>s(12), (eq(57,2),aux(5))>>s(13), (eq(57,2),aux(3))>>s(14), (eq(57,2),aux(1))>>s(15), (eq(57,2),s(3))>>s(16)]

#### Simplifying cost structure of CE 57 
 * Joined equivalent variables [s(10),s(8)] into s(10)
 * Renamed intermediate variables: 
[ (eq(58,2),aux(13))>>s(17), (eq(58,2),aux(2))>>s(18), (eq(58,2),aux(4))>>s(19), (eq(58,2),aux(14))>>s(20), (eq(58,2),it(28))>>s(21), (eq(58,2),aux(11))>>s(22), (eq(58,2),aux(5))>>s(23), (eq(58,2),aux(3))>>s(24), (eq(58,2),aux(1))>>s(25), (eq(58,2),s(3))>>s(26)]

#### Simplifying cost structure of CE 58 
 * Renamed intermediate variables: 
[ (eq(60,1),it(26))>>s(27)]
 * Renamed intermediate variables: 
[ (eq(60,2),aux(13))>>s(28), (eq(60,2),aux(2))>>s(29), (eq(60,2),aux(4))>>s(30), (eq(60,2),aux(14))>>s(31), (eq(60,2),it(28))>>s(32), (eq(60,2),aux(11))>>s(33), (eq(60,2),aux(5))>>s(34), (eq(60,2),aux(3))>>s(35), (eq(60,2),aux(1))>>s(36), (eq(60,2),s(3))>>s(37)]

#### Simplifying cost structure of CE 60 

#### Cost of chains of g(A,B,C,D,E,F,G,H):
* Chain [60]: 6
  with precondition: [A=1,B=0,C=1,D=0,E=G,F=H,E>=0,F>=0] 

* Chain [59]: 5*s(7)+6
  Such that:s(7) =< C

  with precondition: [A=1,B=0,C+E=G+1,D+F=H,C>=2,E>=1,F>=0,D+1>=C] 

* Chain [58]: 14
  with precondition: [A=2,C=1,D=0,E=1,F=0,G=2,B=H,B>=1] 

* Chain [57]: 8*s(11)+5*s(16)+14
  Such that:s(9) =< A
s(10) =< B
s(11) =< s(9)
s(11) =< s(10)
s(12) =< s(9)
s(13) =< s(11)*s(10)
s(14) =< s(11)*s(9)
s(14) =< s(11)*s(12)
s(15) =< s(10)+s(13)
s(15) =< s(9)+s(14)
s(16) =< s(11)*s(15)

  with precondition: [C=1,D=0,E=1,F=0,A>=3,G>=0,H>=0,B+1>=A] 

* Chain [56]: 8*s(21)+5*s(26)+6
  Such that:s(20) =< A
s(17) =< B
s(18) =< E
s(19) =< F
s(21) =< s(20)
s(21) =< s(17)
s(22) =< s(20)
s(23) =< s(21)*s(17)
s(24) =< s(21)*s(20)
s(24) =< s(21)*s(22)
s(25) =< s(19)+s(23)
s(25) =< s(18)+s(24)
s(26) =< s(21)*s(25)

  with precondition: [C=1,D=0,A>=2,B>=1,E>=2,G>=0,H>=0,F+1>=E] 

* Chain [55]: 5*s(27)+8*s(32)+5*s(37)+6
  Such that:s(31) =< A
s(28) =< B
s(27) =< C
s(29) =< C+E
s(30) =< D+F
s(32) =< s(31)
s(32) =< s(28)
s(33) =< s(31)
s(34) =< s(32)*s(28)
s(35) =< s(32)*s(31)
s(35) =< s(32)*s(33)
s(36) =< s(30)+s(34)
s(36) =< s(29)+s(35)
s(37) =< s(32)*s(36)

  with precondition: [A>=2,B>=1,C>=2,E>=1,F>=0,G>=0,H>=0,D+1>=C,D+F+2>=C+E] 


Closed-form bounds of r1(A,B,C,D,E,F): 
-------------------------------------
* Chain [[51],52] with precondition: [A+C=E+1,B+D=F,A>=2,C>=1,D>=0,B+1>=A] 
    - Upper bound: 5*B+2 
    - Complexity: n 
* Chain [52] with precondition: [A=1,B=0,C=E,D=F,C>=0,D>=0] 
    - Upper bound: 2 
    - Complexity: constant 

### Maximum cost of r1(A,B,C,D,E,F): 5*B+2 
Asymptotic class: n 

Closed-form bounds of rev(A,B,C,D): 
-------------------------------------
* Chain [54] with precondition: [A=1,B=0,C=1,D=0] 
    - Upper bound: 4 
    - Complexity: constant 
* Chain [53] with precondition: [A=C,B=D,A>=2,B+1>=A] 
    - Upper bound: 5*A+4 
    - Complexity: n 

### Maximum cost of rev(A,B,C,D): 5*A+4 
Asymptotic class: n 

Closed-form bounds of append(A,B,C,D,E,F): 
-------------------------------------
* Chain [[26],27] with precondition: [F=B+D,A+C=E+1,A>=2,C>=1,B+1>=A,F>=B] 
    - Upper bound: 5*B+2 
    - Complexity: n 
* Chain [27] with precondition: [A=1,B=0,C=E,D=F,C>=0,D>=0] 
    - Upper bound: 2 
    - Complexity: constant 

### Maximum cost of append(A,B,C,D,E,F): 5*B+2 
Asymptotic class: n 
 * Joined equivalent variables [aux(16),aux(13)] into aux(16)

Closed-form bounds of f(A,B,C,D,E,F): 
-------------------------------------
* Chain [[28],30] with precondition: [A>=2,B>=1,C>=2,E>=0,F>=0,D+1>=C] 
    - Upper bound: 8*A+2+5*A*B*A+5*A*D 
    - Complexity: n^3 
* Chain [30] with precondition: [A=1,B=0,C=E,D=F,C>=0,D>=0] 
    - Upper bound: 2 
    - Complexity: constant 
* Chain [29,[28],30] with precondition: [C=1,D=0,A>=3,E>=0,F>=0,B+1>=A] 
    - Upper bound: 8*A+10+5*A*B+5*A*B*A 
    - Complexity: n^3 
* Chain [29,30] with precondition: [A=2,C=1,D=0,E=2,B=F,B>=1] 
    - Upper bound: 10 
    - Complexity: constant 

### Maximum cost of f(A,B,C,D,E,F): max([8,5*A*B*A+8*A+max([5*A*D,5*A*B+8])])+2 
Asymptotic class: n^3 

Closed-form bounds of g(A,B,C,D,E,F,G,H): 
-------------------------------------
* Chain [60] with precondition: [A=1,B=0,C=1,D=0,E=G,F=H,E>=0,F>=0] 
    - Upper bound: 6 
    - Complexity: constant 
* Chain [59] with precondition: [A=1,B=0,C+E=G+1,D+F=H,C>=2,E>=1,F>=0,D+1>=C] 
    - Upper bound: 5*C+6 
    - Complexity: n 
* Chain [58] with precondition: [A=2,C=1,D=0,E=1,F=0,G=2,B=H,B>=1] 
    - Upper bound: 14 
    - Complexity: constant 
* Chain [57] with precondition: [C=1,D=0,E=1,F=0,A>=3,G>=0,H>=0,B+1>=A] 
    - Upper bound: 8*A+14+5*A*B+5*A*B*A 
    - Complexity: n^3 
* Chain [56] with precondition: [C=1,D=0,A>=2,B>=1,E>=2,G>=0,H>=0,F+1>=E] 
    - Upper bound: 8*A+6+5*A*B*A+5*A*F 
    - Complexity: n^3 
* Chain [55] with precondition: [A>=2,B>=1,C>=2,E>=1,F>=0,G>=0,H>=0,D+1>=C,D+F+2>=C+E] 
    - Upper bound: 8*A+6+5*A*B*A+ (D+F)* (5*A)+5*C 
    - Complexity: n^3 

### Maximum cost of g(A,B,C,D,E,F,G,H): max([max([5*C,8]),5*A*B*A+8*A+max([5*A*F,5*A*B+8, (D+F)* (5*A)+5*C])])+6 
Asymptotic class: n^3 
 * Joined equivalent variables [aux(54),aux(43)] into aux(54)
 * Joined equivalent variables [aux(55),aux(44),aux(45)] into aux(55)
 * Joined equivalent variables [aux(56),aux(47),aux(51)] into aux(56)
 * Joined equivalent variables [aux(57),aux(48),aux(50)] into aux(57)
 * Joined equivalent variables [aux(56),aux(40)] into aux(56)

Closed-form bounds of p(A,B,C,D,E,F,G,H): 
-------------------------------------
* Chain [[48,49],50] with precondition: [C>=0,D>=0,E>=1,G>=0,H>=0,D+1>=C,F+1>=E,A>=G,C+E>=3,E+G>=2,B+G>=A+H] 
    - Upper bound: 10*A+10*C+10*E+6 
    - Complexity: n 
* Chain [50] with precondition: [C=1,D=0,E=1,F=0,A=G,B=H,A>=0,B>=0] 
    - Upper bound: 6 
    - Complexity: constant 

### Maximum cost of p(A,B,C,D,E,F,G,H): 10*A+10*C+10*E+6 
Asymptotic class: n 

Closed-form bounds of f2(A,B,C,D,E,F): 
-------------------------------------
* Chain [[32],31] with precondition: [A>=2,B>=0,C>=2,D>=1,E>=0,F>=1,A+C>=E+2,B+D+E+1>=A+C+F] 
    - Upper bound: 7*A+7*C+2 
    - Complexity: n 
* Chain [33,[32],31] with precondition: [A=1,B=0,C>=3,D>=2,E>=0,F>=1,2*C>=E+3,E+2*D+1>=2*C+F] 
    - Upper bound: 14*C+8 
    - Complexity: n 
* Chain [33,31] with precondition: [A=1,B=0,C=2,E=2,D=F,D>=1] 
    - Upper bound: 8 
    - Complexity: constant 
* Chain [31] with precondition: [C=1,D=0,A=E,B=F,A>=0,B>=0] 
    - Upper bound: 2 
    - Complexity: constant 

### Maximum cost of f2(A,B,C,D,E,F): max([14*C+6,7*A+7*C])+2 
Asymptotic class: n 

Closed-form bounds of last(A,B,C,D): 
-------------------------------------
* Chain [[36],37,38] with precondition: [C=2,A>=3,D>=1,B+2>=A+D] 
    - Upper bound: 9*A+13 
    - Complexity: n 
* Chain [38] with precondition: [A=1,B=0,C=1,D=0] 
    - Upper bound: 3 
    - Complexity: constant 
* Chain [37,38] with precondition: [A=2,C=2,B=D,B>=1] 
    - Upper bound: 13 
    - Complexity: constant 

### Maximum cost of last(A,B,C,D): 9*A+13 
Asymptotic class: n 

Closed-form bounds of f2p(A,B,C,D,E,F): 
-------------------------------------
* Chain [[39],40] with precondition: [A>=2,B>=0,C>=2,D>=1,E>=0,F>=1,A+C>=E+2,B+D+E+1>=A+C+F] 
    - Upper bound: 7*A+7*C+2 
    - Complexity: n 
* Chain [42] with precondition: [A=1,B=0,C=2,E=2,D=F,D>=1] 
    - Upper bound: 19 
    - Complexity: constant 
* Chain [41] with precondition: [A=1,B=0,E=2,C>=3,F>=1,D+2>=C+F] 
    - Upper bound: 9*C+19 
    - Complexity: n 
* Chain [40] with precondition: [C=1,D=0,A=E,B=F,A>=0,B>=0] 
    - Upper bound: 2 
    - Complexity: constant 

### Maximum cost of f2p(A,B,C,D,E,F): max([9*C+17,7*A+7*C])+2 
Asymptotic class: n 

Closed-form bounds of g3(A,B,C,D,E,F): 
-------------------------------------
* Chain [[43],44] with precondition: [A+C=E+1,B+D=F,A>=2,C>=1,D>=0,B+1>=A] 
    - Upper bound: 5*B+2 
    - Complexity: n 
* Chain [44] with precondition: [A=1,B=0,C=E,D=F,C>=0,D>=0] 
    - Upper bound: 2 
    - Complexity: constant 

### Maximum cost of g3(A,B,C,D,E,F): 5*B+2 
Asymptotic class: n 

Closed-form bounds of f3(A,B,C,D,E,F): 
-------------------------------------
* Chain [[45],46] with precondition: [A+C=E+1,B+D=F,A>=1,B>=0,C>=2,D+1>=C,B+D+2>=A+C] 
    - Upper bound: 5*A+10*C+6 
    - Complexity: n 
* Chain [47] with precondition: [A=1,B=0,C=1,D=0,E=1,F=0] 
    - Upper bound: 6 
    - Complexity: constant 
* Chain [46] with precondition: [C=1,D=0,A=E,B=F,A>=2,B+1>=A] 
    - Upper bound: 5*A+6 
    - Complexity: n 

### Maximum cost of f3(A,B,C,D,E,F): 5*A+10*C+6 
Asymptotic class: n 
* Total analysis performed in 4053 ms.


Cost relation system solved by CoFloCo in 4061 ms.

Method r1 terminates?: YES

 - ls_1: size of ls wrt. List<A>
 - ls_2: size of ls wrt. A
 - a_1: size of a wrt. List<A>
 - a_2: size of a wrt. A
UB for r1(ls_1,ls_2,a_1,a_2) = 5*ls_2+2

Method rev terminates?: YES

 - ls_1: size of ls wrt. List<A>
 - ls_2: size of ls wrt. A
UB for rev(ls_1,ls_2) = 5*ls_1+4

Method append terminates?: YES

 - l1_1: size of l1 wrt. List<A>
 - l1_2: size of l1 wrt. A
 - l2_1: size of l2 wrt. List<A>
 - l2_2: size of l2 wrt. A
UB for append(l1_1,l1_2,l2_1,l2_2) = 5*l1_2+2

Method f terminates?: YES

 - i_1: size of i wrt. List<A>
 - i_2: size of i wrt. A
 - x_1: size of x wrt. List<A>
 - x_2: size of x wrt. A
UB for f(i_1,i_2,x_1,x_2) = max([8,5*i_1*i_2*i_1+8*i_1+max([5*i_1*x_2,5*i_1*i_2+8])])+2

Method g terminates?: YES

 - a_1: size of a wrt. List<A>
 - a_2: size of a wrt. A
 - b_1: size of b wrt. List<A>
 - b_2: size of b wrt. A
 - c_1: size of c wrt. List<A>
 - c_2: size of c wrt. A
UB for g(a_1,a_2,b_1,b_2,c_1,c_2) = max([max([5*b_1,8]),5*a_1*a_2*a_1+8*a_1+max([5*a_1*c_2,5*a_1*a_2+8, (b_2+c_2)* (5*a_1)+5*b_1])])+6

Method p terminates?: YES

 - m_1: size of m wrt. List<A>
 - m_2: size of m wrt. A
 - n_1: size of n wrt. List<A>
 - n_2: size of n wrt. A
 - r_1: size of r wrt. List<A>
 - r_2: size of r wrt. A
UB for p(m_1,m_2,n_1,n_2,r_1,r_2) = 10*m_1+10*n_1+10*r_1+6

Method f2 terminates?: YES

 - x_1: size of x wrt. List<A>
 - x_2: size of x wrt. A
 - y_1: size of y wrt. List<A>
 - y_2: size of y wrt. A
UB for f2(x_1,x_2,y_1,y_2) = max([14*y_1+6,7*x_1+7*y_1])+2

Method last terminates?: YES

 - l_1: size of l wrt. List<A>
 - l_2: size of l wrt. A
UB for last(l_1,l_2) = 9*l_1+13

Method f2p terminates?: YES

 - x_1: size of x wrt. List<A>
 - x_2: size of x wrt. A
 - y_1: size of y wrt. List<A>
 - y_2: size of y wrt. A
UB for f2p(x_1,x_2,y_1,y_2) = max([9*y_1+17,7*x_1+7*y_1])+2

Method g3 terminates?: YES

 - c_1: size of c wrt. List<A>
 - c_2: size of c wrt. A
 - d_1: size of d wrt. List<A>
 - d_2: size of d wrt. A
UB for g3(c_1,c_2,d_1,d_2) = 5*c_2+2

Method f3 terminates?: YES

 - a_1: size of a wrt. List<A>
 - a_2: size of a wrt. A
 - b_1: size of b wrt. List<A>
 - b_2: size of b wrt. A
UB for f3(a_1,a_2,b_1,b_2) = 5*a_1+10*b_1+6
