
Preprocessing Cost Relations
=====================================

#### Computed strongly connected components 
0. recursive : [merge/2]
1. recursive : [msplit/1]
2. recursive : [mergeSort/1]
4. recursive : [out1_msplit/1]
5. recursive : [out2_msplit/1]

#### Obtained direct recursion through partial evaluation 
0. SCC is partially evaluated into merge/2
1. SCC is partially evaluated into msplit/1
2. SCC is partially evaluated into mergeSort/1
4. SCC is completely evaluated into other SCCs
5. SCC is completely evaluated into other SCCs

Control-Flow Refinement of Cost Relations
=====================================

### Specialization of cost equations merge/2 
* CE 9 is refined into CE [11] 
* CE 10 is refined into CE [12] 
* CE 8 is refined into CE [13] 
* CE 7 is refined into CE [14] 


#### Refined cost equations merge/2 
* CE 11: merge(N1,N2) = 1+ merge(O2,N2)
     [N2>=1,N1>=1,N1=O2+1] 
* CE 12: merge(N1,N2) = 1+ merge(N1,O2)
     [N2>=1,N1>=1,N2=O2+1] 
* CE 13: merge(N1,N2) = 1
     [N1>=1,N2=0] 
* CE 14: merge(N1,N2) = 1
     [N2>=1,N1=0] 

### Cost equations --> "Loop" of merge/2 
* CEs [13] --> Loop 10 
* CEs [14] --> Loop 11 
* CEs [11] --> Loop 12 
* CEs [12] --> Loop 13 

#### Loops of merge/2 
* Loop 10: merge(N1,N2) [N1>=1,N2=0] 
* Loop 11: merge(N1,N2) [N2>=1,N1=0] 
* Loop 12: merge(N1,N2)->  merge(N1',N2)
                  [N2>=1,N1>=1,N1=N1'+1] 
* Loop 13: merge(N1,N2)->  merge(N1,N2')
                  [N2>=1,N1>=1,N2=N2'+1] 

### Ranking functions of CR merge(N1,N2) 
* RF of phase [12,13]: [N1+N2-1]

#### Partial ranking functions of CR merge(N1,N2) 
* Partial RF of phase [12,13]:
  - RF of loop [12:1]:
    N1
  - RF of loop [13:1]:
    N2


### Resulting Chains:merge(N1,N2) 
* [[12,13],11]
* [[12,13],10]


### Specialization of cost equations msplit/1 
* CE 6 is refined into CE [15] 
* CE 5 is refined into CE [16] 
* CE 4 is refined into CE [17] 


#### Refined cost equations msplit/1 
* CE 15: msplit(N) = 1+ msplit(O)
     [N>=2,N=O+2] 
* CE 16: msplit(N) = 1
     [N=1] 
* CE 17: msplit(N) = 1
     [N=0] 

### Cost equations --> "Loop" of msplit/1 
* CEs [16] --> Loop 14 
* CEs [17] --> Loop 15 
* CEs [15] --> Loop 16 

#### Loops of msplit/1 
* Loop 14: msplit(N) [N=1] 
* Loop 15: msplit(N) [N=0] 
* Loop 16: msplit(N)->  msplit(N')
                  [N>=2,N=N'+2] 

### Ranking functions of CR msplit(N) 
* RF of phase [16]: [N-1]

#### Partial ranking functions of CR msplit(N) 
* Partial RF of phase [16]:
  - RF of loop [16:1]:
    N-1


### Resulting Chains:msplit(N) 
* [[16],15]
* [[16],14]


### Specialization of cost equations mergeSort/1 
* CE 3 is refined into CE [18,19,20,21] 
* CE 2 is refined into CE [22] 


#### Refined cost equations mergeSort/1 
* CE 18: mergeSort(N) = 1+ msplit(N):[[16],15]+ mergeSort(O)+ mergeSort(P)+ merge(O,P):[[12,13],11]
     [2*P+1>=N,2*O>=N,N>=2*P,N+1>=2*O,P>=1] 
* CE 19: mergeSort(N) = 1+ msplit(N):[[16],15]+ mergeSort(O)+ mergeSort(P)+ merge(O,P):[[12,13],10]
     [2*P+1>=N,2*O>=N,N>=2*P,N+1>=2*O,P>=1] 
* CE 20: mergeSort(N) = 1+ msplit(N):[[16],14]+ mergeSort(O)+ mergeSort(P)+ merge(O,P):[[12,13],11]
     [2*P+1>=N,2*O>=N,N>=2*P,N+1>=2*O,N>=3] 
* CE 21: mergeSort(N) = 1+ msplit(N):[[16],14]+ mergeSort(O)+ mergeSort(P)+ merge(O,P):[[12,13],10]
     [2*P+1>=N,2*O>=N,N>=2*P,N+1>=2*O,N>=3] 
* CE 22: mergeSort(N) = 1
     [1>=N] 

### Cost equations --> "Loop" of mergeSort/1 
* CEs [22] --> Loop 17 
* CEs [19] --> Loop 18 
* CEs [18] --> Loop 19 
* CEs [21] --> Loop 20 
* CEs [20] --> Loop 21 

#### Loops of mergeSort/1 
* Loop 17: mergeSort(N) [1>=N] 
* Loop 18: mergeSort(N)->  mergeSort(N')  mergeSort(N'2)
                  [2*N'2+1>=N,2*N'>=N,N>=2*N'2,N+1>=2*N',N'2>=1] 
* Loop 19: mergeSort(N)->  mergeSort(N')  mergeSort(N'2)
                  [2*N'2+1>=N,2*N'>=N,N>=2*N'2,N+1>=2*N',N'2>=1] 
* Loop 20: mergeSort(N)->  mergeSort(N')  mergeSort(N'2)
                  [2*N'2+1>=N,2*N'>=N,N>=2*N'2,N+1>=2*N',N>=3] 
* Loop 21: mergeSort(N)->  mergeSort(N')  mergeSort(N'2)
                  [2*N'2+1>=N,2*N'>=N,N>=2*N'2,N+1>=2*N',N>=3] 

### Ranking functions of CR mergeSort(N) 
* RF of phase [18,19,20,21]: [2*N-3]

#### Partial ranking functions of CR mergeSort(N) 
* Partial RF of phase [18,19,20,21]:
  - RF of loop [18:1,19:1]:
    2*N-3
  - RF of loop [18:2,19:2]:
    N-1
  - RF of loop [20:1,21:1]:
    N-2
  - RF of loop [20:2,21:2]:
    2/3*N-5/3


### Resulting Chains:mergeSort(N) 
* [17]
* [multiple([18,19,20,21],[[17]])]


Computing Bounds
=====================================

#### Cost of loops [12,13] 

 * loop 12:merge(N1,N2) -> [merge(N1',N2')] 
1
 * loop 13:merge(N1,N2) -> [merge(N1',N2')] 
1
#### Cost of phase [12,13]:merge(N1,N2) -> [merge(N1',N2')] 
1*it(12)+1*it(13)+0
  Such that:it(12) =< N1
it(12)+it(13) =< N1+N2-1
it(12)+it(13) =< N1+N2-N1'-N2'
it(12) =< N1-N1'
it(13) =< N2
it(13) =< N2-N2'
it(12)+it(13) >= N1+N2-N1'-N2'
it(12) >= N1-N1'
it(13) >= N2-N2'

#### Cost of phase [12,13]:merge(N1,N2) -> [merge(N1',N2')] 
1*it(12)+1*it(13)+0
  Such that:it(12) =< N1
it(12)+it(13) =< N1+N2-1
it(12)+it(13) =< N1+N2-N1'-N2'
it(12) =< N1-N1'
it(13) =< N2
it(13) =< N2-N2'
it(12)+it(13) >= N1+N2-N1'-N2'
it(12) >= N1-N1'
it(13) >= N2-N2'

#### Cost of chains of merge(N1,N2):
* Chain [[12,13],11]: 1*it(12)+1*it(13)+1
  Such that:it(12) =< N1
it(13) =< N2-1
it(12) >= N1

  with precondition: [N1>=1,N2>=1] 

* Chain [[12,13],10]: 1*it(12)+1*it(13)+1
  Such that:it(12) =< N1-1
it(13) =< N2
it(13) >= N2

  with precondition: [N1>=1,N2>=1] 


#### Cost of loops [16] 

 * loop 16:msplit(N) -> [msplit(N')] 
1
#### Cost of phase [16]:msplit(N) -> [msplit(N')] 
1*it(16)+0
  Such that:it(16) =< N-1
it(16) =< N-N'
it(16) >= N/2-N'/2

#### Cost of phase [16]:msplit(N) -> [msplit(N')] 
1*it(16)+0
  Such that:it(16) =< N-1
it(16) =< N-N'
it(16) >= N/2-N'/2

#### Cost of chains of msplit(N):
* Chain [[16],15]: 1*it(16)+1
  Such that:it(16) =< N-1
it(16) >= N/2

  with precondition: [N>=2] 

* Chain [[16],14]: 1*it(16)+1
  Such that:it(16) =< N-1
it(16) >= N/2-1/2

  with precondition: [N>=3] 


#### Cost of loops [18,19,20,21] 

 * loop 18:mergeSort(N) -> [mergeSort(N'),mergeSort(N'2)] 
1*s(4)+1*s(5)+1*s(6)+3
  Such that:s(4) =< N-1
s(5) =< N'-1
s(6) =< N'2
s(4) >= N/2
s(6) >= N'2

 * loop 19:mergeSort(N) -> [mergeSort(N'),mergeSort(N'2)] 
1*s(10)+1*s(11)+1*s(12)+3
  Such that:s(10) =< N-1
s(11) =< N'
s(12) =< N'2-1
s(10) >= N/2
s(11) >= N'

 * loop 20:mergeSort(N) -> [mergeSort(N'),mergeSort(N'2)] 
1*s(16)+1*s(17)+1*s(18)+3
  Such that:s(16) =< N-1
s(17) =< N'-1
s(18) =< N'2
s(16) >= N/2-1/2
s(18) >= N'2

 * loop 21:mergeSort(N) -> [mergeSort(N'),mergeSort(N'2)] 
1*s(22)+1*s(23)+1*s(24)+3
  Such that:s(22) =< N-1
s(23) =< N'
s(24) =< N'2-1
s(22) >= N/2-1/2
s(23) >= N'

#### Cost of phase [18,19,20,21]:mergeSort(N) -> [] 
3*it(18)+3*it(19)+3*it(20)+3*it(21)+1*it([17])+1*s(25)+1*s(26)+1*s(27)+1*s(28)+1*s(29)+1*s(30)+1*s(31)+1*s(32)+1*s(33)+1*s(34)+1*s(35)+1*s(36)+0
  Such that:aux(10) =< N-1
it([17]) =< 2*N-1
aux(43) =< 1
aux(44) =< 4/3*N-5/3
aux(45) =< 4/5*N-7/5
it(18)+it(19)+it(20)+it(21) =< aux(44)
it(20)+it(21) =< aux(45)
aux(22) =< aux(10)* (1/2)-1/2
aux(21) =< aux(10)* (1/2)+1
aux(20) =< aux(10)
aux(12) =< aux(10)* (1/2)+1/2
aux(11) =< aux(10)* (1/2)
it(20)+it(21) =< it([17])* (3/5)+aux(45)
it(18)+it(19)+it(20)+it(21) =< it([17])* (1/3)+aux(44)
s(36) =< it(21)*aux(22)
s(35) =< it(21)*aux(21)
s(34) =< it(21)*aux(20)
s(33) =< it(20)*aux(12)
s(32) =< it(20)*aux(11)
s(31) =< it(20)*aux(20)
s(30) =< it(19)*aux(22)
s(29) =< it(19)*aux(21)
s(28) =< it(19)*aux(20)
s(27) =< it(18)*aux(12)
s(26) =< it(18)*aux(11)
s(25) =< it(18)*aux(10)
it(18)+it(19)+it(20)+it(21)+it([17]) >= N
aux(47) >= 1
aux(46) >= aux(46)
aux(47) >= aux(47)
aux(17) >= aux(47)
aux(27) >= aux(47)-1/2
it(18)+it(19)+it(20)+s(34) >= it([17])+aux(46)-aux(43)
it(18)+it(19)+it(20)+it(21) >= it([17])+aux(46)-aux(43)
it(18)+it(19)+it(21)+s(31) >= it([17])+aux(46)-aux(43)
it(18)+it(20)+it(21)+s(28) >= it([17])+aux(46)-aux(43)
it(19)+it(20)+it(21)+s(27) >= it([17])+aux(46)-aux(43)
it(19)+it(20)+it(21)+s(25) >= it([17])+aux(46)-aux(43)
s(35) >= it(21)*aux(17)
s(34) >= it(21)*aux(27)
s(33) >= it(20)*aux(27)
s(31) >= it(20)*aux(27)
s(29) >= it(19)*aux(17)
s(28) >= it(19)*aux(17)
s(27) >= it(18)*aux(47)
s(25) >= it(18)*aux(47)

#### Cost of chains of mergeSort(N):
* Chain [17]: 1
  with precondition: [1>=N] 

* Chain [multiple([18,19,20,21],[[17]])]: 3*it(18)+3*it(19)+3*it(20)+3*it(21)+1*it([17])+1*s(25)+1*s(26)+1*s(27)+1*s(28)+1*s(29)+1*s(30)+1*s(31)+1*s(32)+1*s(33)+1*s(34)+1*s(35)+1*s(36)+0
  Such that:aux(10) =< N-1
it([17]) =< 2*N-1
aux(43) =< 1
aux(44) =< 4/3*N-5/3
aux(45) =< 4/5*N-7/5
it(18)+it(19)+it(20)+it(21) =< aux(44)
it(20)+it(21) =< aux(45)
aux(22) =< aux(10)* (1/2)-1/2
aux(21) =< aux(10)* (1/2)+1
aux(20) =< aux(10)
aux(12) =< aux(10)* (1/2)+1/2
aux(11) =< aux(10)* (1/2)
it(20)+it(21) =< it([17])* (3/5)+aux(45)
it(18)+it(19)+it(20)+it(21) =< it([17])* (1/3)+aux(44)
s(36) =< it(21)*aux(22)
s(35) =< it(21)*aux(21)
s(34) =< it(21)*aux(20)
s(33) =< it(20)*aux(12)
s(32) =< it(20)*aux(11)
s(31) =< it(20)*aux(20)
s(30) =< it(19)*aux(22)
s(29) =< it(19)*aux(21)
s(28) =< it(19)*aux(20)
s(27) =< it(18)*aux(12)
s(26) =< it(18)*aux(11)
s(25) =< it(18)*aux(10)
it(18)+it(19)+it(20)+it(21)+it([17]) >= N
aux(47) >= 1
aux(46) >= aux(46)
aux(47) >= aux(47)
aux(17) >= aux(47)
aux(27) >= aux(47)-1/2
it(18)+it(19)+it(20)+s(34) >= it([17])+aux(46)-aux(43)
it(18)+it(19)+it(20)+it(21) >= it([17])+aux(46)-aux(43)
it(18)+it(19)+it(21)+s(31) >= it([17])+aux(46)-aux(43)
it(18)+it(20)+it(21)+s(28) >= it([17])+aux(46)-aux(43)
it(19)+it(20)+it(21)+s(27) >= it([17])+aux(46)-aux(43)
it(19)+it(20)+it(21)+s(25) >= it([17])+aux(46)-aux(43)
s(35) >= it(21)*aux(17)
s(34) >= it(21)*aux(27)
s(33) >= it(20)*aux(27)
s(31) >= it(20)*aux(27)
s(29) >= it(19)*aux(17)
s(28) >= it(19)*aux(17)
s(27) >= it(18)*aux(47)
s(25) >= it(18)*aux(47)

  with precondition: [N>=2] 


Closed-form bounds of mergeSort(N): 
-------------------------------------
* Chain [17] with precondition: [1>=N] 
    - Lower bound: 1 
    - Complexity: constant
 * Chain [multiple([18,19,20,21],[[17]])] with precondition: [N>=2] 
    - Lower bound: N 
    - Complexity: n
 
### Partitioned lower bound of mergeSort(N): 
* N 
 if [N>=2]
* 1 
 if [1>=N]
Possible lower bounds : [N,1]
Maximum lower bound complexity: n

Time statistics: 
-------------------------------------
* Partial evaluation computed in 13 ms.
* Invariants computed in 87 ms.
   - Backward Invariants 27 ms.
   - Transitive Invariants 30 ms.
* Refinement performed in 98 ms.
* Termination proved in 55 ms.
* Upper bounds computed in 456 ms.
   - Equation cost structures 55 ms.
   - Phase cost structures 382 ms.
   - Chain cost structures 42 ms.
   - Solving cost expressions 15 ms.
* Total analysis performed in 759 ms.

