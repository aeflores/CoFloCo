
Preprocessing Cost Relations
=====================================

#### Computed strongly connected components 
0. recursive : [insertD/2]
1. recursive : [insertionsortD/1]

#### Obtained direct recursion through partial evaluation 
0. SCC is partially evaluated into insertD/2
1. SCC is partially evaluated into insertionsortD/1

Control-Flow Refinement of Cost Relations
=====================================

### Specialization of cost equations insertD/2 
* CE 6 is refined into CE [7] 
* CE 5 is refined into CE [8] 
* CE 4 is refined into CE [9] 


#### Refined cost equations insertD/2 
* CE 7: insertD(A,B) = 1+ insertD(A,C)
     [B>=1,B=C+1] 
* CE 8: insertD(A,B) = 1
     [B>=1] 
* CE 9: insertD(A,B) = 1
     [B=0] 

### Cost equations --> "Loop" of insertD/2 
* CEs [8] --> Loop 6 
* CEs [9] --> Loop 7 
* CEs [7] --> Loop 8 

#### Loops of insertD/2 
* Loop 6: insertD(A,B) [B>=1] 
* Loop 7: insertD(A,B) [B=0] 
* Loop 8: insertD(A,B)->  insertD(A,B')
                  [B>=1,B=B'+1] 

### Ranking functions of CR insertD(A,B) 
* RF of phase [8]: [B]

#### Partial ranking functions of CR insertD(A,B) 
* Partial RF of phase [8]:
  - RF of loop [8:1]:
    B


### Resulting Chains:insertD(A,B) 
* [[8],7]
* [[8],6]
* [7]
* [6]


### Specialization of cost equations insertionsortD/1 
* CE 3 is refined into CE [10,11,12,13] 
* CE 2 is refined into CE [14] 


#### Refined cost equations insertionsortD/1 
* CE 10: insertionsortD(A) = 1+ insertD(B,C):[[8],7]+ insertionsortD(C)
     [C>=1,C+1=A] 
* CE 11: insertionsortD(A) = 1+ insertD(B,C):[[8],6]+ insertionsortD(C)
     [C>=2,C+1=A] 
* CE 12: insertionsortD(A) = 1+ insertD(B,C):[7]+ insertionsortD(D)
     [D=0,C=0,A=1] 
* CE 13: insertionsortD(A) = 1+ insertD(B,C):[6]+ insertionsortD(C)
     [C>=1,C+1=A] 
* CE 14: insertionsortD(A) = 1
     [A=0] 

### Cost equations --> "Loop" of insertionsortD/1 
* CEs [14] --> Loop 9 
* CEs [11] --> Loop 10 
* CEs [13] --> Loop 11 
* CEs [10] --> Loop 12 
* CEs [12] --> Loop 13 

#### Loops of insertionsortD/1 
* Loop 9: insertionsortD(A) [A=0] 
* Loop 10: insertionsortD(A)->  insertionsortD(A')
                  [A'>=2,A'+1=A] 
* Loop 11: insertionsortD(A)->  insertionsortD(A')
                  [A'>=1,A'+1=A] 
* Loop 12: insertionsortD(A)->  insertionsortD(A')
                  [A'>=1,A'+1=A] 
* Loop 13: insertionsortD(A)->  insertionsortD(A')
                  [A'=0,A=1] 

### Ranking functions of CR insertionsortD(A) 
* RF of phase [10,11,12]: [A-1]

#### Partial ranking functions of CR insertionsortD(A) 
* Partial RF of phase [10,11,12]:
  - RF of loop [10:1]:
    A-2
  - RF of loop [11:1,12:1]:
    A-1


### Resulting Chains:insertionsortD(A) 
* [[10,11,12],13,9]
* [13,9]
* [9]


Computing Bounds
=====================================

#### Cost of loops [8] 

 * loop 8:insertD(A,B) -> [insertD(A',B')] 
1
#### Cost of phase [8]:insertD(A,B) -> [insertD(A',B')] 
1*it(8)+0
  Such that:it(8) =< B
it(8) =< B-B'
it(8) >= B-B'

#### Cost of phase [8]:insertD(A,B) -> [insertD(A',B')] 
1*it(8)+0
  Such that:it(8) =< B
it(8) =< B-B'
it(8) >= B-B'

#### Cost of chains of insertD(A,B):
* Chain [[8],7]: 1*it(8)+1
  Such that:it(8) =< B
it(8) >= B

  with precondition: [B>=1] 

* Chain [[8],6]: 1*it(8)+1
  Such that:it(8) =< B-1
it(8) >= 1

  with precondition: [B>=2] 

* Chain [7]: 1
  with precondition: [B=0] 

* Chain [6]: 1
  with precondition: [B>=1] 


#### Cost of loops [10,11,12] 

 * loop 10:insertionsortD(A) -> [insertionsortD(A')] 
1*s(2)+2
  Such that:s(2) =< A'-1
s(2) >= 1

 * loop 11:insertionsortD(A) -> [insertionsortD(A')] 
2
 * loop 12:insertionsortD(A) -> [insertionsortD(A')] 
1*s(4)+2
  Such that:s(4) =< A'
s(4) >= A'

#### Cost of phase [10,11,12]:insertionsortD(A) -> [insertionsortD(A')] 
2*it(10)+2*it(11)+2*it(12)+1*s(5)+1*s(6)+0
  Such that:it(10)+it(11)+it(12) =< A-1
it(10)+it(11)+it(12) =< A-A'
aux(5) =< A-2
it(10)+it(11)+it(12) =< aux(5)
aux(4) =< aux(5)+1
s(5) =< it(10)*aux(5)
s(6) =< it(12)*aux(4)
aux(3) >= 1
aux(6) >= A-A'
aux(1)+it(11)+it(12) >= aux(6)
it(10)+it(11)+it(12) >= aux(6)
it(10)+it(11)+s(6) >= aux(6)
s(6) >= it(12)*aux(3)
s(5) >= aux(1)

#### Cost of chains of insertionsortD(A):
* Chain [[10,11,12],13,9]: 2*it(10)+2*it(11)+2*it(12)+1*s(5)+1*s(6)+3
  Such that:aux(5) =< A-2
it(12)+it(11)+it(10) =< A-1
it(10)+it(11)+it(12) =< aux(5)
aux(4) =< aux(5)+1
s(5) =< it(10)*aux(5)
s(6) =< it(12)*aux(4)
aux(3) >= 1
aux(6) >= A-1
aux(1)+it(11)+it(12) >= aux(6)
it(10)+it(11)+it(12) >= aux(6)
it(10)+it(11)+s(6) >= aux(6)
s(6) >= it(12)*aux(3)
s(5) >= aux(1)

  with precondition: [A>=2] 

* Chain [13,9]: 3
  with precondition: [A=1] 

* Chain [9]: 1
  with precondition: [A=0] 


Closed-form bounds of insertionsortD(A): 
-------------------------------------
* Chain [[10,11,12],13,9] with precondition: [A>=2] 
    - Lower bound: A+2 
    - Complexity: n
 * Chain [13,9] with precondition: [A=1] 
    - Lower bound: 3 
    - Complexity: constant
 * Chain [9] with precondition: [A=0] 
    - Lower bound: 1 
    - Complexity: constant
 
### Partitioned lower bound of insertionsortD(A): 
* 1 
 if [A=0]
* 3 
 if [A=1]
* A+2 
 if [A>=2]
Possible lower bounds : [1,3,A+2]
Maximum lower bound complexity: n

Time statistics: 
-------------------------------------
* Partial evaluation computed in 5 ms.
* Invariants computed in 31 ms.
   - Backward Invariants 13 ms.
   - Transitive Invariants 7 ms.
* Refinement performed in 37 ms.
* Termination proved in 10 ms.
* Upper bounds computed in 90 ms.
   - Equation cost structures 13 ms.
   - Phase cost structures 55 ms.
   - Chain cost structures 16 ms.
   - Solving cost expressions 5 ms.
* Total analysis performed in 208 ms.

