
Preprocessing Cost Relations
=====================================

#### Computed strongly connected components 
0. recursive  : [fun/3]
1. non_recursive  : [fun1/2]
2. non_recursive  : [fun2/3]
3. non_recursive  : [fun3/2]
4. recursive [non_tail,multiple] : [mark/2]
5. non_recursive  : [start/2]

#### Obtained direct recursion through partial evaluation 
0. SCC is partially evaluated into fun/3
1. SCC is partially evaluated into fun1/2
2. SCC is partially evaluated into fun2/3
3. SCC is partially evaluated into fun3/2
4. SCC is partially evaluated into mark/2
5. SCC is partially evaluated into start/2

Control-Flow Refinement of Cost Relations
=====================================

### Specialization of cost equations fun/3 
* CE 10 is refined into CE [25] 
* CE 9 is refined into CE [26] 
* CE 7 is refined into CE [27] 
* CE 8 is refined into CE [28] 


#### Refined cost equations fun/3 
* CE 25: fun(V1,V,Out) = 1
     [V>=0,V1>=0,V1+V+1=Out] 
* CE 26: fun(V1,V,Out) = 1
     [V>=0,V1>=0,Out=1] 
* CE 27: fun(V1,V,Out) = 1
     [Out=3,V=0,V1=0] 
* CE 28: fun(V1,V,Out) = 1+ fun(W1,X1,Out)
     [X1>=0,W1>=0,X1+1=V,W1+1=V1] 

### Cost equations --> "Loop" of fun/3 
* CEs [28] --> Loop 18 
* CEs [25] --> Loop 19 
* CEs [26] --> Loop 20 
* CEs [27] --> Loop 21 

#### Loops of fun/3 
* Loop 18: fun(V1,V,Out)->  fun(V1',V',Out)
                  [V'>=0,V1'>=0,V'+1=V,V1'+1=V1] 
* Loop 19: fun(V1,V,Out) [V>=0,V1>=0,V1+V+1=Out] 
* Loop 20: fun(V1,V,Out) [V>=0,V1>=0,Out=1] 
* Loop 21: fun(V1,V,Out) [Out=3,V=0,V1=0] 

### Ranking functions of CR fun(V1,V,Out) 
* RF of phase [18]: [V,V1]

#### Partial ranking functions of CR fun(V1,V,Out) 
* Partial RF of phase [18]:
  - RF of loop [18:1]:
    V
    V1


### Resulting Chains:fun(V1,V,Out) 
* [[18],21]
* [[18],20]
* [[18],19]
* [21]
* [20]
* [19]


### Merging Chains  fun/3 into  External patterns of execution 
* [[21]] --> 1 
* [[20],[20,[18]]] --> 2 
* [[21,[18]]] --> 3 
* [[19]] --> 4 
* [[19,[18]]] --> 5 


### Specialization of cost equations fun1/2 
* CE 11 is refined into CE [29] 
* CE 12 is refined into CE [30] 


#### Refined cost equations fun1/2 
* CE 29: fun1(V1,Out) = 1
     [V1>=0,2*V1+3=Out] 
* CE 30: fun1(V1,Out) = 1
     [V1>=0,V1+1=Out] 

### Cost equations --> "Loop" of fun1/2 
* CEs [29] --> Loop 22 
* CEs [30] --> Loop 23 

#### Loops of fun1/2 
* Loop 22: fun1(V1,Out) [V1>=0,2*V1+3=Out] 
* Loop 23: fun1(V1,Out) [V1>=0,V1+1=Out] 

### Ranking functions of CR fun1(V1,Out) 

#### Partial ranking functions of CR fun1(V1,Out) 


### Resulting Chains:fun1(V1,Out) 
* [23]
* [22]


### Merging Chains  fun1/2 into  External patterns of execution 
* [[23]] --> 1 
* [[22]] --> 2 


### Specialization of cost equations fun2/3 
* CE 14 is refined into CE [31] 
* CE 15 is refined into CE [32] 
* CE 13 is refined into CE [33] 


#### Refined cost equations fun2/3 
* CE 31: fun2(V1,V,Out) = 1
     [V>=1,V1>=1,V1+V=Out] 
* CE 32: fun2(V1,V,Out) = 1
     [V>=0,V1>=0,V1+V+1=Out] 
* CE 33: fun2(V1,V,Out) = 1
     [V>=0,Out=2,V1=0] 

### Cost equations --> "Loop" of fun2/3 
* CEs [31] --> Loop 24 
* CEs [32] --> Loop 25 
* CEs [33] --> Loop 26 

#### Loops of fun2/3 
* Loop 24: fun2(V1,V,Out) [V>=1,V1>=1,V1+V=Out] 
* Loop 25: fun2(V1,V,Out) [V>=0,V1>=0,V1+V+1=Out] 
* Loop 26: fun2(V1,V,Out) [V>=0,Out=2,V1=0] 

### Ranking functions of CR fun2(V1,V,Out) 

#### Partial ranking functions of CR fun2(V1,V,Out) 


### Resulting Chains:fun2(V1,V,Out) 
* [26]
* [25]
* [24]


### Merging Chains  fun2/3 into  External patterns of execution 
* [[26]] --> 1 
* [[25]] --> 2 
* [[24]] --> 3 


### Specialization of cost equations fun3/2 
* CE 17 is refined into CE [34] 
* CE 18 is refined into CE [35] 
* CE 16 is refined into CE [36] 


#### Refined cost equations fun3/2 
* CE 34: fun3(V1,Out) = 1
     [V1+1>=Out,Out>=2] 
* CE 35: fun3(V1,Out) = 1
     [V1>=0,V1+1=Out] 
* CE 36: fun3(V1,Out) = 1
     [Out=0,V1=2] 

### Cost equations --> "Loop" of fun3/2 
* CEs [34] --> Loop 27 
* CEs [35] --> Loop 28 
* CEs [36] --> Loop 29 

#### Loops of fun3/2 
* Loop 27: fun3(V1,Out) [V1+1>=Out,Out>=2] 
* Loop 28: fun3(V1,Out) [V1>=0,V1+1=Out] 
* Loop 29: fun3(V1,Out) [Out=0,V1=2] 

### Ranking functions of CR fun3(V1,Out) 

#### Partial ranking functions of CR fun3(V1,Out) 


### Resulting Chains:fun3(V1,Out) 
* [29]
* [28]
* [27]


### Merging Chains  fun3/2 into  External patterns of execution 
* [[29]] --> 1 
* [[28]] --> 2 
* [[27]] --> 3 


### Specialization of cost equations mark/2 
* CE 19 is refined into CE [37,38,39,40,41] 
* CE 24 is refined into CE [42] 
* CE 23 is refined into CE [43] 
* CE 20 is refined into CE [44,45] 
* CE 22 is refined into CE [46,47,48] 
* CE 21 is refined into CE [49,50,51] 


#### Refined cost equations mark/2 
* CE 37: mark(V1,Out) = 1+ fun(W1,X1,Y1):1
     [Y1=3,X1=0,W1=0,Out=3,V1=1] 
* CE 38: mark(V1,Out) = 1+ fun(W1,X1,Y1):2
     [X1>=0,W1>=0,W1+X1+1=V1,Y1=1,Out=1] 
* CE 39: mark(V1,Out) = 1+ fun(W1,W1,X1):3
     [W1>=1,2*W1+1=V1,X1=3,Out=3] 
* CE 40: mark(A,A) = 1+ fun(B,C,A):4
     [A>=B+1,B>=0,A=B+C+1] 
* CE 41: mark(V1,Out) = 1+ fun(W1,X1,Out):5
     [W1+X1>=Out+1,Out+W1>=X1+1,Out+X1>=W1+1,W1+X1+1=V1] 
* CE 42: mark(A,A) = 1
     [A>=1] 
* CE 43: mark(V1,Out) = 1
     [Out=0,V1=0] 
* CE 44: mark(V1,Out) = 1+ mark(W1,X1)+ fun1(Y1,Out):1
     [W1>=0,Out>=1,Out=X1+1,Out=Y1+1,W1+1=V1] 
* CE 45: mark(V1,Out) = 1+ mark(W1,X1)+ fun1(Y1,Out):2
     [W1>=0,Out>=3,W1+1=V1,Out=2*X1+3,Out=2*Y1+3] 
* CE 46: mark(V1,Out) = 1+ mark(W1,X1)+ fun3(Y1,Z1):1
     [W1>=0,W1+1=V1,X1=2,Z1=0,Y1=2,Out=0] 
* CE 47: mark(V1,Out) = 1+ mark(W1,X1)+ fun3(Y1,Out):2
     [W1>=0,Out>=1,Out=X1+1,Out=Y1+1,W1+1=V1] 
* CE 48: mark(V1,Out) = 1+ mark(W1,X1)+ fun3(X1,Out):3
     [X1+1>=Out,W1>=0,Out>=2,W1+1=V1] 
* CE 49: mark(V1,Out) = 1+ mark(W1,X1)+ mark(Y1,Z1)+ fun2(A2,Z1,B2):1
     [Y1>=0,W1>=0,Z1>=0,W1+Y1+1=V1,X1=0,B2=2,A2=0,Out=2] 
* CE 50: mark(V1,Out) = 1+ mark(W1,X1)+ mark(Y1,Z1)+ fun2(X1,A2,Out):2
     [Out>=X1+1,Y1>=0,W1>=0,X1>=0,Out=X1+Z1+1,Out=X1+A2+1,W1+Y1+1=V1] 
* CE 51: mark(V1,Out) = 1+ mark(W1,X1)+ mark(Y1,Z1)+ fun2(X1,A2,Out):3
     [Out>=X1+1,Y1>=0,W1>=0,X1>=1,Out=X1+Z1,Out=X1+A2,W1+Y1+1=V1] 

### Cost equations --> "Loop" of mark/2 
* CEs [51] --> Loop 30 
* CEs [50] --> Loop 31 
* CEs [49] --> Loop 32 
* CEs [48] --> Loop 33 
* CEs [44,47] --> Loop 34 
* CEs [45] --> Loop 35 
* CEs [46] --> Loop 36 
* CEs [41] --> Loop 37 
* CEs [40,42] --> Loop 38 
* CEs [39] --> Loop 39 
* CEs [38] --> Loop 40 
* CEs [37] --> Loop 41 
* CEs [43] --> Loop 42 

#### Loops of mark/2 
* Loop 30: mark(V1,Out)->  mark(V1',Out')  mark(V1'2,Out'2)
                  [Out>=Out'+1,V1>=V1'+1,Out'>=1,V1'>=0,Out'+Out'2=Out,V1'+V1'2+1=V1] 
* Loop 31: mark(V1,Out)->  mark(V1',Out')  mark(V1'2,Out'2)
                  [Out>=Out'+1,V1>=V1'+1,Out'>=0,V1'>=0,Out'+Out'2+1=Out,V1'+V1'2+1=V1] 
* Loop 32: mark(V1,Out)->  mark(V1',Out')  mark(V1'2,Out'2)
                  [V1>=V1'+1,Out'2>=0,V1'>=0,V1'+V1'2+1=V1,Out'=0,Out=2] 
* Loop 33: mark(V1,Out)->  mark(V1',Out')
                  [Out'+1>=Out,Out>=2,V1>=1,V1=V1'+1] 
* Loop 34: mark(V1,Out)->  mark(V1',Out')
                  [Out>=1,V1>=1,Out=Out'+1,V1=V1'+1] 
* Loop 35: mark(V1,Out)->  mark(V1',Out')
                  [Out>=3,V1>=1,V1=V1'+1,Out=2*Out'+3] 
* Loop 36: mark(V1,Out)->  mark(V1',Out')
                  [V1>=1,V1=V1'+1,Out'=2,Out=0] 
* Loop 37: mark(V1,Out) [V1>=Out+2,Out>=1] 
* Loop 38: mark(A,A) [A>=1] 
* Loop 39: mark(V1,Out) [V1>=3,Out=3] 
* Loop 40: mark(V1,Out) [V1>=1,Out=1] 
* Loop 41: mark(V1,Out) [Out=3,V1=1] 
* Loop 42: mark(V1,Out) [Out=0,V1=0] 

### Ranking functions of CR mark(V1,Out) 
* RF of phase [30,31,32,33,34,35,36]: [V1]

#### Partial ranking functions of CR mark(V1,Out) 
* Partial RF of phase [30,31,32,33,34,35,36]:
  - RF of loop [30:1,30:2,31:1,31:2,32:1,32:2,33:1,34:1,35:1,36:1]:
    V1


### Resulting Chains:mark(V1,Out) 
* [42]
* [41]
* [40]
* [39]
* [38]
* [37]
* [multiple([30,31,32,33,34,35,36],[[42],[41],[40],[39],[38],[37]])]


### Merging Chains  mark/2 into  External patterns of execution 
* [[42]] --> 1 
* [[37],[41],[multiple([30,31,32,33,34,35,36],[[42],[41],[40],[39],[38],[37]])]] --> 2 
* [[40]] --> 3 
* [[39]] --> 4 
* [[38]] --> 5 


### Specialization of cost equations start/2 
* CE 2 is refined into CE [52,53,54,55,56] 
* CE 3 is refined into CE [57,58] 
* CE 4 is refined into CE [59,60,61] 
* CE 5 is refined into CE [62,63,64] 
* CE 6 is refined into CE [65,66,67,68,69] 


#### Refined cost equations start/2 
* CE 52: start(V1,V) = 0+ fun(W1,X1,Y1):1
     [Y1=3,X1=0,W1=0,V=0,V1=0] 
* CE 53: start(V1,V) = 0+ fun(V1,V,W1):2
     [V>=0,V1>=0,W1=1] 
* CE 54: start(A,A) = 0+ fun(A,A,B):3
     [A>=1,B=3] 
* CE 55: start(V1,V) = 0+ fun(V1,W1,X1):4
     [X1>=V1+1,V1>=0,X1=V1+W1+1,X1=V1+V+1] 
* CE 56: start(V1,V) = 0+ fun(V1,V,W1):5
     [V1+V>=W1+1,V1+W1>=V+1,V+W1>=V1+1] 
* CE 57: start(V1,V) = 0+ fun1(W1,X1):1
     [X1>=1,X1=W1+1,X1=V1+1] 
* CE 58: start(V1,V) = 0+ fun1(W1,X1):2
     [X1>=3,X1=2*W1+3,X1=2*V1+3] 
* CE 59: start(V1,V) = 0+ fun2(W1,V,X1):1
     [V>=0,X1=2,W1=0,V1=0] 
* CE 60: start(V1,V) = 0+ fun2(V1,W1,X1):2
     [X1>=V1+1,V1>=0,X1=V1+W1+1,X1=V1+V+1] 
* CE 61: start(V1,V) = 0+ fun2(V1,W1,X1):3
     [X1>=V1+1,V1>=1,X1=V1+W1,X1=V1+V] 
* CE 62: start(V1,V) = 0+ fun3(W1,X1):1
     [X1=0,W1=2,V1=2] 
* CE 63: start(V1,V) = 0+ fun3(W1,X1):2
     [X1>=1,X1=W1+1,X1=V1+1] 
* CE 64: start(V1,V) = 0+ fun3(V1,W1):3
     [V1+1>=W1,W1>=2] 
* CE 65: start(V1,V) = 0+ mark(W1,X1):1
     [X1=0,W1=0,V1=0] 
* CE 66: start(V1,V) = 0+ mark(V1,W1):2
     [W1>=0,V1>=1] 
* CE 67: start(V1,V) = 0+ mark(V1,W1):3
     [V1>=1,W1=1] 
* CE 68: start(V1,V) = 0+ mark(V1,W1):4
     [V1>=3,W1=3] 
* CE 69: start(V1,V) = 0+ mark(V1,V1):5
     [V1>=1] 

### Cost equations --> "Loop" of start/2 
* CEs [54] --> Loop 43 
* CEs [62] --> Loop 44 
* CEs [52,53,55,56,57,58,59,60,61,63,64,65,66,67,68,69] --> Loop 45 

#### Loops of start/2 
* Loop 43: start(A,A) [A>=1] 
* Loop 44: start(V1,V) [V1=2] 
* Loop 45: start(V1,V) [V1>=0] 

### Ranking functions of CR start(V1,V) 

#### Partial ranking functions of CR start(V1,V) 


### Resulting Chains:start(V1,V) 
* [45]
* [44]
* [43]


### Merging Chains  start/2 into  External patterns of execution 
* [[44],[45]] --> 1 
* [[43]] --> 2 


Computing Bounds
=====================================

#### Cost of loops [18] 

 * loop 18:fun(V1,V,Out) -> [fun(V1',V',Out')] 
1
#### Cost of phase [18]:fun(V1,V,Out) -> [fun(V1',V',Out')] 
1*it(18)+0
  Such that:it(18) =< V1
it(18) =< V1-V1'
it(18) =< V
it(18) =< V-V'

#### Cost of phase [18]:fun(V1,V,Out) -> [fun(V1',V',Out')] 
1*it(18)+0
  Such that:it(18) =< V1
it(18) =< V1-V1'
it(18) =< V
it(18) =< V-V'

#### Cost of phase [18]:fun(V1,V,Out) -> [fun(V1',V',Out')] 
1*it(18)+0
  Such that:it(18) =< V1
it(18) =< V1-V1'
it(18) =< V
it(18) =< V-V'

#### Cost of chains of fun(V1,V,Out):
* Chain [[18],21]: 1*it(18)+1
  Such that:it(18) =< V1

  with precondition: [Out=3,V1=V,V1>=1] 

* Chain [[18],20]: 1*it(18)+1
  Such that:it(18) =< V

  with precondition: [Out=1,V1>=1,V>=1] 

* Chain [[18],19]: 1*it(18)+1
  Such that:it(18) =< V1/2+V/2-Out/2+1/2

  with precondition: [Out+V>=V1+1,Out+V1>=V+1,V+V1>=Out+1] 

* Chain [21]: 1
  with precondition: [V1=0,V=0,Out=3] 

* Chain [20]: 1
  with precondition: [Out=1,V1>=0,V>=0] 

* Chain [19]: 1
  with precondition: [V+V1+1=Out,V1>=0,V>=0] 


#### Cost of chains of fun1(V1,Out):
* Chain [23]: 1
  with precondition: [V1+1=Out,V1>=0] 

* Chain [22]: 1
  with precondition: [2*V1+3=Out,V1>=0] 


#### Cost of chains of fun2(V1,V,Out):
* Chain [26]: 1
  with precondition: [V1=0,Out=2,V>=0] 

* Chain [25]: 1
  with precondition: [V+V1+1=Out,V1>=0,V>=0] 

* Chain [24]: 1
  with precondition: [V+V1=Out,V1>=1,V>=1] 


#### Cost of chains of fun3(V1,Out):
* Chain [29]: 1
  with precondition: [V1=2,Out=0] 

* Chain [28]: 1
  with precondition: [V1+1=Out,V1>=0] 

* Chain [27]: 1
  with precondition: [Out>=2,V1+1>=Out] 


#### Cost of loops [30,31,32,33,34,35,36] 

 * loop 30:mark(V1,Out) -> [mark(V1',Out'),mark(V1'2,Out'2)] 
2
 * loop 31:mark(V1,Out) -> [mark(V1',Out'),mark(V1'2,Out'2)] 
2
 * loop 32:mark(V1,Out) -> [mark(V1',Out'),mark(V1'2,Out'2)] 
2
 * loop 33:mark(V1,Out) -> [mark(V1',Out')] 
2
 * loop 34:mark(V1,Out) -> [mark(V1',Out')] 
2
 * loop 35:mark(V1,Out) -> [mark(V1',Out')] 
2
 * loop 36:mark(V1,Out) -> [mark(V1',Out')] 
2
#### Cost of phase [30,31,32,33,34,35,36]:mark(V1,Out) -> [] 
14*it(30)+2*it([37])+4*it([38])+2*it([39])+2*it([41])+2*it([42])+2*s(6)+0
  Such that:aux(1) =< V1
aux(2) =< V1+1
aux(3) =< V1/2+1/2
aux(4) =< V1/4+1/4
it(30) =< aux(1)
it([37]) =< aux(1)
it([38]) =< aux(1)
it([39]) =< aux(1)
it([41]) =< aux(1)
it([41]) =< aux(2)
it([42]) =< aux(2)
it([38]) =< aux(3)
it([39]) =< aux(3)
it([41]) =< aux(3)
s(6) =< aux(3)
it([37]) =< aux(4)
it([39]) =< aux(4)

#### Cost of chains of mark(V1,Out):
* Chain [42]: 1
  with precondition: [V1=0,Out=0] 

* Chain [41]: 2
  with precondition: [V1=1,Out=3] 

* Chain [40]: 1*s(2)+2
  Such that:s(2) =< V1

  with precondition: [Out=1,V1>=1] 

* Chain [39]: 1*s(3)+2
  Such that:s(3) =< V1/2

  with precondition: [Out=3,V1>=3] 

* Chain [38]: 2
  with precondition: [V1=Out,V1>=1] 

* Chain [37]: 1*s(4)+2
  Such that:s(4) =< V1/2

  with precondition: [Out>=1,V1>=Out+2] 

* Chain [multiple([30,31,32,33,34,35,36],[[42],[41],[40],[39],[38],[37]])]: 14*it(30)+2*it([37])+4*it([38])+2*it([39])+2*it([41])+2*it([42])+2*s(6)+0
  Such that:aux(1) =< V1
aux(2) =< V1+1
aux(3) =< V1/2+1/2
aux(4) =< V1/4+1/4
it(30) =< aux(1)
it([37]) =< aux(1)
it([38]) =< aux(1)
it([39]) =< aux(1)
it([41]) =< aux(1)
it([41]) =< aux(2)
it([42]) =< aux(2)
it([38]) =< aux(3)
it([39]) =< aux(3)
it([41]) =< aux(3)
s(6) =< aux(3)
it([37]) =< aux(4)
it([39]) =< aux(4)

  with precondition: [V1>=1,Out>=0] 


#### Cost of chains of start(V1,V):
* Chain [45]: 2*s(20)+2*s(24)+15*s(27)+2*s(28)+4*s(29)+2*s(30)+2*s(31)+2*s(32)+2*s(33)+2
  Such that:s(23) =< V1+1
s(25) =< V1/2+1/2
s(26) =< V1/4+1/4
aux(5) =< V1
aux(6) =< V1/2
aux(7) =< V
s(27) =< aux(5)
s(24) =< aux(6)
s(20) =< aux(7)
s(28) =< aux(5)
s(29) =< aux(5)
s(30) =< aux(5)
s(31) =< aux(5)
s(31) =< s(23)
s(32) =< s(23)
s(29) =< s(25)
s(30) =< s(25)
s(31) =< s(25)
s(33) =< s(25)
s(28) =< s(26)
s(30) =< s(26)

  with precondition: [V1>=0] 

* Chain [44]: 1
  with precondition: [V1=2] 

* Chain [43]: 1*s(36)+1
  Such that:s(36) =< V

  with precondition: [V1=V,V1>=1] 


Closed-form bounds of start(V1,V): 
-------------------------------------
* Chain [45] with precondition: [V1>=0] 
    - Upper bound: 25*V1+2+nat(V)*2+ (2*V1+2)+ (V1+1)+V1 
    - Complexity: n 
* Chain [44] with precondition: [V1=2] 
    - Upper bound: 1 
    - Complexity: constant 
* Chain [43] with precondition: [V1=V,V1>=1] 
    - Upper bound: V+1 
    - Complexity: n 

### Maximum cost of start(V1,V): 25*V1+1+nat(V)+ (2*V1+2)+ (V1+1)+V1+nat(V)+1 
Asymptotic class: n 

Time statistics: 
-------------------------------------
* Partial evaluation computed in 14 ms.
* Invariants computed in 38 ms.
   - Backward Invariants 16 ms.
   - Transitive Invariants 9 ms.
* Refinement performed in 79 ms.
* Termination proved in 7 ms.
* Upper bounds computed in 106 ms.
   - Equation cost structures 27 ms.
   - Phase cost structures 68 ms.
   - Chain cost structures 9 ms.
   - Solving cost expressions 2 ms.
* Total analysis performed in 271 ms.

