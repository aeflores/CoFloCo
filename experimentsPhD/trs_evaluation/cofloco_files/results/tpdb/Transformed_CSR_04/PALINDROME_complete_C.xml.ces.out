
Preprocessing Cost Relations
=====================================

#### Computed strongly connected components 
0. recursive  : [and/3]
1. recursive  : [fun/3]
2. recursive  : [fun1/2]
3. recursive  : [fun10/2]
4. recursive  : [fun11/3]
5. recursive  : [fun12/2]
6. recursive  : [fun13/3]
7. recursive  : [fun14/4]
8. recursive  : [fun15/3]
9. recursive  : [fun16/3]
10. recursive  : [fun17/4]
11. recursive  : [fun2/3]
12. recursive  : [fun3/2]
13. recursive  : [fun4/2]
14. recursive  : [fun5/3]
15. recursive  : [fun6/4]
16. recursive  : [fun7/3]
17. recursive  : [fun8/2]
18. recursive  : [fun9/2]
19. recursive  : [isList/2]
20. recursive  : [isNeList/2]
21. recursive  : [isNePal/2]
22. recursive  : [isPal/2]
23. recursive  : [isPalListKind/2]
24. recursive  : [isQid/2]
25. non_recursive  : [proper/2]
26. recursive  : [top/2]
27. non_recursive  : [start/3]

#### Obtained direct recursion through partial evaluation 
0. SCC is partially evaluated into and/3
1. SCC is partially evaluated into fun/3
2. SCC is partially evaluated into fun1/2
3. SCC is partially evaluated into fun10/2
4. SCC is partially evaluated into fun11/3
5. SCC is partially evaluated into fun12/2
6. SCC is partially evaluated into fun13/3
7. SCC is partially evaluated into fun14/4
8. SCC is partially evaluated into fun15/3
9. SCC is partially evaluated into fun16/3
10. SCC is partially evaluated into fun17/4
11. SCC is partially evaluated into fun2/3
12. SCC is partially evaluated into fun3/2
13. SCC is partially evaluated into fun4/2
14. SCC is partially evaluated into fun5/3
15. SCC is partially evaluated into fun6/4
16. SCC is partially evaluated into fun7/3
17. SCC is partially evaluated into fun8/2
18. SCC is partially evaluated into fun9/2
19. SCC is partially evaluated into isList/2
20. SCC is partially evaluated into isNeList/2
21. SCC is partially evaluated into isNePal/2
22. SCC is partially evaluated into isPal/2
23. SCC is partially evaluated into isPalListKind/2
24. SCC is partially evaluated into isQid/2
25. SCC is partially evaluated into proper/2
26. SCC is partially evaluated into top/2
27. SCC is partially evaluated into start/3

Control-Flow Refinement of Cost Relations
=====================================

### Specialization of cost equations and/3 
* CE 52 is refined into CE [103] 
* CE 51 is refined into CE [104] 
* CE 50 is refined into CE [105] 


#### Refined cost equations and/3 
* CE 103: and(V1,V,Out) = 0
     [V>=0,V1>=0,Out=0] 
* CE 104: and(V1,V,Out) = 1+ and(W1,V,X1)
     [W1>=0,V>=0,X1+1=Out,W1+1=V1] 
* CE 105: and(V1,V,Out) = 1+ and(W1,X1,Y1)
     [X1>=0,W1>=0,Y1+1=Out,X1+1=V,W1+1=V1] 

### Cost equations --> "Loop" of and/3 
* CEs [104] --> Loop 75 
* CEs [105] --> Loop 76 
* CEs [103] --> Loop 77 

#### Loops of and/3 
* Loop 75: and(V1,V,Out)->  and(V1',V,Out')
                  [V>=0,V1>=1,Out=Out'+1,V1=V1'+1] 
* Loop 76: and(V1,V,Out)->  and(V1',V',Out')
                  [V>=1,V1>=1,Out=Out'+1,V=V'+1,V1=V1'+1] 
* Loop 77: and(V1,V,Out) [V>=0,V1>=0,Out=0] 

### Ranking functions of CR and(V1,V,Out) 
* RF of phase [75,76]: [V1]

#### Partial ranking functions of CR and(V1,V,Out) 
* Partial RF of phase [75,76]:
  - RF of loop [75:1,76:1]:
    V1
  - RF of loop [76:1]:
    V


### Resulting Chains:and(V1,V,Out) 
* [[75,76],77]
* [77]


### Merging Chains  and/3 into  External patterns of execution 
* [[77]] --> 1 
* [[77,[75,76]]] --> 2 


### Specialization of cost equations fun/3 
* CE 31 is refined into CE [106] 
* CE 30 is refined into CE [107] 
* CE 29 is refined into CE [108] 


#### Refined cost equations fun/3 
* CE 106: fun(V1,V,Out) = 0
     [V>=0,V1>=0,Out=0] 
* CE 107: fun(V1,V,Out) = 1+ fun(W1,V,X1)
     [W1>=0,V>=0,X1+1=Out,W1+1=V1] 
* CE 108: fun(V1,V,Out) = 1+ fun(W1,X1,Y1)
     [X1>=0,W1>=0,Y1+1=Out,X1+1=V,W1+1=V1] 

### Cost equations --> "Loop" of fun/3 
* CEs [107] --> Loop 78 
* CEs [108] --> Loop 79 
* CEs [106] --> Loop 80 

#### Loops of fun/3 
* Loop 78: fun(V1,V,Out)->  fun(V1',V,Out')
                  [V>=0,V1>=1,Out=Out'+1,V1=V1'+1] 
* Loop 79: fun(V1,V,Out)->  fun(V1',V',Out')
                  [V>=1,V1>=1,Out=Out'+1,V=V'+1,V1=V1'+1] 
* Loop 80: fun(V1,V,Out) [V>=0,V1>=0,Out=0] 

### Ranking functions of CR fun(V1,V,Out) 
* RF of phase [78,79]: [V1]

#### Partial ranking functions of CR fun(V1,V,Out) 
* Partial RF of phase [78,79]:
  - RF of loop [78:1,79:1]:
    V1
  - RF of loop [79:1]:
    V


### Resulting Chains:fun(V1,V,Out) 
* [[78,79],80]
* [80]


### Merging Chains  fun/3 into  External patterns of execution 
* [[80]] --> 1 
* [[80,[78,79]]] --> 2 


### Specialization of cost equations fun1/2 
* CE 38 is refined into CE [109] 
* CE 37 is refined into CE [110] 


#### Refined cost equations fun1/2 
* CE 109: fun1(V1,Out) = 0
     [V1>=0,Out=0] 
* CE 110: fun1(V1,Out) = 1+ fun1(W1,X1)
     [W1>=0,X1+1=Out,W1+1=V1] 

### Cost equations --> "Loop" of fun1/2 
* CEs [110] --> Loop 81 
* CEs [109] --> Loop 82 

#### Loops of fun1/2 
* Loop 81: fun1(V1,Out)->  fun1(V1',Out')
                  [V1'>=0,Out=Out'+1,V1'+1=V1] 
* Loop 82: fun1(V1,Out) [V1>=0,Out=0] 

### Ranking functions of CR fun1(V1,Out) 
* RF of phase [81]: [V1]

#### Partial ranking functions of CR fun1(V1,Out) 
* Partial RF of phase [81]:
  - RF of loop [81:1]:
    V1


### Resulting Chains:fun1(V1,Out) 
* [[81],82]
* [82]


### Merging Chains  fun1/2 into  External patterns of execution 
* [[82]] --> 1 
* [[82,[81]]] --> 2 


### Specialization of cost equations fun10/2 
* CE 74 is refined into CE [111] 
* CE 73 is refined into CE [112] 


#### Refined cost equations fun10/2 
* CE 111: fun10(V1,Out) = 0
     [V1>=0,Out=0] 
* CE 112: fun10(V1,Out) = 1+ fun10(W1,X1)
     [W1>=0,X1+1=Out,W1+1=V1] 

### Cost equations --> "Loop" of fun10/2 
* CEs [112] --> Loop 83 
* CEs [111] --> Loop 84 

#### Loops of fun10/2 
* Loop 83: fun10(V1,Out)->  fun10(V1',Out')
                  [V1'>=0,Out=Out'+1,V1'+1=V1] 
* Loop 84: fun10(V1,Out) [V1>=0,Out=0] 

### Ranking functions of CR fun10(V1,Out) 
* RF of phase [83]: [V1]

#### Partial ranking functions of CR fun10(V1,Out) 
* Partial RF of phase [83]:
  - RF of loop [83:1]:
    V1


### Resulting Chains:fun10(V1,Out) 
* [[83],84]
* [84]


### Merging Chains  fun10/2 into  External patterns of execution 
* [[84]] --> 1 
* [[84,[83]]] --> 2 


### Specialization of cost equations fun11/3 
* CE 77 is refined into CE [113] 
* CE 76 is refined into CE [114] 
* CE 75 is refined into CE [115] 


#### Refined cost equations fun11/3 
* CE 113: fun11(V1,V,Out) = 0
     [V>=0,V1>=0,Out=0] 
* CE 114: fun11(V1,V,Out) = 1+ fun11(W1,V,X1)
     [W1>=0,V>=0,X1+1=Out,W1+1=V1] 
* CE 115: fun11(V1,V,Out) = 1+ fun11(W1,X1,Y1)
     [X1>=0,W1>=0,Y1+1=Out,X1+1=V,W1+1=V1] 

### Cost equations --> "Loop" of fun11/3 
* CEs [114] --> Loop 85 
* CEs [115] --> Loop 86 
* CEs [113] --> Loop 87 

#### Loops of fun11/3 
* Loop 85: fun11(V1,V,Out)->  fun11(V1',V,Out')
                  [V>=0,V1>=1,Out=Out'+1,V1=V1'+1] 
* Loop 86: fun11(V1,V,Out)->  fun11(V1',V',Out')
                  [V>=1,V1>=1,Out=Out'+1,V=V'+1,V1=V1'+1] 
* Loop 87: fun11(V1,V,Out) [V>=0,V1>=0,Out=0] 

### Ranking functions of CR fun11(V1,V,Out) 
* RF of phase [85,86]: [V1]

#### Partial ranking functions of CR fun11(V1,V,Out) 
* Partial RF of phase [85,86]:
  - RF of loop [85:1,86:1]:
    V1
  - RF of loop [86:1]:
    V


### Resulting Chains:fun11(V1,V,Out) 
* [[85,86],87]
* [87]


### Merging Chains  fun11/3 into  External patterns of execution 
* [[87]] --> 1 
* [[87,[85,86]]] --> 2 


### Specialization of cost equations fun12/2 
* CE 79 is refined into CE [116] 
* CE 78 is refined into CE [117] 


#### Refined cost equations fun12/2 
* CE 116: fun12(V1,Out) = 0
     [V1>=0,Out=0] 
* CE 117: fun12(V1,Out) = 1+ fun12(W1,X1)
     [W1>=0,X1+1=Out,W1+1=V1] 

### Cost equations --> "Loop" of fun12/2 
* CEs [117] --> Loop 88 
* CEs [116] --> Loop 89 

#### Loops of fun12/2 
* Loop 88: fun12(V1,Out)->  fun12(V1',Out')
                  [V1'>=0,Out=Out'+1,V1'+1=V1] 
* Loop 89: fun12(V1,Out) [V1>=0,Out=0] 

### Ranking functions of CR fun12(V1,Out) 
* RF of phase [88]: [V1]

#### Partial ranking functions of CR fun12(V1,Out) 
* Partial RF of phase [88]:
  - RF of loop [88:1]:
    V1


### Resulting Chains:fun12(V1,Out) 
* [[88],89]
* [89]


### Merging Chains  fun12/2 into  External patterns of execution 
* [[89]] --> 1 
* [[89,[88]]] --> 2 


### Specialization of cost equations fun13/3 
* CE 82 is refined into CE [118] 
* CE 81 is refined into CE [119] 
* CE 80 is refined into CE [120] 


#### Refined cost equations fun13/3 
* CE 118: fun13(V1,V,Out) = 0
     [V>=0,V1>=0,Out=0] 
* CE 119: fun13(V1,V,Out) = 1+ fun13(W1,V,X1)
     [W1>=0,V>=0,X1+1=Out,W1+1=V1] 
* CE 120: fun13(V1,V,Out) = 1+ fun13(W1,X1,Y1)
     [X1>=0,W1>=0,Y1+1=Out,X1+1=V,W1+1=V1] 

### Cost equations --> "Loop" of fun13/3 
* CEs [119] --> Loop 90 
* CEs [120] --> Loop 91 
* CEs [118] --> Loop 92 

#### Loops of fun13/3 
* Loop 90: fun13(V1,V,Out)->  fun13(V1',V,Out')
                  [V>=0,V1>=1,Out=Out'+1,V1=V1'+1] 
* Loop 91: fun13(V1,V,Out)->  fun13(V1',V',Out')
                  [V>=1,V1>=1,Out=Out'+1,V=V'+1,V1=V1'+1] 
* Loop 92: fun13(V1,V,Out) [V>=0,V1>=0,Out=0] 

### Ranking functions of CR fun13(V1,V,Out) 
* RF of phase [90,91]: [V1]

#### Partial ranking functions of CR fun13(V1,V,Out) 
* Partial RF of phase [90,91]:
  - RF of loop [90:1,91:1]:
    V1
  - RF of loop [91:1]:
    V


### Resulting Chains:fun13(V1,V,Out) 
* [[90,91],92]
* [92]


### Merging Chains  fun13/3 into  External patterns of execution 
* [[92]] --> 1 
* [[92,[90,91]]] --> 2 


### Specialization of cost equations fun14/4 
* CE 85 is refined into CE [121] 
* CE 84 is refined into CE [122] 
* CE 83 is refined into CE [123] 


#### Refined cost equations fun14/4 
* CE 121: fun14(V1,V,V2,Out) = 0
     [V2>=0,V>=0,V1>=0,Out=0] 
* CE 122: fun14(V1,V,V2,Out) = 1+ fun14(W2,V,V2,X2)
     [W2>=0,V2>=0,V>=0,X2+1=Out,W2+1=V1] 
* CE 123: fun14(V1,V,V2,Out) = 1+ fun14(W2,X2,Y2,Z2)
     [Y2>=0,X2>=0,W2>=0,Z2+1=Out,Y2+1=V2,X2+1=V,W2+1=V1] 

### Cost equations --> "Loop" of fun14/4 
* CEs [122] --> Loop 93 
* CEs [123] --> Loop 94 
* CEs [121] --> Loop 95 

#### Loops of fun14/4 
* Loop 93: fun14(V1,V,V2,Out)->  fun14(V1',V,V2,Out')
                  [V2>=0,V>=0,V1>=1,Out=Out'+1,V1=V1'+1] 
* Loop 94: fun14(V1,V,V2,Out)->  fun14(V1',V',V2',Out')
                  [V2>=1,V>=1,V1>=1,Out=Out'+1,V2=V2'+1,V=V'+1,V1=V1'+1] 
* Loop 95: fun14(V1,V,V2,Out) [V2>=0,V>=0,V1>=0,Out=0] 

### Ranking functions of CR fun14(V1,V,V2,Out) 
* RF of phase [93,94]: [V1]

#### Partial ranking functions of CR fun14(V1,V,V2,Out) 
* Partial RF of phase [93,94]:
  - RF of loop [93:1,94:1]:
    V1
  - RF of loop [94:1]:
    V
    V2


### Resulting Chains:fun14(V1,V,V2,Out) 
* [[93,94],95]
* [95]


### Merging Chains  fun14/4 into  External patterns of execution 
* [[95]] --> 1 
* [[95,[93,94]]] --> 2 


### Specialization of cost equations fun15/3 
* CE 88 is refined into CE [124] 
* CE 87 is refined into CE [125] 
* CE 86 is refined into CE [126] 


#### Refined cost equations fun15/3 
* CE 124: fun15(V1,V,Out) = 0
     [V>=0,V1>=0,Out=0] 
* CE 125: fun15(V1,V,Out) = 1+ fun15(W1,V,X1)
     [W1>=0,V>=0,X1+1=Out,W1+1=V1] 
* CE 126: fun15(V1,V,Out) = 1+ fun15(W1,X1,Y1)
     [X1>=0,W1>=0,Y1+1=Out,X1+1=V,W1+1=V1] 

### Cost equations --> "Loop" of fun15/3 
* CEs [125] --> Loop 96 
* CEs [126] --> Loop 97 
* CEs [124] --> Loop 98 

#### Loops of fun15/3 
* Loop 96: fun15(V1,V,Out)->  fun15(V1',V,Out')
                  [V>=0,V1>=1,Out=Out'+1,V1=V1'+1] 
* Loop 97: fun15(V1,V,Out)->  fun15(V1',V',Out')
                  [V>=1,V1>=1,Out=Out'+1,V=V'+1,V1=V1'+1] 
* Loop 98: fun15(V1,V,Out) [V>=0,V1>=0,Out=0] 

### Ranking functions of CR fun15(V1,V,Out) 
* RF of phase [96,97]: [V1]

#### Partial ranking functions of CR fun15(V1,V,Out) 
* Partial RF of phase [96,97]:
  - RF of loop [96:1,97:1]:
    V1
  - RF of loop [97:1]:
    V


### Resulting Chains:fun15(V1,V,Out) 
* [[96,97],98]
* [98]


### Merging Chains  fun15/3 into  External patterns of execution 
* [[98]] --> 1 
* [[98,[96,97]]] --> 2 


### Specialization of cost equations fun16/3 
* CE 95 is refined into CE [127] 
* CE 93 is refined into CE [128] 
* CE 94 is refined into CE [129] 


#### Refined cost equations fun16/3 
* CE 127: fun16(V1,V,Out) = 0
     [V>=0,V1>=0,Out=0] 
* CE 128: fun16(V1,V,Out) = 1+ fun16(W1,V,X1)
     [W1>=0,V>=0,X1+1=Out,W1+1=V1] 
* CE 129: fun16(V1,V,Out) = 1+ fun16(W1,X1,Y1)
     [X1>=0,W1>=0,Y1+1=Out,X1+1=V,W1+1=V1] 

### Cost equations --> "Loop" of fun16/3 
* CEs [128] --> Loop 99 
* CEs [129] --> Loop 100 
* CEs [127] --> Loop 101 

#### Loops of fun16/3 
* Loop 99: fun16(V1,V,Out)->  fun16(V1',V,Out')
                  [V>=0,V1>=1,Out=Out'+1,V1=V1'+1] 
* Loop 100: fun16(V1,V,Out)->  fun16(V1',V',Out')
                  [V>=1,V1>=1,Out=Out'+1,V=V'+1,V1=V1'+1] 
* Loop 101: fun16(V1,V,Out) [V>=0,V1>=0,Out=0] 

### Ranking functions of CR fun16(V1,V,Out) 
* RF of phase [99,100]: [V1]

#### Partial ranking functions of CR fun16(V1,V,Out) 
* Partial RF of phase [99,100]:
  - RF of loop [99:1,100:1]:
    V1
  - RF of loop [100:1]:
    V


### Resulting Chains:fun16(V1,V,Out) 
* [[99,100],101]
* [101]


### Merging Chains  fun16/3 into  External patterns of execution 
* [[101]] --> 1 
* [[101,[99,100]]] --> 2 


### Specialization of cost equations fun17/4 
* CE 102 is refined into CE [130] 
* CE 100 is refined into CE [131] 
* CE 101 is refined into CE [132] 


#### Refined cost equations fun17/4 
* CE 130: fun17(V1,V,V2,Out) = 0
     [V2>=0,V>=0,V1>=0,Out=0] 
* CE 131: fun17(V1,V,V2,Out) = 1+ fun17(W2,V,V2,X2)
     [W2>=0,V2>=0,V>=0,X2+1=Out,W2+1=V1] 
* CE 132: fun17(V1,V,V2,Out) = 1+ fun17(W2,X2,Y2,Z2)
     [Y2>=0,X2>=0,W2>=0,Z2+1=Out,Y2+1=V2,X2+1=V,W2+1=V1] 

### Cost equations --> "Loop" of fun17/4 
* CEs [131] --> Loop 102 
* CEs [132] --> Loop 103 
* CEs [130] --> Loop 104 

#### Loops of fun17/4 
* Loop 102: fun17(V1,V,V2,Out)->  fun17(V1',V,V2,Out')
                  [V2>=0,V>=0,V1>=1,Out=Out'+1,V1=V1'+1] 
* Loop 103: fun17(V1,V,V2,Out)->  fun17(V1',V',V2',Out')
                  [V2>=1,V>=1,V1>=1,Out=Out'+1,V2=V2'+1,V=V'+1,V1=V1'+1] 
* Loop 104: fun17(V1,V,V2,Out) [V2>=0,V>=0,V1>=0,Out=0] 

### Ranking functions of CR fun17(V1,V,V2,Out) 
* RF of phase [102,103]: [V1]

#### Partial ranking functions of CR fun17(V1,V,V2,Out) 
* Partial RF of phase [102,103]:
  - RF of loop [102:1,103:1]:
    V1
  - RF of loop [103:1]:
    V
    V2


### Resulting Chains:fun17(V1,V,V2,Out) 
* [[102,103],104]
* [104]


### Merging Chains  fun17/4 into  External patterns of execution 
* [[104]] --> 1 
* [[104,[102,103]]] --> 2 


### Specialization of cost equations fun2/3 
* CE 41 is refined into CE [133] 
* CE 40 is refined into CE [134] 
* CE 39 is refined into CE [135] 


#### Refined cost equations fun2/3 
* CE 133: fun2(V1,V,Out) = 0
     [V>=0,V1>=0,Out=0] 
* CE 134: fun2(V1,V,Out) = 1+ fun2(W1,V,X1)
     [W1>=0,V>=0,X1+1=Out,W1+1=V1] 
* CE 135: fun2(V1,V,Out) = 1+ fun2(W1,X1,Y1)
     [X1>=0,W1>=0,Y1+1=Out,X1+1=V,W1+1=V1] 

### Cost equations --> "Loop" of fun2/3 
* CEs [134] --> Loop 105 
* CEs [135] --> Loop 106 
* CEs [133] --> Loop 107 

#### Loops of fun2/3 
* Loop 105: fun2(V1,V,Out)->  fun2(V1',V,Out')
                  [V>=0,V1>=1,Out=Out'+1,V1=V1'+1] 
* Loop 106: fun2(V1,V,Out)->  fun2(V1',V',Out')
                  [V>=1,V1>=1,Out=Out'+1,V=V'+1,V1=V1'+1] 
* Loop 107: fun2(V1,V,Out) [V>=0,V1>=0,Out=0] 

### Ranking functions of CR fun2(V1,V,Out) 
* RF of phase [105,106]: [V1]

#### Partial ranking functions of CR fun2(V1,V,Out) 
* Partial RF of phase [105,106]:
  - RF of loop [105:1,106:1]:
    V1
  - RF of loop [106:1]:
    V


### Resulting Chains:fun2(V1,V,Out) 
* [[105,106],107]
* [107]


### Merging Chains  fun2/3 into  External patterns of execution 
* [[107]] --> 1 
* [[107,[105,106]]] --> 2 


### Specialization of cost equations fun3/2 
* CE 54 is refined into CE [136] 
* CE 53 is refined into CE [137] 


#### Refined cost equations fun3/2 
* CE 136: fun3(V1,Out) = 0
     [V1>=0,Out=0] 
* CE 137: fun3(V1,Out) = 1+ fun3(W1,X1)
     [W1>=0,X1+1=Out,W1+1=V1] 

### Cost equations --> "Loop" of fun3/2 
* CEs [137] --> Loop 108 
* CEs [136] --> Loop 109 

#### Loops of fun3/2 
* Loop 108: fun3(V1,Out)->  fun3(V1',Out')
                  [V1'>=0,Out=Out'+1,V1'+1=V1] 
* Loop 109: fun3(V1,Out) [V1>=0,Out=0] 

### Ranking functions of CR fun3(V1,Out) 
* RF of phase [108]: [V1]

#### Partial ranking functions of CR fun3(V1,Out) 
* Partial RF of phase [108]:
  - RF of loop [108:1]:
    V1


### Resulting Chains:fun3(V1,Out) 
* [[108],109]
* [109]


### Merging Chains  fun3/2 into  External patterns of execution 
* [[109]] --> 1 
* [[109,[108]]] --> 2 


### Specialization of cost equations fun4/2 
* CE 56 is refined into CE [138] 
* CE 55 is refined into CE [139] 


#### Refined cost equations fun4/2 
* CE 138: fun4(V1,Out) = 0
     [V1>=0,Out=0] 
* CE 139: fun4(V1,Out) = 1+ fun4(W1,X1)
     [W1>=0,X1+1=Out,W1+1=V1] 

### Cost equations --> "Loop" of fun4/2 
* CEs [139] --> Loop 110 
* CEs [138] --> Loop 111 

#### Loops of fun4/2 
* Loop 110: fun4(V1,Out)->  fun4(V1',Out')
                  [V1'>=0,Out=Out'+1,V1'+1=V1] 
* Loop 111: fun4(V1,Out) [V1>=0,Out=0] 

### Ranking functions of CR fun4(V1,Out) 
* RF of phase [110]: [V1]

#### Partial ranking functions of CR fun4(V1,Out) 
* Partial RF of phase [110]:
  - RF of loop [110:1]:
    V1


### Resulting Chains:fun4(V1,Out) 
* [[110],111]
* [111]


### Merging Chains  fun4/2 into  External patterns of execution 
* [[111]] --> 1 
* [[111,[110]]] --> 2 


### Specialization of cost equations fun5/3 
* CE 59 is refined into CE [140] 
* CE 58 is refined into CE [141] 
* CE 57 is refined into CE [142] 


#### Refined cost equations fun5/3 
* CE 140: fun5(V1,V,Out) = 0
     [V>=0,V1>=0,Out=0] 
* CE 141: fun5(V1,V,Out) = 1+ fun5(W1,V,X1)
     [W1>=0,V>=0,X1+1=Out,W1+1=V1] 
* CE 142: fun5(V1,V,Out) = 1+ fun5(W1,X1,Y1)
     [X1>=0,W1>=0,Y1+1=Out,X1+1=V,W1+1=V1] 

### Cost equations --> "Loop" of fun5/3 
* CEs [141] --> Loop 112 
* CEs [142] --> Loop 113 
* CEs [140] --> Loop 114 

#### Loops of fun5/3 
* Loop 112: fun5(V1,V,Out)->  fun5(V1',V,Out')
                  [V>=0,V1>=1,Out=Out'+1,V1=V1'+1] 
* Loop 113: fun5(V1,V,Out)->  fun5(V1',V',Out')
                  [V>=1,V1>=1,Out=Out'+1,V=V'+1,V1=V1'+1] 
* Loop 114: fun5(V1,V,Out) [V>=0,V1>=0,Out=0] 

### Ranking functions of CR fun5(V1,V,Out) 
* RF of phase [112,113]: [V1]

#### Partial ranking functions of CR fun5(V1,V,Out) 
* Partial RF of phase [112,113]:
  - RF of loop [112:1,113:1]:
    V1
  - RF of loop [113:1]:
    V


### Resulting Chains:fun5(V1,V,Out) 
* [[112,113],114]
* [114]


### Merging Chains  fun5/3 into  External patterns of execution 
* [[114]] --> 1 
* [[114,[112,113]]] --> 2 


### Specialization of cost equations fun6/4 
* CE 62 is refined into CE [143] 
* CE 60 is refined into CE [144] 
* CE 61 is refined into CE [145] 


#### Refined cost equations fun6/4 
* CE 143: fun6(V1,V,V2,Out) = 0
     [V2>=0,V>=0,V1>=0,Out=0] 
* CE 144: fun6(V1,V,V2,Out) = 1+ fun6(W2,V,V2,X2)
     [W2>=0,V2>=0,V>=0,X2+1=Out,W2+1=V1] 
* CE 145: fun6(V1,V,V2,Out) = 1+ fun6(W2,X2,Y2,Z2)
     [Y2>=0,X2>=0,W2>=0,Z2+1=Out,Y2+1=V2,X2+1=V,W2+1=V1] 

### Cost equations --> "Loop" of fun6/4 
* CEs [144] --> Loop 115 
* CEs [145] --> Loop 116 
* CEs [143] --> Loop 117 

#### Loops of fun6/4 
* Loop 115: fun6(V1,V,V2,Out)->  fun6(V1',V,V2,Out')
                  [V2>=0,V>=0,V1>=1,Out=Out'+1,V1=V1'+1] 
* Loop 116: fun6(V1,V,V2,Out)->  fun6(V1',V',V2',Out')
                  [V2>=1,V>=1,V1>=1,Out=Out'+1,V2=V2'+1,V=V'+1,V1=V1'+1] 
* Loop 117: fun6(V1,V,V2,Out) [V2>=0,V>=0,V1>=0,Out=0] 

### Ranking functions of CR fun6(V1,V,V2,Out) 
* RF of phase [115,116]: [V1]

#### Partial ranking functions of CR fun6(V1,V,V2,Out) 
* Partial RF of phase [115,116]:
  - RF of loop [115:1,116:1]:
    V1
  - RF of loop [116:1]:
    V
    V2


### Resulting Chains:fun6(V1,V,V2,Out) 
* [[115,116],117]
* [117]


### Merging Chains  fun6/4 into  External patterns of execution 
* [[117]] --> 1 
* [[117,[115,116]]] --> 2 


### Specialization of cost equations fun7/3 
* CE 66 is refined into CE [146] 
* CE 63 is refined into CE [147] 
* CE 64 is refined into CE [148] 
* CE 65 is refined into CE [149] 


#### Refined cost equations fun7/3 
* CE 146: fun7(V1,V,Out) = 0
     [V>=0,V1>=0,Out=0] 
* CE 147: fun7(V1,V,Out) = 1+ fun7(V1,W1,X1)
     [W1>=0,V1>=0,X1+1=Out,W1+1=V] 
* CE 148: fun7(V1,V,Out) = 1+ fun7(W1,V,X1)
     [W1>=0,V>=0,X1+1=Out,W1+1=V1] 
* CE 149: fun7(V1,V,Out) = 1+ fun7(W1,X1,Y1)
     [X1>=0,W1>=0,Y1+1=Out,X1+1=V,W1+1=V1] 

### Cost equations --> "Loop" of fun7/3 
* CEs [147] --> Loop 118 
* CEs [148] --> Loop 119 
* CEs [149] --> Loop 120 
* CEs [146] --> Loop 121 

#### Loops of fun7/3 
* Loop 118: fun7(V1,V,Out)->  fun7(V1,V',Out')
                  [V>=1,V1>=0,Out=Out'+1,V=V'+1] 
* Loop 119: fun7(V1,V,Out)->  fun7(V1',V,Out')
                  [V>=0,V1>=1,Out=Out'+1,V1=V1'+1] 
* Loop 120: fun7(V1,V,Out)->  fun7(V1',V',Out')
                  [V>=1,V1>=1,Out=Out'+1,V=V'+1,V1=V1'+1] 
* Loop 121: fun7(V1,V,Out) [V>=0,V1>=0,Out=0] 

### Ranking functions of CR fun7(V1,V,Out) 
* RF of phase [118,119,120]: [V1+V]

#### Partial ranking functions of CR fun7(V1,V,Out) 
* Partial RF of phase [118,119,120]:
  - RF of loop [118:1,120:1]:
    V
  - RF of loop [119:1,120:1]:
    V1


### Resulting Chains:fun7(V1,V,Out) 
* [[118,119,120],121]
* [121]


### Merging Chains  fun7/3 into  External patterns of execution 
* [[121]] --> 1 
* [[121,[118,119,120]]] --> 2 


### Specialization of cost equations fun8/2 
* CE 70 is refined into CE [150] 
* CE 69 is refined into CE [151] 


#### Refined cost equations fun8/2 
* CE 150: fun8(V1,Out) = 0
     [V1>=0,Out=0] 
* CE 151: fun8(V1,Out) = 1+ fun8(W1,X1)
     [W1>=0,X1+1=Out,W1+1=V1] 

### Cost equations --> "Loop" of fun8/2 
* CEs [151] --> Loop 122 
* CEs [150] --> Loop 123 

#### Loops of fun8/2 
* Loop 122: fun8(V1,Out)->  fun8(V1',Out')
                  [V1'>=0,Out=Out'+1,V1'+1=V1] 
* Loop 123: fun8(V1,Out) [V1>=0,Out=0] 

### Ranking functions of CR fun8(V1,Out) 
* RF of phase [122]: [V1]

#### Partial ranking functions of CR fun8(V1,Out) 
* Partial RF of phase [122]:
  - RF of loop [122:1]:
    V1


### Resulting Chains:fun8(V1,Out) 
* [[122],123]
* [123]


### Merging Chains  fun8/2 into  External patterns of execution 
* [[123]] --> 1 
* [[123,[122]]] --> 2 


### Specialization of cost equations fun9/2 
* CE 72 is refined into CE [152] 
* CE 71 is refined into CE [153] 


#### Refined cost equations fun9/2 
* CE 152: fun9(V1,Out) = 0
     [V1>=0,Out=0] 
* CE 153: fun9(V1,Out) = 1+ fun9(W1,X1)
     [W1>=0,X1+1=Out,W1+1=V1] 

### Cost equations --> "Loop" of fun9/2 
* CEs [153] --> Loop 124 
* CEs [152] --> Loop 125 

#### Loops of fun9/2 
* Loop 124: fun9(V1,Out)->  fun9(V1',Out')
                  [V1'>=0,Out=Out'+1,V1'+1=V1] 
* Loop 125: fun9(V1,Out) [V1>=0,Out=0] 

### Ranking functions of CR fun9(V1,Out) 
* RF of phase [124]: [V1]

#### Partial ranking functions of CR fun9(V1,Out) 
* Partial RF of phase [124]:
  - RF of loop [124:1]:
    V1


### Resulting Chains:fun9(V1,Out) 
* [[124],125]
* [125]


### Merging Chains  fun9/2 into  External patterns of execution 
* [[125]] --> 1 
* [[125,[124]]] --> 2 


### Specialization of cost equations isList/2 
* CE 97 is refined into CE [154] 
* CE 96 is refined into CE [155] 


#### Refined cost equations isList/2 
* CE 154: isList(V1,Out) = 0
     [V1>=0,Out=0] 
* CE 155: isList(V1,Out) = 1+ isList(W1,X1)
     [W1>=0,X1+1=Out,W1+1=V1] 

### Cost equations --> "Loop" of isList/2 
* CEs [155] --> Loop 126 
* CEs [154] --> Loop 127 

#### Loops of isList/2 
* Loop 126: isList(V1,Out)->  isList(V1',Out')
                  [V1'>=0,Out=Out'+1,V1'+1=V1] 
* Loop 127: isList(V1,Out) [V1>=0,Out=0] 

### Ranking functions of CR isList(V1,Out) 
* RF of phase [126]: [V1]

#### Partial ranking functions of CR isList(V1,Out) 
* Partial RF of phase [126]:
  - RF of loop [126:1]:
    V1


### Resulting Chains:isList(V1,Out) 
* [[126],127]
* [127]


### Merging Chains  isList/2 into  External patterns of execution 
* [[127]] --> 1 
* [[127,[126]]] --> 2 


### Specialization of cost equations isNeList/2 
* CE 36 is refined into CE [156] 
* CE 35 is refined into CE [157] 


#### Refined cost equations isNeList/2 
* CE 156: isNeList(V1,Out) = 0
     [V1>=0,Out=0] 
* CE 157: isNeList(V1,Out) = 1+ isNeList(W1,X1)
     [W1>=0,X1+1=Out,W1+1=V1] 

### Cost equations --> "Loop" of isNeList/2 
* CEs [157] --> Loop 128 
* CEs [156] --> Loop 129 

#### Loops of isNeList/2 
* Loop 128: isNeList(V1,Out)->  isNeList(V1',Out')
                  [V1'>=0,Out=Out'+1,V1'+1=V1] 
* Loop 129: isNeList(V1,Out) [V1>=0,Out=0] 

### Ranking functions of CR isNeList(V1,Out) 
* RF of phase [128]: [V1]

#### Partial ranking functions of CR isNeList(V1,Out) 
* Partial RF of phase [128]:
  - RF of loop [128:1]:
    V1


### Resulting Chains:isNeList(V1,Out) 
* [[128],129]
* [129]


### Merging Chains  isNeList/2 into  External patterns of execution 
* [[129]] --> 1 
* [[129,[128]]] --> 2 


### Specialization of cost equations isNePal/2 
* CE 92 is refined into CE [158] 
* CE 91 is refined into CE [159] 


#### Refined cost equations isNePal/2 
* CE 158: isNePal(V1,Out) = 0
     [V1>=0,Out=0] 
* CE 159: isNePal(V1,Out) = 1+ isNePal(W1,X1)
     [W1>=0,X1+1=Out,W1+1=V1] 

### Cost equations --> "Loop" of isNePal/2 
* CEs [159] --> Loop 130 
* CEs [158] --> Loop 131 

#### Loops of isNePal/2 
* Loop 130: isNePal(V1,Out)->  isNePal(V1',Out')
                  [V1'>=0,Out=Out'+1,V1'+1=V1] 
* Loop 131: isNePal(V1,Out) [V1>=0,Out=0] 

### Ranking functions of CR isNePal(V1,Out) 
* RF of phase [130]: [V1]

#### Partial ranking functions of CR isNePal(V1,Out) 
* Partial RF of phase [130]:
  - RF of loop [130:1]:
    V1


### Resulting Chains:isNePal(V1,Out) 
* [[130],131]
* [131]


### Merging Chains  isNePal/2 into  External patterns of execution 
* [[131]] --> 1 
* [[131,[130]]] --> 2 


### Specialization of cost equations isPal/2 
* CE 68 is refined into CE [160] 
* CE 67 is refined into CE [161] 


#### Refined cost equations isPal/2 
* CE 160: isPal(V1,Out) = 0
     [V1>=0,Out=0] 
* CE 161: isPal(V1,Out) = 1+ isPal(W1,X1)
     [W1>=0,X1+1=Out,W1+1=V1] 

### Cost equations --> "Loop" of isPal/2 
* CEs [161] --> Loop 132 
* CEs [160] --> Loop 133 

#### Loops of isPal/2 
* Loop 132: isPal(V1,Out)->  isPal(V1',Out')
                  [V1'>=0,Out=Out'+1,V1'+1=V1] 
* Loop 133: isPal(V1,Out) [V1>=0,Out=0] 

### Ranking functions of CR isPal(V1,Out) 
* RF of phase [132]: [V1]

#### Partial ranking functions of CR isPal(V1,Out) 
* Partial RF of phase [132]:
  - RF of loop [132:1]:
    V1


### Resulting Chains:isPal(V1,Out) 
* [[132],133]
* [133]


### Merging Chains  isPal/2 into  External patterns of execution 
* [[133]] --> 1 
* [[133,[132]]] --> 2 


### Specialization of cost equations isPalListKind/2 
* CE 99 is refined into CE [162] 
* CE 98 is refined into CE [163] 


#### Refined cost equations isPalListKind/2 
* CE 162: isPalListKind(V1,Out) = 0
     [V1>=0,Out=0] 
* CE 163: isPalListKind(V1,Out) = 1+ isPalListKind(W1,X1)
     [W1>=0,X1+1=Out,W1+1=V1] 

### Cost equations --> "Loop" of isPalListKind/2 
* CEs [163] --> Loop 134 
* CEs [162] --> Loop 135 

#### Loops of isPalListKind/2 
* Loop 134: isPalListKind(V1,Out)->  isPalListKind(V1',Out')
                  [V1'>=0,Out=Out'+1,V1'+1=V1] 
* Loop 135: isPalListKind(V1,Out) [V1>=0,Out=0] 

### Ranking functions of CR isPalListKind(V1,Out) 
* RF of phase [134]: [V1]

#### Partial ranking functions of CR isPalListKind(V1,Out) 
* Partial RF of phase [134]:
  - RF of loop [134:1]:
    V1


### Resulting Chains:isPalListKind(V1,Out) 
* [[134],135]
* [135]


### Merging Chains  isPalListKind/2 into  External patterns of execution 
* [[135]] --> 1 
* [[135,[134]]] --> 2 


### Specialization of cost equations isQid/2 
* CE 90 is refined into CE [164] 
* CE 89 is refined into CE [165] 


#### Refined cost equations isQid/2 
* CE 164: isQid(V1,Out) = 0
     [V1>=0,Out=0] 
* CE 165: isQid(V1,Out) = 1+ isQid(W1,X1)
     [W1>=0,X1+1=Out,W1+1=V1] 

### Cost equations --> "Loop" of isQid/2 
* CEs [165] --> Loop 136 
* CEs [164] --> Loop 137 

#### Loops of isQid/2 
* Loop 136: isQid(V1,Out)->  isQid(V1',Out')
                  [V1'>=0,Out=Out'+1,V1'+1=V1] 
* Loop 137: isQid(V1,Out) [V1>=0,Out=0] 

### Ranking functions of CR isQid(V1,Out) 
* RF of phase [136]: [V1]

#### Partial ranking functions of CR isQid(V1,Out) 
* Partial RF of phase [136]:
  - RF of loop [136:1]:
    V1


### Resulting Chains:isQid(V1,Out) 
* [[136],137]
* [137]


### Merging Chains  isQid/2 into  External patterns of execution 
* [[137]] --> 1 
* [[137,[136]]] --> 2 


### Specialization of cost equations proper/2 
* CE 49 is refined into CE [166] 
* CE 43 is refined into CE [167] 
* CE 45 is refined into CE [168] 
* CE 46 is refined into CE [169] 
* CE 44 is refined into CE [170] 
* CE 42 is refined into CE [171] 
* CE 47 is refined into CE [172] 
* CE 48 is refined into CE [173] 


#### Refined cost equations proper/2 
* CE 166: proper(V1,Out) = 0
     [V1>=0,Out=0] 
* CE 167: proper(V1,Out) = 1
     [Out=7,V1=6] 
* CE 168: proper(V1,Out) = 1
     [Out=6,V1=5] 
* CE 169: proper(V1,Out) = 1
     [Out=5,V1=4] 
* CE 170: proper(V1,Out) = 1
     [Out=4,V1=3] 
* CE 171: proper(V1,Out) = 1
     [Out=3,V1=2] 
* CE 172: proper(V1,Out) = 1
     [Out=2,V1=1] 
* CE 173: proper(V1,Out) = 1
     [Out=1,V1=0] 

### Cost equations --> "Loop" of proper/2 
* CEs [166] --> Loop 138 
* CEs [167] --> Loop 139 
* CEs [168] --> Loop 140 
* CEs [169] --> Loop 141 
* CEs [170] --> Loop 142 
* CEs [171] --> Loop 143 
* CEs [172] --> Loop 144 
* CEs [173] --> Loop 145 

#### Loops of proper/2 
* Loop 138: proper(V1,Out) [V1>=0,Out=0] 
* Loop 139: proper(V1,Out) [Out=7,V1=6] 
* Loop 140: proper(V1,Out) [Out=6,V1=5] 
* Loop 141: proper(V1,Out) [Out=5,V1=4] 
* Loop 142: proper(V1,Out) [Out=4,V1=3] 
* Loop 143: proper(V1,Out) [Out=3,V1=2] 
* Loop 144: proper(V1,Out) [Out=2,V1=1] 
* Loop 145: proper(V1,Out) [Out=1,V1=0] 

### Ranking functions of CR proper(V1,Out) 

#### Partial ranking functions of CR proper(V1,Out) 


### Resulting Chains:proper(V1,Out) 
* [145]
* [144]
* [143]
* [142]
* [141]
* [140]
* [139]
* [138]


### Merging Chains  proper/2 into  External patterns of execution 
* [[145]] --> 1 
* [[144]] --> 2 
* [[143]] --> 3 
* [[142]] --> 4 
* [[141]] --> 5 
* [[140]] --> 6 
* [[139]] --> 7 
* [[138]] --> 8 


### Specialization of cost equations top/2 
* CE 34 is refined into CE [174] 
* CE 32 is refined into CE [175] 
* CE 33 is refined into CE [176,177,178,179,180,181,182,183] 


#### Refined cost equations top/2 
* CE 174: top(V1,Out) = 0
     [V1>=0,Out=0] 
* CE 175: top(V1,Out) = 1+ top(V1,Out)
     [V1>=1] 
* CE 176: top(V1,Out) = 1+ proper(W1,X1):1+ top(Y1,Out)
     [Y1=1,X1=1,W1=0,V1=1] 
* CE 177: top(V1,Out) = 1+ proper(W1,X1):2+ top(Y1,Out)
     [Y1=2,X1=2,W1=1,V1=2] 
* CE 178: top(V1,Out) = 1+ proper(W1,X1):3+ top(Y1,Out)
     [Y1=3,X1=3,W1=2,V1=3] 
* CE 179: top(V1,Out) = 1+ proper(W1,X1):4+ top(Y1,Out)
     [Y1=4,X1=4,W1=3,V1=4] 
* CE 180: top(V1,Out) = 1+ proper(W1,X1):5+ top(Y1,Out)
     [Y1=5,X1=5,W1=4,V1=5] 
* CE 181: top(V1,Out) = 1+ proper(W1,X1):6+ top(Y1,Out)
     [Y1=6,X1=6,W1=5,V1=6] 
* CE 182: top(V1,Out) = 1+ proper(W1,X1):7+ top(Y1,Out)
     [Y1=7,X1=7,W1=6,V1=7] 
* CE 183: top(V1,Out) = 1+ proper(W1,X1):8+ top(Y1,Out)
     [W1>=0,W1+1=V1,Y1=0,X1=0] 

### Cost equations --> "Loop" of top/2 
* CEs [183] --> Loop 146 
* CEs [182] --> Loop 147 
* CEs [181] --> Loop 148 
* CEs [180] --> Loop 149 
* CEs [179] --> Loop 150 
* CEs [178] --> Loop 151 
* CEs [177] --> Loop 152 
* CEs [175,176] --> Loop 153 
* CEs [174] --> Loop 154 

#### Loops of top/2 
* Loop 146: top(V1,Out)->  top(V1',Out)
                  [V1>=1,V1'=0] 
* Loop 147: top(V1,Out)->  top(V1',Out)
                  [V1'=7,V1=7] 
* Loop 148: top(V1,Out)->  top(V1',Out)
                  [V1'=6,V1=6] 
* Loop 149: top(V1,Out)->  top(V1',Out)
                  [V1'=5,V1=5] 
* Loop 150: top(V1,Out)->  top(V1',Out)
                  [V1'=4,V1=4] 
* Loop 151: top(V1,Out)->  top(V1',Out)
                  [V1'=3,V1=3] 
* Loop 152: top(V1,Out)->  top(V1',Out)
                  [V1'=2,V1=2] 
* Loop 153: top(V1,Out)->  top(V1,Out)
                  [V1>=1] 
* Loop 154: top(V1,Out) [V1>=0,Out=0] 

### Ranking functions of CR top(V1,Out) 

#### Partial ranking functions of CR top(V1,Out) 


### Resulting Chains:top(V1,Out) 
* [[147,148,149,150,151,152,153]]...
* [[147,148,149,150,151,152,153],154]
* [[147,148,149,150,151,152,153],146,154]
* [154]
* [146,154]


### Merging Chains  top/2 into  External patterns of execution 
* [[154,146],[154],[154,146,[147,148,149,150,151,152,153]],[154,[147,148,149,150,151,152,153]]] --> 1 
* [[[147,148,149,150,151,152,153]]] --> 2 


### Specialization of cost equations start/3 
* CE 2 is refined into CE [184,185] 
* CE 3 is refined into CE [186,187] 
* CE 4 is refined into CE [188,189] 
* CE 5 is refined into CE [190,191] 
* CE 6 is refined into CE [192,193] 
* CE 7 is refined into CE [194,195,196,197,198,199,200,201] 
* CE 8 is refined into CE [202,203] 
* CE 9 is refined into CE [204,205] 
* CE 10 is refined into CE [206,207] 
* CE 11 is refined into CE [208,209] 
* CE 12 is refined into CE [210,211] 
* CE 13 is refined into CE [212,213] 
* CE 14 is refined into CE [214,215] 
* CE 15 is refined into CE [216,217] 
* CE 16 is refined into CE [218,219] 
* CE 17 is refined into CE [220,221] 
* CE 18 is refined into CE [222,223] 
* CE 19 is refined into CE [224,225] 
* CE 20 is refined into CE [226,227] 
* CE 21 is refined into CE [228,229] 
* CE 22 is refined into CE [230,231] 
* CE 23 is refined into CE [232,233] 
* CE 24 is refined into CE [234,235] 
* CE 25 is refined into CE [236,237] 
* CE 26 is refined into CE [238,239] 
* CE 27 is refined into CE [240,241] 
* CE 28 is refined into CE [242,243] 


#### Refined cost equations start/3 
* CE 184: start(V1,V,V2) = 0+ fun(V1,V,W2):1
     [V>=0,V1>=0,W2=0] 
* CE 185: start(V1,V,V2) = 0+ fun(V1,V,W2):2
     [V1>=W2,W2>=1,V>=0] 
* CE 186: start(V1,V,V2) = 0+ top(V1,W2):1
     [V1>=0,W2=0] 
* CE 187: start(V1,V,V2) = 0+ top(V1,W2):2
     [V1>=1] 
* CE 188: start(V1,V,V2) = 0+ isNeList(V1,W2):1
     [V1>=0,W2=0] 
* CE 189: start(V1,V,V2) = 0+ isNeList(V1,W2):2
     [V1>=W2,W2>=1] 
* CE 190: start(V1,V,V2) = 0+ fun1(V1,W2):1
     [V1>=0,W2=0] 
* CE 191: start(V1,V,V2) = 0+ fun1(V1,W2):2
     [V1>=W2,W2>=1] 
* CE 192: start(V1,V,V2) = 0+ fun2(V1,V,W2):1
     [V>=0,V1>=0,W2=0] 
* CE 193: start(V1,V,V2) = 0+ fun2(V1,V,W2):2
     [V1>=W2,W2>=1,V>=0] 
* CE 194: start(V1,V,V2) = 0+ proper(W2,X2):1
     [X2=1,W2=0,V1=0] 
* CE 195: start(V1,V,V2) = 0+ proper(W2,X2):2
     [X2=2,W2=1,V1=1] 
* CE 196: start(V1,V,V2) = 0+ proper(W2,X2):3
     [X2=3,W2=2,V1=2] 
* CE 197: start(V1,V,V2) = 0+ proper(W2,X2):4
     [X2=4,W2=3,V1=3] 
* CE 198: start(V1,V,V2) = 0+ proper(W2,X2):5
     [X2=5,W2=4,V1=4] 
* CE 199: start(V1,V,V2) = 0+ proper(W2,X2):6
     [X2=6,W2=5,V1=5] 
* CE 200: start(V1,V,V2) = 0+ proper(W2,X2):7
     [X2=7,W2=6,V1=6] 
* CE 201: start(V1,V,V2) = 0+ proper(V1,W2):8
     [V1>=0,W2=0] 
* CE 202: start(V1,V,V2) = 0+ and(V1,V,W2):1
     [V>=0,V1>=0,W2=0] 
* CE 203: start(V1,V,V2) = 0+ and(V1,V,W2):2
     [V1>=W2,W2>=1,V>=0] 
* CE 204: start(V1,V,V2) = 0+ fun3(V1,W2):1
     [V1>=0,W2=0] 
* CE 205: start(V1,V,V2) = 0+ fun3(V1,W2):2
     [V1>=W2,W2>=1] 
* CE 206: start(V1,V,V2) = 0+ fun4(V1,W2):1
     [V1>=0,W2=0] 
* CE 207: start(V1,V,V2) = 0+ fun4(V1,W2):2
     [V1>=W2,W2>=1] 
* CE 208: start(V1,V,V2) = 0+ fun5(V1,V,W2):1
     [V>=0,V1>=0,W2=0] 
* CE 209: start(V1,V,V2) = 0+ fun5(V1,V,W2):2
     [V1>=W2,W2>=1,V>=0] 
* CE 210: start(V1,V,V2) = 0+ fun6(V1,V,V2,W2):1
     [V2>=0,V>=0,V1>=0,W2=0] 
* CE 211: start(V1,V,V2) = 0+ fun6(V1,V,V2,W2):2
     [V1>=W2,W2>=1,V2>=0,V>=0] 
* CE 212: start(V1,V,V2) = 0+ fun7(V1,V,W2):1
     [V>=0,V1>=0,W2=0] 
* CE 213: start(V1,V,V2) = 0+ fun7(V1,V,W2):2
     [V1+V>=W2,W2>=1,V>=0,V1>=0] 
* CE 214: start(V1,V,V2) = 0+ isPal(V1,W2):1
     [V1>=0,W2=0] 
* CE 215: start(V1,V,V2) = 0+ isPal(V1,W2):2
     [V1>=W2,W2>=1] 
* CE 216: start(V1,V,V2) = 0+ fun8(V1,W2):1
     [V1>=0,W2=0] 
* CE 217: start(V1,V,V2) = 0+ fun8(V1,W2):2
     [V1>=W2,W2>=1] 
* CE 218: start(V1,V,V2) = 0+ fun9(V1,W2):1
     [V1>=0,W2=0] 
* CE 219: start(V1,V,V2) = 0+ fun9(V1,W2):2
     [V1>=W2,W2>=1] 
* CE 220: start(V1,V,V2) = 0+ fun10(V1,W2):1
     [V1>=0,W2=0] 
* CE 221: start(V1,V,V2) = 0+ fun10(V1,W2):2
     [V1>=W2,W2>=1] 
* CE 222: start(V1,V,V2) = 0+ fun11(V1,V,W2):1
     [V>=0,V1>=0,W2=0] 
* CE 223: start(V1,V,V2) = 0+ fun11(V1,V,W2):2
     [V1>=W2,W2>=1,V>=0] 
* CE 224: start(V1,V,V2) = 0+ fun12(V1,W2):1
     [V1>=0,W2=0] 
* CE 225: start(V1,V,V2) = 0+ fun12(V1,W2):2
     [V1>=W2,W2>=1] 
* CE 226: start(V1,V,V2) = 0+ fun13(V1,V,W2):1
     [V>=0,V1>=0,W2=0] 
* CE 227: start(V1,V,V2) = 0+ fun13(V1,V,W2):2
     [V1>=W2,W2>=1,V>=0] 
* CE 228: start(V1,V,V2) = 0+ fun14(V1,V,V2,W2):1
     [V2>=0,V>=0,V1>=0,W2=0] 
* CE 229: start(V1,V,V2) = 0+ fun14(V1,V,V2,W2):2
     [V1>=W2,W2>=1,V2>=0,V>=0] 
* CE 230: start(V1,V,V2) = 0+ fun15(V1,V,W2):1
     [V>=0,V1>=0,W2=0] 
* CE 231: start(V1,V,V2) = 0+ fun15(V1,V,W2):2
     [V1>=W2,W2>=1,V>=0] 
* CE 232: start(V1,V,V2) = 0+ isQid(V1,W2):1
     [V1>=0,W2=0] 
* CE 233: start(V1,V,V2) = 0+ isQid(V1,W2):2
     [V1>=W2,W2>=1] 
* CE 234: start(V1,V,V2) = 0+ isNePal(V1,W2):1
     [V1>=0,W2=0] 
* CE 235: start(V1,V,V2) = 0+ isNePal(V1,W2):2
     [V1>=W2,W2>=1] 
* CE 236: start(V1,V,V2) = 0+ fun16(V1,V,W2):1
     [V>=0,V1>=0,W2=0] 
* CE 237: start(V1,V,V2) = 0+ fun16(V1,V,W2):2
     [V1>=W2,W2>=1,V>=0] 
* CE 238: start(V1,V,V2) = 0+ isList(V1,W2):1
     [V1>=0,W2=0] 
* CE 239: start(V1,V,V2) = 0+ isList(V1,W2):2
     [V1>=W2,W2>=1] 
* CE 240: start(V1,V,V2) = 0+ isPalListKind(V1,W2):1
     [V1>=0,W2=0] 
* CE 241: start(V1,V,V2) = 0+ isPalListKind(V1,W2):2
     [V1>=W2,W2>=1] 
* CE 242: start(V1,V,V2) = 0+ fun17(V1,V,V2,W2):1
     [V2>=0,V>=0,V1>=0,W2=0] 
* CE 243: start(V1,V,V2) = 0+ fun17(V1,V,V2,W2):2
     [V1>=W2,W2>=1,V2>=0,V>=0] 

### Cost equations --> "Loop" of start/3 
* CEs [200] --> Loop 155 
* CEs [199] --> Loop 156 
* CEs [198] --> Loop 157 
* CEs [197] --> Loop 158 
* CEs [196] --> Loop 159 
* CEs [195] --> Loop 160 
* CEs [184,185,186,188,189,190,191,192,193,194,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243] --> Loop 161 
* CEs [187] --> Loop 162 

#### Loops of start/3 
* Loop 155: start(V1,V,V2) [V1=6] 
* Loop 156: start(V1,V,V2) [V1=5] 
* Loop 157: start(V1,V,V2) [V1=4] 
* Loop 158: start(V1,V,V2) [V1=3] 
* Loop 159: start(V1,V,V2) [V1=2] 
* Loop 160: start(V1,V,V2) [V1=1] 
* Loop 161: start(V1,V,V2) [V1>=0] 
* Loop 162: start(V1,V,V2) [V1>=1] 

### Ranking functions of CR start(V1,V,V2) 

#### Partial ranking functions of CR start(V1,V,V2) 


### Resulting Chains:start(V1,V,V2) 
* [162]...
* [161]
* [160]
* [159]
* [158]
* [157]
* [156]
* [155]


### Merging Chains  start/3 into  External patterns of execution 
* [[160],[161]] --> 1 
* [[159]] --> 2 
* [[158]] --> 3 
* [[157]] --> 4 
* [[156]] --> 5 
* [[155]] --> 6 
* [[162]] --> 7 


Computing Bounds
=====================================

#### Cost of loops [75,76] 

 * loop 75:and(V1,V,Out) -> [and(V1',V',Out')] 
1
 * loop 76:and(V1,V,Out) -> [and(V1',V',Out')] 
1
#### Cost of phase [75,76]:and(V1,V,Out) -> [and(V1',V',Out')] 
1*it(75)+1*it(76)+0
  Such that:it(76) =< V
it(76) =< V-V'
aux(1) =< V1
aux(2) =< V1-V1'
it(75) =< aux(1)
it(76) =< aux(1)
it(75) =< aux(2)
it(76) =< aux(2)

#### Cost of chains of and(V1,V,Out):
* Chain [[75,76],77]: 1*it(75)+1*it(76)+0
  Such that:aux(1) =< V1
it(76) =< V
aux(2) =< Out
it(75) =< aux(1)
it(76) =< aux(1)
it(75) =< aux(2)
it(76) =< aux(2)

  with precondition: [V>=0,Out>=1,V1>=Out] 

* Chain [77]: 0
  with precondition: [Out=0,V1>=0,V>=0] 


#### Cost of loops [78,79] 

 * loop 78:fun(V1,V,Out) -> [fun(V1',V',Out')] 
1
 * loop 79:fun(V1,V,Out) -> [fun(V1',V',Out')] 
1
#### Cost of phase [78,79]:fun(V1,V,Out) -> [fun(V1',V',Out')] 
1*it(78)+1*it(79)+0
  Such that:it(79) =< V
it(79) =< V-V'
aux(3) =< V1
aux(4) =< V1-V1'
it(78) =< aux(3)
it(79) =< aux(3)
it(78) =< aux(4)
it(79) =< aux(4)

#### Cost of chains of fun(V1,V,Out):
* Chain [[78,79],80]: 1*it(78)+1*it(79)+0
  Such that:aux(3) =< V1
it(79) =< V
aux(4) =< Out
it(78) =< aux(3)
it(79) =< aux(3)
it(78) =< aux(4)
it(79) =< aux(4)

  with precondition: [V>=0,Out>=1,V1>=Out] 

* Chain [80]: 0
  with precondition: [Out=0,V1>=0,V>=0] 


#### Cost of loops [81] 

 * loop 81:fun1(V1,Out) -> [fun1(V1',Out')] 
1
#### Cost of phase [81]:fun1(V1,Out) -> [fun1(V1',Out')] 
1*it(81)+0
  Such that:it(81) =< V1
it(81) =< V1-V1'

#### Cost of chains of fun1(V1,Out):
* Chain [[81],82]: 1*it(81)+0
  Such that:it(81) =< Out

  with precondition: [Out>=1,V1>=Out] 

* Chain [82]: 0
  with precondition: [Out=0,V1>=0] 


#### Cost of loops [83] 

 * loop 83:fun10(V1,Out) -> [fun10(V1',Out')] 
1
#### Cost of phase [83]:fun10(V1,Out) -> [fun10(V1',Out')] 
1*it(83)+0
  Such that:it(83) =< V1
it(83) =< V1-V1'

#### Cost of chains of fun10(V1,Out):
* Chain [[83],84]: 1*it(83)+0
  Such that:it(83) =< Out

  with precondition: [Out>=1,V1>=Out] 

* Chain [84]: 0
  with precondition: [Out=0,V1>=0] 


#### Cost of loops [85,86] 

 * loop 85:fun11(V1,V,Out) -> [fun11(V1',V',Out')] 
1
 * loop 86:fun11(V1,V,Out) -> [fun11(V1',V',Out')] 
1
#### Cost of phase [85,86]:fun11(V1,V,Out) -> [fun11(V1',V',Out')] 
1*it(85)+1*it(86)+0
  Such that:it(86) =< V
it(86) =< V-V'
aux(5) =< V1
aux(6) =< V1-V1'
it(85) =< aux(5)
it(86) =< aux(5)
it(85) =< aux(6)
it(86) =< aux(6)

#### Cost of chains of fun11(V1,V,Out):
* Chain [[85,86],87]: 1*it(85)+1*it(86)+0
  Such that:aux(5) =< V1
it(86) =< V
aux(6) =< Out
it(85) =< aux(5)
it(86) =< aux(5)
it(85) =< aux(6)
it(86) =< aux(6)

  with precondition: [V>=0,Out>=1,V1>=Out] 

* Chain [87]: 0
  with precondition: [Out=0,V1>=0,V>=0] 


#### Cost of loops [88] 

 * loop 88:fun12(V1,Out) -> [fun12(V1',Out')] 
1
#### Cost of phase [88]:fun12(V1,Out) -> [fun12(V1',Out')] 
1*it(88)+0
  Such that:it(88) =< V1
it(88) =< V1-V1'

#### Cost of chains of fun12(V1,Out):
* Chain [[88],89]: 1*it(88)+0
  Such that:it(88) =< Out

  with precondition: [Out>=1,V1>=Out] 

* Chain [89]: 0
  with precondition: [Out=0,V1>=0] 


#### Cost of loops [90,91] 

 * loop 90:fun13(V1,V,Out) -> [fun13(V1',V',Out')] 
1
 * loop 91:fun13(V1,V,Out) -> [fun13(V1',V',Out')] 
1
#### Cost of phase [90,91]:fun13(V1,V,Out) -> [fun13(V1',V',Out')] 
1*it(90)+1*it(91)+0
  Such that:it(91) =< V
it(91) =< V-V'
aux(7) =< V1
aux(8) =< V1-V1'
it(90) =< aux(7)
it(91) =< aux(7)
it(90) =< aux(8)
it(91) =< aux(8)

#### Cost of chains of fun13(V1,V,Out):
* Chain [[90,91],92]: 1*it(90)+1*it(91)+0
  Such that:aux(7) =< V1
it(91) =< V
aux(8) =< Out
it(90) =< aux(7)
it(91) =< aux(7)
it(90) =< aux(8)
it(91) =< aux(8)

  with precondition: [V>=0,Out>=1,V1>=Out] 

* Chain [92]: 0
  with precondition: [Out=0,V1>=0,V>=0] 


#### Cost of loops [93,94] 

 * loop 93:fun14(V1,V,V2,Out) -> [fun14(V1',V',V2',Out')] 
1
 * loop 94:fun14(V1,V,V2,Out) -> [fun14(V1',V',V2',Out')] 
1
#### Cost of phase [93,94]:fun14(V1,V,V2,Out) -> [fun14(V1',V',V2',Out')] 
1*it(93)+1*it(94)+0
  Such that:it(94) =< V
it(94) =< V-V'
it(94) =< V2
it(94) =< V2-V2'
aux(9) =< V1
aux(10) =< V1-V1'
it(93) =< aux(9)
it(94) =< aux(9)
it(93) =< aux(10)
it(94) =< aux(10)

#### Cost of chains of fun14(V1,V,V2,Out):
* Chain [[93,94],95]: 1*it(93)+1*it(94)+0
  Such that:aux(9) =< V1
it(94) =< V
aux(10) =< Out
it(93) =< aux(9)
it(94) =< aux(9)
it(93) =< aux(10)
it(94) =< aux(10)

  with precondition: [V>=0,V2>=0,Out>=1,V1>=Out] 

* Chain [95]: 0
  with precondition: [Out=0,V1>=0,V>=0,V2>=0] 


#### Cost of loops [96,97] 

 * loop 96:fun15(V1,V,Out) -> [fun15(V1',V',Out')] 
1
 * loop 97:fun15(V1,V,Out) -> [fun15(V1',V',Out')] 
1
#### Cost of phase [96,97]:fun15(V1,V,Out) -> [fun15(V1',V',Out')] 
1*it(96)+1*it(97)+0
  Such that:it(97) =< V
it(97) =< V-V'
aux(11) =< V1
aux(12) =< V1-V1'
it(96) =< aux(11)
it(97) =< aux(11)
it(96) =< aux(12)
it(97) =< aux(12)

#### Cost of chains of fun15(V1,V,Out):
* Chain [[96,97],98]: 1*it(96)+1*it(97)+0
  Such that:aux(11) =< V1
it(97) =< V
aux(12) =< Out
it(96) =< aux(11)
it(97) =< aux(11)
it(96) =< aux(12)
it(97) =< aux(12)

  with precondition: [V>=0,Out>=1,V1>=Out] 

* Chain [98]: 0
  with precondition: [Out=0,V1>=0,V>=0] 


#### Cost of loops [99,100] 

 * loop 99:fun16(V1,V,Out) -> [fun16(V1',V',Out')] 
1
 * loop 100:fun16(V1,V,Out) -> [fun16(V1',V',Out')] 
1
#### Cost of phase [99,100]:fun16(V1,V,Out) -> [fun16(V1',V',Out')] 
1*it(99)+1*it(100)+0
  Such that:it(100) =< V
it(100) =< V-V'
aux(13) =< V1
aux(14) =< V1-V1'
it(99) =< aux(13)
it(100) =< aux(13)
it(99) =< aux(14)
it(100) =< aux(14)

#### Cost of chains of fun16(V1,V,Out):
* Chain [[99,100],101]: 1*it(99)+1*it(100)+0
  Such that:aux(13) =< V1
it(100) =< V
aux(14) =< Out
it(99) =< aux(13)
it(100) =< aux(13)
it(99) =< aux(14)
it(100) =< aux(14)

  with precondition: [V>=0,Out>=1,V1>=Out] 

* Chain [101]: 0
  with precondition: [Out=0,V1>=0,V>=0] 


#### Cost of loops [102,103] 

 * loop 102:fun17(V1,V,V2,Out) -> [fun17(V1',V',V2',Out')] 
1
 * loop 103:fun17(V1,V,V2,Out) -> [fun17(V1',V',V2',Out')] 
1
#### Cost of phase [102,103]:fun17(V1,V,V2,Out) -> [fun17(V1',V',V2',Out')] 
1*it(102)+1*it(103)+0
  Such that:it(103) =< V
it(103) =< V-V'
it(103) =< V2
it(103) =< V2-V2'
aux(15) =< V1
aux(16) =< V1-V1'
it(102) =< aux(15)
it(103) =< aux(15)
it(102) =< aux(16)
it(103) =< aux(16)

#### Cost of chains of fun17(V1,V,V2,Out):
* Chain [[102,103],104]: 1*it(102)+1*it(103)+0
  Such that:aux(15) =< V1
it(103) =< V
aux(16) =< Out
it(102) =< aux(15)
it(103) =< aux(15)
it(102) =< aux(16)
it(103) =< aux(16)

  with precondition: [V>=0,V2>=0,Out>=1,V1>=Out] 

* Chain [104]: 0
  with precondition: [Out=0,V1>=0,V>=0,V2>=0] 


#### Cost of loops [105,106] 

 * loop 105:fun2(V1,V,Out) -> [fun2(V1',V',Out')] 
1
 * loop 106:fun2(V1,V,Out) -> [fun2(V1',V',Out')] 
1
#### Cost of phase [105,106]:fun2(V1,V,Out) -> [fun2(V1',V',Out')] 
1*it(105)+1*it(106)+0
  Such that:it(106) =< V
it(106) =< V-V'
aux(17) =< V1
aux(18) =< V1-V1'
it(105) =< aux(17)
it(106) =< aux(17)
it(105) =< aux(18)
it(106) =< aux(18)

#### Cost of chains of fun2(V1,V,Out):
* Chain [[105,106],107]: 1*it(105)+1*it(106)+0
  Such that:aux(17) =< V1
it(106) =< V
aux(18) =< Out
it(105) =< aux(17)
it(106) =< aux(17)
it(105) =< aux(18)
it(106) =< aux(18)

  with precondition: [V>=0,Out>=1,V1>=Out] 

* Chain [107]: 0
  with precondition: [Out=0,V1>=0,V>=0] 


#### Cost of loops [108] 

 * loop 108:fun3(V1,Out) -> [fun3(V1',Out')] 
1
#### Cost of phase [108]:fun3(V1,Out) -> [fun3(V1',Out')] 
1*it(108)+0
  Such that:it(108) =< V1
it(108) =< V1-V1'

#### Cost of chains of fun3(V1,Out):
* Chain [[108],109]: 1*it(108)+0
  Such that:it(108) =< Out

  with precondition: [Out>=1,V1>=Out] 

* Chain [109]: 0
  with precondition: [Out=0,V1>=0] 


#### Cost of loops [110] 

 * loop 110:fun4(V1,Out) -> [fun4(V1',Out')] 
1
#### Cost of phase [110]:fun4(V1,Out) -> [fun4(V1',Out')] 
1*it(110)+0
  Such that:it(110) =< V1
it(110) =< V1-V1'

#### Cost of chains of fun4(V1,Out):
* Chain [[110],111]: 1*it(110)+0
  Such that:it(110) =< Out

  with precondition: [Out>=1,V1>=Out] 

* Chain [111]: 0
  with precondition: [Out=0,V1>=0] 


#### Cost of loops [112,113] 

 * loop 112:fun5(V1,V,Out) -> [fun5(V1',V',Out')] 
1
 * loop 113:fun5(V1,V,Out) -> [fun5(V1',V',Out')] 
1
#### Cost of phase [112,113]:fun5(V1,V,Out) -> [fun5(V1',V',Out')] 
1*it(112)+1*it(113)+0
  Such that:it(113) =< V
it(113) =< V-V'
aux(19) =< V1
aux(20) =< V1-V1'
it(112) =< aux(19)
it(113) =< aux(19)
it(112) =< aux(20)
it(113) =< aux(20)

#### Cost of chains of fun5(V1,V,Out):
* Chain [[112,113],114]: 1*it(112)+1*it(113)+0
  Such that:aux(19) =< V1
it(113) =< V
aux(20) =< Out
it(112) =< aux(19)
it(113) =< aux(19)
it(112) =< aux(20)
it(113) =< aux(20)

  with precondition: [V>=0,Out>=1,V1>=Out] 

* Chain [114]: 0
  with precondition: [Out=0,V1>=0,V>=0] 


#### Cost of loops [115,116] 

 * loop 115:fun6(V1,V,V2,Out) -> [fun6(V1',V',V2',Out')] 
1
 * loop 116:fun6(V1,V,V2,Out) -> [fun6(V1',V',V2',Out')] 
1
#### Cost of phase [115,116]:fun6(V1,V,V2,Out) -> [fun6(V1',V',V2',Out')] 
1*it(115)+1*it(116)+0
  Such that:it(116) =< V
it(116) =< V-V'
it(116) =< V2
it(116) =< V2-V2'
aux(21) =< V1
aux(22) =< V1-V1'
it(115) =< aux(21)
it(116) =< aux(21)
it(115) =< aux(22)
it(116) =< aux(22)

#### Cost of chains of fun6(V1,V,V2,Out):
* Chain [[115,116],117]: 1*it(115)+1*it(116)+0
  Such that:aux(21) =< V1
it(116) =< V
aux(22) =< Out
it(115) =< aux(21)
it(116) =< aux(21)
it(115) =< aux(22)
it(116) =< aux(22)

  with precondition: [V>=0,V2>=0,Out>=1,V1>=Out] 

* Chain [117]: 0
  with precondition: [Out=0,V1>=0,V>=0,V2>=0] 


#### Cost of loops [118,119,120] 

 * loop 118:fun7(V1,V,Out) -> [fun7(V1',V',Out')] 
1
 * loop 119:fun7(V1,V,Out) -> [fun7(V1',V',Out')] 
1
 * loop 120:fun7(V1,V,Out) -> [fun7(V1',V',Out')] 
1
#### Cost of phase [118,119,120]:fun7(V1,V,Out) -> [fun7(V1',V',Out')] 
1*it(118)+1*it(119)+1*it(120)+0
  Such that:aux(23) =< V1
aux(24) =< V1+V
aux(25) =< V1+V-V1'-V'
aux(26) =< V1-V1'
aux(27) =< V
aux(28) =< V-V'
it(119) =< aux(23)
it(120) =< aux(23)
it(118) =< aux(24)
it(119) =< aux(24)
it(120) =< aux(24)
it(118) =< aux(25)
it(119) =< aux(25)
it(120) =< aux(25)
it(119) =< aux(26)
it(120) =< aux(26)
it(118) =< aux(27)
it(120) =< aux(27)
it(118) =< aux(28)
it(120) =< aux(28)

#### Cost of chains of fun7(V1,V,Out):
* Chain [[118,119,120],121]: 1*it(118)+1*it(119)+1*it(120)+0
  Such that:aux(29) =< V1
aux(30) =< V1+V
aux(31) =< V
it(119) =< aux(29)
it(120) =< aux(29)
it(118) =< aux(30)
it(119) =< aux(30)
it(120) =< aux(30)
it(118) =< aux(31)
it(120) =< aux(31)

  with precondition: [V1>=0,V>=0,Out>=1,V+V1>=Out] 

* Chain [121]: 0
  with precondition: [Out=0,V1>=0,V>=0] 


#### Cost of loops [122] 

 * loop 122:fun8(V1,Out) -> [fun8(V1',Out')] 
1
#### Cost of phase [122]:fun8(V1,Out) -> [fun8(V1',Out')] 
1*it(122)+0
  Such that:it(122) =< V1
it(122) =< V1-V1'

#### Cost of chains of fun8(V1,Out):
* Chain [[122],123]: 1*it(122)+0
  Such that:it(122) =< Out

  with precondition: [Out>=1,V1>=Out] 

* Chain [123]: 0
  with precondition: [Out=0,V1>=0] 


#### Cost of loops [124] 

 * loop 124:fun9(V1,Out) -> [fun9(V1',Out')] 
1
#### Cost of phase [124]:fun9(V1,Out) -> [fun9(V1',Out')] 
1*it(124)+0
  Such that:it(124) =< V1
it(124) =< V1-V1'

#### Cost of chains of fun9(V1,Out):
* Chain [[124],125]: 1*it(124)+0
  Such that:it(124) =< Out

  with precondition: [Out>=1,V1>=Out] 

* Chain [125]: 0
  with precondition: [Out=0,V1>=0] 


#### Cost of loops [126] 

 * loop 126:isList(V1,Out) -> [isList(V1',Out')] 
1
#### Cost of phase [126]:isList(V1,Out) -> [isList(V1',Out')] 
1*it(126)+0
  Such that:it(126) =< V1
it(126) =< V1-V1'

#### Cost of chains of isList(V1,Out):
* Chain [[126],127]: 1*it(126)+0
  Such that:it(126) =< Out

  with precondition: [Out>=1,V1>=Out] 

* Chain [127]: 0
  with precondition: [Out=0,V1>=0] 


#### Cost of loops [128] 

 * loop 128:isNeList(V1,Out) -> [isNeList(V1',Out')] 
1
#### Cost of phase [128]:isNeList(V1,Out) -> [isNeList(V1',Out')] 
1*it(128)+0
  Such that:it(128) =< V1
it(128) =< V1-V1'

#### Cost of chains of isNeList(V1,Out):
* Chain [[128],129]: 1*it(128)+0
  Such that:it(128) =< Out

  with precondition: [Out>=1,V1>=Out] 

* Chain [129]: 0
  with precondition: [Out=0,V1>=0] 


#### Cost of loops [130] 

 * loop 130:isNePal(V1,Out) -> [isNePal(V1',Out')] 
1
#### Cost of phase [130]:isNePal(V1,Out) -> [isNePal(V1',Out')] 
1*it(130)+0
  Such that:it(130) =< V1
it(130) =< V1-V1'

#### Cost of chains of isNePal(V1,Out):
* Chain [[130],131]: 1*it(130)+0
  Such that:it(130) =< Out

  with precondition: [Out>=1,V1>=Out] 

* Chain [131]: 0
  with precondition: [Out=0,V1>=0] 


#### Cost of loops [132] 

 * loop 132:isPal(V1,Out) -> [isPal(V1',Out')] 
1
#### Cost of phase [132]:isPal(V1,Out) -> [isPal(V1',Out')] 
1*it(132)+0
  Such that:it(132) =< V1
it(132) =< V1-V1'

#### Cost of chains of isPal(V1,Out):
* Chain [[132],133]: 1*it(132)+0
  Such that:it(132) =< Out

  with precondition: [Out>=1,V1>=Out] 

* Chain [133]: 0
  with precondition: [Out=0,V1>=0] 


#### Cost of loops [134] 

 * loop 134:isPalListKind(V1,Out) -> [isPalListKind(V1',Out')] 
1
#### Cost of phase [134]:isPalListKind(V1,Out) -> [isPalListKind(V1',Out')] 
1*it(134)+0
  Such that:it(134) =< V1
it(134) =< V1-V1'

#### Cost of chains of isPalListKind(V1,Out):
* Chain [[134],135]: 1*it(134)+0
  Such that:it(134) =< Out

  with precondition: [Out>=1,V1>=Out] 

* Chain [135]: 0
  with precondition: [Out=0,V1>=0] 


#### Cost of loops [136] 

 * loop 136:isQid(V1,Out) -> [isQid(V1',Out')] 
1
#### Cost of phase [136]:isQid(V1,Out) -> [isQid(V1',Out')] 
1*it(136)+0
  Such that:it(136) =< V1
it(136) =< V1-V1'

#### Cost of chains of isQid(V1,Out):
* Chain [[136],137]: 1*it(136)+0
  Such that:it(136) =< Out

  with precondition: [Out>=1,V1>=Out] 

* Chain [137]: 0
  with precondition: [Out=0,V1>=0] 


#### Cost of chains of proper(V1,Out):
* Chain [145]: 1
  with precondition: [V1=0,Out=1] 

* Chain [144]: 1
  with precondition: [V1=1,Out=2] 

* Chain [143]: 1
  with precondition: [V1=2,Out=3] 

* Chain [142]: 1
  with precondition: [V1=3,Out=4] 

* Chain [141]: 1
  with precondition: [V1=4,Out=5] 

* Chain [140]: 1
  with precondition: [V1=5,Out=6] 

* Chain [139]: 1
  with precondition: [V1=6,Out=7] 

* Chain [138]: 0
  with precondition: [Out=0,V1>=0] 


#### Cost of loops [147,148,149,150,151,152,153] 

 * loop 147:top(V1,Out) -> [top(V1',Out')] 
2
 * loop 148:top(V1,Out) -> [top(V1',Out')] 
2
 * loop 149:top(V1,Out) -> [top(V1',Out')] 
2
 * loop 150:top(V1,Out) -> [top(V1',Out')] 
2
 * loop 151:top(V1,Out) -> [top(V1',Out')] 
2
 * loop 152:top(V1,Out) -> [top(V1',Out')] 
2
 * loop 153:top(V1,Out) -> [top(V1',Out')] 
2
#### Cost of phase [147,148,149,150,151,152,153]:top(V1,Out) -> [top(V1',Out')] 
14*it(147)+0
#### Cost of phase [147,148,149,150,151,152,153]:top(V1,Out) -> [top(V1',Out')] 
14*it(147)+0
#### Cost of phase [147,148,149,150,151,152,153]:top(V1,Out) -> [top(V1',Out')] 
14*it(147)+0
#### Cost of chains of top(V1,Out):
* Chain [[147,148,149,150,151,152,153]]...: 14*it(147)+0
  with precondition: [V1>=1] 

* Chain [[147,148,149,150,151,152,153],154]: 14*it(147)+0
  with precondition: [Out=0,V1>=1] 

* Chain [[147,148,149,150,151,152,153],146,154]: 14*it(147)+1
  with precondition: [Out=0,V1>=1] 

* Chain [154]: 0
  with precondition: [Out=0,V1>=0] 

* Chain [146,154]: 1
  with precondition: [Out=0,V1>=1] 


#### Cost of chains of start(V1,V,V2):
* Chain [162]...: 14*s(3)+0
  with precondition: [V1>=1] 

* Chain [161]: 11*s(5)+24*s(7)+1*s(8)+1*s(32)+1*s(33)+1*s(34)+1
  Such that:s(30) =< V1+V
aux(44) =< V1
aux(45) =< V
s(7) =< aux(44)
s(5) =< aux(45)
s(32) =< aux(44)
s(33) =< aux(44)
s(34) =< s(30)
s(32) =< s(30)
s(33) =< s(30)
s(34) =< aux(45)
s(33) =< aux(45)
s(5) =< aux(44)

  with precondition: [V1>=0] 

* Chain [160]: 1
  with precondition: [V1=1] 

* Chain [159]: 1
  with precondition: [V1=2] 

* Chain [158]: 1
  with precondition: [V1=3] 

* Chain [157]: 1
  with precondition: [V1=4] 

* Chain [156]: 1
  with precondition: [V1=5] 

* Chain [155]: 1
  with precondition: [V1=6] 


Closed-form bounds of start(V1,V,V2): 
-------------------------------------
* Chain [162]... with precondition: [V1>=1] 
    - Upper bound: inf 
    - Complexity: infinity 
* Chain [161] with precondition: [V1>=0] 
    - Upper bound: inf 
    - Complexity: infinity 
* Chain [160] with precondition: [V1=1] 
    - Upper bound: 1 
    - Complexity: constant 
* Chain [159] with precondition: [V1=2] 
    - Upper bound: 1 
    - Complexity: constant 
* Chain [158] with precondition: [V1=3] 
    - Upper bound: 1 
    - Complexity: constant 
* Chain [157] with precondition: [V1=4] 
    - Upper bound: 1 
    - Complexity: constant 
* Chain [156] with precondition: [V1=5] 
    - Upper bound: 1 
    - Complexity: constant 
* Chain [155] with precondition: [V1=6] 
    - Upper bound: 1 
    - Complexity: constant 

### Maximum cost of start(V1,V,V2): inf 
Asymptotic class: infinity 

Time statistics: 
-------------------------------------
* Partial evaluation computed in 58 ms.
* Invariants computed in 169 ms.
   - Backward Invariants 65 ms.
   - Transitive Invariants 50 ms.
* Refinement performed in 283 ms.
* Termination proved in 54 ms.
* Upper bounds computed in 254 ms.
   - Equation cost structures 85 ms.
   - Phase cost structures 101 ms.
   - Chain cost structures 80 ms.
   - Solving cost expressions 1 ms.
* Total analysis performed in 937 ms.

