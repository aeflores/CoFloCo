
Preprocessing Cost Relations
=====================================

#### Computed strongly connected components 
0. recursive  : [fun/2]
1. recursive  : [fun1/3]
2. recursive  : [fun10/2]
3. recursive  : [fun11/2]
4. recursive  : [fun12/2]
5. recursive  : [fun2/3]
6. recursive  : [fun3/2]
7. recursive  : [fun4/3]
8. recursive  : [fun5/2]
9. recursive  : [fun6/3]
10. recursive  : [fun7/2]
11. recursive  : [fun8/2]
12. recursive  : [fun9/3]
13. recursive  : [isList/2]
14. recursive  : [isNeList/2]
15. recursive  : [isNePal/2]
16. recursive  : [isPal/2]
17. recursive  : [isQid/2]
18. non_recursive  : [proper/2]
19. recursive  : [top/2]
20. non_recursive  : [start/2]

#### Obtained direct recursion through partial evaluation 
0. SCC is partially evaluated into fun/2
1. SCC is partially evaluated into fun1/3
2. SCC is partially evaluated into fun10/2
3. SCC is partially evaluated into fun11/2
4. SCC is partially evaluated into fun12/2
5. SCC is partially evaluated into fun2/3
6. SCC is partially evaluated into fun3/2
7. SCC is partially evaluated into fun4/3
8. SCC is partially evaluated into fun5/2
9. SCC is partially evaluated into fun6/3
10. SCC is partially evaluated into fun7/2
11. SCC is partially evaluated into fun8/2
12. SCC is partially evaluated into fun9/3
13. SCC is partially evaluated into isList/2
14. SCC is partially evaluated into isNeList/2
15. SCC is partially evaluated into isNePal/2
16. SCC is partially evaluated into isPal/2
17. SCC is partially evaluated into isQid/2
18. SCC is partially evaluated into proper/2
19. SCC is partially evaluated into top/2
20. SCC is partially evaluated into start/2

Control-Flow Refinement of Cost Relations
=====================================

### Specialization of cost equations fun/2 
* CE 23 is refined into CE [75] 
* CE 22 is refined into CE [76] 


#### Refined cost equations fun/2 
* CE 75: fun(V,Out) = 0
     [V>=0,Out=0] 
* CE 76: fun(V,Out) = 1+ fun(W,X)
     [W>=0,X+1=Out,W+1=V] 

### Cost equations --> "Loop" of fun/2 
* CEs [76] --> Loop 54 
* CEs [75] --> Loop 55 

#### Loops of fun/2 
* Loop 54: fun(V,Out)->  fun(V',Out')
                  [V'>=0,Out=Out'+1,V'+1=V] 
* Loop 55: fun(V,Out) [V>=0,Out=0] 

### Ranking functions of CR fun(V,Out) 
* RF of phase [54]: [V]

#### Partial ranking functions of CR fun(V,Out) 
* Partial RF of phase [54]:
  - RF of loop [54:1]:
    V


### Resulting Chains:fun(V,Out) 
* [[54],55]
* [55]


### Merging Chains  fun/2 into  External patterns of execution 
* [[55]] --> 1 
* [[55,[54]]] --> 2 


### Specialization of cost equations fun1/3 
* CE 33 is refined into CE [77] 
* CE 31 is refined into CE [78] 
* CE 32 is refined into CE [79] 


#### Refined cost equations fun1/3 
* CE 77: fun1(V,V1,Out) = 0
     [V1>=0,V>=0,Out=0] 
* CE 78: fun1(V,V1,Out) = 1+ fun1(W1,V1,X1)
     [W1>=0,V1>=0,X1+1=Out,W1+1=V] 
* CE 79: fun1(V,V1,Out) = 1+ fun1(W1,X1,Y1)
     [X1>=0,W1>=0,Y1+1=Out,X1+1=V1,W1+1=V] 

### Cost equations --> "Loop" of fun1/3 
* CEs [78] --> Loop 56 
* CEs [79] --> Loop 57 
* CEs [77] --> Loop 58 

#### Loops of fun1/3 
* Loop 56: fun1(V,V1,Out)->  fun1(V',V1,Out')
                  [V1>=0,V>=1,Out=Out'+1,V=V'+1] 
* Loop 57: fun1(V,V1,Out)->  fun1(V',V1',Out')
                  [V1>=1,V>=1,Out=Out'+1,V1=V1'+1,V=V'+1] 
* Loop 58: fun1(V,V1,Out) [V1>=0,V>=0,Out=0] 

### Ranking functions of CR fun1(V,V1,Out) 
* RF of phase [56,57]: [V]

#### Partial ranking functions of CR fun1(V,V1,Out) 
* Partial RF of phase [56,57]:
  - RF of loop [56:1,57:1]:
    V
  - RF of loop [57:1]:
    V1


### Resulting Chains:fun1(V,V1,Out) 
* [[56,57],58]
* [58]


### Merging Chains  fun1/3 into  External patterns of execution 
* [[58]] --> 1 
* [[58,[56,57]]] --> 2 


### Specialization of cost equations fun10/2 
* CE 70 is refined into CE [80] 
* CE 69 is refined into CE [81] 


#### Refined cost equations fun10/2 
* CE 80: fun10(V,Out) = 0
     [V>=0,Out=0] 
* CE 81: fun10(V,Out) = 1+ fun10(W,X)
     [W>=0,X+1=Out,W+1=V] 

### Cost equations --> "Loop" of fun10/2 
* CEs [81] --> Loop 59 
* CEs [80] --> Loop 60 

#### Loops of fun10/2 
* Loop 59: fun10(V,Out)->  fun10(V',Out')
                  [V'>=0,Out=Out'+1,V'+1=V] 
* Loop 60: fun10(V,Out) [V>=0,Out=0] 

### Ranking functions of CR fun10(V,Out) 
* RF of phase [59]: [V]

#### Partial ranking functions of CR fun10(V,Out) 
* Partial RF of phase [59]:
  - RF of loop [59:1]:
    V


### Resulting Chains:fun10(V,Out) 
* [[59],60]
* [60]


### Merging Chains  fun10/2 into  External patterns of execution 
* [[60]] --> 1 
* [[60,[59]]] --> 2 


### Specialization of cost equations fun11/2 
* CE 72 is refined into CE [82] 
* CE 71 is refined into CE [83] 


#### Refined cost equations fun11/2 
* CE 82: fun11(V,Out) = 0
     [V>=0,Out=0] 
* CE 83: fun11(V,Out) = 1+ fun11(W,X)
     [W>=0,X+1=Out,W+1=V] 

### Cost equations --> "Loop" of fun11/2 
* CEs [83] --> Loop 61 
* CEs [82] --> Loop 62 

#### Loops of fun11/2 
* Loop 61: fun11(V,Out)->  fun11(V',Out')
                  [V'>=0,Out=Out'+1,V'+1=V] 
* Loop 62: fun11(V,Out) [V>=0,Out=0] 

### Ranking functions of CR fun11(V,Out) 
* RF of phase [61]: [V]

#### Partial ranking functions of CR fun11(V,Out) 
* Partial RF of phase [61]:
  - RF of loop [61:1]:
    V


### Resulting Chains:fun11(V,Out) 
* [[61],62]
* [62]


### Merging Chains  fun11/2 into  External patterns of execution 
* [[62]] --> 1 
* [[62,[61]]] --> 2 


### Specialization of cost equations fun12/2 
* CE 74 is refined into CE [84] 
* CE 73 is refined into CE [85] 


#### Refined cost equations fun12/2 
* CE 84: fun12(V,Out) = 0
     [V>=0,Out=0] 
* CE 85: fun12(V,Out) = 1+ fun12(W,X)
     [W>=0,X+1=Out,W+1=V] 

### Cost equations --> "Loop" of fun12/2 
* CEs [85] --> Loop 63 
* CEs [84] --> Loop 64 

#### Loops of fun12/2 
* Loop 63: fun12(V,Out)->  fun12(V',Out')
                  [V'>=0,Out=Out'+1,V'+1=V] 
* Loop 64: fun12(V,Out) [V>=0,Out=0] 

### Ranking functions of CR fun12(V,Out) 
* RF of phase [63]: [V]

#### Partial ranking functions of CR fun12(V,Out) 
* Partial RF of phase [63]:
  - RF of loop [63:1]:
    V


### Resulting Chains:fun12(V,Out) 
* [[63],64]
* [64]


### Merging Chains  fun12/2 into  External patterns of execution 
* [[64]] --> 1 
* [[64,[63]]] --> 2 


### Specialization of cost equations fun2/3 
* CE 39 is refined into CE [86] 
* CE 37 is refined into CE [87] 
* CE 36 is refined into CE [88] 
* CE 38 is refined into CE [89] 


#### Refined cost equations fun2/3 
* CE 86: fun2(V,V1,Out) = 0
     [V1>=0,V>=0,Out=0] 
* CE 87: fun2(V,V1,Out) = 1+ fun2(V,W1,X1)
     [W1>=0,V>=0,X1+1=Out,W1+1=V1] 
* CE 88: fun2(V,V1,Out) = 1+ fun2(W1,V1,X1)
     [W1>=0,V1>=0,X1+1=Out,W1+1=V] 
* CE 89: fun2(V,V1,Out) = 1+ fun2(W1,X1,Y1)
     [X1>=0,W1>=0,Y1+1=Out,X1+1=V1,W1+1=V] 

### Cost equations --> "Loop" of fun2/3 
* CEs [87] --> Loop 65 
* CEs [88] --> Loop 66 
* CEs [89] --> Loop 67 
* CEs [86] --> Loop 68 

#### Loops of fun2/3 
* Loop 65: fun2(V,V1,Out)->  fun2(V,V1',Out')
                  [V1>=1,V>=0,Out=Out'+1,V1=V1'+1] 
* Loop 66: fun2(V,V1,Out)->  fun2(V',V1,Out')
                  [V1>=0,V>=1,Out=Out'+1,V=V'+1] 
* Loop 67: fun2(V,V1,Out)->  fun2(V',V1',Out')
                  [V1>=1,V>=1,Out=Out'+1,V1=V1'+1,V=V'+1] 
* Loop 68: fun2(V,V1,Out) [V1>=0,V>=0,Out=0] 

### Ranking functions of CR fun2(V,V1,Out) 
* RF of phase [65,66,67]: [V+V1]

#### Partial ranking functions of CR fun2(V,V1,Out) 
* Partial RF of phase [65,66,67]:
  - RF of loop [65:1,67:1]:
    V1
  - RF of loop [66:1,67:1]:
    V


### Resulting Chains:fun2(V,V1,Out) 
* [[65,66,67],68]
* [68]


### Merging Chains  fun2/3 into  External patterns of execution 
* [[68]] --> 1 
* [[68,[65,66,67]]] --> 2 


### Specialization of cost equations fun3/2 
* CE 41 is refined into CE [90] 
* CE 40 is refined into CE [91] 


#### Refined cost equations fun3/2 
* CE 90: fun3(V,Out) = 0
     [V>=0,Out=0] 
* CE 91: fun3(V,Out) = 1+ fun3(W,X)
     [W>=0,X+1=Out,W+1=V] 

### Cost equations --> "Loop" of fun3/2 
* CEs [91] --> Loop 69 
* CEs [90] --> Loop 70 

#### Loops of fun3/2 
* Loop 69: fun3(V,Out)->  fun3(V',Out')
                  [V'>=0,Out=Out'+1,V'+1=V] 
* Loop 70: fun3(V,Out) [V>=0,Out=0] 

### Ranking functions of CR fun3(V,Out) 
* RF of phase [69]: [V]

#### Partial ranking functions of CR fun3(V,Out) 
* Partial RF of phase [69]:
  - RF of loop [69:1]:
    V


### Resulting Chains:fun3(V,Out) 
* [[69],70]
* [70]


### Merging Chains  fun3/2 into  External patterns of execution 
* [[70]] --> 1 
* [[70,[69]]] --> 2 


### Specialization of cost equations fun4/3 
* CE 52 is refined into CE [92] 
* CE 50 is refined into CE [93] 
* CE 51 is refined into CE [94] 


#### Refined cost equations fun4/3 
* CE 92: fun4(V,V1,Out) = 0
     [V1>=0,V>=0,Out=0] 
* CE 93: fun4(V,V1,Out) = 1+ fun4(W1,V1,X1)
     [W1>=0,V1>=0,X1+1=Out,W1+1=V] 
* CE 94: fun4(V,V1,Out) = 1+ fun4(W1,X1,Y1)
     [X1>=0,W1>=0,Y1+1=Out,X1+1=V1,W1+1=V] 

### Cost equations --> "Loop" of fun4/3 
* CEs [93] --> Loop 71 
* CEs [94] --> Loop 72 
* CEs [92] --> Loop 73 

#### Loops of fun4/3 
* Loop 71: fun4(V,V1,Out)->  fun4(V',V1,Out')
                  [V1>=0,V>=1,Out=Out'+1,V=V'+1] 
* Loop 72: fun4(V,V1,Out)->  fun4(V',V1',Out')
                  [V1>=1,V>=1,Out=Out'+1,V1=V1'+1,V=V'+1] 
* Loop 73: fun4(V,V1,Out) [V1>=0,V>=0,Out=0] 

### Ranking functions of CR fun4(V,V1,Out) 
* RF of phase [71,72]: [V]

#### Partial ranking functions of CR fun4(V,V1,Out) 
* Partial RF of phase [71,72]:
  - RF of loop [71:1,72:1]:
    V
  - RF of loop [72:1]:
    V1


### Resulting Chains:fun4(V,V1,Out) 
* [[71,72],73]
* [73]


### Merging Chains  fun4/3 into  External patterns of execution 
* [[73]] --> 1 
* [[73,[71,72]]] --> 2 


### Specialization of cost equations fun5/2 
* CE 54 is refined into CE [95] 
* CE 53 is refined into CE [96] 


#### Refined cost equations fun5/2 
* CE 95: fun5(V,Out) = 0
     [V>=0,Out=0] 
* CE 96: fun5(V,Out) = 1+ fun5(W,X)
     [W>=0,X+1=Out,W+1=V] 

### Cost equations --> "Loop" of fun5/2 
* CEs [96] --> Loop 74 
* CEs [95] --> Loop 75 

#### Loops of fun5/2 
* Loop 74: fun5(V,Out)->  fun5(V',Out')
                  [V'>=0,Out=Out'+1,V'+1=V] 
* Loop 75: fun5(V,Out) [V>=0,Out=0] 

### Ranking functions of CR fun5(V,Out) 
* RF of phase [74]: [V]

#### Partial ranking functions of CR fun5(V,Out) 
* Partial RF of phase [74]:
  - RF of loop [74:1]:
    V


### Resulting Chains:fun5(V,Out) 
* [[74],75]
* [75]


### Merging Chains  fun5/2 into  External patterns of execution 
* [[75]] --> 1 
* [[75,[74]]] --> 2 


### Specialization of cost equations fun6/3 
* CE 57 is refined into CE [97] 
* CE 55 is refined into CE [98] 
* CE 56 is refined into CE [99] 


#### Refined cost equations fun6/3 
* CE 97: fun6(V,V1,Out) = 0
     [V1>=0,V>=0,Out=0] 
* CE 98: fun6(V,V1,Out) = 1+ fun6(W1,V1,X1)
     [W1>=0,V1>=0,X1+1=Out,W1+1=V] 
* CE 99: fun6(V,V1,Out) = 1+ fun6(W1,X1,Y1)
     [X1>=0,W1>=0,Y1+1=Out,X1+1=V1,W1+1=V] 

### Cost equations --> "Loop" of fun6/3 
* CEs [98] --> Loop 76 
* CEs [99] --> Loop 77 
* CEs [97] --> Loop 78 

#### Loops of fun6/3 
* Loop 76: fun6(V,V1,Out)->  fun6(V',V1,Out')
                  [V1>=0,V>=1,Out=Out'+1,V=V'+1] 
* Loop 77: fun6(V,V1,Out)->  fun6(V',V1',Out')
                  [V1>=1,V>=1,Out=Out'+1,V1=V1'+1,V=V'+1] 
* Loop 78: fun6(V,V1,Out) [V1>=0,V>=0,Out=0] 

### Ranking functions of CR fun6(V,V1,Out) 
* RF of phase [76,77]: [V]

#### Partial ranking functions of CR fun6(V,V1,Out) 
* Partial RF of phase [76,77]:
  - RF of loop [76:1,77:1]:
    V
  - RF of loop [77:1]:
    V1


### Resulting Chains:fun6(V,V1,Out) 
* [[76,77],78]
* [78]


### Merging Chains  fun6/3 into  External patterns of execution 
* [[78]] --> 1 
* [[78,[76,77]]] --> 2 


### Specialization of cost equations fun7/2 
* CE 63 is refined into CE [100] 
* CE 62 is refined into CE [101] 


#### Refined cost equations fun7/2 
* CE 100: fun7(V,Out) = 0
     [V>=0,Out=0] 
* CE 101: fun7(V,Out) = 1+ fun7(W,X)
     [W>=0,X+1=Out,W+1=V] 

### Cost equations --> "Loop" of fun7/2 
* CEs [101] --> Loop 79 
* CEs [100] --> Loop 80 

#### Loops of fun7/2 
* Loop 79: fun7(V,Out)->  fun7(V',Out')
                  [V'>=0,Out=Out'+1,V'+1=V] 
* Loop 80: fun7(V,Out) [V>=0,Out=0] 

### Ranking functions of CR fun7(V,Out) 
* RF of phase [79]: [V]

#### Partial ranking functions of CR fun7(V,Out) 
* Partial RF of phase [79]:
  - RF of loop [79:1]:
    V


### Resulting Chains:fun7(V,Out) 
* [[79],80]
* [80]


### Merging Chains  fun7/2 into  External patterns of execution 
* [[80]] --> 1 
* [[80,[79]]] --> 2 


### Specialization of cost equations fun8/2 
* CE 65 is refined into CE [102] 
* CE 64 is refined into CE [103] 


#### Refined cost equations fun8/2 
* CE 102: fun8(V,Out) = 0
     [V>=0,Out=0] 
* CE 103: fun8(V,Out) = 1+ fun8(W,X)
     [W>=0,X+1=Out,W+1=V] 

### Cost equations --> "Loop" of fun8/2 
* CEs [103] --> Loop 81 
* CEs [102] --> Loop 82 

#### Loops of fun8/2 
* Loop 81: fun8(V,Out)->  fun8(V',Out')
                  [V'>=0,Out=Out'+1,V'+1=V] 
* Loop 82: fun8(V,Out) [V>=0,Out=0] 

### Ranking functions of CR fun8(V,Out) 
* RF of phase [81]: [V]

#### Partial ranking functions of CR fun8(V,Out) 
* Partial RF of phase [81]:
  - RF of loop [81:1]:
    V


### Resulting Chains:fun8(V,Out) 
* [[81],82]
* [82]


### Merging Chains  fun8/2 into  External patterns of execution 
* [[82]] --> 1 
* [[82,[81]]] --> 2 


### Specialization of cost equations fun9/3 
* CE 68 is refined into CE [104] 
* CE 66 is refined into CE [105] 
* CE 67 is refined into CE [106] 


#### Refined cost equations fun9/3 
* CE 104: fun9(V,V1,Out) = 0
     [V1>=0,V>=0,Out=0] 
* CE 105: fun9(V,V1,Out) = 1+ fun9(W1,V1,X1)
     [W1>=0,V1>=0,X1+1=Out,W1+1=V] 
* CE 106: fun9(V,V1,Out) = 1+ fun9(W1,X1,Y1)
     [X1>=0,W1>=0,Y1+1=Out,X1+1=V1,W1+1=V] 

### Cost equations --> "Loop" of fun9/3 
* CEs [105] --> Loop 83 
* CEs [106] --> Loop 84 
* CEs [104] --> Loop 85 

#### Loops of fun9/3 
* Loop 83: fun9(V,V1,Out)->  fun9(V',V1,Out')
                  [V1>=0,V>=1,Out=Out'+1,V=V'+1] 
* Loop 84: fun9(V,V1,Out)->  fun9(V',V1',Out')
                  [V1>=1,V>=1,Out=Out'+1,V1=V1'+1,V=V'+1] 
* Loop 85: fun9(V,V1,Out) [V1>=0,V>=0,Out=0] 

### Ranking functions of CR fun9(V,V1,Out) 
* RF of phase [83,84]: [V]

#### Partial ranking functions of CR fun9(V,V1,Out) 
* Partial RF of phase [83,84]:
  - RF of loop [83:1,84:1]:
    V
  - RF of loop [84:1]:
    V1


### Resulting Chains:fun9(V,V1,Out) 
* [[83,84],85]
* [85]


### Merging Chains  fun9/3 into  External patterns of execution 
* [[85]] --> 1 
* [[85,[83,84]]] --> 2 


### Specialization of cost equations isList/2 
* CE 59 is refined into CE [107] 
* CE 58 is refined into CE [108] 


#### Refined cost equations isList/2 
* CE 107: isList(V,Out) = 0
     [V>=0,Out=0] 
* CE 108: isList(V,Out) = 1+ isList(W,X)
     [W>=0,X+1=Out,W+1=V] 

### Cost equations --> "Loop" of isList/2 
* CEs [108] --> Loop 86 
* CEs [107] --> Loop 87 

#### Loops of isList/2 
* Loop 86: isList(V,Out)->  isList(V',Out')
                  [V'>=0,Out=Out'+1,V'+1=V] 
* Loop 87: isList(V,Out) [V>=0,Out=0] 

### Ranking functions of CR isList(V,Out) 
* RF of phase [86]: [V]

#### Partial ranking functions of CR isList(V,Out) 
* Partial RF of phase [86]:
  - RF of loop [86:1]:
    V


### Resulting Chains:isList(V,Out) 
* [[86],87]
* [87]


### Merging Chains  isList/2 into  External patterns of execution 
* [[87]] --> 1 
* [[87,[86]]] --> 2 


### Specialization of cost equations isNeList/2 
* CE 28 is refined into CE [109] 
* CE 27 is refined into CE [110] 


#### Refined cost equations isNeList/2 
* CE 109: isNeList(V,Out) = 0
     [V>=0,Out=0] 
* CE 110: isNeList(V,Out) = 1+ isNeList(W,X)
     [W>=0,X+1=Out,W+1=V] 

### Cost equations --> "Loop" of isNeList/2 
* CEs [110] --> Loop 88 
* CEs [109] --> Loop 89 

#### Loops of isNeList/2 
* Loop 88: isNeList(V,Out)->  isNeList(V',Out')
                  [V'>=0,Out=Out'+1,V'+1=V] 
* Loop 89: isNeList(V,Out) [V>=0,Out=0] 

### Ranking functions of CR isNeList(V,Out) 
* RF of phase [88]: [V]

#### Partial ranking functions of CR isNeList(V,Out) 
* Partial RF of phase [88]:
  - RF of loop [88:1]:
    V


### Resulting Chains:isNeList(V,Out) 
* [[88],89]
* [89]


### Merging Chains  isNeList/2 into  External patterns of execution 
* [[89]] --> 1 
* [[89,[88]]] --> 2 


### Specialization of cost equations isNePal/2 
* CE 35 is refined into CE [111] 
* CE 34 is refined into CE [112] 


#### Refined cost equations isNePal/2 
* CE 111: isNePal(V,Out) = 0
     [V>=0,Out=0] 
* CE 112: isNePal(V,Out) = 1+ isNePal(W,X)
     [W>=0,X+1=Out,W+1=V] 

### Cost equations --> "Loop" of isNePal/2 
* CEs [112] --> Loop 90 
* CEs [111] --> Loop 91 

#### Loops of isNePal/2 
* Loop 90: isNePal(V,Out)->  isNePal(V',Out')
                  [V'>=0,Out=Out'+1,V'+1=V] 
* Loop 91: isNePal(V,Out) [V>=0,Out=0] 

### Ranking functions of CR isNePal(V,Out) 
* RF of phase [90]: [V]

#### Partial ranking functions of CR isNePal(V,Out) 
* Partial RF of phase [90]:
  - RF of loop [90:1]:
    V


### Resulting Chains:isNePal(V,Out) 
* [[90],91]
* [91]


### Merging Chains  isNePal/2 into  External patterns of execution 
* [[91]] --> 1 
* [[91,[90]]] --> 2 


### Specialization of cost equations isPal/2 
* CE 61 is refined into CE [113] 
* CE 60 is refined into CE [114] 


#### Refined cost equations isPal/2 
* CE 113: isPal(V,Out) = 0
     [V>=0,Out=0] 
* CE 114: isPal(V,Out) = 1+ isPal(W,X)
     [W>=0,X+1=Out,W+1=V] 

### Cost equations --> "Loop" of isPal/2 
* CEs [114] --> Loop 92 
* CEs [113] --> Loop 93 

#### Loops of isPal/2 
* Loop 92: isPal(V,Out)->  isPal(V',Out')
                  [V'>=0,Out=Out'+1,V'+1=V] 
* Loop 93: isPal(V,Out) [V>=0,Out=0] 

### Ranking functions of CR isPal(V,Out) 
* RF of phase [92]: [V]

#### Partial ranking functions of CR isPal(V,Out) 
* Partial RF of phase [92]:
  - RF of loop [92:1]:
    V


### Resulting Chains:isPal(V,Out) 
* [[92],93]
* [93]


### Merging Chains  isPal/2 into  External patterns of execution 
* [[93]] --> 1 
* [[93,[92]]] --> 2 


### Specialization of cost equations isQid/2 
* CE 30 is refined into CE [115] 
* CE 29 is refined into CE [116] 


#### Refined cost equations isQid/2 
* CE 115: isQid(V,Out) = 0
     [V>=0,Out=0] 
* CE 116: isQid(V,Out) = 1+ isQid(W,X)
     [W>=0,X+1=Out,W+1=V] 

### Cost equations --> "Loop" of isQid/2 
* CEs [116] --> Loop 94 
* CEs [115] --> Loop 95 

#### Loops of isQid/2 
* Loop 94: isQid(V,Out)->  isQid(V',Out')
                  [V'>=0,Out=Out'+1,V'+1=V] 
* Loop 95: isQid(V,Out) [V>=0,Out=0] 

### Ranking functions of CR isQid(V,Out) 
* RF of phase [94]: [V]

#### Partial ranking functions of CR isQid(V,Out) 
* Partial RF of phase [94]:
  - RF of loop [94:1]:
    V


### Resulting Chains:isQid(V,Out) 
* [[94],95]
* [95]


### Merging Chains  isQid/2 into  External patterns of execution 
* [[95]] --> 1 
* [[95,[94]]] --> 2 


### Specialization of cost equations proper/2 
* CE 49 is refined into CE [117] 
* CE 44 is refined into CE [118] 
* CE 47 is refined into CE [119] 
* CE 43 is refined into CE [120] 
* CE 46 is refined into CE [121] 
* CE 42 is refined into CE [122] 
* CE 45 is refined into CE [123] 
* CE 48 is refined into CE [124] 


#### Refined cost equations proper/2 
* CE 117: proper(V,Out) = 0
     [V>=0,Out=0] 
* CE 118: proper(V,Out) = 1
     [Out=7,V=6] 
* CE 119: proper(V,Out) = 1
     [Out=6,V=5] 
* CE 120: proper(V,Out) = 1
     [Out=5,V=4] 
* CE 121: proper(V,Out) = 1
     [Out=4,V=3] 
* CE 122: proper(V,Out) = 1
     [Out=3,V=2] 
* CE 123: proper(V,Out) = 1
     [Out=2,V=1] 
* CE 124: proper(V,Out) = 1
     [Out=1,V=0] 

### Cost equations --> "Loop" of proper/2 
* CEs [117] --> Loop 96 
* CEs [118] --> Loop 97 
* CEs [119] --> Loop 98 
* CEs [120] --> Loop 99 
* CEs [121] --> Loop 100 
* CEs [122] --> Loop 101 
* CEs [123] --> Loop 102 
* CEs [124] --> Loop 103 

#### Loops of proper/2 
* Loop 96: proper(V,Out) [V>=0,Out=0] 
* Loop 97: proper(V,Out) [Out=7,V=6] 
* Loop 98: proper(V,Out) [Out=6,V=5] 
* Loop 99: proper(V,Out) [Out=5,V=4] 
* Loop 100: proper(V,Out) [Out=4,V=3] 
* Loop 101: proper(V,Out) [Out=3,V=2] 
* Loop 102: proper(V,Out) [Out=2,V=1] 
* Loop 103: proper(V,Out) [Out=1,V=0] 

### Ranking functions of CR proper(V,Out) 

#### Partial ranking functions of CR proper(V,Out) 


### Resulting Chains:proper(V,Out) 
* [103]
* [102]
* [101]
* [100]
* [99]
* [98]
* [97]
* [96]


### Merging Chains  proper/2 into  External patterns of execution 
* [[103]] --> 1 
* [[102]] --> 2 
* [[101]] --> 3 
* [[100]] --> 4 
* [[99]] --> 5 
* [[98]] --> 6 
* [[97]] --> 7 
* [[96]] --> 8 


### Specialization of cost equations top/2 
* CE 26 is refined into CE [125] 
* CE 24 is refined into CE [126] 
* CE 25 is refined into CE [127,128,129,130,131,132,133,134] 


#### Refined cost equations top/2 
* CE 125: top(V,Out) = 0
     [V>=0,Out=0] 
* CE 126: top(V,Out) = 1+ top(V,Out)
     [V>=1] 
* CE 127: top(V,Out) = 1+ proper(W,X):1+ top(Y,Out)
     [Y=1,X=1,W=0,V=1] 
* CE 128: top(V,Out) = 1+ proper(W,X):2+ top(Y,Out)
     [Y=2,X=2,W=1,V=2] 
* CE 129: top(V,Out) = 1+ proper(W,X):3+ top(Y,Out)
     [Y=3,X=3,W=2,V=3] 
* CE 130: top(V,Out) = 1+ proper(W,X):4+ top(Y,Out)
     [Y=4,X=4,W=3,V=4] 
* CE 131: top(V,Out) = 1+ proper(W,X):5+ top(Y,Out)
     [Y=5,X=5,W=4,V=5] 
* CE 132: top(V,Out) = 1+ proper(W,X):6+ top(Y,Out)
     [Y=6,X=6,W=5,V=6] 
* CE 133: top(V,Out) = 1+ proper(W,X):7+ top(Y,Out)
     [Y=7,X=7,W=6,V=7] 
* CE 134: top(V,Out) = 1+ proper(W,X):8+ top(Y,Out)
     [W>=0,W+1=V,Y=0,X=0] 

### Cost equations --> "Loop" of top/2 
* CEs [134] --> Loop 104 
* CEs [133] --> Loop 105 
* CEs [132] --> Loop 106 
* CEs [131] --> Loop 107 
* CEs [130] --> Loop 108 
* CEs [129] --> Loop 109 
* CEs [128] --> Loop 110 
* CEs [126,127] --> Loop 111 
* CEs [125] --> Loop 112 

#### Loops of top/2 
* Loop 104: top(V,Out)->  top(V',Out)
                  [V>=1,V'=0] 
* Loop 105: top(V,Out)->  top(V',Out)
                  [V'=7,V=7] 
* Loop 106: top(V,Out)->  top(V',Out)
                  [V'=6,V=6] 
* Loop 107: top(V,Out)->  top(V',Out)
                  [V'=5,V=5] 
* Loop 108: top(V,Out)->  top(V',Out)
                  [V'=4,V=4] 
* Loop 109: top(V,Out)->  top(V',Out)
                  [V'=3,V=3] 
* Loop 110: top(V,Out)->  top(V',Out)
                  [V'=2,V=2] 
* Loop 111: top(V,Out)->  top(V,Out)
                  [V>=1] 
* Loop 112: top(V,Out) [V>=0,Out=0] 

### Ranking functions of CR top(V,Out) 

#### Partial ranking functions of CR top(V,Out) 


### Resulting Chains:top(V,Out) 
* [[105,106,107,108,109,110,111]]...
* [[105,106,107,108,109,110,111],112]
* [[105,106,107,108,109,110,111],104,112]
* [112]
* [104,112]


### Merging Chains  top/2 into  External patterns of execution 
* [[112,104],[112],[112,104,[105,106,107,108,109,110,111]],[112,[105,106,107,108,109,110,111]]] --> 1 
* [[[105,106,107,108,109,110,111]]] --> 2 


### Specialization of cost equations start/2 
* CE 2 is refined into CE [135,136] 
* CE 3 is refined into CE [137,138] 
* CE 4 is refined into CE [139,140] 
* CE 5 is refined into CE [141,142] 
* CE 6 is refined into CE [143,144] 
* CE 7 is refined into CE [145,146] 
* CE 8 is refined into CE [147,148] 
* CE 9 is refined into CE [149,150] 
* CE 10 is refined into CE [151,152,153,154,155,156,157,158] 
* CE 11 is refined into CE [159,160] 
* CE 12 is refined into CE [161,162] 
* CE 13 is refined into CE [163,164] 
* CE 14 is refined into CE [165,166] 
* CE 15 is refined into CE [167,168] 
* CE 16 is refined into CE [169,170] 
* CE 17 is refined into CE [171,172] 
* CE 18 is refined into CE [173,174] 
* CE 19 is refined into CE [175,176] 
* CE 20 is refined into CE [177,178] 
* CE 21 is refined into CE [179,180] 


#### Refined cost equations start/2 
* CE 135: start(V,V1) = 0+ fun(V,W1):1
     [V>=0,W1=0] 
* CE 136: start(V,V1) = 0+ fun(V,W1):2
     [V>=W1,W1>=1] 
* CE 137: start(V,V1) = 0+ top(V,W1):1
     [V>=0,W1=0] 
* CE 138: start(V,V1) = 0+ top(V,W1):2
     [V>=1] 
* CE 139: start(V,V1) = 0+ isNeList(V,W1):1
     [V>=0,W1=0] 
* CE 140: start(V,V1) = 0+ isNeList(V,W1):2
     [V>=W1,W1>=1] 
* CE 141: start(V,V1) = 0+ isQid(V,W1):1
     [V>=0,W1=0] 
* CE 142: start(V,V1) = 0+ isQid(V,W1):2
     [V>=W1,W1>=1] 
* CE 143: start(V,V1) = 0+ fun1(V,V1,W1):1
     [V1>=0,V>=0,W1=0] 
* CE 144: start(V,V1) = 0+ fun1(V,V1,W1):2
     [V>=W1,W1>=1,V1>=0] 
* CE 145: start(V,V1) = 0+ isNePal(V,W1):1
     [V>=0,W1=0] 
* CE 146: start(V,V1) = 0+ isNePal(V,W1):2
     [V>=W1,W1>=1] 
* CE 147: start(V,V1) = 0+ fun2(V,V1,W1):1
     [V1>=0,V>=0,W1=0] 
* CE 148: start(V,V1) = 0+ fun2(V,V1,W1):2
     [V+V1>=W1,W1>=1,V1>=0,V>=0] 
* CE 149: start(V,V1) = 0+ fun3(V,W1):1
     [V>=0,W1=0] 
* CE 150: start(V,V1) = 0+ fun3(V,W1):2
     [V>=W1,W1>=1] 
* CE 151: start(V,V1) = 0+ proper(W1,X1):1
     [X1=1,W1=0,V=0] 
* CE 152: start(V,V1) = 0+ proper(W1,X1):2
     [X1=2,W1=1,V=1] 
* CE 153: start(V,V1) = 0+ proper(W1,X1):3
     [X1=3,W1=2,V=2] 
* CE 154: start(V,V1) = 0+ proper(W1,X1):4
     [X1=4,W1=3,V=3] 
* CE 155: start(V,V1) = 0+ proper(W1,X1):5
     [X1=5,W1=4,V=4] 
* CE 156: start(V,V1) = 0+ proper(W1,X1):6
     [X1=6,W1=5,V=5] 
* CE 157: start(V,V1) = 0+ proper(W1,X1):7
     [X1=7,W1=6,V=6] 
* CE 158: start(V,V1) = 0+ proper(V,W1):8
     [V>=0,W1=0] 
* CE 159: start(V,V1) = 0+ fun4(V,V1,W1):1
     [V1>=0,V>=0,W1=0] 
* CE 160: start(V,V1) = 0+ fun4(V,V1,W1):2
     [V>=W1,W1>=1,V1>=0] 
* CE 161: start(V,V1) = 0+ fun5(V,W1):1
     [V>=0,W1=0] 
* CE 162: start(V,V1) = 0+ fun5(V,W1):2
     [V>=W1,W1>=1] 
* CE 163: start(V,V1) = 0+ fun6(V,V1,W1):1
     [V1>=0,V>=0,W1=0] 
* CE 164: start(V,V1) = 0+ fun6(V,V1,W1):2
     [V>=W1,W1>=1,V1>=0] 
* CE 165: start(V,V1) = 0+ isList(V,W1):1
     [V>=0,W1=0] 
* CE 166: start(V,V1) = 0+ isList(V,W1):2
     [V>=W1,W1>=1] 
* CE 167: start(V,V1) = 0+ isPal(V,W1):1
     [V>=0,W1=0] 
* CE 168: start(V,V1) = 0+ isPal(V,W1):2
     [V>=W1,W1>=1] 
* CE 169: start(V,V1) = 0+ fun7(V,W1):1
     [V>=0,W1=0] 
* CE 170: start(V,V1) = 0+ fun7(V,W1):2
     [V>=W1,W1>=1] 
* CE 171: start(V,V1) = 0+ fun8(V,W1):1
     [V>=0,W1=0] 
* CE 172: start(V,V1) = 0+ fun8(V,W1):2
     [V>=W1,W1>=1] 
* CE 173: start(V,V1) = 0+ fun9(V,V1,W1):1
     [V1>=0,V>=0,W1=0] 
* CE 174: start(V,V1) = 0+ fun9(V,V1,W1):2
     [V>=W1,W1>=1,V1>=0] 
* CE 175: start(V,V1) = 0+ fun10(V,W1):1
     [V>=0,W1=0] 
* CE 176: start(V,V1) = 0+ fun10(V,W1):2
     [V>=W1,W1>=1] 
* CE 177: start(V,V1) = 0+ fun11(V,W1):1
     [V>=0,W1=0] 
* CE 178: start(V,V1) = 0+ fun11(V,W1):2
     [V>=W1,W1>=1] 
* CE 179: start(V,V1) = 0+ fun12(V,W1):1
     [V>=0,W1=0] 
* CE 180: start(V,V1) = 0+ fun12(V,W1):2
     [V>=W1,W1>=1] 

### Cost equations --> "Loop" of start/2 
* CEs [157] --> Loop 113 
* CEs [156] --> Loop 114 
* CEs [155] --> Loop 115 
* CEs [154] --> Loop 116 
* CEs [153] --> Loop 117 
* CEs [152] --> Loop 118 
* CEs [135,136,137,139,140,141,142,143,144,145,146,147,148,149,150,151,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180] --> Loop 119 
* CEs [138] --> Loop 120 

#### Loops of start/2 
* Loop 113: start(V,V1) [V=6] 
* Loop 114: start(V,V1) [V=5] 
* Loop 115: start(V,V1) [V=4] 
* Loop 116: start(V,V1) [V=3] 
* Loop 117: start(V,V1) [V=2] 
* Loop 118: start(V,V1) [V=1] 
* Loop 119: start(V,V1) [V>=0] 
* Loop 120: start(V,V1) [V>=1] 

### Ranking functions of CR start(V,V1) 

#### Partial ranking functions of CR start(V,V1) 


### Resulting Chains:start(V,V1) 
* [120]...
* [119]
* [118]
* [117]
* [116]
* [115]
* [114]
* [113]


### Merging Chains  start/2 into  External patterns of execution 
* [[118],[119]] --> 1 
* [[117]] --> 2 
* [[116]] --> 3 
* [[115]] --> 4 
* [[114]] --> 5 
* [[113]] --> 6 
* [[120]] --> 7 


Computing Bounds
=====================================

#### Cost of loops [54] 

 * loop 54:fun(V,Out) -> [fun(V',Out')] 
1
#### Cost of phase [54]:fun(V,Out) -> [fun(V',Out')] 
1*it(54)+0
  Such that:it(54) =< V
it(54) =< V-V'

#### Cost of chains of fun(V,Out):
* Chain [[54],55]: 1*it(54)+0
  Such that:it(54) =< Out

  with precondition: [Out>=1,V>=Out] 

* Chain [55]: 0
  with precondition: [Out=0,V>=0] 


#### Cost of loops [56,57] 

 * loop 56:fun1(V,V1,Out) -> [fun1(V',V1',Out')] 
1
 * loop 57:fun1(V,V1,Out) -> [fun1(V',V1',Out')] 
1
#### Cost of phase [56,57]:fun1(V,V1,Out) -> [fun1(V',V1',Out')] 
1*it(56)+1*it(57)+0
  Such that:it(57) =< V1
it(57) =< V1-V1'
aux(1) =< V
aux(2) =< V-V'
it(56) =< aux(1)
it(57) =< aux(1)
it(56) =< aux(2)
it(57) =< aux(2)

#### Cost of chains of fun1(V,V1,Out):
* Chain [[56,57],58]: 1*it(56)+1*it(57)+0
  Such that:aux(1) =< V
it(57) =< V1
aux(2) =< Out
it(56) =< aux(1)
it(57) =< aux(1)
it(56) =< aux(2)
it(57) =< aux(2)

  with precondition: [V1>=0,Out>=1,V>=Out] 

* Chain [58]: 0
  with precondition: [Out=0,V>=0,V1>=0] 


#### Cost of loops [59] 

 * loop 59:fun10(V,Out) -> [fun10(V',Out')] 
1
#### Cost of phase [59]:fun10(V,Out) -> [fun10(V',Out')] 
1*it(59)+0
  Such that:it(59) =< V
it(59) =< V-V'

#### Cost of chains of fun10(V,Out):
* Chain [[59],60]: 1*it(59)+0
  Such that:it(59) =< Out

  with precondition: [Out>=1,V>=Out] 

* Chain [60]: 0
  with precondition: [Out=0,V>=0] 


#### Cost of loops [61] 

 * loop 61:fun11(V,Out) -> [fun11(V',Out')] 
1
#### Cost of phase [61]:fun11(V,Out) -> [fun11(V',Out')] 
1*it(61)+0
  Such that:it(61) =< V
it(61) =< V-V'

#### Cost of chains of fun11(V,Out):
* Chain [[61],62]: 1*it(61)+0
  Such that:it(61) =< Out

  with precondition: [Out>=1,V>=Out] 

* Chain [62]: 0
  with precondition: [Out=0,V>=0] 


#### Cost of loops [63] 

 * loop 63:fun12(V,Out) -> [fun12(V',Out')] 
1
#### Cost of phase [63]:fun12(V,Out) -> [fun12(V',Out')] 
1*it(63)+0
  Such that:it(63) =< V
it(63) =< V-V'

#### Cost of chains of fun12(V,Out):
* Chain [[63],64]: 1*it(63)+0
  Such that:it(63) =< Out

  with precondition: [Out>=1,V>=Out] 

* Chain [64]: 0
  with precondition: [Out=0,V>=0] 


#### Cost of loops [65,66,67] 

 * loop 65:fun2(V,V1,Out) -> [fun2(V',V1',Out')] 
1
 * loop 66:fun2(V,V1,Out) -> [fun2(V',V1',Out')] 
1
 * loop 67:fun2(V,V1,Out) -> [fun2(V',V1',Out')] 
1
#### Cost of phase [65,66,67]:fun2(V,V1,Out) -> [fun2(V',V1',Out')] 
1*it(65)+1*it(66)+1*it(67)+0
  Such that:aux(3) =< V
aux(4) =< V+V1
aux(5) =< V+V1-V'-V1'
aux(6) =< V-V'
aux(7) =< V1
aux(8) =< V1-V1'
it(66) =< aux(3)
it(67) =< aux(3)
it(65) =< aux(4)
it(66) =< aux(4)
it(67) =< aux(4)
it(65) =< aux(5)
it(66) =< aux(5)
it(67) =< aux(5)
it(66) =< aux(6)
it(67) =< aux(6)
it(65) =< aux(7)
it(67) =< aux(7)
it(65) =< aux(8)
it(67) =< aux(8)

#### Cost of chains of fun2(V,V1,Out):
* Chain [[65,66,67],68]: 1*it(65)+1*it(66)+1*it(67)+0
  Such that:aux(9) =< V
aux(10) =< V+V1
aux(11) =< V1
it(66) =< aux(9)
it(67) =< aux(9)
it(65) =< aux(10)
it(66) =< aux(10)
it(67) =< aux(10)
it(65) =< aux(11)
it(67) =< aux(11)

  with precondition: [V>=0,V1>=0,Out>=1,V+V1>=Out] 

* Chain [68]: 0
  with precondition: [Out=0,V>=0,V1>=0] 


#### Cost of loops [69] 

 * loop 69:fun3(V,Out) -> [fun3(V',Out')] 
1
#### Cost of phase [69]:fun3(V,Out) -> [fun3(V',Out')] 
1*it(69)+0
  Such that:it(69) =< V
it(69) =< V-V'

#### Cost of chains of fun3(V,Out):
* Chain [[69],70]: 1*it(69)+0
  Such that:it(69) =< Out

  with precondition: [Out>=1,V>=Out] 

* Chain [70]: 0
  with precondition: [Out=0,V>=0] 


#### Cost of loops [71,72] 

 * loop 71:fun4(V,V1,Out) -> [fun4(V',V1',Out')] 
1
 * loop 72:fun4(V,V1,Out) -> [fun4(V',V1',Out')] 
1
#### Cost of phase [71,72]:fun4(V,V1,Out) -> [fun4(V',V1',Out')] 
1*it(71)+1*it(72)+0
  Such that:it(72) =< V1
it(72) =< V1-V1'
aux(12) =< V
aux(13) =< V-V'
it(71) =< aux(12)
it(72) =< aux(12)
it(71) =< aux(13)
it(72) =< aux(13)

#### Cost of chains of fun4(V,V1,Out):
* Chain [[71,72],73]: 1*it(71)+1*it(72)+0
  Such that:aux(12) =< V
it(72) =< V1
aux(13) =< Out
it(71) =< aux(12)
it(72) =< aux(12)
it(71) =< aux(13)
it(72) =< aux(13)

  with precondition: [V1>=0,Out>=1,V>=Out] 

* Chain [73]: 0
  with precondition: [Out=0,V>=0,V1>=0] 


#### Cost of loops [74] 

 * loop 74:fun5(V,Out) -> [fun5(V',Out')] 
1
#### Cost of phase [74]:fun5(V,Out) -> [fun5(V',Out')] 
1*it(74)+0
  Such that:it(74) =< V
it(74) =< V-V'

#### Cost of chains of fun5(V,Out):
* Chain [[74],75]: 1*it(74)+0
  Such that:it(74) =< Out

  with precondition: [Out>=1,V>=Out] 

* Chain [75]: 0
  with precondition: [Out=0,V>=0] 


#### Cost of loops [76,77] 

 * loop 76:fun6(V,V1,Out) -> [fun6(V',V1',Out')] 
1
 * loop 77:fun6(V,V1,Out) -> [fun6(V',V1',Out')] 
1
#### Cost of phase [76,77]:fun6(V,V1,Out) -> [fun6(V',V1',Out')] 
1*it(76)+1*it(77)+0
  Such that:it(77) =< V1
it(77) =< V1-V1'
aux(14) =< V
aux(15) =< V-V'
it(76) =< aux(14)
it(77) =< aux(14)
it(76) =< aux(15)
it(77) =< aux(15)

#### Cost of chains of fun6(V,V1,Out):
* Chain [[76,77],78]: 1*it(76)+1*it(77)+0
  Such that:aux(14) =< V
it(77) =< V1
aux(15) =< Out
it(76) =< aux(14)
it(77) =< aux(14)
it(76) =< aux(15)
it(77) =< aux(15)

  with precondition: [V1>=0,Out>=1,V>=Out] 

* Chain [78]: 0
  with precondition: [Out=0,V>=0,V1>=0] 


#### Cost of loops [79] 

 * loop 79:fun7(V,Out) -> [fun7(V',Out')] 
1
#### Cost of phase [79]:fun7(V,Out) -> [fun7(V',Out')] 
1*it(79)+0
  Such that:it(79) =< V
it(79) =< V-V'

#### Cost of chains of fun7(V,Out):
* Chain [[79],80]: 1*it(79)+0
  Such that:it(79) =< Out

  with precondition: [Out>=1,V>=Out] 

* Chain [80]: 0
  with precondition: [Out=0,V>=0] 


#### Cost of loops [81] 

 * loop 81:fun8(V,Out) -> [fun8(V',Out')] 
1
#### Cost of phase [81]:fun8(V,Out) -> [fun8(V',Out')] 
1*it(81)+0
  Such that:it(81) =< V
it(81) =< V-V'

#### Cost of chains of fun8(V,Out):
* Chain [[81],82]: 1*it(81)+0
  Such that:it(81) =< Out

  with precondition: [Out>=1,V>=Out] 

* Chain [82]: 0
  with precondition: [Out=0,V>=0] 


#### Cost of loops [83,84] 

 * loop 83:fun9(V,V1,Out) -> [fun9(V',V1',Out')] 
1
 * loop 84:fun9(V,V1,Out) -> [fun9(V',V1',Out')] 
1
#### Cost of phase [83,84]:fun9(V,V1,Out) -> [fun9(V',V1',Out')] 
1*it(83)+1*it(84)+0
  Such that:it(84) =< V1
it(84) =< V1-V1'
aux(16) =< V
aux(17) =< V-V'
it(83) =< aux(16)
it(84) =< aux(16)
it(83) =< aux(17)
it(84) =< aux(17)

#### Cost of chains of fun9(V,V1,Out):
* Chain [[83,84],85]: 1*it(83)+1*it(84)+0
  Such that:aux(16) =< V
it(84) =< V1
aux(17) =< Out
it(83) =< aux(16)
it(84) =< aux(16)
it(83) =< aux(17)
it(84) =< aux(17)

  with precondition: [V1>=0,Out>=1,V>=Out] 

* Chain [85]: 0
  with precondition: [Out=0,V>=0,V1>=0] 


#### Cost of loops [86] 

 * loop 86:isList(V,Out) -> [isList(V',Out')] 
1
#### Cost of phase [86]:isList(V,Out) -> [isList(V',Out')] 
1*it(86)+0
  Such that:it(86) =< V
it(86) =< V-V'

#### Cost of chains of isList(V,Out):
* Chain [[86],87]: 1*it(86)+0
  Such that:it(86) =< Out

  with precondition: [Out>=1,V>=Out] 

* Chain [87]: 0
  with precondition: [Out=0,V>=0] 


#### Cost of loops [88] 

 * loop 88:isNeList(V,Out) -> [isNeList(V',Out')] 
1
#### Cost of phase [88]:isNeList(V,Out) -> [isNeList(V',Out')] 
1*it(88)+0
  Such that:it(88) =< V
it(88) =< V-V'

#### Cost of chains of isNeList(V,Out):
* Chain [[88],89]: 1*it(88)+0
  Such that:it(88) =< Out

  with precondition: [Out>=1,V>=Out] 

* Chain [89]: 0
  with precondition: [Out=0,V>=0] 


#### Cost of loops [90] 

 * loop 90:isNePal(V,Out) -> [isNePal(V',Out')] 
1
#### Cost of phase [90]:isNePal(V,Out) -> [isNePal(V',Out')] 
1*it(90)+0
  Such that:it(90) =< V
it(90) =< V-V'

#### Cost of chains of isNePal(V,Out):
* Chain [[90],91]: 1*it(90)+0
  Such that:it(90) =< Out

  with precondition: [Out>=1,V>=Out] 

* Chain [91]: 0
  with precondition: [Out=0,V>=0] 


#### Cost of loops [92] 

 * loop 92:isPal(V,Out) -> [isPal(V',Out')] 
1
#### Cost of phase [92]:isPal(V,Out) -> [isPal(V',Out')] 
1*it(92)+0
  Such that:it(92) =< V
it(92) =< V-V'

#### Cost of chains of isPal(V,Out):
* Chain [[92],93]: 1*it(92)+0
  Such that:it(92) =< Out

  with precondition: [Out>=1,V>=Out] 

* Chain [93]: 0
  with precondition: [Out=0,V>=0] 


#### Cost of loops [94] 

 * loop 94:isQid(V,Out) -> [isQid(V',Out')] 
1
#### Cost of phase [94]:isQid(V,Out) -> [isQid(V',Out')] 
1*it(94)+0
  Such that:it(94) =< V
it(94) =< V-V'

#### Cost of chains of isQid(V,Out):
* Chain [[94],95]: 1*it(94)+0
  Such that:it(94) =< Out

  with precondition: [Out>=1,V>=Out] 

* Chain [95]: 0
  with precondition: [Out=0,V>=0] 


#### Cost of chains of proper(V,Out):
* Chain [103]: 1
  with precondition: [V=0,Out=1] 

* Chain [102]: 1
  with precondition: [V=1,Out=2] 

* Chain [101]: 1
  with precondition: [V=2,Out=3] 

* Chain [100]: 1
  with precondition: [V=3,Out=4] 

* Chain [99]: 1
  with precondition: [V=4,Out=5] 

* Chain [98]: 1
  with precondition: [V=5,Out=6] 

* Chain [97]: 1
  with precondition: [V=6,Out=7] 

* Chain [96]: 0
  with precondition: [Out=0,V>=0] 


#### Cost of loops [105,106,107,108,109,110,111] 

 * loop 105:top(V,Out) -> [top(V',Out')] 
2
 * loop 106:top(V,Out) -> [top(V',Out')] 
2
 * loop 107:top(V,Out) -> [top(V',Out')] 
2
 * loop 108:top(V,Out) -> [top(V',Out')] 
2
 * loop 109:top(V,Out) -> [top(V',Out')] 
2
 * loop 110:top(V,Out) -> [top(V',Out')] 
2
 * loop 111:top(V,Out) -> [top(V',Out')] 
2
#### Cost of phase [105,106,107,108,109,110,111]:top(V,Out) -> [top(V',Out')] 
14*it(105)+0
#### Cost of phase [105,106,107,108,109,110,111]:top(V,Out) -> [top(V',Out')] 
14*it(105)+0
#### Cost of phase [105,106,107,108,109,110,111]:top(V,Out) -> [top(V',Out')] 
14*it(105)+0
#### Cost of chains of top(V,Out):
* Chain [[105,106,107,108,109,110,111]]...: 14*it(105)+0
  with precondition: [V>=1] 

* Chain [[105,106,107,108,109,110,111],112]: 14*it(105)+0
  with precondition: [Out=0,V>=1] 

* Chain [[105,106,107,108,109,110,111],104,112]: 14*it(105)+1
  with precondition: [Out=0,V>=1] 

* Chain [112]: 0
  with precondition: [Out=0,V>=0] 

* Chain [104,112]: 1
  with precondition: [Out=0,V>=1] 


#### Cost of chains of start(V,V1):
* Chain [120]...: 14*s(3)+0
  with precondition: [V>=1] 

* Chain [119]: 17*s(4)+1*s(5)+4*s(9)+1*s(16)+1*s(17)+1*s(18)+1
  Such that:s(14) =< V+V1
aux(23) =< V
aux(24) =< V1
s(4) =< aux(23)
s(9) =< aux(24)
s(16) =< aux(23)
s(17) =< aux(23)
s(18) =< s(14)
s(16) =< s(14)
s(17) =< s(14)
s(18) =< aux(24)
s(17) =< aux(24)
s(9) =< aux(23)

  with precondition: [V>=0] 

* Chain [118]: 1
  with precondition: [V=1] 

* Chain [117]: 1
  with precondition: [V=2] 

* Chain [116]: 1
  with precondition: [V=3] 

* Chain [115]: 1
  with precondition: [V=4] 

* Chain [114]: 1
  with precondition: [V=5] 

* Chain [113]: 1
  with precondition: [V=6] 


Closed-form bounds of start(V,V1): 
-------------------------------------
* Chain [120]... with precondition: [V>=1] 
    - Upper bound: inf 
    - Complexity: infinity 
* Chain [119] with precondition: [V>=0] 
    - Upper bound: inf 
    - Complexity: infinity 
* Chain [118] with precondition: [V=1] 
    - Upper bound: 1 
    - Complexity: constant 
* Chain [117] with precondition: [V=2] 
    - Upper bound: 1 
    - Complexity: constant 
* Chain [116] with precondition: [V=3] 
    - Upper bound: 1 
    - Complexity: constant 
* Chain [115] with precondition: [V=4] 
    - Upper bound: 1 
    - Complexity: constant 
* Chain [114] with precondition: [V=5] 
    - Upper bound: 1 
    - Complexity: constant 
* Chain [113] with precondition: [V=6] 
    - Upper bound: 1 
    - Complexity: constant 

### Maximum cost of start(V,V1): inf 
Asymptotic class: infinity 

Time statistics: 
-------------------------------------
* Partial evaluation computed in 35 ms.
* Invariants computed in 101 ms.
   - Backward Invariants 42 ms.
   - Transitive Invariants 27 ms.
* Refinement performed in 175 ms.
* Termination proved in 32 ms.
* Upper bounds computed in 153 ms.
   - Equation cost structures 55 ms.
   - Phase cost structures 60 ms.
   - Chain cost structures 45 ms.
   - Solving cost expressions 1 ms.
* Total analysis performed in 579 ms.

