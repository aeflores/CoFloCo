
Preprocessing Cost Relations
=====================================

#### Computed strongly connected components 
0. recursive  : [fun/3]
1. recursive  : [fun1/3]
2. recursive  : [fun10/4]
3. recursive  : [fun11/4]
4. recursive  : [fun12/3]
5. recursive  : [fun13/3]
6. recursive  : [fun14/2]
7. recursive  : [fun15/3]
8. recursive  : [fun16/2]
9. recursive  : [fun17/4]
10. recursive  : [fun18/4]
11. recursive  : [fun19/3]
12. recursive  : [fun2/3]
13. recursive  : [fun20/3]
14. recursive  : [fun21/2]
15. recursive  : [fun22/3]
16. recursive  : [fun23/2]
17. recursive  : [fun24/2]
18. recursive  : [fun25/2]
19. recursive  : [fun26/4]
20. recursive  : [fun27/4]
21. recursive  : [fun28/3]
22. recursive  : [fun29/4]
23. recursive  : [fun3/4]
24. recursive  : [fun30/3]
25. recursive  : [fun31/4]
26. recursive  : [fun32/4]
27. recursive  : [fun33/3]
28. recursive  : [fun34/4]
29. recursive  : [fun35/3]
30. recursive  : [fun36/4]
31. recursive  : [fun4/2]
32. recursive  : [fun5/3]
33. recursive  : [fun6/3]
34. recursive  : [fun7/4]
35. recursive  : [fun8/2]
36. recursive  : [fun9/2]
37. recursive  : [isList/2]
38. recursive  : [isNeList/2]
39. recursive  : [isNePal/2]
40. recursive  : [isPal/2]
41. recursive  : [isPalListKind/2]
42. recursive  : [isQid/2]
43. non_recursive  : [proper/2]
44. recursive  : [top/2]
45. non_recursive  : [start/3]

#### Obtained direct recursion through partial evaluation 
0. SCC is partially evaluated into fun/3
1. SCC is partially evaluated into fun1/3
2. SCC is partially evaluated into fun10/4
3. SCC is partially evaluated into fun11/4
4. SCC is partially evaluated into fun12/3
5. SCC is partially evaluated into fun13/3
6. SCC is partially evaluated into fun14/2
7. SCC is partially evaluated into fun15/3
8. SCC is partially evaluated into fun16/2
9. SCC is partially evaluated into fun17/4
10. SCC is partially evaluated into fun18/4
11. SCC is partially evaluated into fun19/3
12. SCC is partially evaluated into fun2/3
13. SCC is partially evaluated into fun20/3
14. SCC is partially evaluated into fun21/2
15. SCC is partially evaluated into fun22/3
16. SCC is partially evaluated into fun23/2
17. SCC is partially evaluated into fun24/2
18. SCC is partially evaluated into fun25/2
19. SCC is partially evaluated into fun26/4
20. SCC is partially evaluated into fun27/4
21. SCC is partially evaluated into fun28/3
22. SCC is partially evaluated into fun29/4
23. SCC is partially evaluated into fun3/4
24. SCC is partially evaluated into fun30/3
25. SCC is partially evaluated into fun31/4
26. SCC is partially evaluated into fun32/4
27. SCC is partially evaluated into fun33/3
28. SCC is partially evaluated into fun34/4
29. SCC is partially evaluated into fun35/3
30. SCC is partially evaluated into fun36/4
31. SCC is partially evaluated into fun4/2
32. SCC is partially evaluated into fun5/3
33. SCC is partially evaluated into fun6/3
34. SCC is partially evaluated into fun7/4
35. SCC is partially evaluated into fun8/2
36. SCC is partially evaluated into fun9/2
37. SCC is partially evaluated into isList/2
38. SCC is partially evaluated into isNeList/2
39. SCC is partially evaluated into isNePal/2
40. SCC is partially evaluated into isPal/2
41. SCC is partially evaluated into isPalListKind/2
42. SCC is partially evaluated into isQid/2
43. SCC is partially evaluated into proper/2
44. SCC is partially evaluated into top/2
45. SCC is partially evaluated into start/3

Control-Flow Refinement of Cost Relations
=====================================

### Specialization of cost equations fun/3 
* CE 49 is refined into CE [173] 
* CE 48 is refined into CE [174] 
* CE 47 is refined into CE [175] 


#### Refined cost equations fun/3 
* CE 173: fun(V1,V,Out) = 0
     [V>=0,V1>=0,Out=0] 
* CE 174: fun(V1,V,Out) = 1+ fun(W1,V,X1)
     [W1>=0,V>=0,X1+1=Out,W1+1=V1] 
* CE 175: fun(V1,V,Out) = 1+ fun(W1,X1,Y1)
     [X1>=0,W1>=0,Y1+1=Out,X1+1=V,W1+1=V1] 

### Cost equations --> "Loop" of fun/3 
* CEs [174] --> Loop 127 
* CEs [175] --> Loop 128 
* CEs [173] --> Loop 129 

#### Loops of fun/3 
* Loop 127: fun(V1,V,Out)->  fun(V1',V,Out')
                  [V>=0,V1>=1,Out=Out'+1,V1=V1'+1] 
* Loop 128: fun(V1,V,Out)->  fun(V1',V',Out')
                  [V>=1,V1>=1,Out=Out'+1,V=V'+1,V1=V1'+1] 
* Loop 129: fun(V1,V,Out) [V>=0,V1>=0,Out=0] 

### Ranking functions of CR fun(V1,V,Out) 
* RF of phase [127,128]: [V1]

#### Partial ranking functions of CR fun(V1,V,Out) 
* Partial RF of phase [127,128]:
  - RF of loop [127:1,128:1]:
    V1
  - RF of loop [128:1]:
    V


### Resulting Chains:fun(V1,V,Out) 
* [[127,128],129]
* [129]


### Merging Chains  fun/3 into  External patterns of execution 
* [[129]] --> 1 
* [[129,[127,128]]] --> 2 


### Specialization of cost equations fun1/3 
* CE 57 is refined into CE [176] 
* CE 55 is refined into CE [177] 
* CE 56 is refined into CE [178] 


#### Refined cost equations fun1/3 
* CE 176: fun1(V1,V,Out) = 0
     [V>=0,V1>=0,Out=0] 
* CE 177: fun1(V1,V,Out) = 1+ fun1(W1,V,X1)
     [W1>=0,V>=0,X1+1=Out,W1+1=V1] 
* CE 178: fun1(V1,V,Out) = 1+ fun1(W1,X1,Y1)
     [X1>=0,W1>=0,Y1+1=Out,X1+1=V,W1+1=V1] 

### Cost equations --> "Loop" of fun1/3 
* CEs [177] --> Loop 130 
* CEs [178] --> Loop 131 
* CEs [176] --> Loop 132 

#### Loops of fun1/3 
* Loop 130: fun1(V1,V,Out)->  fun1(V1',V,Out')
                  [V>=0,V1>=1,Out=Out'+1,V1=V1'+1] 
* Loop 131: fun1(V1,V,Out)->  fun1(V1',V',Out')
                  [V>=1,V1>=1,Out=Out'+1,V=V'+1,V1=V1'+1] 
* Loop 132: fun1(V1,V,Out) [V>=0,V1>=0,Out=0] 

### Ranking functions of CR fun1(V1,V,Out) 
* RF of phase [130,131]: [V1]

#### Partial ranking functions of CR fun1(V1,V,Out) 
* Partial RF of phase [130,131]:
  - RF of loop [130:1,131:1]:
    V1
  - RF of loop [131:1]:
    V


### Resulting Chains:fun1(V1,V,Out) 
* [[130,131],132]
* [132]


### Merging Chains  fun1/3 into  External patterns of execution 
* [[132]] --> 1 
* [[132,[130,131]]] --> 2 


### Specialization of cost equations fun10/4 
* CE 89 is refined into CE [179] 
* CE 87 is refined into CE [180] 
* CE 88 is refined into CE [181] 


#### Refined cost equations fun10/4 
* CE 179: fun10(V1,V,V2,Out) = 0
     [V2>=0,V>=0,V1>=0,Out=0] 
* CE 180: fun10(V1,V,V2,Out) = 1+ fun10(W2,V,V2,X2)
     [W2>=0,V2>=0,V>=0,X2+1=Out,W2+1=V1] 
* CE 181: fun10(V1,V,V2,Out) = 1+ fun10(W2,X2,Y2,Z2)
     [Y2>=0,X2>=0,W2>=0,Z2+1=Out,Y2+1=V2,X2+1=V,W2+1=V1] 

### Cost equations --> "Loop" of fun10/4 
* CEs [180] --> Loop 133 
* CEs [181] --> Loop 134 
* CEs [179] --> Loop 135 

#### Loops of fun10/4 
* Loop 133: fun10(V1,V,V2,Out)->  fun10(V1',V,V2,Out')
                  [V2>=0,V>=0,V1>=1,Out=Out'+1,V1=V1'+1] 
* Loop 134: fun10(V1,V,V2,Out)->  fun10(V1',V',V2',Out')
                  [V2>=1,V>=1,V1>=1,Out=Out'+1,V2=V2'+1,V=V'+1,V1=V1'+1] 
* Loop 135: fun10(V1,V,V2,Out) [V2>=0,V>=0,V1>=0,Out=0] 

### Ranking functions of CR fun10(V1,V,V2,Out) 
* RF of phase [133,134]: [V1]

#### Partial ranking functions of CR fun10(V1,V,V2,Out) 
* Partial RF of phase [133,134]:
  - RF of loop [133:1,134:1]:
    V1
  - RF of loop [134:1]:
    V
    V2


### Resulting Chains:fun10(V1,V,V2,Out) 
* [[133,134],135]
* [135]


### Merging Chains  fun10/4 into  External patterns of execution 
* [[135]] --> 1 
* [[135,[133,134]]] --> 2 


### Specialization of cost equations fun11/4 
* CE 92 is refined into CE [182] 
* CE 90 is refined into CE [183] 
* CE 91 is refined into CE [184] 


#### Refined cost equations fun11/4 
* CE 182: fun11(V1,V,V2,Out) = 0
     [V2>=0,V>=0,V1>=0,Out=0] 
* CE 183: fun11(V1,V,V2,Out) = 1+ fun11(W2,V,V2,X2)
     [W2>=0,V2>=0,V>=0,X2+1=Out,W2+1=V1] 
* CE 184: fun11(V1,V,V2,Out) = 1+ fun11(W2,X2,Y2,Z2)
     [Y2>=0,X2>=0,W2>=0,Z2+1=Out,Y2+1=V2,X2+1=V,W2+1=V1] 

### Cost equations --> "Loop" of fun11/4 
* CEs [183] --> Loop 136 
* CEs [184] --> Loop 137 
* CEs [182] --> Loop 138 

#### Loops of fun11/4 
* Loop 136: fun11(V1,V,V2,Out)->  fun11(V1',V,V2,Out')
                  [V2>=0,V>=0,V1>=1,Out=Out'+1,V1=V1'+1] 
* Loop 137: fun11(V1,V,V2,Out)->  fun11(V1',V',V2',Out')
                  [V2>=1,V>=1,V1>=1,Out=Out'+1,V2=V2'+1,V=V'+1,V1=V1'+1] 
* Loop 138: fun11(V1,V,V2,Out) [V2>=0,V>=0,V1>=0,Out=0] 

### Ranking functions of CR fun11(V1,V,V2,Out) 
* RF of phase [136,137]: [V1]

#### Partial ranking functions of CR fun11(V1,V,V2,Out) 
* Partial RF of phase [136,137]:
  - RF of loop [136:1,137:1]:
    V1
  - RF of loop [137:1]:
    V
    V2


### Resulting Chains:fun11(V1,V,V2,Out) 
* [[136,137],138]
* [138]


### Merging Chains  fun11/4 into  External patterns of execution 
* [[138]] --> 1 
* [[138,[136,137]]] --> 2 


### Specialization of cost equations fun12/3 
* CE 96 is refined into CE [185] 
* CE 93 is refined into CE [186] 
* CE 94 is refined into CE [187] 
* CE 95 is refined into CE [188] 


#### Refined cost equations fun12/3 
* CE 185: fun12(V1,V,Out) = 0
     [V>=0,V1>=0,Out=0] 
* CE 186: fun12(V1,V,Out) = 1+ fun12(V1,W1,X1)
     [W1>=0,V1>=0,X1+1=Out,W1+1=V] 
* CE 187: fun12(V1,V,Out) = 1+ fun12(W1,V,X1)
     [W1>=0,V>=0,X1+1=Out,W1+1=V1] 
* CE 188: fun12(V1,V,Out) = 1+ fun12(W1,X1,Y1)
     [X1>=0,W1>=0,Y1+1=Out,X1+1=V,W1+1=V1] 

### Cost equations --> "Loop" of fun12/3 
* CEs [186] --> Loop 139 
* CEs [187] --> Loop 140 
* CEs [188] --> Loop 141 
* CEs [185] --> Loop 142 

#### Loops of fun12/3 
* Loop 139: fun12(V1,V,Out)->  fun12(V1,V',Out')
                  [V>=1,V1>=0,Out=Out'+1,V=V'+1] 
* Loop 140: fun12(V1,V,Out)->  fun12(V1',V,Out')
                  [V>=0,V1>=1,Out=Out'+1,V1=V1'+1] 
* Loop 141: fun12(V1,V,Out)->  fun12(V1',V',Out')
                  [V>=1,V1>=1,Out=Out'+1,V=V'+1,V1=V1'+1] 
* Loop 142: fun12(V1,V,Out) [V>=0,V1>=0,Out=0] 

### Ranking functions of CR fun12(V1,V,Out) 
* RF of phase [139,140,141]: [V1+V]

#### Partial ranking functions of CR fun12(V1,V,Out) 
* Partial RF of phase [139,140,141]:
  - RF of loop [139:1,141:1]:
    V
  - RF of loop [140:1,141:1]:
    V1


### Resulting Chains:fun12(V1,V,Out) 
* [[139,140,141],142]
* [142]


### Merging Chains  fun12/3 into  External patterns of execution 
* [[142]] --> 1 
* [[142,[139,140,141]]] --> 2 


### Specialization of cost equations fun13/3 
* CE 99 is refined into CE [189] 
* CE 98 is refined into CE [190] 
* CE 97 is refined into CE [191] 


#### Refined cost equations fun13/3 
* CE 189: fun13(V1,V,Out) = 0
     [V>=0,V1>=0,Out=0] 
* CE 190: fun13(V1,V,Out) = 1+ fun13(W1,V,X1)
     [W1>=0,V>=0,X1+1=Out,W1+1=V1] 
* CE 191: fun13(V1,V,Out) = 1+ fun13(W1,X1,Y1)
     [X1>=0,W1>=0,Y1+1=Out,X1+1=V,W1+1=V1] 

### Cost equations --> "Loop" of fun13/3 
* CEs [190] --> Loop 143 
* CEs [191] --> Loop 144 
* CEs [189] --> Loop 145 

#### Loops of fun13/3 
* Loop 143: fun13(V1,V,Out)->  fun13(V1',V,Out')
                  [V>=0,V1>=1,Out=Out'+1,V1=V1'+1] 
* Loop 144: fun13(V1,V,Out)->  fun13(V1',V',Out')
                  [V>=1,V1>=1,Out=Out'+1,V=V'+1,V1=V1'+1] 
* Loop 145: fun13(V1,V,Out) [V>=0,V1>=0,Out=0] 

### Ranking functions of CR fun13(V1,V,Out) 
* RF of phase [143,144]: [V1]

#### Partial ranking functions of CR fun13(V1,V,Out) 
* Partial RF of phase [143,144]:
  - RF of loop [143:1,144:1]:
    V1
  - RF of loop [144:1]:
    V


### Resulting Chains:fun13(V1,V,Out) 
* [[143,144],145]
* [145]


### Merging Chains  fun13/3 into  External patterns of execution 
* [[145]] --> 1 
* [[145,[143,144]]] --> 2 


### Specialization of cost equations fun14/2 
* CE 101 is refined into CE [192] 
* CE 100 is refined into CE [193] 


#### Refined cost equations fun14/2 
* CE 192: fun14(V1,Out) = 0
     [V1>=0,Out=0] 
* CE 193: fun14(V1,Out) = 1+ fun14(W1,X1)
     [W1>=0,X1+1=Out,W1+1=V1] 

### Cost equations --> "Loop" of fun14/2 
* CEs [193] --> Loop 146 
* CEs [192] --> Loop 147 

#### Loops of fun14/2 
* Loop 146: fun14(V1,Out)->  fun14(V1',Out')
                  [V1'>=0,Out=Out'+1,V1'+1=V1] 
* Loop 147: fun14(V1,Out) [V1>=0,Out=0] 

### Ranking functions of CR fun14(V1,Out) 
* RF of phase [146]: [V1]

#### Partial ranking functions of CR fun14(V1,Out) 
* Partial RF of phase [146]:
  - RF of loop [146:1]:
    V1


### Resulting Chains:fun14(V1,Out) 
* [[146],147]
* [147]


### Merging Chains  fun14/2 into  External patterns of execution 
* [[147]] --> 1 
* [[147,[146]]] --> 2 


### Specialization of cost equations fun15/3 
* CE 104 is refined into CE [194] 
* CE 102 is refined into CE [195] 
* CE 103 is refined into CE [196] 


#### Refined cost equations fun15/3 
* CE 194: fun15(V1,V,Out) = 0
     [V>=0,V1>=0,Out=0] 
* CE 195: fun15(V1,V,Out) = 1+ fun15(W1,V,X1)
     [W1>=0,V>=0,X1+1=Out,W1+1=V1] 
* CE 196: fun15(V1,V,Out) = 1+ fun15(W1,X1,Y1)
     [X1>=0,W1>=0,Y1+1=Out,X1+1=V,W1+1=V1] 

### Cost equations --> "Loop" of fun15/3 
* CEs [195] --> Loop 148 
* CEs [196] --> Loop 149 
* CEs [194] --> Loop 150 

#### Loops of fun15/3 
* Loop 148: fun15(V1,V,Out)->  fun15(V1',V,Out')
                  [V>=0,V1>=1,Out=Out'+1,V1=V1'+1] 
* Loop 149: fun15(V1,V,Out)->  fun15(V1',V',Out')
                  [V>=1,V1>=1,Out=Out'+1,V=V'+1,V1=V1'+1] 
* Loop 150: fun15(V1,V,Out) [V>=0,V1>=0,Out=0] 

### Ranking functions of CR fun15(V1,V,Out) 
* RF of phase [148,149]: [V1]

#### Partial ranking functions of CR fun15(V1,V,Out) 
* Partial RF of phase [148,149]:
  - RF of loop [148:1,149:1]:
    V1
  - RF of loop [149:1]:
    V


### Resulting Chains:fun15(V1,V,Out) 
* [[148,149],150]
* [150]


### Merging Chains  fun15/3 into  External patterns of execution 
* [[150]] --> 1 
* [[150,[148,149]]] --> 2 


### Specialization of cost equations fun16/2 
* CE 106 is refined into CE [197] 
* CE 105 is refined into CE [198] 


#### Refined cost equations fun16/2 
* CE 197: fun16(V1,Out) = 0
     [V1>=0,Out=0] 
* CE 198: fun16(V1,Out) = 1+ fun16(W1,X1)
     [W1>=0,X1+1=Out,W1+1=V1] 

### Cost equations --> "Loop" of fun16/2 
* CEs [198] --> Loop 151 
* CEs [197] --> Loop 152 

#### Loops of fun16/2 
* Loop 151: fun16(V1,Out)->  fun16(V1',Out')
                  [V1'>=0,Out=Out'+1,V1'+1=V1] 
* Loop 152: fun16(V1,Out) [V1>=0,Out=0] 

### Ranking functions of CR fun16(V1,Out) 
* RF of phase [151]: [V1]

#### Partial ranking functions of CR fun16(V1,Out) 
* Partial RF of phase [151]:
  - RF of loop [151:1]:
    V1


### Resulting Chains:fun16(V1,Out) 
* [[151],152]
* [152]


### Merging Chains  fun16/2 into  External patterns of execution 
* [[152]] --> 1 
* [[152,[151]]] --> 2 


### Specialization of cost equations fun17/4 
* CE 109 is refined into CE [199] 
* CE 108 is refined into CE [200] 
* CE 107 is refined into CE [201] 


#### Refined cost equations fun17/4 
* CE 199: fun17(V1,V,V2,Out) = 0
     [V2>=0,V>=0,V1>=0,Out=0] 
* CE 200: fun17(V1,V,V2,Out) = 1+ fun17(W2,V,V2,X2)
     [W2>=0,V2>=0,V>=0,X2+1=Out,W2+1=V1] 
* CE 201: fun17(V1,V,V2,Out) = 1+ fun17(W2,X2,Y2,Z2)
     [Y2>=0,X2>=0,W2>=0,Z2+1=Out,Y2+1=V2,X2+1=V,W2+1=V1] 

### Cost equations --> "Loop" of fun17/4 
* CEs [200] --> Loop 153 
* CEs [201] --> Loop 154 
* CEs [199] --> Loop 155 

#### Loops of fun17/4 
* Loop 153: fun17(V1,V,V2,Out)->  fun17(V1',V,V2,Out')
                  [V2>=0,V>=0,V1>=1,Out=Out'+1,V1=V1'+1] 
* Loop 154: fun17(V1,V,V2,Out)->  fun17(V1',V',V2',Out')
                  [V2>=1,V>=1,V1>=1,Out=Out'+1,V2=V2'+1,V=V'+1,V1=V1'+1] 
* Loop 155: fun17(V1,V,V2,Out) [V2>=0,V>=0,V1>=0,Out=0] 

### Ranking functions of CR fun17(V1,V,V2,Out) 
* RF of phase [153,154]: [V1]

#### Partial ranking functions of CR fun17(V1,V,V2,Out) 
* Partial RF of phase [153,154]:
  - RF of loop [153:1,154:1]:
    V1
  - RF of loop [154:1]:
    V
    V2


### Resulting Chains:fun17(V1,V,V2,Out) 
* [[153,154],155]
* [155]


### Merging Chains  fun17/4 into  External patterns of execution 
* [[155]] --> 1 
* [[155,[153,154]]] --> 2 


### Specialization of cost equations fun18/4 
* CE 112 is refined into CE [202] 
* CE 110 is refined into CE [203] 
* CE 111 is refined into CE [204] 


#### Refined cost equations fun18/4 
* CE 202: fun18(V1,V,V2,Out) = 0
     [V2>=0,V>=0,V1>=0,Out=0] 
* CE 203: fun18(V1,V,V2,Out) = 1+ fun18(W2,V,V2,X2)
     [W2>=0,V2>=0,V>=0,X2+1=Out,W2+1=V1] 
* CE 204: fun18(V1,V,V2,Out) = 1+ fun18(W2,X2,Y2,Z2)
     [Y2>=0,X2>=0,W2>=0,Z2+1=Out,Y2+1=V2,X2+1=V,W2+1=V1] 

### Cost equations --> "Loop" of fun18/4 
* CEs [203] --> Loop 156 
* CEs [204] --> Loop 157 
* CEs [202] --> Loop 158 

#### Loops of fun18/4 
* Loop 156: fun18(V1,V,V2,Out)->  fun18(V1',V,V2,Out')
                  [V2>=0,V>=0,V1>=1,Out=Out'+1,V1=V1'+1] 
* Loop 157: fun18(V1,V,V2,Out)->  fun18(V1',V',V2',Out')
                  [V2>=1,V>=1,V1>=1,Out=Out'+1,V2=V2'+1,V=V'+1,V1=V1'+1] 
* Loop 158: fun18(V1,V,V2,Out) [V2>=0,V>=0,V1>=0,Out=0] 

### Ranking functions of CR fun18(V1,V,V2,Out) 
* RF of phase [156,157]: [V1]

#### Partial ranking functions of CR fun18(V1,V,V2,Out) 
* Partial RF of phase [156,157]:
  - RF of loop [156:1,157:1]:
    V1
  - RF of loop [157:1]:
    V
    V2


### Resulting Chains:fun18(V1,V,V2,Out) 
* [[156,157],158]
* [158]


### Merging Chains  fun18/4 into  External patterns of execution 
* [[158]] --> 1 
* [[158,[156,157]]] --> 2 


### Specialization of cost equations fun19/3 
* CE 115 is refined into CE [205] 
* CE 114 is refined into CE [206] 
* CE 113 is refined into CE [207] 


#### Refined cost equations fun19/3 
* CE 205: fun19(V1,V,Out) = 0
     [V>=0,V1>=0,Out=0] 
* CE 206: fun19(V1,V,Out) = 1+ fun19(W1,V,X1)
     [W1>=0,V>=0,X1+1=Out,W1+1=V1] 
* CE 207: fun19(V1,V,Out) = 1+ fun19(W1,X1,Y1)
     [X1>=0,W1>=0,Y1+1=Out,X1+1=V,W1+1=V1] 

### Cost equations --> "Loop" of fun19/3 
* CEs [206] --> Loop 159 
* CEs [207] --> Loop 160 
* CEs [205] --> Loop 161 

#### Loops of fun19/3 
* Loop 159: fun19(V1,V,Out)->  fun19(V1',V,Out')
                  [V>=0,V1>=1,Out=Out'+1,V1=V1'+1] 
* Loop 160: fun19(V1,V,Out)->  fun19(V1',V',Out')
                  [V>=1,V1>=1,Out=Out'+1,V=V'+1,V1=V1'+1] 
* Loop 161: fun19(V1,V,Out) [V>=0,V1>=0,Out=0] 

### Ranking functions of CR fun19(V1,V,Out) 
* RF of phase [159,160]: [V1]

#### Partial ranking functions of CR fun19(V1,V,Out) 
* Partial RF of phase [159,160]:
  - RF of loop [159:1,160:1]:
    V1
  - RF of loop [160:1]:
    V


### Resulting Chains:fun19(V1,V,Out) 
* [[159,160],161]
* [161]


### Merging Chains  fun19/3 into  External patterns of execution 
* [[161]] --> 1 
* [[161,[159,160]]] --> 2 


### Specialization of cost equations fun2/3 
* CE 60 is refined into CE [208] 
* CE 58 is refined into CE [209] 
* CE 59 is refined into CE [210] 


#### Refined cost equations fun2/3 
* CE 208: fun2(V1,V,Out) = 0
     [V>=0,V1>=0,Out=0] 
* CE 209: fun2(V1,V,Out) = 1+ fun2(W1,V,X1)
     [W1>=0,V>=0,X1+1=Out,W1+1=V1] 
* CE 210: fun2(V1,V,Out) = 1+ fun2(W1,X1,Y1)
     [X1>=0,W1>=0,Y1+1=Out,X1+1=V,W1+1=V1] 

### Cost equations --> "Loop" of fun2/3 
* CEs [209] --> Loop 162 
* CEs [210] --> Loop 163 
* CEs [208] --> Loop 164 

#### Loops of fun2/3 
* Loop 162: fun2(V1,V,Out)->  fun2(V1',V,Out')
                  [V>=0,V1>=1,Out=Out'+1,V1=V1'+1] 
* Loop 163: fun2(V1,V,Out)->  fun2(V1',V',Out')
                  [V>=1,V1>=1,Out=Out'+1,V=V'+1,V1=V1'+1] 
* Loop 164: fun2(V1,V,Out) [V>=0,V1>=0,Out=0] 

### Ranking functions of CR fun2(V1,V,Out) 
* RF of phase [162,163]: [V1]

#### Partial ranking functions of CR fun2(V1,V,Out) 
* Partial RF of phase [162,163]:
  - RF of loop [162:1,163:1]:
    V1
  - RF of loop [163:1]:
    V


### Resulting Chains:fun2(V1,V,Out) 
* [[162,163],164]
* [164]


### Merging Chains  fun2/3 into  External patterns of execution 
* [[164]] --> 1 
* [[164,[162,163]]] --> 2 


### Specialization of cost equations fun20/3 
* CE 118 is refined into CE [211] 
* CE 116 is refined into CE [212] 
* CE 117 is refined into CE [213] 


#### Refined cost equations fun20/3 
* CE 211: fun20(V1,V,Out) = 0
     [V>=0,V1>=0,Out=0] 
* CE 212: fun20(V1,V,Out) = 1+ fun20(W1,V,X1)
     [W1>=0,V>=0,X1+1=Out,W1+1=V1] 
* CE 213: fun20(V1,V,Out) = 1+ fun20(W1,X1,Y1)
     [X1>=0,W1>=0,Y1+1=Out,X1+1=V,W1+1=V1] 

### Cost equations --> "Loop" of fun20/3 
* CEs [212] --> Loop 165 
* CEs [213] --> Loop 166 
* CEs [211] --> Loop 167 

#### Loops of fun20/3 
* Loop 165: fun20(V1,V,Out)->  fun20(V1',V,Out')
                  [V>=0,V1>=1,Out=Out'+1,V1=V1'+1] 
* Loop 166: fun20(V1,V,Out)->  fun20(V1',V',Out')
                  [V>=1,V1>=1,Out=Out'+1,V=V'+1,V1=V1'+1] 
* Loop 167: fun20(V1,V,Out) [V>=0,V1>=0,Out=0] 

### Ranking functions of CR fun20(V1,V,Out) 
* RF of phase [165,166]: [V1]

#### Partial ranking functions of CR fun20(V1,V,Out) 
* Partial RF of phase [165,166]:
  - RF of loop [165:1,166:1]:
    V1
  - RF of loop [166:1]:
    V


### Resulting Chains:fun20(V1,V,Out) 
* [[165,166],167]
* [167]


### Merging Chains  fun20/3 into  External patterns of execution 
* [[167]] --> 1 
* [[167,[165,166]]] --> 2 


### Specialization of cost equations fun21/2 
* CE 122 is refined into CE [214] 
* CE 121 is refined into CE [215] 


#### Refined cost equations fun21/2 
* CE 214: fun21(V1,Out) = 0
     [V1>=0,Out=0] 
* CE 215: fun21(V1,Out) = 1+ fun21(W1,X1)
     [W1>=0,X1+1=Out,W1+1=V1] 

### Cost equations --> "Loop" of fun21/2 
* CEs [215] --> Loop 168 
* CEs [214] --> Loop 169 

#### Loops of fun21/2 
* Loop 168: fun21(V1,Out)->  fun21(V1',Out')
                  [V1'>=0,Out=Out'+1,V1'+1=V1] 
* Loop 169: fun21(V1,Out) [V1>=0,Out=0] 

### Ranking functions of CR fun21(V1,Out) 
* RF of phase [168]: [V1]

#### Partial ranking functions of CR fun21(V1,Out) 
* Partial RF of phase [168]:
  - RF of loop [168:1]:
    V1


### Resulting Chains:fun21(V1,Out) 
* [[168],169]
* [169]


### Merging Chains  fun21/2 into  External patterns of execution 
* [[169]] --> 1 
* [[169,[168]]] --> 2 


### Specialization of cost equations fun22/3 
* CE 125 is refined into CE [216] 
* CE 124 is refined into CE [217] 
* CE 123 is refined into CE [218] 


#### Refined cost equations fun22/3 
* CE 216: fun22(V1,V,Out) = 0
     [V>=0,V1>=0,Out=0] 
* CE 217: fun22(V1,V,Out) = 1+ fun22(W1,V,X1)
     [W1>=0,V>=0,X1+1=Out,W1+1=V1] 
* CE 218: fun22(V1,V,Out) = 1+ fun22(W1,X1,Y1)
     [X1>=0,W1>=0,Y1+1=Out,X1+1=V,W1+1=V1] 

### Cost equations --> "Loop" of fun22/3 
* CEs [217] --> Loop 170 
* CEs [218] --> Loop 171 
* CEs [216] --> Loop 172 

#### Loops of fun22/3 
* Loop 170: fun22(V1,V,Out)->  fun22(V1',V,Out')
                  [V>=0,V1>=1,Out=Out'+1,V1=V1'+1] 
* Loop 171: fun22(V1,V,Out)->  fun22(V1',V',Out')
                  [V>=1,V1>=1,Out=Out'+1,V=V'+1,V1=V1'+1] 
* Loop 172: fun22(V1,V,Out) [V>=0,V1>=0,Out=0] 

### Ranking functions of CR fun22(V1,V,Out) 
* RF of phase [170,171]: [V1]

#### Partial ranking functions of CR fun22(V1,V,Out) 
* Partial RF of phase [170,171]:
  - RF of loop [170:1,171:1]:
    V1
  - RF of loop [171:1]:
    V


### Resulting Chains:fun22(V1,V,Out) 
* [[170,171],172]
* [172]


### Merging Chains  fun22/3 into  External patterns of execution 
* [[172]] --> 1 
* [[172,[170,171]]] --> 2 


### Specialization of cost equations fun23/2 
* CE 127 is refined into CE [219] 
* CE 126 is refined into CE [220] 


#### Refined cost equations fun23/2 
* CE 219: fun23(V1,Out) = 0
     [V1>=0,Out=0] 
* CE 220: fun23(V1,Out) = 1+ fun23(W1,X1)
     [W1>=0,X1+1=Out,W1+1=V1] 

### Cost equations --> "Loop" of fun23/2 
* CEs [220] --> Loop 173 
* CEs [219] --> Loop 174 

#### Loops of fun23/2 
* Loop 173: fun23(V1,Out)->  fun23(V1',Out')
                  [V1'>=0,Out=Out'+1,V1'+1=V1] 
* Loop 174: fun23(V1,Out) [V1>=0,Out=0] 

### Ranking functions of CR fun23(V1,Out) 
* RF of phase [173]: [V1]

#### Partial ranking functions of CR fun23(V1,Out) 
* Partial RF of phase [173]:
  - RF of loop [173:1]:
    V1


### Resulting Chains:fun23(V1,Out) 
* [[173],174]
* [174]


### Merging Chains  fun23/2 into  External patterns of execution 
* [[174]] --> 1 
* [[174,[173]]] --> 2 


### Specialization of cost equations fun24/2 
* CE 129 is refined into CE [221] 
* CE 128 is refined into CE [222] 


#### Refined cost equations fun24/2 
* CE 221: fun24(V1,Out) = 0
     [V1>=0,Out=0] 
* CE 222: fun24(V1,Out) = 1+ fun24(W1,X1)
     [W1>=0,X1+1=Out,W1+1=V1] 

### Cost equations --> "Loop" of fun24/2 
* CEs [222] --> Loop 175 
* CEs [221] --> Loop 176 

#### Loops of fun24/2 
* Loop 175: fun24(V1,Out)->  fun24(V1',Out')
                  [V1'>=0,Out=Out'+1,V1'+1=V1] 
* Loop 176: fun24(V1,Out) [V1>=0,Out=0] 

### Ranking functions of CR fun24(V1,Out) 
* RF of phase [175]: [V1]

#### Partial ranking functions of CR fun24(V1,Out) 
* Partial RF of phase [175]:
  - RF of loop [175:1]:
    V1


### Resulting Chains:fun24(V1,Out) 
* [[175],176]
* [176]


### Merging Chains  fun24/2 into  External patterns of execution 
* [[176]] --> 1 
* [[176,[175]]] --> 2 


### Specialization of cost equations fun25/2 
* CE 131 is refined into CE [223] 
* CE 130 is refined into CE [224] 


#### Refined cost equations fun25/2 
* CE 223: fun25(V1,Out) = 0
     [V1>=0,Out=0] 
* CE 224: fun25(V1,Out) = 1+ fun25(W1,X1)
     [W1>=0,X1+1=Out,W1+1=V1] 

### Cost equations --> "Loop" of fun25/2 
* CEs [224] --> Loop 177 
* CEs [223] --> Loop 178 

#### Loops of fun25/2 
* Loop 177: fun25(V1,Out)->  fun25(V1',Out')
                  [V1'>=0,Out=Out'+1,V1'+1=V1] 
* Loop 178: fun25(V1,Out) [V1>=0,Out=0] 

### Ranking functions of CR fun25(V1,Out) 
* RF of phase [177]: [V1]

#### Partial ranking functions of CR fun25(V1,Out) 
* Partial RF of phase [177]:
  - RF of loop [177:1]:
    V1


### Resulting Chains:fun25(V1,Out) 
* [[177],178]
* [178]


### Merging Chains  fun25/2 into  External patterns of execution 
* [[178]] --> 1 
* [[178,[177]]] --> 2 


### Specialization of cost equations fun26/4 
* CE 134 is refined into CE [225] 
* CE 133 is refined into CE [226] 
* CE 132 is refined into CE [227] 


#### Refined cost equations fun26/4 
* CE 225: fun26(V1,V,V2,Out) = 0
     [V2>=0,V>=0,V1>=0,Out=0] 
* CE 226: fun26(V1,V,V2,Out) = 1+ fun26(W2,V,V2,X2)
     [W2>=0,V2>=0,V>=0,X2+1=Out,W2+1=V1] 
* CE 227: fun26(V1,V,V2,Out) = 1+ fun26(W2,X2,Y2,Z2)
     [Y2>=0,X2>=0,W2>=0,Z2+1=Out,Y2+1=V2,X2+1=V,W2+1=V1] 

### Cost equations --> "Loop" of fun26/4 
* CEs [226] --> Loop 179 
* CEs [227] --> Loop 180 
* CEs [225] --> Loop 181 

#### Loops of fun26/4 
* Loop 179: fun26(V1,V,V2,Out)->  fun26(V1',V,V2,Out')
                  [V2>=0,V>=0,V1>=1,Out=Out'+1,V1=V1'+1] 
* Loop 180: fun26(V1,V,V2,Out)->  fun26(V1',V',V2',Out')
                  [V2>=1,V>=1,V1>=1,Out=Out'+1,V2=V2'+1,V=V'+1,V1=V1'+1] 
* Loop 181: fun26(V1,V,V2,Out) [V2>=0,V>=0,V1>=0,Out=0] 

### Ranking functions of CR fun26(V1,V,V2,Out) 
* RF of phase [179,180]: [V1]

#### Partial ranking functions of CR fun26(V1,V,V2,Out) 
* Partial RF of phase [179,180]:
  - RF of loop [179:1,180:1]:
    V1
  - RF of loop [180:1]:
    V
    V2


### Resulting Chains:fun26(V1,V,V2,Out) 
* [[179,180],181]
* [181]


### Merging Chains  fun26/4 into  External patterns of execution 
* [[181]] --> 1 
* [[181,[179,180]]] --> 2 


### Specialization of cost equations fun27/4 
* CE 137 is refined into CE [228] 
* CE 136 is refined into CE [229] 
* CE 135 is refined into CE [230] 


#### Refined cost equations fun27/4 
* CE 228: fun27(V1,V,V2,Out) = 0
     [V2>=0,V>=0,V1>=0,Out=0] 
* CE 229: fun27(V1,V,V2,Out) = 1+ fun27(W2,V,V2,X2)
     [W2>=0,V2>=0,V>=0,X2+1=Out,W2+1=V1] 
* CE 230: fun27(V1,V,V2,Out) = 1+ fun27(W2,X2,Y2,Z2)
     [Y2>=0,X2>=0,W2>=0,Z2+1=Out,Y2+1=V2,X2+1=V,W2+1=V1] 

### Cost equations --> "Loop" of fun27/4 
* CEs [229] --> Loop 182 
* CEs [230] --> Loop 183 
* CEs [228] --> Loop 184 

#### Loops of fun27/4 
* Loop 182: fun27(V1,V,V2,Out)->  fun27(V1',V,V2,Out')
                  [V2>=0,V>=0,V1>=1,Out=Out'+1,V1=V1'+1] 
* Loop 183: fun27(V1,V,V2,Out)->  fun27(V1',V',V2',Out')
                  [V2>=1,V>=1,V1>=1,Out=Out'+1,V2=V2'+1,V=V'+1,V1=V1'+1] 
* Loop 184: fun27(V1,V,V2,Out) [V2>=0,V>=0,V1>=0,Out=0] 

### Ranking functions of CR fun27(V1,V,V2,Out) 
* RF of phase [182,183]: [V1]

#### Partial ranking functions of CR fun27(V1,V,V2,Out) 
* Partial RF of phase [182,183]:
  - RF of loop [182:1,183:1]:
    V1
  - RF of loop [183:1]:
    V
    V2


### Resulting Chains:fun27(V1,V,V2,Out) 
* [[182,183],184]
* [184]


### Merging Chains  fun27/4 into  External patterns of execution 
* [[184]] --> 1 
* [[184,[182,183]]] --> 2 


### Specialization of cost equations fun28/3 
* CE 140 is refined into CE [231] 
* CE 138 is refined into CE [232] 
* CE 139 is refined into CE [233] 


#### Refined cost equations fun28/3 
* CE 231: fun28(V1,V,Out) = 0
     [V>=0,V1>=0,Out=0] 
* CE 232: fun28(V1,V,Out) = 1+ fun28(W1,V,X1)
     [W1>=0,V>=0,X1+1=Out,W1+1=V1] 
* CE 233: fun28(V1,V,Out) = 1+ fun28(W1,X1,Y1)
     [X1>=0,W1>=0,Y1+1=Out,X1+1=V,W1+1=V1] 

### Cost equations --> "Loop" of fun28/3 
* CEs [232] --> Loop 185 
* CEs [233] --> Loop 186 
* CEs [231] --> Loop 187 

#### Loops of fun28/3 
* Loop 185: fun28(V1,V,Out)->  fun28(V1',V,Out')
                  [V>=0,V1>=1,Out=Out'+1,V1=V1'+1] 
* Loop 186: fun28(V1,V,Out)->  fun28(V1',V',Out')
                  [V>=1,V1>=1,Out=Out'+1,V=V'+1,V1=V1'+1] 
* Loop 187: fun28(V1,V,Out) [V>=0,V1>=0,Out=0] 

### Ranking functions of CR fun28(V1,V,Out) 
* RF of phase [185,186]: [V1]

#### Partial ranking functions of CR fun28(V1,V,Out) 
* Partial RF of phase [185,186]:
  - RF of loop [185:1,186:1]:
    V1
  - RF of loop [186:1]:
    V


### Resulting Chains:fun28(V1,V,Out) 
* [[185,186],187]
* [187]


### Merging Chains  fun28/3 into  External patterns of execution 
* [[187]] --> 1 
* [[187,[185,186]]] --> 2 


### Specialization of cost equations fun29/4 
* CE 143 is refined into CE [234] 
* CE 142 is refined into CE [235] 
* CE 141 is refined into CE [236] 


#### Refined cost equations fun29/4 
* CE 234: fun29(V1,V,V2,Out) = 0
     [V2>=0,V>=0,V1>=0,Out=0] 
* CE 235: fun29(V1,V,V2,Out) = 1+ fun29(W2,V,V2,X2)
     [W2>=0,V2>=0,V>=0,X2+1=Out,W2+1=V1] 
* CE 236: fun29(V1,V,V2,Out) = 1+ fun29(W2,X2,Y2,Z2)
     [Y2>=0,X2>=0,W2>=0,Z2+1=Out,Y2+1=V2,X2+1=V,W2+1=V1] 

### Cost equations --> "Loop" of fun29/4 
* CEs [235] --> Loop 188 
* CEs [236] --> Loop 189 
* CEs [234] --> Loop 190 

#### Loops of fun29/4 
* Loop 188: fun29(V1,V,V2,Out)->  fun29(V1',V,V2,Out')
                  [V2>=0,V>=0,V1>=1,Out=Out'+1,V1=V1'+1] 
* Loop 189: fun29(V1,V,V2,Out)->  fun29(V1',V',V2',Out')
                  [V2>=1,V>=1,V1>=1,Out=Out'+1,V2=V2'+1,V=V'+1,V1=V1'+1] 
* Loop 190: fun29(V1,V,V2,Out) [V2>=0,V>=0,V1>=0,Out=0] 

### Ranking functions of CR fun29(V1,V,V2,Out) 
* RF of phase [188,189]: [V1]

#### Partial ranking functions of CR fun29(V1,V,V2,Out) 
* Partial RF of phase [188,189]:
  - RF of loop [188:1,189:1]:
    V1
  - RF of loop [189:1]:
    V
    V2


### Resulting Chains:fun29(V1,V,V2,Out) 
* [[188,189],190]
* [190]


### Merging Chains  fun29/4 into  External patterns of execution 
* [[190]] --> 1 
* [[190,[188,189]]] --> 2 


### Specialization of cost equations fun3/4 
* CE 63 is refined into CE [237] 
* CE 62 is refined into CE [238] 
* CE 61 is refined into CE [239] 


#### Refined cost equations fun3/4 
* CE 237: fun3(V1,V,V2,Out) = 0
     [V2>=0,V>=0,V1>=0,Out=0] 
* CE 238: fun3(V1,V,V2,Out) = 1+ fun3(W2,V,V2,X2)
     [W2>=0,V2>=0,V>=0,X2+1=Out,W2+1=V1] 
* CE 239: fun3(V1,V,V2,Out) = 1+ fun3(W2,X2,Y2,Z2)
     [Y2>=0,X2>=0,W2>=0,Z2+1=Out,Y2+1=V2,X2+1=V,W2+1=V1] 

### Cost equations --> "Loop" of fun3/4 
* CEs [238] --> Loop 191 
* CEs [239] --> Loop 192 
* CEs [237] --> Loop 193 

#### Loops of fun3/4 
* Loop 191: fun3(V1,V,V2,Out)->  fun3(V1',V,V2,Out')
                  [V2>=0,V>=0,V1>=1,Out=Out'+1,V1=V1'+1] 
* Loop 192: fun3(V1,V,V2,Out)->  fun3(V1',V',V2',Out')
                  [V2>=1,V>=1,V1>=1,Out=Out'+1,V2=V2'+1,V=V'+1,V1=V1'+1] 
* Loop 193: fun3(V1,V,V2,Out) [V2>=0,V>=0,V1>=0,Out=0] 

### Ranking functions of CR fun3(V1,V,V2,Out) 
* RF of phase [191,192]: [V1]

#### Partial ranking functions of CR fun3(V1,V,V2,Out) 
* Partial RF of phase [191,192]:
  - RF of loop [191:1,192:1]:
    V1
  - RF of loop [192:1]:
    V
    V2


### Resulting Chains:fun3(V1,V,V2,Out) 
* [[191,192],193]
* [193]


### Merging Chains  fun3/4 into  External patterns of execution 
* [[193]] --> 1 
* [[193,[191,192]]] --> 2 


### Specialization of cost equations fun30/3 
* CE 148 is refined into CE [240] 
* CE 146 is refined into CE [241] 
* CE 147 is refined into CE [242] 


#### Refined cost equations fun30/3 
* CE 240: fun30(V1,V,Out) = 0
     [V>=0,V1>=0,Out=0] 
* CE 241: fun30(V1,V,Out) = 1+ fun30(W1,V,X1)
     [W1>=0,V>=0,X1+1=Out,W1+1=V1] 
* CE 242: fun30(V1,V,Out) = 1+ fun30(W1,X1,Y1)
     [X1>=0,W1>=0,Y1+1=Out,X1+1=V,W1+1=V1] 

### Cost equations --> "Loop" of fun30/3 
* CEs [241] --> Loop 194 
* CEs [242] --> Loop 195 
* CEs [240] --> Loop 196 

#### Loops of fun30/3 
* Loop 194: fun30(V1,V,Out)->  fun30(V1',V,Out')
                  [V>=0,V1>=1,Out=Out'+1,V1=V1'+1] 
* Loop 195: fun30(V1,V,Out)->  fun30(V1',V',Out')
                  [V>=1,V1>=1,Out=Out'+1,V=V'+1,V1=V1'+1] 
* Loop 196: fun30(V1,V,Out) [V>=0,V1>=0,Out=0] 

### Ranking functions of CR fun30(V1,V,Out) 
* RF of phase [194,195]: [V1]

#### Partial ranking functions of CR fun30(V1,V,Out) 
* Partial RF of phase [194,195]:
  - RF of loop [194:1,195:1]:
    V1
  - RF of loop [195:1]:
    V


### Resulting Chains:fun30(V1,V,Out) 
* [[194,195],196]
* [196]


### Merging Chains  fun30/3 into  External patterns of execution 
* [[196]] --> 1 
* [[196,[194,195]]] --> 2 


### Specialization of cost equations fun31/4 
* CE 153 is refined into CE [243] 
* CE 152 is refined into CE [244] 
* CE 151 is refined into CE [245] 


#### Refined cost equations fun31/4 
* CE 243: fun31(V1,V,V2,Out) = 0
     [V2>=0,V>=0,V1>=0,Out=0] 
* CE 244: fun31(V1,V,V2,Out) = 1+ fun31(W2,V,V2,X2)
     [W2>=0,V2>=0,V>=0,X2+1=Out,W2+1=V1] 
* CE 245: fun31(V1,V,V2,Out) = 1+ fun31(W2,X2,Y2,Z2)
     [Y2>=0,X2>=0,W2>=0,Z2+1=Out,Y2+1=V2,X2+1=V,W2+1=V1] 

### Cost equations --> "Loop" of fun31/4 
* CEs [244] --> Loop 197 
* CEs [245] --> Loop 198 
* CEs [243] --> Loop 199 

#### Loops of fun31/4 
* Loop 197: fun31(V1,V,V2,Out)->  fun31(V1',V,V2,Out')
                  [V2>=0,V>=0,V1>=1,Out=Out'+1,V1=V1'+1] 
* Loop 198: fun31(V1,V,V2,Out)->  fun31(V1',V',V2',Out')
                  [V2>=1,V>=1,V1>=1,Out=Out'+1,V2=V2'+1,V=V'+1,V1=V1'+1] 
* Loop 199: fun31(V1,V,V2,Out) [V2>=0,V>=0,V1>=0,Out=0] 

### Ranking functions of CR fun31(V1,V,V2,Out) 
* RF of phase [197,198]: [V1]

#### Partial ranking functions of CR fun31(V1,V,V2,Out) 
* Partial RF of phase [197,198]:
  - RF of loop [197:1,198:1]:
    V1
  - RF of loop [198:1]:
    V
    V2


### Resulting Chains:fun31(V1,V,V2,Out) 
* [[197,198],199]
* [199]


### Merging Chains  fun31/4 into  External patterns of execution 
* [[199]] --> 1 
* [[199,[197,198]]] --> 2 


### Specialization of cost equations fun32/4 
* CE 156 is refined into CE [246] 
* CE 154 is refined into CE [247] 
* CE 155 is refined into CE [248] 


#### Refined cost equations fun32/4 
* CE 246: fun32(V1,V,V2,Out) = 0
     [V2>=0,V>=0,V1>=0,Out=0] 
* CE 247: fun32(V1,V,V2,Out) = 1+ fun32(W2,V,V2,X2)
     [W2>=0,V2>=0,V>=0,X2+1=Out,W2+1=V1] 
* CE 248: fun32(V1,V,V2,Out) = 1+ fun32(W2,X2,Y2,Z2)
     [Y2>=0,X2>=0,W2>=0,Z2+1=Out,Y2+1=V2,X2+1=V,W2+1=V1] 

### Cost equations --> "Loop" of fun32/4 
* CEs [247] --> Loop 200 
* CEs [248] --> Loop 201 
* CEs [246] --> Loop 202 

#### Loops of fun32/4 
* Loop 200: fun32(V1,V,V2,Out)->  fun32(V1',V,V2,Out')
                  [V2>=0,V>=0,V1>=1,Out=Out'+1,V1=V1'+1] 
* Loop 201: fun32(V1,V,V2,Out)->  fun32(V1',V',V2',Out')
                  [V2>=1,V>=1,V1>=1,Out=Out'+1,V2=V2'+1,V=V'+1,V1=V1'+1] 
* Loop 202: fun32(V1,V,V2,Out) [V2>=0,V>=0,V1>=0,Out=0] 

### Ranking functions of CR fun32(V1,V,V2,Out) 
* RF of phase [200,201]: [V1]

#### Partial ranking functions of CR fun32(V1,V,V2,Out) 
* Partial RF of phase [200,201]:
  - RF of loop [200:1,201:1]:
    V1
  - RF of loop [201:1]:
    V
    V2


### Resulting Chains:fun32(V1,V,V2,Out) 
* [[200,201],202]
* [202]


### Merging Chains  fun32/4 into  External patterns of execution 
* [[202]] --> 1 
* [[202,[200,201]]] --> 2 


### Specialization of cost equations fun33/3 
* CE 161 is refined into CE [249] 
* CE 160 is refined into CE [250] 
* CE 159 is refined into CE [251] 


#### Refined cost equations fun33/3 
* CE 249: fun33(V1,V,Out) = 0
     [V>=0,V1>=0,Out=0] 
* CE 250: fun33(V1,V,Out) = 1+ fun33(W1,V,X1)
     [W1>=0,V>=0,X1+1=Out,W1+1=V1] 
* CE 251: fun33(V1,V,Out) = 1+ fun33(W1,X1,Y1)
     [X1>=0,W1>=0,Y1+1=Out,X1+1=V,W1+1=V1] 

### Cost equations --> "Loop" of fun33/3 
* CEs [250] --> Loop 203 
* CEs [251] --> Loop 204 
* CEs [249] --> Loop 205 

#### Loops of fun33/3 
* Loop 203: fun33(V1,V,Out)->  fun33(V1',V,Out')
                  [V>=0,V1>=1,Out=Out'+1,V1=V1'+1] 
* Loop 204: fun33(V1,V,Out)->  fun33(V1',V',Out')
                  [V>=1,V1>=1,Out=Out'+1,V=V'+1,V1=V1'+1] 
* Loop 205: fun33(V1,V,Out) [V>=0,V1>=0,Out=0] 

### Ranking functions of CR fun33(V1,V,Out) 
* RF of phase [203,204]: [V1]

#### Partial ranking functions of CR fun33(V1,V,Out) 
* Partial RF of phase [203,204]:
  - RF of loop [203:1,204:1]:
    V1
  - RF of loop [204:1]:
    V


### Resulting Chains:fun33(V1,V,Out) 
* [[203,204],205]
* [205]


### Merging Chains  fun33/3 into  External patterns of execution 
* [[205]] --> 1 
* [[205,[203,204]]] --> 2 


### Specialization of cost equations fun34/4 
* CE 166 is refined into CE [252] 
* CE 164 is refined into CE [253] 
* CE 165 is refined into CE [254] 


#### Refined cost equations fun34/4 
* CE 252: fun34(V1,V,V2,Out) = 0
     [V2>=0,V>=0,V1>=0,Out=0] 
* CE 253: fun34(V1,V,V2,Out) = 1+ fun34(W2,V,V2,X2)
     [W2>=0,V2>=0,V>=0,X2+1=Out,W2+1=V1] 
* CE 254: fun34(V1,V,V2,Out) = 1+ fun34(W2,X2,Y2,Z2)
     [Y2>=0,X2>=0,W2>=0,Z2+1=Out,Y2+1=V2,X2+1=V,W2+1=V1] 

### Cost equations --> "Loop" of fun34/4 
* CEs [253] --> Loop 206 
* CEs [254] --> Loop 207 
* CEs [252] --> Loop 208 

#### Loops of fun34/4 
* Loop 206: fun34(V1,V,V2,Out)->  fun34(V1',V,V2,Out')
                  [V2>=0,V>=0,V1>=1,Out=Out'+1,V1=V1'+1] 
* Loop 207: fun34(V1,V,V2,Out)->  fun34(V1',V',V2',Out')
                  [V2>=1,V>=1,V1>=1,Out=Out'+1,V2=V2'+1,V=V'+1,V1=V1'+1] 
* Loop 208: fun34(V1,V,V2,Out) [V2>=0,V>=0,V1>=0,Out=0] 

### Ranking functions of CR fun34(V1,V,V2,Out) 
* RF of phase [206,207]: [V1]

#### Partial ranking functions of CR fun34(V1,V,V2,Out) 
* Partial RF of phase [206,207]:
  - RF of loop [206:1,207:1]:
    V1
  - RF of loop [207:1]:
    V
    V2


### Resulting Chains:fun34(V1,V,V2,Out) 
* [[206,207],208]
* [208]


### Merging Chains  fun34/4 into  External patterns of execution 
* [[208]] --> 1 
* [[208,[206,207]]] --> 2 


### Specialization of cost equations fun35/3 
* CE 169 is refined into CE [255] 
* CE 168 is refined into CE [256] 
* CE 167 is refined into CE [257] 


#### Refined cost equations fun35/3 
* CE 255: fun35(V1,V,Out) = 0
     [V>=0,V1>=0,Out=0] 
* CE 256: fun35(V1,V,Out) = 1+ fun35(W1,V,X1)
     [W1>=0,V>=0,X1+1=Out,W1+1=V1] 
* CE 257: fun35(V1,V,Out) = 1+ fun35(W1,X1,Y1)
     [X1>=0,W1>=0,Y1+1=Out,X1+1=V,W1+1=V1] 

### Cost equations --> "Loop" of fun35/3 
* CEs [256] --> Loop 209 
* CEs [257] --> Loop 210 
* CEs [255] --> Loop 211 

#### Loops of fun35/3 
* Loop 209: fun35(V1,V,Out)->  fun35(V1',V,Out')
                  [V>=0,V1>=1,Out=Out'+1,V1=V1'+1] 
* Loop 210: fun35(V1,V,Out)->  fun35(V1',V',Out')
                  [V>=1,V1>=1,Out=Out'+1,V=V'+1,V1=V1'+1] 
* Loop 211: fun35(V1,V,Out) [V>=0,V1>=0,Out=0] 

### Ranking functions of CR fun35(V1,V,Out) 
* RF of phase [209,210]: [V1]

#### Partial ranking functions of CR fun35(V1,V,Out) 
* Partial RF of phase [209,210]:
  - RF of loop [209:1,210:1]:
    V1
  - RF of loop [210:1]:
    V


### Resulting Chains:fun35(V1,V,Out) 
* [[209,210],211]
* [211]


### Merging Chains  fun35/3 into  External patterns of execution 
* [[211]] --> 1 
* [[211,[209,210]]] --> 2 


### Specialization of cost equations fun36/4 
* CE 172 is refined into CE [258] 
* CE 170 is refined into CE [259] 
* CE 171 is refined into CE [260] 


#### Refined cost equations fun36/4 
* CE 258: fun36(V1,V,V2,Out) = 0
     [V2>=0,V>=0,V1>=0,Out=0] 
* CE 259: fun36(V1,V,V2,Out) = 1+ fun36(W2,V,V2,X2)
     [W2>=0,V2>=0,V>=0,X2+1=Out,W2+1=V1] 
* CE 260: fun36(V1,V,V2,Out) = 1+ fun36(W2,X2,Y2,Z2)
     [Y2>=0,X2>=0,W2>=0,Z2+1=Out,Y2+1=V2,X2+1=V,W2+1=V1] 

### Cost equations --> "Loop" of fun36/4 
* CEs [259] --> Loop 212 
* CEs [260] --> Loop 213 
* CEs [258] --> Loop 214 

#### Loops of fun36/4 
* Loop 212: fun36(V1,V,V2,Out)->  fun36(V1',V,V2,Out')
                  [V2>=0,V>=0,V1>=1,Out=Out'+1,V1=V1'+1] 
* Loop 213: fun36(V1,V,V2,Out)->  fun36(V1',V',V2',Out')
                  [V2>=1,V>=1,V1>=1,Out=Out'+1,V2=V2'+1,V=V'+1,V1=V1'+1] 
* Loop 214: fun36(V1,V,V2,Out) [V2>=0,V>=0,V1>=0,Out=0] 

### Ranking functions of CR fun36(V1,V,V2,Out) 
* RF of phase [212,213]: [V1]

#### Partial ranking functions of CR fun36(V1,V,V2,Out) 
* Partial RF of phase [212,213]:
  - RF of loop [212:1,213:1]:
    V1
  - RF of loop [213:1]:
    V
    V2


### Resulting Chains:fun36(V1,V,V2,Out) 
* [[212,213],214]
* [214]


### Merging Chains  fun36/4 into  External patterns of execution 
* [[214]] --> 1 
* [[214,[212,213]]] --> 2 


### Specialization of cost equations fun4/2 
* CE 65 is refined into CE [261] 
* CE 64 is refined into CE [262] 


#### Refined cost equations fun4/2 
* CE 261: fun4(V1,Out) = 0
     [V1>=0,Out=0] 
* CE 262: fun4(V1,Out) = 1+ fun4(W1,X1)
     [W1>=0,X1+1=Out,W1+1=V1] 

### Cost equations --> "Loop" of fun4/2 
* CEs [262] --> Loop 215 
* CEs [261] --> Loop 216 

#### Loops of fun4/2 
* Loop 215: fun4(V1,Out)->  fun4(V1',Out')
                  [V1'>=0,Out=Out'+1,V1'+1=V1] 
* Loop 216: fun4(V1,Out) [V1>=0,Out=0] 

### Ranking functions of CR fun4(V1,Out) 
* RF of phase [215]: [V1]

#### Partial ranking functions of CR fun4(V1,Out) 
* Partial RF of phase [215]:
  - RF of loop [215:1]:
    V1


### Resulting Chains:fun4(V1,Out) 
* [[215],216]
* [216]


### Merging Chains  fun4/2 into  External patterns of execution 
* [[216]] --> 1 
* [[216,[215]]] --> 2 


### Specialization of cost equations fun5/3 
* CE 68 is refined into CE [263] 
* CE 66 is refined into CE [264] 
* CE 67 is refined into CE [265] 


#### Refined cost equations fun5/3 
* CE 263: fun5(V1,V,Out) = 0
     [V>=0,V1>=0,Out=0] 
* CE 264: fun5(V1,V,Out) = 1+ fun5(W1,V,X1)
     [W1>=0,V>=0,X1+1=Out,W1+1=V1] 
* CE 265: fun5(V1,V,Out) = 1+ fun5(W1,X1,Y1)
     [X1>=0,W1>=0,Y1+1=Out,X1+1=V,W1+1=V1] 

### Cost equations --> "Loop" of fun5/3 
* CEs [264] --> Loop 217 
* CEs [265] --> Loop 218 
* CEs [263] --> Loop 219 

#### Loops of fun5/3 
* Loop 217: fun5(V1,V,Out)->  fun5(V1',V,Out')
                  [V>=0,V1>=1,Out=Out'+1,V1=V1'+1] 
* Loop 218: fun5(V1,V,Out)->  fun5(V1',V',Out')
                  [V>=1,V1>=1,Out=Out'+1,V=V'+1,V1=V1'+1] 
* Loop 219: fun5(V1,V,Out) [V>=0,V1>=0,Out=0] 

### Ranking functions of CR fun5(V1,V,Out) 
* RF of phase [217,218]: [V1]

#### Partial ranking functions of CR fun5(V1,V,Out) 
* Partial RF of phase [217,218]:
  - RF of loop [217:1,218:1]:
    V1
  - RF of loop [218:1]:
    V


### Resulting Chains:fun5(V1,V,Out) 
* [[217,218],219]
* [219]


### Merging Chains  fun5/3 into  External patterns of execution 
* [[219]] --> 1 
* [[219,[217,218]]] --> 2 


### Specialization of cost equations fun6/3 
* CE 71 is refined into CE [266] 
* CE 70 is refined into CE [267] 
* CE 69 is refined into CE [268] 


#### Refined cost equations fun6/3 
* CE 266: fun6(V1,V,Out) = 0
     [V>=0,V1>=0,Out=0] 
* CE 267: fun6(V1,V,Out) = 1+ fun6(W1,V,X1)
     [W1>=0,V>=0,X1+1=Out,W1+1=V1] 
* CE 268: fun6(V1,V,Out) = 1+ fun6(W1,X1,Y1)
     [X1>=0,W1>=0,Y1+1=Out,X1+1=V,W1+1=V1] 

### Cost equations --> "Loop" of fun6/3 
* CEs [267] --> Loop 220 
* CEs [268] --> Loop 221 
* CEs [266] --> Loop 222 

#### Loops of fun6/3 
* Loop 220: fun6(V1,V,Out)->  fun6(V1',V,Out')
                  [V>=0,V1>=1,Out=Out'+1,V1=V1'+1] 
* Loop 221: fun6(V1,V,Out)->  fun6(V1',V',Out')
                  [V>=1,V1>=1,Out=Out'+1,V=V'+1,V1=V1'+1] 
* Loop 222: fun6(V1,V,Out) [V>=0,V1>=0,Out=0] 

### Ranking functions of CR fun6(V1,V,Out) 
* RF of phase [220,221]: [V1]

#### Partial ranking functions of CR fun6(V1,V,Out) 
* Partial RF of phase [220,221]:
  - RF of loop [220:1,221:1]:
    V1
  - RF of loop [221:1]:
    V


### Resulting Chains:fun6(V1,V,Out) 
* [[220,221],222]
* [222]


### Merging Chains  fun6/3 into  External patterns of execution 
* [[222]] --> 1 
* [[222,[220,221]]] --> 2 


### Specialization of cost equations fun7/4 
* CE 74 is refined into CE [269] 
* CE 73 is refined into CE [270] 
* CE 72 is refined into CE [271] 


#### Refined cost equations fun7/4 
* CE 269: fun7(V1,V,V2,Out) = 0
     [V2>=0,V>=0,V1>=0,Out=0] 
* CE 270: fun7(V1,V,V2,Out) = 1+ fun7(W2,V,V2,X2)
     [W2>=0,V2>=0,V>=0,X2+1=Out,W2+1=V1] 
* CE 271: fun7(V1,V,V2,Out) = 1+ fun7(W2,X2,Y2,Z2)
     [Y2>=0,X2>=0,W2>=0,Z2+1=Out,Y2+1=V2,X2+1=V,W2+1=V1] 

### Cost equations --> "Loop" of fun7/4 
* CEs [270] --> Loop 223 
* CEs [271] --> Loop 224 
* CEs [269] --> Loop 225 

#### Loops of fun7/4 
* Loop 223: fun7(V1,V,V2,Out)->  fun7(V1',V,V2,Out')
                  [V2>=0,V>=0,V1>=1,Out=Out'+1,V1=V1'+1] 
* Loop 224: fun7(V1,V,V2,Out)->  fun7(V1',V',V2',Out')
                  [V2>=1,V>=1,V1>=1,Out=Out'+1,V2=V2'+1,V=V'+1,V1=V1'+1] 
* Loop 225: fun7(V1,V,V2,Out) [V2>=0,V>=0,V1>=0,Out=0] 

### Ranking functions of CR fun7(V1,V,V2,Out) 
* RF of phase [223,224]: [V1]

#### Partial ranking functions of CR fun7(V1,V,V2,Out) 
* Partial RF of phase [223,224]:
  - RF of loop [223:1,224:1]:
    V1
  - RF of loop [224:1]:
    V
    V2


### Resulting Chains:fun7(V1,V,V2,Out) 
* [[223,224],225]
* [225]


### Merging Chains  fun7/4 into  External patterns of execution 
* [[225]] --> 1 
* [[225,[223,224]]] --> 2 


### Specialization of cost equations fun8/2 
* CE 76 is refined into CE [272] 
* CE 75 is refined into CE [273] 


#### Refined cost equations fun8/2 
* CE 272: fun8(V1,Out) = 0
     [V1>=0,Out=0] 
* CE 273: fun8(V1,Out) = 1+ fun8(W1,X1)
     [W1>=0,X1+1=Out,W1+1=V1] 

### Cost equations --> "Loop" of fun8/2 
* CEs [273] --> Loop 226 
* CEs [272] --> Loop 227 

#### Loops of fun8/2 
* Loop 226: fun8(V1,Out)->  fun8(V1',Out')
                  [V1'>=0,Out=Out'+1,V1'+1=V1] 
* Loop 227: fun8(V1,Out) [V1>=0,Out=0] 

### Ranking functions of CR fun8(V1,Out) 
* RF of phase [226]: [V1]

#### Partial ranking functions of CR fun8(V1,Out) 
* Partial RF of phase [226]:
  - RF of loop [226:1]:
    V1


### Resulting Chains:fun8(V1,Out) 
* [[226],227]
* [227]


### Merging Chains  fun8/2 into  External patterns of execution 
* [[227]] --> 1 
* [[227,[226]]] --> 2 


### Specialization of cost equations fun9/2 
* CE 78 is refined into CE [274] 
* CE 77 is refined into CE [275] 


#### Refined cost equations fun9/2 
* CE 274: fun9(V1,Out) = 0
     [V1>=0,Out=0] 
* CE 275: fun9(V1,Out) = 1+ fun9(W1,X1)
     [W1>=0,X1+1=Out,W1+1=V1] 

### Cost equations --> "Loop" of fun9/2 
* CEs [275] --> Loop 228 
* CEs [274] --> Loop 229 

#### Loops of fun9/2 
* Loop 228: fun9(V1,Out)->  fun9(V1',Out')
                  [V1'>=0,Out=Out'+1,V1'+1=V1] 
* Loop 229: fun9(V1,Out) [V1>=0,Out=0] 

### Ranking functions of CR fun9(V1,Out) 
* RF of phase [228]: [V1]

#### Partial ranking functions of CR fun9(V1,Out) 
* Partial RF of phase [228]:
  - RF of loop [228:1]:
    V1


### Resulting Chains:fun9(V1,Out) 
* [[228],229]
* [229]


### Merging Chains  fun9/2 into  External patterns of execution 
* [[229]] --> 1 
* [[229,[228]]] --> 2 


### Specialization of cost equations isList/2 
* CE 158 is refined into CE [276] 
* CE 157 is refined into CE [277] 


#### Refined cost equations isList/2 
* CE 276: isList(V1,Out) = 0
     [V1>=0,Out=0] 
* CE 277: isList(V1,Out) = 1+ isList(W1,X1)
     [W1>=0,X1+1=Out,W1+1=V1] 

### Cost equations --> "Loop" of isList/2 
* CEs [277] --> Loop 230 
* CEs [276] --> Loop 231 

#### Loops of isList/2 
* Loop 230: isList(V1,Out)->  isList(V1',Out')
                  [V1'>=0,Out=Out'+1,V1'+1=V1] 
* Loop 231: isList(V1,Out) [V1>=0,Out=0] 

### Ranking functions of CR isList(V1,Out) 
* RF of phase [230]: [V1]

#### Partial ranking functions of CR isList(V1,Out) 
* Partial RF of phase [230]:
  - RF of loop [230:1]:
    V1


### Resulting Chains:isList(V1,Out) 
* [[230],231]
* [231]


### Merging Chains  isList/2 into  External patterns of execution 
* [[231]] --> 1 
* [[231,[230]]] --> 2 


### Specialization of cost equations isNeList/2 
* CE 54 is refined into CE [278] 
* CE 53 is refined into CE [279] 


#### Refined cost equations isNeList/2 
* CE 278: isNeList(V1,Out) = 0
     [V1>=0,Out=0] 
* CE 279: isNeList(V1,Out) = 1+ isNeList(W1,X1)
     [W1>=0,X1+1=Out,W1+1=V1] 

### Cost equations --> "Loop" of isNeList/2 
* CEs [279] --> Loop 232 
* CEs [278] --> Loop 233 

#### Loops of isNeList/2 
* Loop 232: isNeList(V1,Out)->  isNeList(V1',Out')
                  [V1'>=0,Out=Out'+1,V1'+1=V1] 
* Loop 233: isNeList(V1,Out) [V1>=0,Out=0] 

### Ranking functions of CR isNeList(V1,Out) 
* RF of phase [232]: [V1]

#### Partial ranking functions of CR isNeList(V1,Out) 
* Partial RF of phase [232]:
  - RF of loop [232:1]:
    V1


### Resulting Chains:isNeList(V1,Out) 
* [[232],233]
* [233]


### Merging Chains  isNeList/2 into  External patterns of execution 
* [[233]] --> 1 
* [[233,[232]]] --> 2 


### Specialization of cost equations isNePal/2 
* CE 150 is refined into CE [280] 
* CE 149 is refined into CE [281] 


#### Refined cost equations isNePal/2 
* CE 280: isNePal(V1,Out) = 0
     [V1>=0,Out=0] 
* CE 281: isNePal(V1,Out) = 1+ isNePal(W1,X1)
     [W1>=0,X1+1=Out,W1+1=V1] 

### Cost equations --> "Loop" of isNePal/2 
* CEs [281] --> Loop 234 
* CEs [280] --> Loop 235 

#### Loops of isNePal/2 
* Loop 234: isNePal(V1,Out)->  isNePal(V1',Out')
                  [V1'>=0,Out=Out'+1,V1'+1=V1] 
* Loop 235: isNePal(V1,Out) [V1>=0,Out=0] 

### Ranking functions of CR isNePal(V1,Out) 
* RF of phase [234]: [V1]

#### Partial ranking functions of CR isNePal(V1,Out) 
* Partial RF of phase [234]:
  - RF of loop [234:1]:
    V1


### Resulting Chains:isNePal(V1,Out) 
* [[234],235]
* [235]


### Merging Chains  isNePal/2 into  External patterns of execution 
* [[235]] --> 1 
* [[235,[234]]] --> 2 


### Specialization of cost equations isPal/2 
* CE 120 is refined into CE [282] 
* CE 119 is refined into CE [283] 


#### Refined cost equations isPal/2 
* CE 282: isPal(V1,Out) = 0
     [V1>=0,Out=0] 
* CE 283: isPal(V1,Out) = 1+ isPal(W1,X1)
     [W1>=0,X1+1=Out,W1+1=V1] 

### Cost equations --> "Loop" of isPal/2 
* CEs [283] --> Loop 236 
* CEs [282] --> Loop 237 

#### Loops of isPal/2 
* Loop 236: isPal(V1,Out)->  isPal(V1',Out')
                  [V1'>=0,Out=Out'+1,V1'+1=V1] 
* Loop 237: isPal(V1,Out) [V1>=0,Out=0] 

### Ranking functions of CR isPal(V1,Out) 
* RF of phase [236]: [V1]

#### Partial ranking functions of CR isPal(V1,Out) 
* Partial RF of phase [236]:
  - RF of loop [236:1]:
    V1


### Resulting Chains:isPal(V1,Out) 
* [[236],237]
* [237]


### Merging Chains  isPal/2 into  External patterns of execution 
* [[237]] --> 1 
* [[237,[236]]] --> 2 


### Specialization of cost equations isPalListKind/2 
* CE 163 is refined into CE [284] 
* CE 162 is refined into CE [285] 


#### Refined cost equations isPalListKind/2 
* CE 284: isPalListKind(V1,Out) = 0
     [V1>=0,Out=0] 
* CE 285: isPalListKind(V1,Out) = 1+ isPalListKind(W1,X1)
     [W1>=0,X1+1=Out,W1+1=V1] 

### Cost equations --> "Loop" of isPalListKind/2 
* CEs [285] --> Loop 238 
* CEs [284] --> Loop 239 

#### Loops of isPalListKind/2 
* Loop 238: isPalListKind(V1,Out)->  isPalListKind(V1',Out')
                  [V1'>=0,Out=Out'+1,V1'+1=V1] 
* Loop 239: isPalListKind(V1,Out) [V1>=0,Out=0] 

### Ranking functions of CR isPalListKind(V1,Out) 
* RF of phase [238]: [V1]

#### Partial ranking functions of CR isPalListKind(V1,Out) 
* Partial RF of phase [238]:
  - RF of loop [238:1]:
    V1


### Resulting Chains:isPalListKind(V1,Out) 
* [[238],239]
* [239]


### Merging Chains  isPalListKind/2 into  External patterns of execution 
* [[239]] --> 1 
* [[239,[238]]] --> 2 


### Specialization of cost equations isQid/2 
* CE 145 is refined into CE [286] 
* CE 144 is refined into CE [287] 


#### Refined cost equations isQid/2 
* CE 286: isQid(V1,Out) = 0
     [V1>=0,Out=0] 
* CE 287: isQid(V1,Out) = 1+ isQid(W1,X1)
     [W1>=0,X1+1=Out,W1+1=V1] 

### Cost equations --> "Loop" of isQid/2 
* CEs [287] --> Loop 240 
* CEs [286] --> Loop 241 

#### Loops of isQid/2 
* Loop 240: isQid(V1,Out)->  isQid(V1',Out')
                  [V1'>=0,Out=Out'+1,V1'+1=V1] 
* Loop 241: isQid(V1,Out) [V1>=0,Out=0] 

### Ranking functions of CR isQid(V1,Out) 
* RF of phase [240]: [V1]

#### Partial ranking functions of CR isQid(V1,Out) 
* Partial RF of phase [240]:
  - RF of loop [240:1]:
    V1


### Resulting Chains:isQid(V1,Out) 
* [[240],241]
* [241]


### Merging Chains  isQid/2 into  External patterns of execution 
* [[241]] --> 1 
* [[241,[240]]] --> 2 


### Specialization of cost equations proper/2 
* CE 86 is refined into CE [288] 
* CE 80 is refined into CE [289] 
* CE 82 is refined into CE [290] 
* CE 83 is refined into CE [291] 
* CE 81 is refined into CE [292] 
* CE 79 is refined into CE [293] 
* CE 84 is refined into CE [294] 
* CE 85 is refined into CE [295] 


#### Refined cost equations proper/2 
* CE 288: proper(V1,Out) = 0
     [V1>=0,Out=0] 
* CE 289: proper(V1,Out) = 1
     [Out=7,V1=6] 
* CE 290: proper(V1,Out) = 1
     [Out=6,V1=5] 
* CE 291: proper(V1,Out) = 1
     [Out=5,V1=4] 
* CE 292: proper(V1,Out) = 1
     [Out=4,V1=3] 
* CE 293: proper(V1,Out) = 1
     [Out=3,V1=2] 
* CE 294: proper(V1,Out) = 1
     [Out=2,V1=1] 
* CE 295: proper(V1,Out) = 1
     [Out=1,V1=0] 

### Cost equations --> "Loop" of proper/2 
* CEs [288] --> Loop 242 
* CEs [289] --> Loop 243 
* CEs [290] --> Loop 244 
* CEs [291] --> Loop 245 
* CEs [292] --> Loop 246 
* CEs [293] --> Loop 247 
* CEs [294] --> Loop 248 
* CEs [295] --> Loop 249 

#### Loops of proper/2 
* Loop 242: proper(V1,Out) [V1>=0,Out=0] 
* Loop 243: proper(V1,Out) [Out=7,V1=6] 
* Loop 244: proper(V1,Out) [Out=6,V1=5] 
* Loop 245: proper(V1,Out) [Out=5,V1=4] 
* Loop 246: proper(V1,Out) [Out=4,V1=3] 
* Loop 247: proper(V1,Out) [Out=3,V1=2] 
* Loop 248: proper(V1,Out) [Out=2,V1=1] 
* Loop 249: proper(V1,Out) [Out=1,V1=0] 

### Ranking functions of CR proper(V1,Out) 

#### Partial ranking functions of CR proper(V1,Out) 


### Resulting Chains:proper(V1,Out) 
* [249]
* [248]
* [247]
* [246]
* [245]
* [244]
* [243]
* [242]


### Merging Chains  proper/2 into  External patterns of execution 
* [[249]] --> 1 
* [[248]] --> 2 
* [[247]] --> 3 
* [[246]] --> 4 
* [[245]] --> 5 
* [[244]] --> 6 
* [[243]] --> 7 
* [[242]] --> 8 


### Specialization of cost equations top/2 
* CE 52 is refined into CE [296] 
* CE 50 is refined into CE [297] 
* CE 51 is refined into CE [298,299,300,301,302,303,304,305] 


#### Refined cost equations top/2 
* CE 296: top(V1,Out) = 0
     [V1>=0,Out=0] 
* CE 297: top(V1,Out) = 1+ top(V1,Out)
     [V1>=1] 
* CE 298: top(V1,Out) = 1+ proper(W1,X1):1+ top(Y1,Out)
     [Y1=1,X1=1,W1=0,V1=1] 
* CE 299: top(V1,Out) = 1+ proper(W1,X1):2+ top(Y1,Out)
     [Y1=2,X1=2,W1=1,V1=2] 
* CE 300: top(V1,Out) = 1+ proper(W1,X1):3+ top(Y1,Out)
     [Y1=3,X1=3,W1=2,V1=3] 
* CE 301: top(V1,Out) = 1+ proper(W1,X1):4+ top(Y1,Out)
     [Y1=4,X1=4,W1=3,V1=4] 
* CE 302: top(V1,Out) = 1+ proper(W1,X1):5+ top(Y1,Out)
     [Y1=5,X1=5,W1=4,V1=5] 
* CE 303: top(V1,Out) = 1+ proper(W1,X1):6+ top(Y1,Out)
     [Y1=6,X1=6,W1=5,V1=6] 
* CE 304: top(V1,Out) = 1+ proper(W1,X1):7+ top(Y1,Out)
     [Y1=7,X1=7,W1=6,V1=7] 
* CE 305: top(V1,Out) = 1+ proper(W1,X1):8+ top(Y1,Out)
     [W1>=0,W1+1=V1,Y1=0,X1=0] 

### Cost equations --> "Loop" of top/2 
* CEs [305] --> Loop 250 
* CEs [304] --> Loop 251 
* CEs [303] --> Loop 252 
* CEs [302] --> Loop 253 
* CEs [301] --> Loop 254 
* CEs [300] --> Loop 255 
* CEs [299] --> Loop 256 
* CEs [297,298] --> Loop 257 
* CEs [296] --> Loop 258 

#### Loops of top/2 
* Loop 250: top(V1,Out)->  top(V1',Out)
                  [V1>=1,V1'=0] 
* Loop 251: top(V1,Out)->  top(V1',Out)
                  [V1'=7,V1=7] 
* Loop 252: top(V1,Out)->  top(V1',Out)
                  [V1'=6,V1=6] 
* Loop 253: top(V1,Out)->  top(V1',Out)
                  [V1'=5,V1=5] 
* Loop 254: top(V1,Out)->  top(V1',Out)
                  [V1'=4,V1=4] 
* Loop 255: top(V1,Out)->  top(V1',Out)
                  [V1'=3,V1=3] 
* Loop 256: top(V1,Out)->  top(V1',Out)
                  [V1'=2,V1=2] 
* Loop 257: top(V1,Out)->  top(V1,Out)
                  [V1>=1] 
* Loop 258: top(V1,Out) [V1>=0,Out=0] 

### Ranking functions of CR top(V1,Out) 

#### Partial ranking functions of CR top(V1,Out) 


### Resulting Chains:top(V1,Out) 
* [[251,252,253,254,255,256,257]]...
* [[251,252,253,254,255,256,257],258]
* [[251,252,253,254,255,256,257],250,258]
* [258]
* [250,258]


### Merging Chains  top/2 into  External patterns of execution 
* [[258,250],[258],[258,250,[251,252,253,254,255,256,257]],[258,[251,252,253,254,255,256,257]]] --> 1 
* [[[251,252,253,254,255,256,257]]] --> 2 


### Specialization of cost equations start/3 
* CE 2 is refined into CE [306,307] 
* CE 3 is refined into CE [308,309] 
* CE 4 is refined into CE [310,311] 
* CE 5 is refined into CE [312,313] 
* CE 6 is refined into CE [314,315] 
* CE 7 is refined into CE [316,317] 
* CE 8 is refined into CE [318,319] 
* CE 9 is refined into CE [320,321] 
* CE 10 is refined into CE [322,323] 
* CE 11 is refined into CE [324,325] 
* CE 12 is refined into CE [326,327] 
* CE 13 is refined into CE [328,329] 
* CE 14 is refined into CE [330,331,332,333,334,335,336,337] 
* CE 15 is refined into CE [338,339] 
* CE 16 is refined into CE [340,341] 
* CE 17 is refined into CE [342,343] 
* CE 18 is refined into CE [344,345] 
* CE 19 is refined into CE [346,347] 
* CE 20 is refined into CE [348,349] 
* CE 21 is refined into CE [350,351] 
* CE 22 is refined into CE [352,353] 
* CE 23 is refined into CE [354,355] 
* CE 24 is refined into CE [356,357] 
* CE 25 is refined into CE [358,359] 
* CE 26 is refined into CE [360,361] 
* CE 27 is refined into CE [362,363] 
* CE 28 is refined into CE [364,365] 
* CE 29 is refined into CE [366,367] 
* CE 30 is refined into CE [368,369] 
* CE 31 is refined into CE [370,371] 
* CE 32 is refined into CE [372,373] 
* CE 33 is refined into CE [374,375] 
* CE 34 is refined into CE [376,377] 
* CE 35 is refined into CE [378,379] 
* CE 36 is refined into CE [380,381] 
* CE 37 is refined into CE [382,383] 
* CE 38 is refined into CE [384,385] 
* CE 39 is refined into CE [386,387] 
* CE 40 is refined into CE [388,389] 
* CE 41 is refined into CE [390,391] 
* CE 42 is refined into CE [392,393] 
* CE 43 is refined into CE [394,395] 
* CE 44 is refined into CE [396,397] 
* CE 45 is refined into CE [398,399] 
* CE 46 is refined into CE [400,401] 


#### Refined cost equations start/3 
* CE 306: start(V1,V,V2) = 0+ fun(V1,V,W2):1
     [V>=0,V1>=0,W2=0] 
* CE 307: start(V1,V,V2) = 0+ fun(V1,V,W2):2
     [V1>=W2,W2>=1,V>=0] 
* CE 308: start(V1,V,V2) = 0+ top(V1,W2):1
     [V1>=0,W2=0] 
* CE 309: start(V1,V,V2) = 0+ top(V1,W2):2
     [V1>=1] 
* CE 310: start(V1,V,V2) = 0+ isNeList(V1,W2):1
     [V1>=0,W2=0] 
* CE 311: start(V1,V,V2) = 0+ isNeList(V1,W2):2
     [V1>=W2,W2>=1] 
* CE 312: start(V1,V,V2) = 0+ fun1(V1,V,W2):1
     [V>=0,V1>=0,W2=0] 
* CE 313: start(V1,V,V2) = 0+ fun1(V1,V,W2):2
     [V1>=W2,W2>=1,V>=0] 
* CE 314: start(V1,V,V2) = 0+ fun2(V1,V,W2):1
     [V>=0,V1>=0,W2=0] 
* CE 315: start(V1,V,V2) = 0+ fun2(V1,V,W2):2
     [V1>=W2,W2>=1,V>=0] 
* CE 316: start(V1,V,V2) = 0+ fun3(V1,V,V2,W2):1
     [V2>=0,V>=0,V1>=0,W2=0] 
* CE 317: start(V1,V,V2) = 0+ fun3(V1,V,V2,W2):2
     [V1>=W2,W2>=1,V2>=0,V>=0] 
* CE 318: start(V1,V,V2) = 0+ fun4(V1,W2):1
     [V1>=0,W2=0] 
* CE 319: start(V1,V,V2) = 0+ fun4(V1,W2):2
     [V1>=W2,W2>=1] 
* CE 320: start(V1,V,V2) = 0+ fun5(V1,V,W2):1
     [V>=0,V1>=0,W2=0] 
* CE 321: start(V1,V,V2) = 0+ fun5(V1,V,W2):2
     [V1>=W2,W2>=1,V>=0] 
* CE 322: start(V1,V,V2) = 0+ fun6(V1,V,W2):1
     [V>=0,V1>=0,W2=0] 
* CE 323: start(V1,V,V2) = 0+ fun6(V1,V,W2):2
     [V1>=W2,W2>=1,V>=0] 
* CE 324: start(V1,V,V2) = 0+ fun7(V1,V,V2,W2):1
     [V2>=0,V>=0,V1>=0,W2=0] 
* CE 325: start(V1,V,V2) = 0+ fun7(V1,V,V2,W2):2
     [V1>=W2,W2>=1,V2>=0,V>=0] 
* CE 326: start(V1,V,V2) = 0+ fun8(V1,W2):1
     [V1>=0,W2=0] 
* CE 327: start(V1,V,V2) = 0+ fun8(V1,W2):2
     [V1>=W2,W2>=1] 
* CE 328: start(V1,V,V2) = 0+ fun9(V1,W2):1
     [V1>=0,W2=0] 
* CE 329: start(V1,V,V2) = 0+ fun9(V1,W2):2
     [V1>=W2,W2>=1] 
* CE 330: start(V1,V,V2) = 0+ proper(W2,X2):1
     [X2=1,W2=0,V1=0] 
* CE 331: start(V1,V,V2) = 0+ proper(W2,X2):2
     [X2=2,W2=1,V1=1] 
* CE 332: start(V1,V,V2) = 0+ proper(W2,X2):3
     [X2=3,W2=2,V1=2] 
* CE 333: start(V1,V,V2) = 0+ proper(W2,X2):4
     [X2=4,W2=3,V1=3] 
* CE 334: start(V1,V,V2) = 0+ proper(W2,X2):5
     [X2=5,W2=4,V1=4] 
* CE 335: start(V1,V,V2) = 0+ proper(W2,X2):6
     [X2=6,W2=5,V1=5] 
* CE 336: start(V1,V,V2) = 0+ proper(W2,X2):7
     [X2=7,W2=6,V1=6] 
* CE 337: start(V1,V,V2) = 0+ proper(V1,W2):8
     [V1>=0,W2=0] 
* CE 338: start(V1,V,V2) = 0+ fun10(V1,V,V2,W2):1
     [V2>=0,V>=0,V1>=0,W2=0] 
* CE 339: start(V1,V,V2) = 0+ fun10(V1,V,V2,W2):2
     [V1>=W2,W2>=1,V2>=0,V>=0] 
* CE 340: start(V1,V,V2) = 0+ fun11(V1,V,V2,W2):1
     [V2>=0,V>=0,V1>=0,W2=0] 
* CE 341: start(V1,V,V2) = 0+ fun11(V1,V,V2,W2):2
     [V1>=W2,W2>=1,V2>=0,V>=0] 
* CE 342: start(V1,V,V2) = 0+ fun12(V1,V,W2):1
     [V>=0,V1>=0,W2=0] 
* CE 343: start(V1,V,V2) = 0+ fun12(V1,V,W2):2
     [V1+V>=W2,W2>=1,V>=0,V1>=0] 
* CE 344: start(V1,V,V2) = 0+ fun13(V1,V,W2):1
     [V>=0,V1>=0,W2=0] 
* CE 345: start(V1,V,V2) = 0+ fun13(V1,V,W2):2
     [V1>=W2,W2>=1,V>=0] 
* CE 346: start(V1,V,V2) = 0+ fun14(V1,W2):1
     [V1>=0,W2=0] 
* CE 347: start(V1,V,V2) = 0+ fun14(V1,W2):2
     [V1>=W2,W2>=1] 
* CE 348: start(V1,V,V2) = 0+ fun15(V1,V,W2):1
     [V>=0,V1>=0,W2=0] 
* CE 349: start(V1,V,V2) = 0+ fun15(V1,V,W2):2
     [V1>=W2,W2>=1,V>=0] 
* CE 350: start(V1,V,V2) = 0+ fun16(V1,W2):1
     [V1>=0,W2=0] 
* CE 351: start(V1,V,V2) = 0+ fun16(V1,W2):2
     [V1>=W2,W2>=1] 
* CE 352: start(V1,V,V2) = 0+ fun17(V1,V,V2,W2):1
     [V2>=0,V>=0,V1>=0,W2=0] 
* CE 353: start(V1,V,V2) = 0+ fun17(V1,V,V2,W2):2
     [V1>=W2,W2>=1,V2>=0,V>=0] 
* CE 354: start(V1,V,V2) = 0+ fun18(V1,V,V2,W2):1
     [V2>=0,V>=0,V1>=0,W2=0] 
* CE 355: start(V1,V,V2) = 0+ fun18(V1,V,V2,W2):2
     [V1>=W2,W2>=1,V2>=0,V>=0] 
* CE 356: start(V1,V,V2) = 0+ fun19(V1,V,W2):1
     [V>=0,V1>=0,W2=0] 
* CE 357: start(V1,V,V2) = 0+ fun19(V1,V,W2):2
     [V1>=W2,W2>=1,V>=0] 
* CE 358: start(V1,V,V2) = 0+ fun20(V1,V,W2):1
     [V>=0,V1>=0,W2=0] 
* CE 359: start(V1,V,V2) = 0+ fun20(V1,V,W2):2
     [V1>=W2,W2>=1,V>=0] 
* CE 360: start(V1,V,V2) = 0+ isPal(V1,W2):1
     [V1>=0,W2=0] 
* CE 361: start(V1,V,V2) = 0+ isPal(V1,W2):2
     [V1>=W2,W2>=1] 
* CE 362: start(V1,V,V2) = 0+ fun21(V1,W2):1
     [V1>=0,W2=0] 
* CE 363: start(V1,V,V2) = 0+ fun21(V1,W2):2
     [V1>=W2,W2>=1] 
* CE 364: start(V1,V,V2) = 0+ fun22(V1,V,W2):1
     [V>=0,V1>=0,W2=0] 
* CE 365: start(V1,V,V2) = 0+ fun22(V1,V,W2):2
     [V1>=W2,W2>=1,V>=0] 
* CE 366: start(V1,V,V2) = 0+ fun23(V1,W2):1
     [V1>=0,W2=0] 
* CE 367: start(V1,V,V2) = 0+ fun23(V1,W2):2
     [V1>=W2,W2>=1] 
* CE 368: start(V1,V,V2) = 0+ fun24(V1,W2):1
     [V1>=0,W2=0] 
* CE 369: start(V1,V,V2) = 0+ fun24(V1,W2):2
     [V1>=W2,W2>=1] 
* CE 370: start(V1,V,V2) = 0+ fun25(V1,W2):1
     [V1>=0,W2=0] 
* CE 371: start(V1,V,V2) = 0+ fun25(V1,W2):2
     [V1>=W2,W2>=1] 
* CE 372: start(V1,V,V2) = 0+ fun26(V1,V,V2,W2):1
     [V2>=0,V>=0,V1>=0,W2=0] 
* CE 373: start(V1,V,V2) = 0+ fun26(V1,V,V2,W2):2
     [V1>=W2,W2>=1,V2>=0,V>=0] 
* CE 374: start(V1,V,V2) = 0+ fun27(V1,V,V2,W2):1
     [V2>=0,V>=0,V1>=0,W2=0] 
* CE 375: start(V1,V,V2) = 0+ fun27(V1,V,V2,W2):2
     [V1>=W2,W2>=1,V2>=0,V>=0] 
* CE 376: start(V1,V,V2) = 0+ fun28(V1,V,W2):1
     [V>=0,V1>=0,W2=0] 
* CE 377: start(V1,V,V2) = 0+ fun28(V1,V,W2):2
     [V1>=W2,W2>=1,V>=0] 
* CE 378: start(V1,V,V2) = 0+ fun29(V1,V,V2,W2):1
     [V2>=0,V>=0,V1>=0,W2=0] 
* CE 379: start(V1,V,V2) = 0+ fun29(V1,V,V2,W2):2
     [V1>=W2,W2>=1,V2>=0,V>=0] 
* CE 380: start(V1,V,V2) = 0+ isQid(V1,W2):1
     [V1>=0,W2=0] 
* CE 381: start(V1,V,V2) = 0+ isQid(V1,W2):2
     [V1>=W2,W2>=1] 
* CE 382: start(V1,V,V2) = 0+ fun30(V1,V,W2):1
     [V>=0,V1>=0,W2=0] 
* CE 383: start(V1,V,V2) = 0+ fun30(V1,V,W2):2
     [V1>=W2,W2>=1,V>=0] 
* CE 384: start(V1,V,V2) = 0+ isNePal(V1,W2):1
     [V1>=0,W2=0] 
* CE 385: start(V1,V,V2) = 0+ isNePal(V1,W2):2
     [V1>=W2,W2>=1] 
* CE 386: start(V1,V,V2) = 0+ fun31(V1,V,V2,W2):1
     [V2>=0,V>=0,V1>=0,W2=0] 
* CE 387: start(V1,V,V2) = 0+ fun31(V1,V,V2,W2):2
     [V1>=W2,W2>=1,V2>=0,V>=0] 
* CE 388: start(V1,V,V2) = 0+ fun32(V1,V,V2,W2):1
     [V2>=0,V>=0,V1>=0,W2=0] 
* CE 389: start(V1,V,V2) = 0+ fun32(V1,V,V2,W2):2
     [V1>=W2,W2>=1,V2>=0,V>=0] 
* CE 390: start(V1,V,V2) = 0+ isList(V1,W2):1
     [V1>=0,W2=0] 
* CE 391: start(V1,V,V2) = 0+ isList(V1,W2):2
     [V1>=W2,W2>=1] 
* CE 392: start(V1,V,V2) = 0+ fun33(V1,V,W2):1
     [V>=0,V1>=0,W2=0] 
* CE 393: start(V1,V,V2) = 0+ fun33(V1,V,W2):2
     [V1>=W2,W2>=1,V>=0] 
* CE 394: start(V1,V,V2) = 0+ isPalListKind(V1,W2):1
     [V1>=0,W2=0] 
* CE 395: start(V1,V,V2) = 0+ isPalListKind(V1,W2):2
     [V1>=W2,W2>=1] 
* CE 396: start(V1,V,V2) = 0+ fun34(V1,V,V2,W2):1
     [V2>=0,V>=0,V1>=0,W2=0] 
* CE 397: start(V1,V,V2) = 0+ fun34(V1,V,V2,W2):2
     [V1>=W2,W2>=1,V2>=0,V>=0] 
* CE 398: start(V1,V,V2) = 0+ fun35(V1,V,W2):1
     [V>=0,V1>=0,W2=0] 
* CE 399: start(V1,V,V2) = 0+ fun35(V1,V,W2):2
     [V1>=W2,W2>=1,V>=0] 
* CE 400: start(V1,V,V2) = 0+ fun36(V1,V,V2,W2):1
     [V2>=0,V>=0,V1>=0,W2=0] 
* CE 401: start(V1,V,V2) = 0+ fun36(V1,V,V2,W2):2
     [V1>=W2,W2>=1,V2>=0,V>=0] 

### Cost equations --> "Loop" of start/3 
* CEs [336] --> Loop 259 
* CEs [335] --> Loop 260 
* CEs [334] --> Loop 261 
* CEs [333] --> Loop 262 
* CEs [332] --> Loop 263 
* CEs [331] --> Loop 264 
* CEs [306,307,308,310,311,312,313,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,337,338,339,340,341,342,343,344,345,346,347,348,349,350,351,352,353,354,355,356,357,358,359,360,361,362,363,364,365,366,367,368,369,370,371,372,373,374,375,376,377,378,379,380,381,382,383,384,385,386,387,388,389,390,391,392,393,394,395,396,397,398,399,400,401] --> Loop 265 
* CEs [309] --> Loop 266 

#### Loops of start/3 
* Loop 259: start(V1,V,V2) [V1=6] 
* Loop 260: start(V1,V,V2) [V1=5] 
* Loop 261: start(V1,V,V2) [V1=4] 
* Loop 262: start(V1,V,V2) [V1=3] 
* Loop 263: start(V1,V,V2) [V1=2] 
* Loop 264: start(V1,V,V2) [V1=1] 
* Loop 265: start(V1,V,V2) [V1>=0] 
* Loop 266: start(V1,V,V2) [V1>=1] 

### Ranking functions of CR start(V1,V,V2) 

#### Partial ranking functions of CR start(V1,V,V2) 


### Resulting Chains:start(V1,V,V2) 
* [266]...
* [265]
* [264]
* [263]
* [262]
* [261]
* [260]
* [259]


### Merging Chains  start/3 into  External patterns of execution 
* [[264],[265]] --> 1 
* [[263]] --> 2 
* [[262]] --> 3 
* [[261]] --> 4 
* [[260]] --> 5 
* [[259]] --> 6 
* [[266]] --> 7 


Computing Bounds
=====================================

#### Cost of loops [127,128] 

 * loop 127:fun(V1,V,Out) -> [fun(V1',V',Out')] 
1
 * loop 128:fun(V1,V,Out) -> [fun(V1',V',Out')] 
1
#### Cost of phase [127,128]:fun(V1,V,Out) -> [fun(V1',V',Out')] 
1*it(127)+1*it(128)+0
  Such that:it(128) =< V
it(128) =< V-V'
aux(1) =< V1
aux(2) =< V1-V1'
it(127) =< aux(1)
it(128) =< aux(1)
it(127) =< aux(2)
it(128) =< aux(2)

#### Cost of chains of fun(V1,V,Out):
* Chain [[127,128],129]: 1*it(127)+1*it(128)+0
  Such that:aux(1) =< V1
it(128) =< V
aux(2) =< Out
it(127) =< aux(1)
it(128) =< aux(1)
it(127) =< aux(2)
it(128) =< aux(2)

  with precondition: [V>=0,Out>=1,V1>=Out] 

* Chain [129]: 0
  with precondition: [Out=0,V1>=0,V>=0] 


#### Cost of loops [130,131] 

 * loop 130:fun1(V1,V,Out) -> [fun1(V1',V',Out')] 
1
 * loop 131:fun1(V1,V,Out) -> [fun1(V1',V',Out')] 
1
#### Cost of phase [130,131]:fun1(V1,V,Out) -> [fun1(V1',V',Out')] 
1*it(130)+1*it(131)+0
  Such that:it(131) =< V
it(131) =< V-V'
aux(3) =< V1
aux(4) =< V1-V1'
it(130) =< aux(3)
it(131) =< aux(3)
it(130) =< aux(4)
it(131) =< aux(4)

#### Cost of chains of fun1(V1,V,Out):
* Chain [[130,131],132]: 1*it(130)+1*it(131)+0
  Such that:aux(3) =< V1
it(131) =< V
aux(4) =< Out
it(130) =< aux(3)
it(131) =< aux(3)
it(130) =< aux(4)
it(131) =< aux(4)

  with precondition: [V>=0,Out>=1,V1>=Out] 

* Chain [132]: 0
  with precondition: [Out=0,V1>=0,V>=0] 


#### Cost of loops [133,134] 

 * loop 133:fun10(V1,V,V2,Out) -> [fun10(V1',V',V2',Out')] 
1
 * loop 134:fun10(V1,V,V2,Out) -> [fun10(V1',V',V2',Out')] 
1
#### Cost of phase [133,134]:fun10(V1,V,V2,Out) -> [fun10(V1',V',V2',Out')] 
1*it(133)+1*it(134)+0
  Such that:it(134) =< V
it(134) =< V-V'
it(134) =< V2
it(134) =< V2-V2'
aux(5) =< V1
aux(6) =< V1-V1'
it(133) =< aux(5)
it(134) =< aux(5)
it(133) =< aux(6)
it(134) =< aux(6)

#### Cost of chains of fun10(V1,V,V2,Out):
* Chain [[133,134],135]: 1*it(133)+1*it(134)+0
  Such that:aux(5) =< V1
it(134) =< V
aux(6) =< Out
it(133) =< aux(5)
it(134) =< aux(5)
it(133) =< aux(6)
it(134) =< aux(6)

  with precondition: [V>=0,V2>=0,Out>=1,V1>=Out] 

* Chain [135]: 0
  with precondition: [Out=0,V1>=0,V>=0,V2>=0] 


#### Cost of loops [136,137] 

 * loop 136:fun11(V1,V,V2,Out) -> [fun11(V1',V',V2',Out')] 
1
 * loop 137:fun11(V1,V,V2,Out) -> [fun11(V1',V',V2',Out')] 
1
#### Cost of phase [136,137]:fun11(V1,V,V2,Out) -> [fun11(V1',V',V2',Out')] 
1*it(136)+1*it(137)+0
  Such that:it(137) =< V
it(137) =< V-V'
it(137) =< V2
it(137) =< V2-V2'
aux(7) =< V1
aux(8) =< V1-V1'
it(136) =< aux(7)
it(137) =< aux(7)
it(136) =< aux(8)
it(137) =< aux(8)

#### Cost of chains of fun11(V1,V,V2,Out):
* Chain [[136,137],138]: 1*it(136)+1*it(137)+0
  Such that:aux(7) =< V1
it(137) =< V
aux(8) =< Out
it(136) =< aux(7)
it(137) =< aux(7)
it(136) =< aux(8)
it(137) =< aux(8)

  with precondition: [V>=0,V2>=0,Out>=1,V1>=Out] 

* Chain [138]: 0
  with precondition: [Out=0,V1>=0,V>=0,V2>=0] 


#### Cost of loops [139,140,141] 

 * loop 139:fun12(V1,V,Out) -> [fun12(V1',V',Out')] 
1
 * loop 140:fun12(V1,V,Out) -> [fun12(V1',V',Out')] 
1
 * loop 141:fun12(V1,V,Out) -> [fun12(V1',V',Out')] 
1
#### Cost of phase [139,140,141]:fun12(V1,V,Out) -> [fun12(V1',V',Out')] 
1*it(139)+1*it(140)+1*it(141)+0
  Such that:aux(9) =< V1
aux(10) =< V1+V
aux(11) =< V1+V-V1'-V'
aux(12) =< V1-V1'
aux(13) =< V
aux(14) =< V-V'
it(140) =< aux(9)
it(141) =< aux(9)
it(139) =< aux(10)
it(140) =< aux(10)
it(141) =< aux(10)
it(139) =< aux(11)
it(140) =< aux(11)
it(141) =< aux(11)
it(140) =< aux(12)
it(141) =< aux(12)
it(139) =< aux(13)
it(141) =< aux(13)
it(139) =< aux(14)
it(141) =< aux(14)

#### Cost of chains of fun12(V1,V,Out):
* Chain [[139,140,141],142]: 1*it(139)+1*it(140)+1*it(141)+0
  Such that:aux(15) =< V1
aux(16) =< V1+V
aux(17) =< V
it(140) =< aux(15)
it(141) =< aux(15)
it(139) =< aux(16)
it(140) =< aux(16)
it(141) =< aux(16)
it(139) =< aux(17)
it(141) =< aux(17)

  with precondition: [V1>=0,V>=0,Out>=1,V+V1>=Out] 

* Chain [142]: 0
  with precondition: [Out=0,V1>=0,V>=0] 


#### Cost of loops [143,144] 

 * loop 143:fun13(V1,V,Out) -> [fun13(V1',V',Out')] 
1
 * loop 144:fun13(V1,V,Out) -> [fun13(V1',V',Out')] 
1
#### Cost of phase [143,144]:fun13(V1,V,Out) -> [fun13(V1',V',Out')] 
1*it(143)+1*it(144)+0
  Such that:it(144) =< V
it(144) =< V-V'
aux(18) =< V1
aux(19) =< V1-V1'
it(143) =< aux(18)
it(144) =< aux(18)
it(143) =< aux(19)
it(144) =< aux(19)

#### Cost of chains of fun13(V1,V,Out):
* Chain [[143,144],145]: 1*it(143)+1*it(144)+0
  Such that:aux(18) =< V1
it(144) =< V
aux(19) =< Out
it(143) =< aux(18)
it(144) =< aux(18)
it(143) =< aux(19)
it(144) =< aux(19)

  with precondition: [V>=0,Out>=1,V1>=Out] 

* Chain [145]: 0
  with precondition: [Out=0,V1>=0,V>=0] 


#### Cost of loops [146] 

 * loop 146:fun14(V1,Out) -> [fun14(V1',Out')] 
1
#### Cost of phase [146]:fun14(V1,Out) -> [fun14(V1',Out')] 
1*it(146)+0
  Such that:it(146) =< V1
it(146) =< V1-V1'

#### Cost of chains of fun14(V1,Out):
* Chain [[146],147]: 1*it(146)+0
  Such that:it(146) =< Out

  with precondition: [Out>=1,V1>=Out] 

* Chain [147]: 0
  with precondition: [Out=0,V1>=0] 


#### Cost of loops [148,149] 

 * loop 148:fun15(V1,V,Out) -> [fun15(V1',V',Out')] 
1
 * loop 149:fun15(V1,V,Out) -> [fun15(V1',V',Out')] 
1
#### Cost of phase [148,149]:fun15(V1,V,Out) -> [fun15(V1',V',Out')] 
1*it(148)+1*it(149)+0
  Such that:it(149) =< V
it(149) =< V-V'
aux(20) =< V1
aux(21) =< V1-V1'
it(148) =< aux(20)
it(149) =< aux(20)
it(148) =< aux(21)
it(149) =< aux(21)

#### Cost of chains of fun15(V1,V,Out):
* Chain [[148,149],150]: 1*it(148)+1*it(149)+0
  Such that:aux(20) =< V1
it(149) =< V
aux(21) =< Out
it(148) =< aux(20)
it(149) =< aux(20)
it(148) =< aux(21)
it(149) =< aux(21)

  with precondition: [V>=0,Out>=1,V1>=Out] 

* Chain [150]: 0
  with precondition: [Out=0,V1>=0,V>=0] 


#### Cost of loops [151] 

 * loop 151:fun16(V1,Out) -> [fun16(V1',Out')] 
1
#### Cost of phase [151]:fun16(V1,Out) -> [fun16(V1',Out')] 
1*it(151)+0
  Such that:it(151) =< V1
it(151) =< V1-V1'

#### Cost of chains of fun16(V1,Out):
* Chain [[151],152]: 1*it(151)+0
  Such that:it(151) =< Out

  with precondition: [Out>=1,V1>=Out] 

* Chain [152]: 0
  with precondition: [Out=0,V1>=0] 


#### Cost of loops [153,154] 

 * loop 153:fun17(V1,V,V2,Out) -> [fun17(V1',V',V2',Out')] 
1
 * loop 154:fun17(V1,V,V2,Out) -> [fun17(V1',V',V2',Out')] 
1
#### Cost of phase [153,154]:fun17(V1,V,V2,Out) -> [fun17(V1',V',V2',Out')] 
1*it(153)+1*it(154)+0
  Such that:it(154) =< V
it(154) =< V-V'
it(154) =< V2
it(154) =< V2-V2'
aux(22) =< V1
aux(23) =< V1-V1'
it(153) =< aux(22)
it(154) =< aux(22)
it(153) =< aux(23)
it(154) =< aux(23)

#### Cost of chains of fun17(V1,V,V2,Out):
* Chain [[153,154],155]: 1*it(153)+1*it(154)+0
  Such that:aux(22) =< V1
it(154) =< V
aux(23) =< Out
it(153) =< aux(22)
it(154) =< aux(22)
it(153) =< aux(23)
it(154) =< aux(23)

  with precondition: [V>=0,V2>=0,Out>=1,V1>=Out] 

* Chain [155]: 0
  with precondition: [Out=0,V1>=0,V>=0,V2>=0] 


#### Cost of loops [156,157] 

 * loop 156:fun18(V1,V,V2,Out) -> [fun18(V1',V',V2',Out')] 
1
 * loop 157:fun18(V1,V,V2,Out) -> [fun18(V1',V',V2',Out')] 
1
#### Cost of phase [156,157]:fun18(V1,V,V2,Out) -> [fun18(V1',V',V2',Out')] 
1*it(156)+1*it(157)+0
  Such that:it(157) =< V
it(157) =< V-V'
it(157) =< V2
it(157) =< V2-V2'
aux(24) =< V1
aux(25) =< V1-V1'
it(156) =< aux(24)
it(157) =< aux(24)
it(156) =< aux(25)
it(157) =< aux(25)

#### Cost of chains of fun18(V1,V,V2,Out):
* Chain [[156,157],158]: 1*it(156)+1*it(157)+0
  Such that:aux(24) =< V1
it(157) =< V
aux(25) =< Out
it(156) =< aux(24)
it(157) =< aux(24)
it(156) =< aux(25)
it(157) =< aux(25)

  with precondition: [V>=0,V2>=0,Out>=1,V1>=Out] 

* Chain [158]: 0
  with precondition: [Out=0,V1>=0,V>=0,V2>=0] 


#### Cost of loops [159,160] 

 * loop 159:fun19(V1,V,Out) -> [fun19(V1',V',Out')] 
1
 * loop 160:fun19(V1,V,Out) -> [fun19(V1',V',Out')] 
1
#### Cost of phase [159,160]:fun19(V1,V,Out) -> [fun19(V1',V',Out')] 
1*it(159)+1*it(160)+0
  Such that:it(160) =< V
it(160) =< V-V'
aux(26) =< V1
aux(27) =< V1-V1'
it(159) =< aux(26)
it(160) =< aux(26)
it(159) =< aux(27)
it(160) =< aux(27)

#### Cost of chains of fun19(V1,V,Out):
* Chain [[159,160],161]: 1*it(159)+1*it(160)+0
  Such that:aux(26) =< V1
it(160) =< V
aux(27) =< Out
it(159) =< aux(26)
it(160) =< aux(26)
it(159) =< aux(27)
it(160) =< aux(27)

  with precondition: [V>=0,Out>=1,V1>=Out] 

* Chain [161]: 0
  with precondition: [Out=0,V1>=0,V>=0] 


#### Cost of loops [162,163] 

 * loop 162:fun2(V1,V,Out) -> [fun2(V1',V',Out')] 
1
 * loop 163:fun2(V1,V,Out) -> [fun2(V1',V',Out')] 
1
#### Cost of phase [162,163]:fun2(V1,V,Out) -> [fun2(V1',V',Out')] 
1*it(162)+1*it(163)+0
  Such that:it(163) =< V
it(163) =< V-V'
aux(28) =< V1
aux(29) =< V1-V1'
it(162) =< aux(28)
it(163) =< aux(28)
it(162) =< aux(29)
it(163) =< aux(29)

#### Cost of chains of fun2(V1,V,Out):
* Chain [[162,163],164]: 1*it(162)+1*it(163)+0
  Such that:aux(28) =< V1
it(163) =< V
aux(29) =< Out
it(162) =< aux(28)
it(163) =< aux(28)
it(162) =< aux(29)
it(163) =< aux(29)

  with precondition: [V>=0,Out>=1,V1>=Out] 

* Chain [164]: 0
  with precondition: [Out=0,V1>=0,V>=0] 


#### Cost of loops [165,166] 

 * loop 165:fun20(V1,V,Out) -> [fun20(V1',V',Out')] 
1
 * loop 166:fun20(V1,V,Out) -> [fun20(V1',V',Out')] 
1
#### Cost of phase [165,166]:fun20(V1,V,Out) -> [fun20(V1',V',Out')] 
1*it(165)+1*it(166)+0
  Such that:it(166) =< V
it(166) =< V-V'
aux(30) =< V1
aux(31) =< V1-V1'
it(165) =< aux(30)
it(166) =< aux(30)
it(165) =< aux(31)
it(166) =< aux(31)

#### Cost of chains of fun20(V1,V,Out):
* Chain [[165,166],167]: 1*it(165)+1*it(166)+0
  Such that:aux(30) =< V1
it(166) =< V
aux(31) =< Out
it(165) =< aux(30)
it(166) =< aux(30)
it(165) =< aux(31)
it(166) =< aux(31)

  with precondition: [V>=0,Out>=1,V1>=Out] 

* Chain [167]: 0
  with precondition: [Out=0,V1>=0,V>=0] 


#### Cost of loops [168] 

 * loop 168:fun21(V1,Out) -> [fun21(V1',Out')] 
1
#### Cost of phase [168]:fun21(V1,Out) -> [fun21(V1',Out')] 
1*it(168)+0
  Such that:it(168) =< V1
it(168) =< V1-V1'

#### Cost of chains of fun21(V1,Out):
* Chain [[168],169]: 1*it(168)+0
  Such that:it(168) =< Out

  with precondition: [Out>=1,V1>=Out] 

* Chain [169]: 0
  with precondition: [Out=0,V1>=0] 


#### Cost of loops [170,171] 

 * loop 170:fun22(V1,V,Out) -> [fun22(V1',V',Out')] 
1
 * loop 171:fun22(V1,V,Out) -> [fun22(V1',V',Out')] 
1
#### Cost of phase [170,171]:fun22(V1,V,Out) -> [fun22(V1',V',Out')] 
1*it(170)+1*it(171)+0
  Such that:it(171) =< V
it(171) =< V-V'
aux(32) =< V1
aux(33) =< V1-V1'
it(170) =< aux(32)
it(171) =< aux(32)
it(170) =< aux(33)
it(171) =< aux(33)

#### Cost of chains of fun22(V1,V,Out):
* Chain [[170,171],172]: 1*it(170)+1*it(171)+0
  Such that:aux(32) =< V1
it(171) =< V
aux(33) =< Out
it(170) =< aux(32)
it(171) =< aux(32)
it(170) =< aux(33)
it(171) =< aux(33)

  with precondition: [V>=0,Out>=1,V1>=Out] 

* Chain [172]: 0
  with precondition: [Out=0,V1>=0,V>=0] 


#### Cost of loops [173] 

 * loop 173:fun23(V1,Out) -> [fun23(V1',Out')] 
1
#### Cost of phase [173]:fun23(V1,Out) -> [fun23(V1',Out')] 
1*it(173)+0
  Such that:it(173) =< V1
it(173) =< V1-V1'

#### Cost of chains of fun23(V1,Out):
* Chain [[173],174]: 1*it(173)+0
  Such that:it(173) =< Out

  with precondition: [Out>=1,V1>=Out] 

* Chain [174]: 0
  with precondition: [Out=0,V1>=0] 


#### Cost of loops [175] 

 * loop 175:fun24(V1,Out) -> [fun24(V1',Out')] 
1
#### Cost of phase [175]:fun24(V1,Out) -> [fun24(V1',Out')] 
1*it(175)+0
  Such that:it(175) =< V1
it(175) =< V1-V1'

#### Cost of chains of fun24(V1,Out):
* Chain [[175],176]: 1*it(175)+0
  Such that:it(175) =< Out

  with precondition: [Out>=1,V1>=Out] 

* Chain [176]: 0
  with precondition: [Out=0,V1>=0] 


#### Cost of loops [177] 

 * loop 177:fun25(V1,Out) -> [fun25(V1',Out')] 
1
#### Cost of phase [177]:fun25(V1,Out) -> [fun25(V1',Out')] 
1*it(177)+0
  Such that:it(177) =< V1
it(177) =< V1-V1'

#### Cost of chains of fun25(V1,Out):
* Chain [[177],178]: 1*it(177)+0
  Such that:it(177) =< Out

  with precondition: [Out>=1,V1>=Out] 

* Chain [178]: 0
  with precondition: [Out=0,V1>=0] 


#### Cost of loops [179,180] 

 * loop 179:fun26(V1,V,V2,Out) -> [fun26(V1',V',V2',Out')] 
1
 * loop 180:fun26(V1,V,V2,Out) -> [fun26(V1',V',V2',Out')] 
1
#### Cost of phase [179,180]:fun26(V1,V,V2,Out) -> [fun26(V1',V',V2',Out')] 
1*it(179)+1*it(180)+0
  Such that:it(180) =< V
it(180) =< V-V'
it(180) =< V2
it(180) =< V2-V2'
aux(34) =< V1
aux(35) =< V1-V1'
it(179) =< aux(34)
it(180) =< aux(34)
it(179) =< aux(35)
it(180) =< aux(35)

#### Cost of chains of fun26(V1,V,V2,Out):
* Chain [[179,180],181]: 1*it(179)+1*it(180)+0
  Such that:aux(34) =< V1
it(180) =< V
aux(35) =< Out
it(179) =< aux(34)
it(180) =< aux(34)
it(179) =< aux(35)
it(180) =< aux(35)

  with precondition: [V>=0,V2>=0,Out>=1,V1>=Out] 

* Chain [181]: 0
  with precondition: [Out=0,V1>=0,V>=0,V2>=0] 


#### Cost of loops [182,183] 

 * loop 182:fun27(V1,V,V2,Out) -> [fun27(V1',V',V2',Out')] 
1
 * loop 183:fun27(V1,V,V2,Out) -> [fun27(V1',V',V2',Out')] 
1
#### Cost of phase [182,183]:fun27(V1,V,V2,Out) -> [fun27(V1',V',V2',Out')] 
1*it(182)+1*it(183)+0
  Such that:it(183) =< V
it(183) =< V-V'
it(183) =< V2
it(183) =< V2-V2'
aux(36) =< V1
aux(37) =< V1-V1'
it(182) =< aux(36)
it(183) =< aux(36)
it(182) =< aux(37)
it(183) =< aux(37)

#### Cost of chains of fun27(V1,V,V2,Out):
* Chain [[182,183],184]: 1*it(182)+1*it(183)+0
  Such that:aux(36) =< V1
it(183) =< V
aux(37) =< Out
it(182) =< aux(36)
it(183) =< aux(36)
it(182) =< aux(37)
it(183) =< aux(37)

  with precondition: [V>=0,V2>=0,Out>=1,V1>=Out] 

* Chain [184]: 0
  with precondition: [Out=0,V1>=0,V>=0,V2>=0] 


#### Cost of loops [185,186] 

 * loop 185:fun28(V1,V,Out) -> [fun28(V1',V',Out')] 
1
 * loop 186:fun28(V1,V,Out) -> [fun28(V1',V',Out')] 
1
#### Cost of phase [185,186]:fun28(V1,V,Out) -> [fun28(V1',V',Out')] 
1*it(185)+1*it(186)+0
  Such that:it(186) =< V
it(186) =< V-V'
aux(38) =< V1
aux(39) =< V1-V1'
it(185) =< aux(38)
it(186) =< aux(38)
it(185) =< aux(39)
it(186) =< aux(39)

#### Cost of chains of fun28(V1,V,Out):
* Chain [[185,186],187]: 1*it(185)+1*it(186)+0
  Such that:aux(38) =< V1
it(186) =< V
aux(39) =< Out
it(185) =< aux(38)
it(186) =< aux(38)
it(185) =< aux(39)
it(186) =< aux(39)

  with precondition: [V>=0,Out>=1,V1>=Out] 

* Chain [187]: 0
  with precondition: [Out=0,V1>=0,V>=0] 


#### Cost of loops [188,189] 

 * loop 188:fun29(V1,V,V2,Out) -> [fun29(V1',V',V2',Out')] 
1
 * loop 189:fun29(V1,V,V2,Out) -> [fun29(V1',V',V2',Out')] 
1
#### Cost of phase [188,189]:fun29(V1,V,V2,Out) -> [fun29(V1',V',V2',Out')] 
1*it(188)+1*it(189)+0
  Such that:it(189) =< V
it(189) =< V-V'
it(189) =< V2
it(189) =< V2-V2'
aux(40) =< V1
aux(41) =< V1-V1'
it(188) =< aux(40)
it(189) =< aux(40)
it(188) =< aux(41)
it(189) =< aux(41)

#### Cost of chains of fun29(V1,V,V2,Out):
* Chain [[188,189],190]: 1*it(188)+1*it(189)+0
  Such that:aux(40) =< V1
it(189) =< V
aux(41) =< Out
it(188) =< aux(40)
it(189) =< aux(40)
it(188) =< aux(41)
it(189) =< aux(41)

  with precondition: [V>=0,V2>=0,Out>=1,V1>=Out] 

* Chain [190]: 0
  with precondition: [Out=0,V1>=0,V>=0,V2>=0] 


#### Cost of loops [191,192] 

 * loop 191:fun3(V1,V,V2,Out) -> [fun3(V1',V',V2',Out')] 
1
 * loop 192:fun3(V1,V,V2,Out) -> [fun3(V1',V',V2',Out')] 
1
#### Cost of phase [191,192]:fun3(V1,V,V2,Out) -> [fun3(V1',V',V2',Out')] 
1*it(191)+1*it(192)+0
  Such that:it(192) =< V
it(192) =< V-V'
it(192) =< V2
it(192) =< V2-V2'
aux(42) =< V1
aux(43) =< V1-V1'
it(191) =< aux(42)
it(192) =< aux(42)
it(191) =< aux(43)
it(192) =< aux(43)

#### Cost of chains of fun3(V1,V,V2,Out):
* Chain [[191,192],193]: 1*it(191)+1*it(192)+0
  Such that:aux(42) =< V1
it(192) =< V
aux(43) =< Out
it(191) =< aux(42)
it(192) =< aux(42)
it(191) =< aux(43)
it(192) =< aux(43)

  with precondition: [V>=0,V2>=0,Out>=1,V1>=Out] 

* Chain [193]: 0
  with precondition: [Out=0,V1>=0,V>=0,V2>=0] 


#### Cost of loops [194,195] 

 * loop 194:fun30(V1,V,Out) -> [fun30(V1',V',Out')] 
1
 * loop 195:fun30(V1,V,Out) -> [fun30(V1',V',Out')] 
1
#### Cost of phase [194,195]:fun30(V1,V,Out) -> [fun30(V1',V',Out')] 
1*it(194)+1*it(195)+0
  Such that:it(195) =< V
it(195) =< V-V'
aux(44) =< V1
aux(45) =< V1-V1'
it(194) =< aux(44)
it(195) =< aux(44)
it(194) =< aux(45)
it(195) =< aux(45)

#### Cost of chains of fun30(V1,V,Out):
* Chain [[194,195],196]: 1*it(194)+1*it(195)+0
  Such that:aux(44) =< V1
it(195) =< V
aux(45) =< Out
it(194) =< aux(44)
it(195) =< aux(44)
it(194) =< aux(45)
it(195) =< aux(45)

  with precondition: [V>=0,Out>=1,V1>=Out] 

* Chain [196]: 0
  with precondition: [Out=0,V1>=0,V>=0] 


#### Cost of loops [197,198] 

 * loop 197:fun31(V1,V,V2,Out) -> [fun31(V1',V',V2',Out')] 
1
 * loop 198:fun31(V1,V,V2,Out) -> [fun31(V1',V',V2',Out')] 
1
#### Cost of phase [197,198]:fun31(V1,V,V2,Out) -> [fun31(V1',V',V2',Out')] 
1*it(197)+1*it(198)+0
  Such that:it(198) =< V
it(198) =< V-V'
it(198) =< V2
it(198) =< V2-V2'
aux(46) =< V1
aux(47) =< V1-V1'
it(197) =< aux(46)
it(198) =< aux(46)
it(197) =< aux(47)
it(198) =< aux(47)

#### Cost of chains of fun31(V1,V,V2,Out):
* Chain [[197,198],199]: 1*it(197)+1*it(198)+0
  Such that:aux(46) =< V1
it(198) =< V
aux(47) =< Out
it(197) =< aux(46)
it(198) =< aux(46)
it(197) =< aux(47)
it(198) =< aux(47)

  with precondition: [V>=0,V2>=0,Out>=1,V1>=Out] 

* Chain [199]: 0
  with precondition: [Out=0,V1>=0,V>=0,V2>=0] 


#### Cost of loops [200,201] 

 * loop 200:fun32(V1,V,V2,Out) -> [fun32(V1',V',V2',Out')] 
1
 * loop 201:fun32(V1,V,V2,Out) -> [fun32(V1',V',V2',Out')] 
1
#### Cost of phase [200,201]:fun32(V1,V,V2,Out) -> [fun32(V1',V',V2',Out')] 
1*it(200)+1*it(201)+0
  Such that:it(201) =< V
it(201) =< V-V'
it(201) =< V2
it(201) =< V2-V2'
aux(48) =< V1
aux(49) =< V1-V1'
it(200) =< aux(48)
it(201) =< aux(48)
it(200) =< aux(49)
it(201) =< aux(49)

#### Cost of chains of fun32(V1,V,V2,Out):
* Chain [[200,201],202]: 1*it(200)+1*it(201)+0
  Such that:aux(48) =< V1
it(201) =< V
aux(49) =< Out
it(200) =< aux(48)
it(201) =< aux(48)
it(200) =< aux(49)
it(201) =< aux(49)

  with precondition: [V>=0,V2>=0,Out>=1,V1>=Out] 

* Chain [202]: 0
  with precondition: [Out=0,V1>=0,V>=0,V2>=0] 


#### Cost of loops [203,204] 

 * loop 203:fun33(V1,V,Out) -> [fun33(V1',V',Out')] 
1
 * loop 204:fun33(V1,V,Out) -> [fun33(V1',V',Out')] 
1
#### Cost of phase [203,204]:fun33(V1,V,Out) -> [fun33(V1',V',Out')] 
1*it(203)+1*it(204)+0
  Such that:it(204) =< V
it(204) =< V-V'
aux(50) =< V1
aux(51) =< V1-V1'
it(203) =< aux(50)
it(204) =< aux(50)
it(203) =< aux(51)
it(204) =< aux(51)

#### Cost of chains of fun33(V1,V,Out):
* Chain [[203,204],205]: 1*it(203)+1*it(204)+0
  Such that:aux(50) =< V1
it(204) =< V
aux(51) =< Out
it(203) =< aux(50)
it(204) =< aux(50)
it(203) =< aux(51)
it(204) =< aux(51)

  with precondition: [V>=0,Out>=1,V1>=Out] 

* Chain [205]: 0
  with precondition: [Out=0,V1>=0,V>=0] 


#### Cost of loops [206,207] 

 * loop 206:fun34(V1,V,V2,Out) -> [fun34(V1',V',V2',Out')] 
1
 * loop 207:fun34(V1,V,V2,Out) -> [fun34(V1',V',V2',Out')] 
1
#### Cost of phase [206,207]:fun34(V1,V,V2,Out) -> [fun34(V1',V',V2',Out')] 
1*it(206)+1*it(207)+0
  Such that:it(207) =< V
it(207) =< V-V'
it(207) =< V2
it(207) =< V2-V2'
aux(52) =< V1
aux(53) =< V1-V1'
it(206) =< aux(52)
it(207) =< aux(52)
it(206) =< aux(53)
it(207) =< aux(53)

#### Cost of chains of fun34(V1,V,V2,Out):
* Chain [[206,207],208]: 1*it(206)+1*it(207)+0
  Such that:aux(52) =< V1
it(207) =< V
aux(53) =< Out
it(206) =< aux(52)
it(207) =< aux(52)
it(206) =< aux(53)
it(207) =< aux(53)

  with precondition: [V>=0,V2>=0,Out>=1,V1>=Out] 

* Chain [208]: 0
  with precondition: [Out=0,V1>=0,V>=0,V2>=0] 


#### Cost of loops [209,210] 

 * loop 209:fun35(V1,V,Out) -> [fun35(V1',V',Out')] 
1
 * loop 210:fun35(V1,V,Out) -> [fun35(V1',V',Out')] 
1
#### Cost of phase [209,210]:fun35(V1,V,Out) -> [fun35(V1',V',Out')] 
1*it(209)+1*it(210)+0
  Such that:it(210) =< V
it(210) =< V-V'
aux(54) =< V1
aux(55) =< V1-V1'
it(209) =< aux(54)
it(210) =< aux(54)
it(209) =< aux(55)
it(210) =< aux(55)

#### Cost of chains of fun35(V1,V,Out):
* Chain [[209,210],211]: 1*it(209)+1*it(210)+0
  Such that:aux(54) =< V1
it(210) =< V
aux(55) =< Out
it(209) =< aux(54)
it(210) =< aux(54)
it(209) =< aux(55)
it(210) =< aux(55)

  with precondition: [V>=0,Out>=1,V1>=Out] 

* Chain [211]: 0
  with precondition: [Out=0,V1>=0,V>=0] 


#### Cost of loops [212,213] 

 * loop 212:fun36(V1,V,V2,Out) -> [fun36(V1',V',V2',Out')] 
1
 * loop 213:fun36(V1,V,V2,Out) -> [fun36(V1',V',V2',Out')] 
1
#### Cost of phase [212,213]:fun36(V1,V,V2,Out) -> [fun36(V1',V',V2',Out')] 
1*it(212)+1*it(213)+0
  Such that:it(213) =< V
it(213) =< V-V'
it(213) =< V2
it(213) =< V2-V2'
aux(56) =< V1
aux(57) =< V1-V1'
it(212) =< aux(56)
it(213) =< aux(56)
it(212) =< aux(57)
it(213) =< aux(57)

#### Cost of chains of fun36(V1,V,V2,Out):
* Chain [[212,213],214]: 1*it(212)+1*it(213)+0
  Such that:aux(56) =< V1
it(213) =< V
aux(57) =< Out
it(212) =< aux(56)
it(213) =< aux(56)
it(212) =< aux(57)
it(213) =< aux(57)

  with precondition: [V>=0,V2>=0,Out>=1,V1>=Out] 

* Chain [214]: 0
  with precondition: [Out=0,V1>=0,V>=0,V2>=0] 


#### Cost of loops [215] 

 * loop 215:fun4(V1,Out) -> [fun4(V1',Out')] 
1
#### Cost of phase [215]:fun4(V1,Out) -> [fun4(V1',Out')] 
1*it(215)+0
  Such that:it(215) =< V1
it(215) =< V1-V1'

#### Cost of chains of fun4(V1,Out):
* Chain [[215],216]: 1*it(215)+0
  Such that:it(215) =< Out

  with precondition: [Out>=1,V1>=Out] 

* Chain [216]: 0
  with precondition: [Out=0,V1>=0] 


#### Cost of loops [217,218] 

 * loop 217:fun5(V1,V,Out) -> [fun5(V1',V',Out')] 
1
 * loop 218:fun5(V1,V,Out) -> [fun5(V1',V',Out')] 
1
#### Cost of phase [217,218]:fun5(V1,V,Out) -> [fun5(V1',V',Out')] 
1*it(217)+1*it(218)+0
  Such that:it(218) =< V
it(218) =< V-V'
aux(58) =< V1
aux(59) =< V1-V1'
it(217) =< aux(58)
it(218) =< aux(58)
it(217) =< aux(59)
it(218) =< aux(59)

#### Cost of chains of fun5(V1,V,Out):
* Chain [[217,218],219]: 1*it(217)+1*it(218)+0
  Such that:aux(58) =< V1
it(218) =< V
aux(59) =< Out
it(217) =< aux(58)
it(218) =< aux(58)
it(217) =< aux(59)
it(218) =< aux(59)

  with precondition: [V>=0,Out>=1,V1>=Out] 

* Chain [219]: 0
  with precondition: [Out=0,V1>=0,V>=0] 


#### Cost of loops [220,221] 

 * loop 220:fun6(V1,V,Out) -> [fun6(V1',V',Out')] 
1
 * loop 221:fun6(V1,V,Out) -> [fun6(V1',V',Out')] 
1
#### Cost of phase [220,221]:fun6(V1,V,Out) -> [fun6(V1',V',Out')] 
1*it(220)+1*it(221)+0
  Such that:it(221) =< V
it(221) =< V-V'
aux(60) =< V1
aux(61) =< V1-V1'
it(220) =< aux(60)
it(221) =< aux(60)
it(220) =< aux(61)
it(221) =< aux(61)

#### Cost of chains of fun6(V1,V,Out):
* Chain [[220,221],222]: 1*it(220)+1*it(221)+0
  Such that:aux(60) =< V1
it(221) =< V
aux(61) =< Out
it(220) =< aux(60)
it(221) =< aux(60)
it(220) =< aux(61)
it(221) =< aux(61)

  with precondition: [V>=0,Out>=1,V1>=Out] 

* Chain [222]: 0
  with precondition: [Out=0,V1>=0,V>=0] 


#### Cost of loops [223,224] 

 * loop 223:fun7(V1,V,V2,Out) -> [fun7(V1',V',V2',Out')] 
1
 * loop 224:fun7(V1,V,V2,Out) -> [fun7(V1',V',V2',Out')] 
1
#### Cost of phase [223,224]:fun7(V1,V,V2,Out) -> [fun7(V1',V',V2',Out')] 
1*it(223)+1*it(224)+0
  Such that:it(224) =< V
it(224) =< V-V'
it(224) =< V2
it(224) =< V2-V2'
aux(62) =< V1
aux(63) =< V1-V1'
it(223) =< aux(62)
it(224) =< aux(62)
it(223) =< aux(63)
it(224) =< aux(63)

#### Cost of chains of fun7(V1,V,V2,Out):
* Chain [[223,224],225]: 1*it(223)+1*it(224)+0
  Such that:aux(62) =< V1
it(224) =< V
aux(63) =< Out
it(223) =< aux(62)
it(224) =< aux(62)
it(223) =< aux(63)
it(224) =< aux(63)

  with precondition: [V>=0,V2>=0,Out>=1,V1>=Out] 

* Chain [225]: 0
  with precondition: [Out=0,V1>=0,V>=0,V2>=0] 


#### Cost of loops [226] 

 * loop 226:fun8(V1,Out) -> [fun8(V1',Out')] 
1
#### Cost of phase [226]:fun8(V1,Out) -> [fun8(V1',Out')] 
1*it(226)+0
  Such that:it(226) =< V1
it(226) =< V1-V1'

#### Cost of chains of fun8(V1,Out):
* Chain [[226],227]: 1*it(226)+0
  Such that:it(226) =< Out

  with precondition: [Out>=1,V1>=Out] 

* Chain [227]: 0
  with precondition: [Out=0,V1>=0] 


#### Cost of loops [228] 

 * loop 228:fun9(V1,Out) -> [fun9(V1',Out')] 
1
#### Cost of phase [228]:fun9(V1,Out) -> [fun9(V1',Out')] 
1*it(228)+0
  Such that:it(228) =< V1
it(228) =< V1-V1'

#### Cost of chains of fun9(V1,Out):
* Chain [[228],229]: 1*it(228)+0
  Such that:it(228) =< Out

  with precondition: [Out>=1,V1>=Out] 

* Chain [229]: 0
  with precondition: [Out=0,V1>=0] 


#### Cost of loops [230] 

 * loop 230:isList(V1,Out) -> [isList(V1',Out')] 
1
#### Cost of phase [230]:isList(V1,Out) -> [isList(V1',Out')] 
1*it(230)+0
  Such that:it(230) =< V1
it(230) =< V1-V1'

#### Cost of chains of isList(V1,Out):
* Chain [[230],231]: 1*it(230)+0
  Such that:it(230) =< Out

  with precondition: [Out>=1,V1>=Out] 

* Chain [231]: 0
  with precondition: [Out=0,V1>=0] 


#### Cost of loops [232] 

 * loop 232:isNeList(V1,Out) -> [isNeList(V1',Out')] 
1
#### Cost of phase [232]:isNeList(V1,Out) -> [isNeList(V1',Out')] 
1*it(232)+0
  Such that:it(232) =< V1
it(232) =< V1-V1'

#### Cost of chains of isNeList(V1,Out):
* Chain [[232],233]: 1*it(232)+0
  Such that:it(232) =< Out

  with precondition: [Out>=1,V1>=Out] 

* Chain [233]: 0
  with precondition: [Out=0,V1>=0] 


#### Cost of loops [234] 

 * loop 234:isNePal(V1,Out) -> [isNePal(V1',Out')] 
1
#### Cost of phase [234]:isNePal(V1,Out) -> [isNePal(V1',Out')] 
1*it(234)+0
  Such that:it(234) =< V1
it(234) =< V1-V1'

#### Cost of chains of isNePal(V1,Out):
* Chain [[234],235]: 1*it(234)+0
  Such that:it(234) =< Out

  with precondition: [Out>=1,V1>=Out] 

* Chain [235]: 0
  with precondition: [Out=0,V1>=0] 


#### Cost of loops [236] 

 * loop 236:isPal(V1,Out) -> [isPal(V1',Out')] 
1
#### Cost of phase [236]:isPal(V1,Out) -> [isPal(V1',Out')] 
1*it(236)+0
  Such that:it(236) =< V1
it(236) =< V1-V1'

#### Cost of chains of isPal(V1,Out):
* Chain [[236],237]: 1*it(236)+0
  Such that:it(236) =< Out

  with precondition: [Out>=1,V1>=Out] 

* Chain [237]: 0
  with precondition: [Out=0,V1>=0] 


#### Cost of loops [238] 

 * loop 238:isPalListKind(V1,Out) -> [isPalListKind(V1',Out')] 
1
#### Cost of phase [238]:isPalListKind(V1,Out) -> [isPalListKind(V1',Out')] 
1*it(238)+0
  Such that:it(238) =< V1
it(238) =< V1-V1'

#### Cost of chains of isPalListKind(V1,Out):
* Chain [[238],239]: 1*it(238)+0
  Such that:it(238) =< Out

  with precondition: [Out>=1,V1>=Out] 

* Chain [239]: 0
  with precondition: [Out=0,V1>=0] 


#### Cost of loops [240] 

 * loop 240:isQid(V1,Out) -> [isQid(V1',Out')] 
1
#### Cost of phase [240]:isQid(V1,Out) -> [isQid(V1',Out')] 
1*it(240)+0
  Such that:it(240) =< V1
it(240) =< V1-V1'

#### Cost of chains of isQid(V1,Out):
* Chain [[240],241]: 1*it(240)+0
  Such that:it(240) =< Out

  with precondition: [Out>=1,V1>=Out] 

* Chain [241]: 0
  with precondition: [Out=0,V1>=0] 


#### Cost of chains of proper(V1,Out):
* Chain [249]: 1
  with precondition: [V1=0,Out=1] 

* Chain [248]: 1
  with precondition: [V1=1,Out=2] 

* Chain [247]: 1
  with precondition: [V1=2,Out=3] 

* Chain [246]: 1
  with precondition: [V1=3,Out=4] 

* Chain [245]: 1
  with precondition: [V1=4,Out=5] 

* Chain [244]: 1
  with precondition: [V1=5,Out=6] 

* Chain [243]: 1
  with precondition: [V1=6,Out=7] 

* Chain [242]: 0
  with precondition: [Out=0,V1>=0] 


#### Cost of loops [251,252,253,254,255,256,257] 

 * loop 251:top(V1,Out) -> [top(V1',Out')] 
2
 * loop 252:top(V1,Out) -> [top(V1',Out')] 
2
 * loop 253:top(V1,Out) -> [top(V1',Out')] 
2
 * loop 254:top(V1,Out) -> [top(V1',Out')] 
2
 * loop 255:top(V1,Out) -> [top(V1',Out')] 
2
 * loop 256:top(V1,Out) -> [top(V1',Out')] 
2
 * loop 257:top(V1,Out) -> [top(V1',Out')] 
2
#### Cost of phase [251,252,253,254,255,256,257]:top(V1,Out) -> [top(V1',Out')] 
14*it(251)+0
#### Cost of phase [251,252,253,254,255,256,257]:top(V1,Out) -> [top(V1',Out')] 
14*it(251)+0
#### Cost of phase [251,252,253,254,255,256,257]:top(V1,Out) -> [top(V1',Out')] 
14*it(251)+0
#### Cost of chains of top(V1,Out):
* Chain [[251,252,253,254,255,256,257]]...: 14*it(251)+0
  with precondition: [V1>=1] 

* Chain [[251,252,253,254,255,256,257],258]: 14*it(251)+0
  with precondition: [Out=0,V1>=1] 

* Chain [[251,252,253,254,255,256,257],250,258]: 14*it(251)+1
  with precondition: [Out=0,V1>=1] 

* Chain [258]: 0
  with precondition: [Out=0,V1>=0] 

* Chain [250,258]: 1
  with precondition: [Out=0,V1>=1] 


#### Cost of chains of start(V1,V,V2):
* Chain [266]...: 14*s(3)+0
  with precondition: [V1>=1] 

* Chain [265]: 27*s(5)+42*s(7)+1*s(8)+1*s(48)+1*s(49)+1*s(50)+1
  Such that:s(46) =< V1+V
aux(92) =< V1
aux(93) =< V
s(7) =< aux(92)
s(5) =< aux(93)
s(48) =< aux(92)
s(49) =< aux(92)
s(50) =< s(46)
s(48) =< s(46)
s(49) =< s(46)
s(50) =< aux(93)
s(49) =< aux(93)
s(5) =< aux(92)

  with precondition: [V1>=0] 

* Chain [264]: 1
  with precondition: [V1=1] 

* Chain [263]: 1
  with precondition: [V1=2] 

* Chain [262]: 1
  with precondition: [V1=3] 

* Chain [261]: 1
  with precondition: [V1=4] 

* Chain [260]: 1
  with precondition: [V1=5] 

* Chain [259]: 1
  with precondition: [V1=6] 


Closed-form bounds of start(V1,V,V2): 
-------------------------------------
* Chain [266]... with precondition: [V1>=1] 
    - Upper bound: inf 
    - Complexity: infinity 
* Chain [265] with precondition: [V1>=0] 
    - Upper bound: inf 
    - Complexity: infinity 
* Chain [264] with precondition: [V1=1] 
    - Upper bound: 1 
    - Complexity: constant 
* Chain [263] with precondition: [V1=2] 
    - Upper bound: 1 
    - Complexity: constant 
* Chain [262] with precondition: [V1=3] 
    - Upper bound: 1 
    - Complexity: constant 
* Chain [261] with precondition: [V1=4] 
    - Upper bound: 1 
    - Complexity: constant 
* Chain [260] with precondition: [V1=5] 
    - Upper bound: 1 
    - Complexity: constant 
* Chain [259] with precondition: [V1=6] 
    - Upper bound: 1 
    - Complexity: constant 

### Maximum cost of start(V1,V,V2): inf 
Asymptotic class: infinity 

Time statistics: 
-------------------------------------
* Partial evaluation computed in 360 ms.
* Invariants computed in 326 ms.
   - Backward Invariants 125 ms.
   - Transitive Invariants 98 ms.
* Refinement performed in 555 ms.
* Termination proved in 115 ms.
* Upper bounds computed in 507 ms.
   - Equation cost structures 177 ms.
   - Phase cost structures 203 ms.
   - Chain cost structures 176 ms.
   - Solving cost expressions 1 ms.
* Total analysis performed in 2267 ms.

