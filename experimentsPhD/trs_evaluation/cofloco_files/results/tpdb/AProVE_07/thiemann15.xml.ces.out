
Preprocessing Cost Relations
=====================================

#### Computed strongly connected components 
0. recursive  : [half/2]
1. non_recursive  : [p/2]
2. recursive  : [inc/2]
3. non_recursive  : [zero/2]
4. recursive  : [bitIter/3,if/4]
5. non_recursive  : [bits/2]
6. non_recursive  : [start/3]

#### Obtained direct recursion through partial evaluation 
0. SCC is partially evaluated into half/2
1. SCC is partially evaluated into p/2
2. SCC is partially evaluated into inc/2
3. SCC is partially evaluated into zero/2
4. SCC is partially evaluated into bitIter/3
5. SCC is completely evaluated into other SCCs
6. SCC is partially evaluated into start/3

Control-Flow Refinement of Cost Relations
=====================================

### Specialization of cost equations half/2 
* CE 12 is refined into CE [21] 
* CE 11 is refined into CE [22] 
* CE 10 is refined into CE [23] 


#### Refined cost equations half/2 
* CE 21: half(V,Out) = 1+ half(W,X)
     [W>=0,X+1=Out,W+2=V] 
* CE 22: half(V,Out) = 1
     [Out=0,V=1] 
* CE 23: half(V,Out) = 1
     [Out=0,V=0] 

### Cost equations --> "Loop" of half/2 
* CEs [22] --> Loop 14 
* CEs [23] --> Loop 15 
* CEs [21] --> Loop 16 

#### Loops of half/2 
* Loop 14: half(V,Out) [Out=0,V=1] 
* Loop 15: half(V,Out) [Out=0,V=0] 
* Loop 16: half(V,Out)->  half(V',Out')
                  [V'>=0,Out=Out'+1,V'+2=V] 

### Ranking functions of CR half(V,Out) 
* RF of phase [16]: [V-1]

#### Partial ranking functions of CR half(V,Out) 
* Partial RF of phase [16]:
  - RF of loop [16:1]:
    V-1


### Resulting Chains:half(V,Out) 
* [[16],15]
* [[16],14]
* [15]
* [14]


### Merging Chains  half/2 into  External patterns of execution 
* [[15]] --> 1 
* [[14]] --> 2 
* [[15,[16]]] --> 3 
* [[14,[16]]] --> 4 


### Specialization of cost equations p/2 
* CE 16 is refined into CE [24] 
* CE 15 is refined into CE [25] 


#### Refined cost equations p/2 
* CE 24: p(V,Out) = 1
     [Out>=0,Out+1=V] 
* CE 25: p(V,Out) = 1
     [Out=0,V=0] 

### Cost equations --> "Loop" of p/2 
* CEs [24] --> Loop 17 
* CEs [25] --> Loop 18 

#### Loops of p/2 
* Loop 17: p(V,Out) [V>=1,V=Out+1] 
* Loop 18: p(V,Out) [Out=0,V=0] 

### Ranking functions of CR p(V,Out) 

#### Partial ranking functions of CR p(V,Out) 


### Resulting Chains:p(V,Out) 
* [18]
* [17]


### Merging Chains  p/2 into  External patterns of execution 
* [[18]] --> 1 
* [[17]] --> 2 


### Specialization of cost equations inc/2 
* CE 18 is refined into CE [26] 
* CE 17 is refined into CE [27] 


#### Refined cost equations inc/2 
* CE 26: inc(V,Out) = 1+ inc(W,X)
     [W>=0,X+1=Out,W+1=V] 
* CE 27: inc(V,Out) = 1
     [Out=0,V=0] 

### Cost equations --> "Loop" of inc/2 
* CEs [27] --> Loop 19 
* CEs [26] --> Loop 20 

#### Loops of inc/2 
* Loop 19: inc(V,Out) [Out=0,V=0] 
* Loop 20: inc(V,Out)->  inc(V',Out')
                  [V'>=0,Out=Out'+1,V'+1=V] 

### Ranking functions of CR inc(V,Out) 
* RF of phase [20]: [V]

#### Partial ranking functions of CR inc(V,Out) 
* Partial RF of phase [20]:
  - RF of loop [20:1]:
    V


### Resulting Chains:inc(V,Out) 
* [[20],19]
* [19]


### Merging Chains  inc/2 into  External patterns of execution 
* [[19]] --> 1 
* [[19,[20]]] --> 2 


### Specialization of cost equations zero/2 
* CE 20 is refined into CE [28] 
* CE 19 is refined into CE [29] 


#### Refined cost equations zero/2 
* CE 28: zero(V,Out) = 1
     [V>=1,Out=0] 
* CE 29: zero(V,Out) = 1
     [Out=1,V=0] 

### Cost equations --> "Loop" of zero/2 
* CEs [28] --> Loop 21 
* CEs [29] --> Loop 22 

#### Loops of zero/2 
* Loop 21: zero(V,Out) [V>=1,Out=0] 
* Loop 22: zero(V,Out) [Out=1,V=0] 

### Ranking functions of CR zero(V,Out) 

#### Partial ranking functions of CR zero(V,Out) 


### Resulting Chains:zero(V,Out) 
* [22]
* [21]


### Merging Chains  zero/2 into  External patterns of execution 
* [[22]] --> 1 
* [[21]] --> 2 


### Specialization of cost equations bitIter/3 
* CE 14 is refined into CE [30,31] 
* CE 13 is refined into CE [32,33,34,35,36,37] 


#### Refined cost equations bitIter/3 
* CE 30: bitIter(V,V6,Out) = 2+ zero(W6,X6):1+ inc(Y6,Z6):1+ p(A7,B7):1
     [B7=0,A7=0,Z6=0,Y6=0,X6=1,W6=0,Out=0,V6=0,V=0] 
* CE 31: bitIter(V,V6,Out) = 2+ zero(W6,X6):1+ inc(Y6,Z6):2+ p(A7,Out):2
     [Out>=0,Out+1=A7,Out+1=Z6,Out+1=Y6,Out+1=V6,X6=1,W6=0,V=0] 
* CE 32: bitIter(V,V6,Out) = 2+ zero(W6,X6):2+ inc(Y6,Z6):1+ half(A7,B7):2+ bitIter(C7,D7,Out)
     [D7=0,C7=0,B7=0,A7=1,Z6=0,Y6=0,X6=0,W6=1,V6=0,V=1] 
* CE 33: bitIter(V,V6,Out) = 2+ zero(W6,X6):2+ inc(Y6,Z6):1+ half(A7,B7):3+ bitIter(B7,C7,Out)
     [B7>=1,2*B7=A7,2*B7=W6,2*B7=V,C7=0,Z6=0,Y6=0,X6=0,V6=0] 
* CE 34: bitIter(V,V6,Out) = 2+ zero(W6,X6):2+ inc(Y6,Z6):1+ half(A7,B7):4+ bitIter(B7,C7,Out)
     [B7>=1,2*B7+1=A7,2*B7+1=W6,2*B7+1=V,C7=0,Z6=0,Y6=0,X6=0,V6=0] 
* CE 35: bitIter(V,V6,Out) = 2+ zero(W6,X6):2+ inc(V6,V6):2+ half(Y6,Z6):2+ bitIter(A7,V6,Out)
     [V6>=1,A7=0,Z6=0,Y6=1,X6=0,W6=1,V=1] 
* CE 36: bitIter(V,V6,Out) = 2+ zero(W6,X6):2+ inc(V6,V6):2+ half(Y6,Z6):3+ bitIter(Z6,V6,Out)
     [Z6>=1,V6>=1,2*Z6=Y6,2*Z6=W6,2*Z6=V,X6=0] 
* CE 37: bitIter(V,V6,Out) = 2+ zero(W6,X6):2+ inc(V6,V6):2+ half(Y6,Z6):4+ bitIter(Z6,V6,Out)
     [Z6>=1,V6>=1,2*Z6+1=Y6,2*Z6+1=W6,2*Z6+1=V,X6=0] 

### Cost equations --> "Loop" of bitIter/3 
* CEs [37] --> Loop 23 
* CEs [36] --> Loop 24 
* CEs [34] --> Loop 25 
* CEs [33] --> Loop 26 
* CEs [35] --> Loop 27 
* CEs [32] --> Loop 28 
* CEs [31] --> Loop 29 
* CEs [30] --> Loop 30 

#### Loops of bitIter/3 
* Loop 23: bitIter(V,V6,Out)->  bitIter(V',V6,Out)
                  [V6>=1,V>=3,V=2*V'+1] 
* Loop 24: bitIter(V,V6,Out)->  bitIter(V',V6,Out)
                  [V6>=1,V>=2,V=2*V'] 
* Loop 25: bitIter(V,V6,Out)->  bitIter(V',V6',Out)
                  [V>=3,V=2*V'+1,V6'=0,V6=0] 
* Loop 26: bitIter(V,V6,Out)->  bitIter(V',V6',Out)
                  [V>=2,V=2*V',V6'=0,V6=0] 
* Loop 27: bitIter(V,V6,Out)->  bitIter(V',V6,Out)
                  [V6>=1,V'=0,V=1] 
* Loop 28: bitIter(V,V6,Out)->  bitIter(V',V6',Out)
                  [V6'=0,V'=0,V6=0,V=1] 
* Loop 29: bitIter(V,V6,Out) [V6>=1,V6=Out+1,V=0] 
* Loop 30: bitIter(V,V6,Out) [Out=0,V6=0,V=0] 

### Ranking functions of CR bitIter(V,V6,Out) 
* RF of phase [23,24]: [V-1]
* RF of phase [25,26]: [V-1]

#### Partial ranking functions of CR bitIter(V,V6,Out) 
* Partial RF of phase [23,24]:
  - RF of loop [23:1]:
    V/2-1
  - RF of loop [24:1]:
    V-1
* Partial RF of phase [25,26]:
  - RF of loop [25:1]:
    V/2-1
  - RF of loop [26:1]:
    V-1


### Resulting Chains:bitIter(V,V6,Out) 
* [[25,26],28,30]
* [[23,24],27,29]
* [30]
* [29]
* [28,30]
* [27,29]


### Merging Chains  bitIter/3 into  External patterns of execution 
* [[30]] --> 1 
* [[29]] --> 2 
* [[30,28]] --> 3 
* [[29,27]] --> 4 
* [[30,28,[25,26]]] --> 5 
* [[29,27,[23,24]]] --> 6 


### Specialization of cost equations start/3 
* CE 3 is refined into CE [38,39] 
* CE 2 is refined into CE [40,41,42,43,44,45,46,47,48,49,50,51] 
* CE 4 is refined into CE [52,53,54,55] 
* CE 5 is refined into CE [56,57] 
* CE 6 is refined into CE [58,59] 
* CE 7 is refined into CE [60,61] 
* CE 8 is refined into CE [62,63,64] 
* CE 9 is refined into CE [65,66,67,68,69,70] 


#### Refined cost equations start/3 
* CE 38: start(V,V6,V9) = 1+ p(W9,X9):1
     [V6>=0,X9=0,W9=0,V9=0,V=1] 
* CE 39: start(V,V6,V9) = 1+ p(W9,X9):2
     [X9>=0,V6>=0,X9+1=W9,X9+1=V9,V=1] 
* CE 40: start(V,V6,V9) = 1+ half(W9,X9):1+ bitIter(Y9,Z9,A10):1
     [A10=0,Z9=0,Y9=0,X9=0,W9=0,V9=0,V6=0,V=0] 
* CE 41: start(V,V6,V9) = 1+ half(W9,X9):1+ bitIter(Y9,Z9,A10):2
     [A10>=0,A10+1=Z9,A10+1=V9,Y9=0,X9=0,W9=0,V6=0,V=0] 
* CE 42: start(V,V6,V9) = 1+ half(W9,X9):2+ bitIter(Y9,Z9,A10):1
     [A10=0,Z9=0,Y9=0,X9=0,W9=1,V9=0,V6=1,V=0] 
* CE 43: start(V,V6,V9) = 1+ half(W9,X9):2+ bitIter(Y9,Z9,A10):2
     [A10>=0,A10+1=Z9,A10+1=V9,Y9=0,X9=0,W9=1,V6=1,V=0] 
* CE 44: start(V,V6,V9) = 1+ half(W9,X9):3+ bitIter(Y9,Z9,A10):3
     [A10=0,Z9=0,Y9=1,X9=1,W9=2,V9=0,V6=2,V=0] 
* CE 45: start(V,V6,V9) = 1+ half(W9,X9):3+ bitIter(Y9,Z9,A10):4
     [A10>=0,A10+1=Z9,A10+1=V9,Y9=1,X9=1,W9=2,V6=2,V=0] 
* CE 46: start(V,V6,V9) = 1+ half(W9,X9):3+ bitIter(X9,Y9,Z9):5
     [X9>=2,2*X9=W9,2*X9=V6,Z9=0,Y9=0,V9=0,V=0] 
* CE 47: start(V,V6,V9) = 1+ half(W9,X9):3+ bitIter(X9,Y9,Z9):6
     [Z9>=0,X9>=2,Z9+1=Y9,2*X9=W9,Z9+1=V9,2*X9=V6,V=0] 
* CE 48: start(V,V6,V9) = 1+ half(W9,X9):4+ bitIter(Y9,Z9,A10):3
     [A10=0,Z9=0,Y9=1,X9=1,W9=3,V9=0,V6=3,V=0] 
* CE 49: start(V,V6,V9) = 1+ half(W9,X9):4+ bitIter(Y9,Z9,A10):4
     [A10>=0,A10+1=Z9,A10+1=V9,Y9=1,X9=1,W9=3,V6=3,V=0] 
* CE 50: start(V,V6,V9) = 1+ half(W9,X9):4+ bitIter(X9,Y9,Z9):5
     [X9>=2,2*X9+1=W9,2*X9+1=V6,Z9=0,Y9=0,V9=0,V=0] 
* CE 51: start(V,V6,V9) = 1+ half(W9,X9):4+ bitIter(X9,Y9,Z9):6
     [Z9>=0,X9>=2,Z9+1=Y9,2*X9+1=W9,Z9+1=V9,2*X9+1=V6,V=0] 
* CE 52: start(V,V6,V9) = 0+ half(W9,X9):1
     [X9=0,W9=0,V=0] 
* CE 53: start(V,V6,V9) = 0+ half(W9,X9):2
     [X9=0,W9=1,V=1] 
* CE 54: start(V,V6,V9) = 0+ half(W9,X9):3
     [X9>=1,2*X9=W9,2*X9=V] 
* CE 55: start(V,V6,V9) = 0+ half(W9,X9):4
     [X9>=1,2*X9+1=W9,2*X9+1=V] 
* CE 56: start(V,V6,V9) = 0+ inc(W9,X9):1
     [X9=0,W9=0,V=0] 
* CE 57: start(V,V6,V9) = 0+ inc(V,V):2
     [V>=1] 
* CE 58: start(V,V6,V9) = 0+ zero(W9,X9):1
     [X9=1,W9=0,V=0] 
* CE 59: start(V,V6,V9) = 0+ zero(V,W9):2
     [V>=1,W9=0] 
* CE 60: start(V,V6,V9) = 0+ p(W9,X9):1
     [X9=0,W9=0,V=0] 
* CE 61: start(V,V6,V9) = 0+ p(W9,X9):2
     [X9>=0,X9+1=W9,X9+1=V] 
* CE 62: start(V,V6,V9) = 1+ bitIter(W9,X9,Y9):1
     [Y9=0,X9=0,W9=0,V=0] 
* CE 63: start(V,V6,V9) = 1+ bitIter(W9,X9,Y9):3
     [Y9=0,X9=0,W9=1,V=1] 
* CE 64: start(V,V6,V9) = 1+ bitIter(V,W9,X9):5
     [V>=2,X9=0,W9=0] 
* CE 65: start(V,V6,V9) = 0+ bitIter(W9,X9,Y9):1
     [Y9=0,X9=0,W9=0,V6=0,V=0] 
* CE 66: start(V,V6,V9) = 0+ bitIter(W9,X9,Y9):2
     [Y9>=0,Y9+1=X9,Y9+1=V6,W9=0,V=0] 
* CE 67: start(V,V6,V9) = 0+ bitIter(W9,X9,Y9):3
     [Y9=0,X9=0,W9=1,V6=0,V=1] 
* CE 68: start(V,V6,V9) = 0+ bitIter(W9,X9,Y9):4
     [Y9>=0,Y9+1=X9,Y9+1=V6,W9=1,V=1] 
* CE 69: start(V,V6,V9) = 0+ bitIter(V,W9,X9):5
     [V>=2,X9=0,W9=0,V6=0] 
* CE 70: start(V,V6,V9) = 0+ bitIter(V,W9,X9):6
     [X9>=0,V>=2,X9+1=W9,X9+1=V6] 

### Cost equations --> "Loop" of start/3 
* CEs [69] --> Loop 31 
* CEs [38,39,53,54,55,57,59,61,63,64,67,68,70] --> Loop 32 
* CEs [40,41,42,43,44,45,46,47,48,49,50,51,52,56,58,60,62,65,66] --> Loop 33 

#### Loops of start/3 
* Loop 31: start(V,V6,V9) [V>=2,V6=0] 
* Loop 32: start(V,V6,V9) [V>=1] 
* Loop 33: start(V,V6,V9) [V=0] 

### Ranking functions of CR start(V,V6,V9) 

#### Partial ranking functions of CR start(V,V6,V9) 


### Resulting Chains:start(V,V6,V9) 
* [33]
* [32]
* [31]


### Merging Chains  start/3 into  External patterns of execution 
* [[33]] --> 1 
* [[31],[32]] --> 2 


Computing Bounds
=====================================

#### Cost of loops [16] 

 * loop 16:half(V,Out) -> [half(V',Out')] 
1
#### Cost of phase [16]:half(V,Out) -> [half(V',Out')] 
1*it(16)+0
  Such that:it(16) =< V
it(16) =< V-V'

#### Cost of phase [16]:half(V,Out) -> [half(V',Out')] 
1*it(16)+0
  Such that:it(16) =< V
it(16) =< V-V'

#### Cost of chains of half(V,Out):
* Chain [[16],15]: 1*it(16)+1
  Such that:it(16) =< 2*Out

  with precondition: [V=2*Out,V>=2] 

* Chain [[16],14]: 1*it(16)+1
  Such that:it(16) =< 2*Out

  with precondition: [V=2*Out+1,V>=3] 

* Chain [15]: 1
  with precondition: [V=0,Out=0] 

* Chain [14]: 1
  with precondition: [V=1,Out=0] 


#### Cost of chains of p(V,Out):
* Chain [18]: 1
  with precondition: [V=0,Out=0] 

* Chain [17]: 1
  with precondition: [V=Out+1,V>=1] 


#### Cost of loops [20] 

 * loop 20:inc(V,Out) -> [inc(V',Out')] 
1
#### Cost of phase [20]:inc(V,Out) -> [inc(V',Out')] 
1*it(20)+0
  Such that:it(20) =< V
it(20) =< V-V'

#### Cost of chains of inc(V,Out):
* Chain [[20],19]: 1*it(20)+1
  Such that:it(20) =< Out

  with precondition: [V=Out,V>=1] 

* Chain [19]: 1
  with precondition: [V=0,Out=0] 


#### Cost of chains of zero(V,Out):
* Chain [22]: 1
  with precondition: [V=0,Out=1] 

* Chain [21]: 1
  with precondition: [Out=0,V>=1] 


#### Cost of loops [25,26] 

 * loop 25:bitIter(V,V6,Out) -> [bitIter(V',V6',Out')] 
1*s(2)+5
  Such that:s(2) =< V

 * loop 26:bitIter(V,V6,Out) -> [bitIter(V',V6',Out')] 
1*s(4)+5
  Such that:s(4) =< V

#### Cost of phase [25,26]:bitIter(V,V6,Out) -> [bitIter(V',V6',Out')] 
5*it(25)+5*it(26)+2*s(5)+0
  Such that:it(25) =< V/2
it(25) =< V/2-V'/2
aux(1) =< V
aux(2) =< V-V'
aux(3) =< 2*V
aux(4) =< 2*V-2*V'
it(25) =< aux(1)
it(26) =< aux(1)
it(25) =< aux(2)
it(26) =< aux(2)
it(26) =< aux(3)
s(5) =< aux(3)
it(26) =< aux(4)
s(5) =< aux(4)

#### Cost of loops [23,24] 

 * loop 23:bitIter(V,V6,Out) -> [bitIter(V',V6',Out')] 
1*s(12)+1*s(11)+5
  Such that:s(11) =< 2*V'
s(12) =< V6'

 * loop 24:bitIter(V,V6,Out) -> [bitIter(V',V6',Out')] 
1*s(16)+1*s(15)+5
  Such that:s(15) =< 2*V'
s(16) =< V6'

#### Cost of phase [23,24]:bitIter(V,V6,Out) -> [bitIter(V',V6',Out')] 
5*it(23)+5*it(24)+1*s(17)+2*s(18)+1*s(19)+0
  Such that:it(23) =< V/2
it(23) =< V/2-V'/2
aux(8) =< V6
aux(10) =< V
aux(11) =< V-V'
aux(12) =< 2*V
aux(13) =< 2*V-2*V'
it(23) =< aux(10)
it(24) =< aux(10)
it(23) =< aux(11)
it(24) =< aux(11)
it(24) =< aux(12)
s(18) =< aux(12)
it(24) =< aux(13)
s(18) =< aux(13)
aux(9) =< aux(8)
s(17) =< it(23)*aux(8)
s(19) =< it(24)*aux(9)

#### Cost of chains of bitIter(V,V6,Out):
* Chain [[25,26],28,30]: 5*it(25)+5*it(26)+2*s(5)+10
  Such that:it(25) =< V/2
aux(5) =< V
aux(6) =< 2*V
it(25) =< aux(5)
it(26) =< aux(5)
it(26) =< aux(6)
s(5) =< aux(6)

  with precondition: [V6=0,Out=0,V>=2] 

* Chain [[23,24],27,29]: 5*it(23)+5*it(24)+2*s(7)+1*s(17)+2*s(18)+1*s(19)+10
  Such that:it(23) =< V/2
aux(14) =< V
aux(15) =< 2*V
aux(16) =< Out+1
s(7) =< aux(16)
it(23) =< aux(14)
it(24) =< aux(14)
it(24) =< aux(15)
s(18) =< aux(15)
aux(9) =< aux(16)
s(17) =< it(23)*aux(16)
s(19) =< it(24)*aux(9)

  with precondition: [V6=Out+1,V>=2,V6>=1] 

* Chain [30]: 5
  with precondition: [V=0,V6=0,Out=0] 

* Chain [29]: 1*s(7)+5
  Such that:s(7) =< V6

  with precondition: [V=0,V6=Out+1,V6>=1] 

* Chain [28,30]: 10
  with precondition: [V=1,V6=0,Out=0] 

* Chain [27,29]: 2*s(7)+10
  Such that:aux(7) =< Out+1
s(7) =< aux(7)

  with precondition: [V=1,V6=Out+1,V6>=1] 


#### Cost of chains of start(V,V6,V9):
* Chain [33]: 10*s(21)+4*s(23)+13*s(27)+20*s(28)+20*s(31)+2*s(42)+2*s(43)+12
  Such that:aux(21) =< 2
aux(22) =< V6
aux(23) =< V6/2
aux(24) =< V6/4
aux(25) =< V9
s(23) =< aux(21)
s(27) =< aux(22)
s(28) =< aux(24)
s(21) =< aux(25)
s(28) =< aux(23)
s(31) =< aux(23)
s(31) =< aux(22)
s(41) =< aux(25)
s(42) =< s(28)*aux(25)
s(43) =< s(31)*s(41)

  with precondition: [V=0] 

* Chain [32]: 3*s(66)+10*s(69)+10*s(72)+4*s(73)+4*s(75)+1*s(84)+1*s(85)+11
  Such that:aux(26) =< V
aux(27) =< 2*V
aux(28) =< V/2
aux(29) =< V6
s(66) =< aux(26)
s(69) =< aux(28)
s(69) =< aux(26)
s(72) =< aux(26)
s(72) =< aux(27)
s(73) =< aux(27)
s(75) =< aux(29)
s(83) =< aux(29)
s(84) =< s(69)*aux(29)
s(85) =< s(72)*s(83)

  with precondition: [V>=1] 

* Chain [31]: 5*s(86)+5*s(89)+2*s(90)+10
  Such that:s(87) =< V
s(88) =< 2*V
s(86) =< V/2
s(86) =< s(87)
s(89) =< s(87)
s(89) =< s(88)
s(90) =< s(88)

  with precondition: [V6=0,V>=2] 


Closed-form bounds of start(V,V6,V9): 
-------------------------------------
* Chain [33] with precondition: [V=0] 
    - Upper bound: nat(V6)*13+20+nat(V9)*10+nat(V9)*2*nat(V6/2)+nat(V9)*2*nat(V6/4)+nat(V6/2)*20+nat(V6/4)*20 
    - Complexity: n^2 
* Chain [32] with precondition: [V>=1] 
    - Upper bound: 13*V+11+nat(V6)*4+nat(V6)*V+V/2*nat(V6)+8*V+5*V 
    - Complexity: n^2 
* Chain [31] with precondition: [V6=0,V>=2] 
    - Upper bound: 23/2*V+10 
    - Complexity: n 

### Maximum cost of start(V,V6,V9): max([nat(V6)*13+10+nat(V9)*10+nat(V9)*2*nat(V6/2)+nat(V9)*2*nat(V6/4)+nat(V6/2)*20+nat(V6/4)*20,8*V+1+nat(V6)*4+nat(V6)*V+V/2*nat(V6)+4*V+5/2*V+23/2*V])+10 
Asymptotic class: n^2 

Time statistics: 
-------------------------------------
* Partial evaluation computed in 13 ms.
* Invariants computed in 30 ms.
   - Backward Invariants 13 ms.
   - Transitive Invariants 6 ms.
* Refinement performed in 88 ms.
* Termination proved in 8 ms.
* Upper bounds computed in 116 ms.
   - Equation cost structures 49 ms.
   - Phase cost structures 48 ms.
   - Chain cost structures 13 ms.
   - Solving cost expressions 3 ms.
* Total analysis performed in 276 ms.

