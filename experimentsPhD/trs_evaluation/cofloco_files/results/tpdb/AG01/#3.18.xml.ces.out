
Preprocessing Cost Relations
=====================================

#### Computed strongly connected components 
0. recursive  : [double/2]
1. recursive  : [minus/3]
2. recursive  : [plus/3]
3. non_recursive  : [start/2]

#### Obtained direct recursion through partial evaluation 
0. SCC is partially evaluated into double/2
1. SCC is partially evaluated into minus/3
2. SCC is partially evaluated into plus/3
3. SCC is partially evaluated into start/2

Control-Flow Refinement of Cost Relations
=====================================

### Specialization of cost equations double/2 
* CE 8 is refined into CE [16] 
* CE 10 is refined into CE [17] 
* CE 9 is refined into CE [18] 


#### Refined cost equations double/2 
* CE 16: double(V1,Out) = 1
     [Out=0,V1=0] 
* CE 17: double(V1,Out) = 0
     [V1>=0,Out=0] 
* CE 18: double(V1,Out) = 1+ double(W1,X1)
     [W1>=0,X1+2=Out,W1+1=V1] 

### Cost equations --> "Loop" of double/2 
* CEs [18] --> Loop 11 
* CEs [16,17] --> Loop 12 

#### Loops of double/2 
* Loop 11: double(V1,Out)->  double(V1',Out')
                  [V1'>=0,Out=Out'+2,V1'+1=V1] 
* Loop 12: double(V1,Out) [V1>=0,Out=0] 

### Ranking functions of CR double(V1,Out) 
* RF of phase [11]: [V1]

#### Partial ranking functions of CR double(V1,Out) 
* Partial RF of phase [11]:
  - RF of loop [11:1]:
    V1


### Resulting Chains:double(V1,Out) 
* [[11],12]
* [12]


### Merging Chains  double/2 into  External patterns of execution 
* [[12]] --> 1 
* [[12,[11]]] --> 2 


### Specialization of cost equations minus/3 
* CE 7 is refined into CE [19] 
* CE 5 is refined into CE [20] 
* CE 6 is refined into CE [21] 


#### Refined cost equations minus/3 
* CE 19: minus(V1,V,Out) = 0
     [V>=0,V1>=0,Out=0] 
* CE 20: minus(A,B,A) = 1
     [A>=0,B=0] 
* CE 21: minus(V1,V,Out) = 1+ minus(W1,X1,Out)
     [X1>=0,W1>=0,X1+1=V,W1+1=V1] 

### Cost equations --> "Loop" of minus/3 
* CEs [21] --> Loop 13 
* CEs [19] --> Loop 14 
* CEs [20] --> Loop 15 

#### Loops of minus/3 
* Loop 13: minus(V1,V,Out)->  minus(V1',V',Out)
                  [V'>=0,V1'>=0,V'+1=V,V1'+1=V1] 
* Loop 14: minus(V1,V,Out) [V>=0,V1>=0,Out=0] 
* Loop 15: minus(A,B,A) [A>=0,B=0] 

### Ranking functions of CR minus(V1,V,Out) 
* RF of phase [13]: [V,V1]

#### Partial ranking functions of CR minus(V1,V,Out) 
* Partial RF of phase [13]:
  - RF of loop [13:1]:
    V
    V1


### Resulting Chains:minus(V1,V,Out) 
* [[13],15]
* [[13],14]
* [15]
* [14]


### Merging Chains  minus/3 into  External patterns of execution 
* [[15]] --> 1 
* [[14],[14,[13]]] --> 2 
* [[15,[13]]] --> 3 


### Specialization of cost equations plus/3 
* CE 15 is refined into CE [22] 
* CE 11 is refined into CE [23] 
* CE 12 is refined into CE [24] 
* CE 14 is refined into CE [25,26,27,28,29] 
* CE 13 is refined into CE [30] 


#### Refined cost equations plus/3 
* CE 22: plus(V1,V,Out) = 0
     [V>=0,V1>=0,Out=0] 
* CE 23: plus(A,B,B) = 1
     [B>=0,A=0] 
* CE 24: plus(V1,V,Out) = 1+ plus(W1,V,X1)
     [W1>=0,V>=0,X1+1=Out,W1+1=V1] 
* CE 25: plus(V1,V,Out) = 1+ minus(W1,X1,W1):1+ double(Y1,Z1):1+ plus(W1,A2,B2)
     [W1>=0,B2+1=Out,W1+1=V1,A2=0,Z1=0,Y1=0,X1=0,V=0] 
* CE 26: plus(V1,V,Out) = 1+ minus(W1,V,X1):2+ double(V,Y1):1+ plus(Z1,A2,B2)
     [V>=0,W1>=0,B2+1=Out,W1+1=V1,A2=0,Z1=0,Y1=0,X1=0] 
* CE 27: plus(V1,V,Out) = 1+ minus(W1,V,X1):2+ double(V,Y1):2+ plus(Z1,Y1,A2)
     [2*V>=Y1,Y1>=2,W1>=0,A2+1=Out,W1+1=V1,Z1=0,X1=0] 
* CE 28: plus(V1,V,Out) = 1+ minus(W1,V,X1):3+ double(V,Y1):1+ plus(X1,Z1,A2)
     [V>=1,X1>=0,V+X1=W1,V+X1+1=V1,A2+1=Out,Z1=0,Y1=0] 
* CE 29: plus(V1,V,Out) = 1+ minus(W1,V,X1):3+ double(V,Y1):2+ plus(X1,Y1,Z1)
     [2*V>=Y1,Y1>=2,X1>=0,V+X1=W1,V+X1+1=V1,Z1+1=Out] 
* CE 30: plus(V1,V,Out) = 1+ plus(W1,X1,Out)
     [W1>=0,V>=0,V+1=X1,W1+1=V1] 

### Cost equations --> "Loop" of plus/3 
* CEs [29] --> Loop 16 
* CEs [30] --> Loop 17 
* CEs [28] --> Loop 18 
* CEs [27] --> Loop 19 
* CEs [26] --> Loop 20 
* CEs [24,25] --> Loop 21 
* CEs [22] --> Loop 22 
* CEs [23] --> Loop 23 

#### Loops of plus/3 
* Loop 16: plus(V1,V,Out)->  plus(V1',V',Out')
                  [2*V>=V',V1>=V+1,V'>=2,V1=V+V1'+1,Out=Out'+1] 
* Loop 17: plus(V1,V,Out)->  plus(V1',V',Out)
                  [V>=0,V1>=1,V+1=V',V1=V1'+1] 
* Loop 18: plus(V1,V,Out)->  plus(V1',V',Out')
                  [V1>=V+1,V>=1,V+V1'+1=V1,Out=Out'+1,V'=0] 
* Loop 19: plus(V1,V,Out)->  plus(V1',V',Out')
                  [2*V>=V',V'>=2,V1>=1,Out=Out'+1,V1'=0] 
* Loop 20: plus(V1,V,Out)->  plus(V1',V',Out')
                  [V>=0,V1>=1,Out=Out'+1,V'=0,V1'=0] 
* Loop 21: plus(V1,V,Out)->  plus(V1',V,Out')
                  [V>=0,V1>=1,Out=Out'+1,V1=V1'+1] 
* Loop 22: plus(V1,V,Out) [V>=0,V1>=0,Out=0] 
* Loop 23: plus(A,B,B) [B>=0,A=0] 

### Ranking functions of CR plus(V1,V,Out) 
* RF of phase [16,17,18,21]: [V1,2*V1-1]

#### Partial ranking functions of CR plus(V1,V,Out) 
* Partial RF of phase [16,17,18,21]:
  - RF of loop [16:1]:
    V1+V-2
    V1/3-V/3
  - RF of loop [16:1,18:1]:
    V1/2-1/2
  - RF of loop [17:1,21:1]:
    V1
  - RF of loop [18:1]:
    V depends on loops [16:1,17:1] 
    V1-V


### Resulting Chains:plus(V1,V,Out) 
* [[16,17,18,21],23]
* [[16,17,18,21],22]
* [[16,17,18,21],20,23]
* [[16,17,18,21],20,22]
* [[16,17,18,21],19,23]
* [[16,17,18,21],19,22]
* [23]
* [22]
* [20,23]
* [20,22]
* [19,23]
* [19,22]


### Merging Chains  plus/3 into  External patterns of execution 
* [[23]] --> 1 
* [[22]] --> 2 
* [[22,19],[22,20],[23,20],[22,19,[16,17,18,21]],[22,20,[16,17,18,21]],[23,20,[16,17,18,21]],[22,[16,17,18,21]]] --> 3 
* [[23,19]] --> 4 
* [[23,19,[16,17,18,21]]] --> 5 
* [[23,[16,17,18,21]]] --> 6 


### Specialization of cost equations start/2 
* CE 2 is refined into CE [31,32,33] 
* CE 3 is refined into CE [34,35] 
* CE 4 is refined into CE [36,37,38,39,40,41] 


#### Refined cost equations start/2 
* CE 31: start(V1,V) = 0+ minus(V1,W1,V1):1
     [V1>=0,W1=0,V=0] 
* CE 32: start(V1,V) = 0+ minus(V1,V,W1):2
     [V>=0,V1>=0,W1=0] 
* CE 33: start(V1,V) = 0+ minus(W1,V,X1):3
     [X1>=0,V>=1,V+X1=W1,V+X1=V1] 
* CE 34: start(V1,V) = 0+ double(V1,W1):1
     [V1>=0,W1=0] 
* CE 35: start(V1,V) = 0+ double(V1,W1):2
     [2*V1>=W1,W1>=2] 
* CE 36: start(V1,V) = 0+ plus(W1,V,V):1
     [V>=0,W1=0,V1=0] 
* CE 37: start(V1,V) = 0+ plus(V1,V,W1):2
     [V>=0,V1>=0,W1=0] 
* CE 38: start(V1,V) = 0+ plus(V1,V,W1):3
     [V1>=W1,W1>=0,V>=0,V1>=1] 
* CE 39: start(V1,V) = 0+ plus(V1,V,W1):4
     [2*V+1>=W1,W1>=3,V1>=1] 
* CE 40: start(V1,V) = 0+ plus(V1,V,W1):5
     [2*V1+2*V>=W1+1,W1>=3,V>=0,V1>=2] 
* CE 41: start(V1,V) = 0+ plus(V1,V,W1):6
     [V1+V>=W1,V1+W1>=V+2,W1>=1,V>=0] 

### Cost equations --> "Loop" of start/2 
* CEs [31] --> Loop 24 
* CEs [32,33,34,35,36,37,38,39,40,41] --> Loop 25 

#### Loops of start/2 
* Loop 24: start(V1,V) [V1>=0,V=0] 
* Loop 25: start(V1,V) [V1>=0] 

### Ranking functions of CR start(V1,V) 

#### Partial ranking functions of CR start(V1,V) 


### Resulting Chains:start(V1,V) 
* [25]
* [24]


### Merging Chains  start/2 into  External patterns of execution 
* [[24],[25]] --> 1 


Computing Bounds
=====================================

#### Cost of loops [11] 

 * loop 11:double(V1,Out) -> [double(V1',Out')] 
1
#### Cost of phase [11]:double(V1,Out) -> [double(V1',Out')] 
1*it(11)+0
  Such that:it(11) =< V1
it(11) =< V1-V1'

#### Cost of chains of double(V1,Out):
* Chain [[11],12]: 1*it(11)+1
  Such that:it(11) =< Out/2

  with precondition: [Out>=2,2*V1>=Out] 

* Chain [12]: 1
  with precondition: [Out=0,V1>=0] 


#### Cost of loops [13] 

 * loop 13:minus(V1,V,Out) -> [minus(V1',V',Out')] 
1
#### Cost of phase [13]:minus(V1,V,Out) -> [minus(V1',V',Out')] 
1*it(13)+0
  Such that:it(13) =< V1
it(13) =< V1-V1'
it(13) =< V
it(13) =< V-V'

#### Cost of phase [13]:minus(V1,V,Out) -> [minus(V1',V',Out')] 
1*it(13)+0
  Such that:it(13) =< V1
it(13) =< V1-V1'
it(13) =< V
it(13) =< V-V'

#### Cost of chains of minus(V1,V,Out):
* Chain [[13],15]: 1*it(13)+1
  Such that:it(13) =< V

  with precondition: [V1=Out+V,V>=1,V1>=V] 

* Chain [[13],14]: 1*it(13)+0
  Such that:it(13) =< V

  with precondition: [Out=0,V1>=1,V>=1] 

* Chain [15]: 1
  with precondition: [V=0,V1=Out,V1>=0] 

* Chain [14]: 0
  with precondition: [Out=0,V1>=0,V>=0] 


#### Cost of loops [16,17,18,21] 

 * loop 16:plus(V1,V,Out) -> [plus(V1',V',Out')] 
1*s(4)+1*s(5)+3
  Such that:s(4) =< V
s(5) =< V'/2

 * loop 17:plus(V1,V,Out) -> [plus(V1',V',Out')] 
1
 * loop 18:plus(V1,V,Out) -> [plus(V1',V',Out')] 
1*s(7)+3
  Such that:s(7) =< V1-V1'

 * loop 21:plus(V1,V,Out) -> [plus(V1',V',Out')] 
3
#### Cost of phase [16,17,18,21]:plus(V1,V,Out) -> [plus(V1',V',Out')] 
3*it(16)+1*it(17)+3*it(18)+3*it(21)+2*s(8)+1*s(10)+0
  Such that:it(18) =< V1-V
it(16) =< V1/3-V/3
it(16) =< V1/3-V/3-V1'/3+V'/3
aux(2) =< V
aux(4) =< V-V'
aux(7) =< 2*V
aux(9) =< 2*V-2*V'
aux(13) =< V1
aux(14) =< V1-V-V1'+V'
aux(15) =< V1+V
aux(16) =< V1+V-V1'-V'
aux(17) =< V1-V1'
aux(18) =< 2*V1
aux(19) =< 2*V1-2*V1'
aux(20) =< V1/2
aux(21) =< V1/2-V1'/2
aux(1) =< aux(13)
it(16) =< aux(13)
it(17) =< aux(13)
it(18) =< aux(13)
it(21) =< aux(13)
s(8) =< aux(13)
it(18) =< aux(14)
it(21) =< aux(14)
it(16) =< aux(15)
it(18) =< aux(15)
it(21) =< aux(15)
it(16) =< aux(16)
it(18) =< aux(16)
it(21) =< aux(16)
aux(1) =< aux(17)
it(16) =< aux(17)
it(17) =< aux(17)
it(18) =< aux(17)
it(21) =< aux(17)
s(8) =< aux(17)
it(16) =< aux(18)
it(17) =< aux(18)
it(18) =< aux(18)
it(21) =< aux(18)
it(16) =< aux(19)
it(17) =< aux(19)
it(18) =< aux(19)
it(21) =< aux(19)
it(16) =< aux(20)
it(18) =< aux(20)
it(16) =< aux(21)
it(18) =< aux(21)
aux(6) =< aux(1)*2
it(18) =< it(17)+aux(1)+aux(2)
s(10) =< it(17)*2+aux(6)+aux(9)
s(10) =< it(17)*2+aux(6)+aux(7)
it(18) =< it(17)+aux(1)+aux(4)
s(10) =< it(18)*aux(15)

#### Cost of phase [16,17,18,21]:plus(V1,V,Out) -> [plus(V1',V',Out')] 
3*it(16)+1*it(17)+3*it(18)+3*it(21)+2*s(8)+1*s(10)+0
  Such that:it(18) =< V1-V
it(16) =< V1/3-V/3
it(16) =< V1/3-V/3-V1'/3+V'/3
aux(2) =< V
aux(4) =< V-V'
aux(7) =< 2*V
aux(9) =< 2*V-2*V'
aux(13) =< V1
aux(14) =< V1-V-V1'+V'
aux(15) =< V1+V
aux(16) =< V1+V-V1'-V'
aux(17) =< V1-V1'
aux(18) =< 2*V1
aux(19) =< 2*V1-2*V1'
aux(20) =< V1/2
aux(21) =< V1/2-V1'/2
aux(1) =< aux(13)
it(16) =< aux(13)
it(17) =< aux(13)
it(18) =< aux(13)
it(21) =< aux(13)
s(8) =< aux(13)
it(18) =< aux(14)
it(21) =< aux(14)
it(16) =< aux(15)
it(18) =< aux(15)
it(21) =< aux(15)
it(16) =< aux(16)
it(18) =< aux(16)
it(21) =< aux(16)
aux(1) =< aux(17)
it(16) =< aux(17)
it(17) =< aux(17)
it(18) =< aux(17)
it(21) =< aux(17)
s(8) =< aux(17)
it(16) =< aux(18)
it(17) =< aux(18)
it(18) =< aux(18)
it(21) =< aux(18)
it(16) =< aux(19)
it(17) =< aux(19)
it(18) =< aux(19)
it(21) =< aux(19)
it(16) =< aux(20)
it(18) =< aux(20)
it(16) =< aux(21)
it(18) =< aux(21)
aux(6) =< aux(1)*2
it(18) =< it(17)+aux(1)+aux(2)
s(10) =< it(17)*2+aux(6)+aux(9)
s(10) =< it(17)*2+aux(6)+aux(7)
it(18) =< it(17)+aux(1)+aux(4)
s(10) =< it(18)*aux(15)

#### Cost of phase [16,17,18,21]:plus(V1,V,Out) -> [plus(V1',V',Out')] 
3*it(16)+1*it(17)+3*it(18)+3*it(21)+2*s(8)+1*s(10)+0
  Such that:it(18) =< V1-V
it(16) =< V1/3-V/3
it(16) =< V1/3-V/3-V1'/3+V'/3
aux(2) =< V
aux(4) =< V-V'
aux(7) =< 2*V
aux(9) =< 2*V-2*V'
aux(13) =< V1
aux(14) =< V1-V-V1'+V'
aux(15) =< V1+V
aux(16) =< V1+V-V1'-V'
aux(17) =< V1-V1'
aux(18) =< 2*V1
aux(19) =< 2*V1-2*V1'
aux(20) =< V1/2
aux(21) =< V1/2-V1'/2
aux(1) =< aux(13)
it(16) =< aux(13)
it(17) =< aux(13)
it(18) =< aux(13)
it(21) =< aux(13)
s(8) =< aux(13)
it(18) =< aux(14)
it(21) =< aux(14)
it(16) =< aux(15)
it(18) =< aux(15)
it(21) =< aux(15)
it(16) =< aux(16)
it(18) =< aux(16)
it(21) =< aux(16)
aux(1) =< aux(17)
it(16) =< aux(17)
it(17) =< aux(17)
it(18) =< aux(17)
it(21) =< aux(17)
s(8) =< aux(17)
it(16) =< aux(18)
it(17) =< aux(18)
it(18) =< aux(18)
it(21) =< aux(18)
it(16) =< aux(19)
it(17) =< aux(19)
it(18) =< aux(19)
it(21) =< aux(19)
it(16) =< aux(20)
it(18) =< aux(20)
it(16) =< aux(21)
it(18) =< aux(21)
aux(6) =< aux(1)*2
it(18) =< it(17)+aux(1)+aux(2)
s(10) =< it(17)*2+aux(6)+aux(9)
s(10) =< it(17)*2+aux(6)+aux(7)
it(18) =< it(17)+aux(1)+aux(4)
s(10) =< it(18)*aux(15)

#### Cost of phase [16,17,18,21]:plus(V1,V,Out) -> [plus(V1',V',Out')] 
3*it(16)+1*it(17)+3*it(18)+3*it(21)+2*s(8)+1*s(10)+0
  Such that:it(18) =< V1-V
it(16) =< V1/3-V/3
it(16) =< V1/3-V/3-V1'/3+V'/3
aux(2) =< V
aux(4) =< V-V'
aux(7) =< 2*V
aux(9) =< 2*V-2*V'
aux(13) =< V1
aux(14) =< V1-V-V1'+V'
aux(15) =< V1+V
aux(16) =< V1+V-V1'-V'
aux(17) =< V1-V1'
aux(18) =< 2*V1
aux(19) =< 2*V1-2*V1'
aux(20) =< V1/2
aux(21) =< V1/2-V1'/2
aux(1) =< aux(13)
it(16) =< aux(13)
it(17) =< aux(13)
it(18) =< aux(13)
it(21) =< aux(13)
s(8) =< aux(13)
it(18) =< aux(14)
it(21) =< aux(14)
it(16) =< aux(15)
it(18) =< aux(15)
it(21) =< aux(15)
it(16) =< aux(16)
it(18) =< aux(16)
it(21) =< aux(16)
aux(1) =< aux(17)
it(16) =< aux(17)
it(17) =< aux(17)
it(18) =< aux(17)
it(21) =< aux(17)
s(8) =< aux(17)
it(16) =< aux(18)
it(17) =< aux(18)
it(18) =< aux(18)
it(21) =< aux(18)
it(16) =< aux(19)
it(17) =< aux(19)
it(18) =< aux(19)
it(21) =< aux(19)
it(16) =< aux(20)
it(18) =< aux(20)
it(16) =< aux(21)
it(18) =< aux(21)
aux(6) =< aux(1)*2
it(18) =< it(17)+aux(1)+aux(2)
s(10) =< it(17)*2+aux(6)+aux(9)
s(10) =< it(17)*2+aux(6)+aux(7)
it(18) =< it(17)+aux(1)+aux(4)
s(10) =< it(18)*aux(15)

#### Cost of phase [16,17,18,21]:plus(V1,V,Out) -> [plus(V1',V',Out')] 
3*it(16)+1*it(17)+3*it(18)+3*it(21)+2*s(8)+1*s(10)+0
  Such that:it(18) =< V1-V
it(16) =< V1/3-V/3
it(16) =< V1/3-V/3-V1'/3+V'/3
aux(2) =< V
aux(4) =< V-V'
aux(7) =< 2*V
aux(9) =< 2*V-2*V'
aux(13) =< V1
aux(14) =< V1-V-V1'+V'
aux(15) =< V1+V
aux(16) =< V1+V-V1'-V'
aux(17) =< V1-V1'
aux(18) =< 2*V1
aux(19) =< 2*V1-2*V1'
aux(20) =< V1/2
aux(21) =< V1/2-V1'/2
aux(1) =< aux(13)
it(16) =< aux(13)
it(17) =< aux(13)
it(18) =< aux(13)
it(21) =< aux(13)
s(8) =< aux(13)
it(18) =< aux(14)
it(21) =< aux(14)
it(16) =< aux(15)
it(18) =< aux(15)
it(21) =< aux(15)
it(16) =< aux(16)
it(18) =< aux(16)
it(21) =< aux(16)
aux(1) =< aux(17)
it(16) =< aux(17)
it(17) =< aux(17)
it(18) =< aux(17)
it(21) =< aux(17)
s(8) =< aux(17)
it(16) =< aux(18)
it(17) =< aux(18)
it(18) =< aux(18)
it(21) =< aux(18)
it(16) =< aux(19)
it(17) =< aux(19)
it(18) =< aux(19)
it(21) =< aux(19)
it(16) =< aux(20)
it(18) =< aux(20)
it(16) =< aux(21)
it(18) =< aux(21)
aux(6) =< aux(1)*2
it(18) =< it(17)+aux(1)+aux(2)
s(10) =< it(17)*2+aux(6)+aux(9)
s(10) =< it(17)*2+aux(6)+aux(7)
it(18) =< it(17)+aux(1)+aux(4)
s(10) =< it(18)*aux(15)

#### Cost of phase [16,17,18,21]:plus(V1,V,Out) -> [plus(V1',V',Out')] 
3*it(16)+1*it(17)+3*it(18)+3*it(21)+2*s(8)+1*s(10)+0
  Such that:it(18) =< V1-V
it(16) =< V1/3-V/3
it(16) =< V1/3-V/3-V1'/3+V'/3
aux(2) =< V
aux(4) =< V-V'
aux(7) =< 2*V
aux(9) =< 2*V-2*V'
aux(13) =< V1
aux(14) =< V1-V-V1'+V'
aux(15) =< V1+V
aux(16) =< V1+V-V1'-V'
aux(17) =< V1-V1'
aux(18) =< 2*V1
aux(19) =< 2*V1-2*V1'
aux(20) =< V1/2
aux(21) =< V1/2-V1'/2
aux(1) =< aux(13)
it(16) =< aux(13)
it(17) =< aux(13)
it(18) =< aux(13)
it(21) =< aux(13)
s(8) =< aux(13)
it(18) =< aux(14)
it(21) =< aux(14)
it(16) =< aux(15)
it(18) =< aux(15)
it(21) =< aux(15)
it(16) =< aux(16)
it(18) =< aux(16)
it(21) =< aux(16)
aux(1) =< aux(17)
it(16) =< aux(17)
it(17) =< aux(17)
it(18) =< aux(17)
it(21) =< aux(17)
s(8) =< aux(17)
it(16) =< aux(18)
it(17) =< aux(18)
it(18) =< aux(18)
it(21) =< aux(18)
it(16) =< aux(19)
it(17) =< aux(19)
it(18) =< aux(19)
it(21) =< aux(19)
it(16) =< aux(20)
it(18) =< aux(20)
it(16) =< aux(21)
it(18) =< aux(21)
aux(6) =< aux(1)*2
it(18) =< it(17)+aux(1)+aux(2)
s(10) =< it(17)*2+aux(6)+aux(9)
s(10) =< it(17)*2+aux(6)+aux(7)
it(18) =< it(17)+aux(1)+aux(4)
s(10) =< it(18)*aux(15)

#### Cost of chains of plus(V1,V,Out):
* Chain [[16,17,18,21],23]: 3*it(16)+1*it(17)+3*it(18)+3*it(21)+2*s(8)+1*s(10)+1
  Such that:it(18) =< V1-V
aux(15) =< V1+V
it(16) =< V1/3-V/3
aux(22) =< V1
aux(23) =< 2*V1
aux(24) =< V1/2
aux(25) =< V
aux(26) =< 2*V
it(16) =< aux(23)
it(16) =< aux(22)
it(17) =< aux(22)
it(18) =< aux(22)
it(21) =< aux(22)
s(8) =< aux(22)
it(18) =< aux(23)
it(21) =< aux(23)
it(16) =< aux(15)
it(18) =< aux(15)
it(21) =< aux(15)
it(17) =< aux(23)
it(16) =< aux(24)
it(18) =< aux(24)
aux(6) =< aux(22)*2
it(18) =< it(17)+aux(22)+aux(25)
s(10) =< it(17)*2+aux(6)+aux(26)
s(10) =< it(18)*aux(15)

  with precondition: [V>=0,Out>=1,Out+V1>=V+2,V+V1>=Out] 

* Chain [[16,17,18,21],22]: 3*it(16)+1*it(17)+3*it(18)+3*it(21)+2*s(8)+1*s(10)+0
  Such that:it(18) =< V1-V
aux(15) =< V1+V
aux(14) =< 2*V1-Out
it(16) =< V1/3-V/3
aux(27) =< V1
aux(28) =< 2*V1
aux(29) =< V1/2
aux(30) =< V
aux(31) =< 2*V
aux(14) =< aux(28)
it(16) =< aux(28)
it(16) =< aux(27)
it(17) =< aux(27)
it(18) =< aux(27)
it(21) =< aux(27)
s(8) =< aux(27)
it(18) =< aux(14)
it(21) =< aux(14)
it(16) =< aux(15)
it(18) =< aux(15)
it(21) =< aux(15)
it(18) =< aux(28)
it(21) =< aux(28)
it(17) =< aux(28)
it(16) =< aux(29)
it(18) =< aux(29)
aux(6) =< aux(27)*2
it(18) =< it(17)+aux(27)+aux(30)
s(10) =< it(17)*2+aux(6)+aux(31)
s(10) =< it(18)*aux(15)

  with precondition: [V1>=1,V>=0,Out>=0,V1>=Out] 

* Chain [[16,17,18,21],20,23]: 3*it(16)+1*it(17)+3*it(18)+3*it(21)+2*s(8)+1*s(10)+1*s(11)+3
  Such that:it(18) =< V1-V
it(16) =< V1/3-V/3
aux(32) =< V1
aux(33) =< V1+V
aux(34) =< 2*V1
aux(35) =< V1/2
aux(36) =< V
aux(37) =< 2*V
s(11) =< aux(33)
it(16) =< aux(34)
it(16) =< aux(32)
it(17) =< aux(32)
it(18) =< aux(32)
it(21) =< aux(32)
s(8) =< aux(32)
it(18) =< aux(34)
it(21) =< aux(34)
it(16) =< aux(33)
it(18) =< aux(33)
it(21) =< aux(33)
it(17) =< aux(34)
it(16) =< aux(35)
it(18) =< aux(35)
aux(6) =< aux(32)*2
it(18) =< it(17)+aux(32)+aux(36)
s(10) =< it(17)*2+aux(6)+aux(37)
s(10) =< it(18)*aux(33)

  with precondition: [V1>=2,V>=0,Out>=1,V1>=Out] 

* Chain [[16,17,18,21],20,22]: 3*it(16)+1*it(17)+3*it(18)+3*it(21)+2*s(8)+1*s(10)+1*s(11)+2
  Such that:it(18) =< V1-V
it(16) =< V1/3-V/3
aux(38) =< V1
aux(39) =< V1+V
aux(40) =< 2*V1
aux(41) =< V1/2
aux(42) =< V
aux(43) =< 2*V
s(11) =< aux(39)
it(16) =< aux(40)
it(16) =< aux(38)
it(17) =< aux(38)
it(18) =< aux(38)
it(21) =< aux(38)
s(8) =< aux(38)
it(18) =< aux(40)
it(21) =< aux(40)
it(16) =< aux(39)
it(18) =< aux(39)
it(21) =< aux(39)
it(17) =< aux(40)
it(16) =< aux(41)
it(18) =< aux(41)
aux(6) =< aux(38)*2
it(18) =< it(17)+aux(38)+aux(42)
s(10) =< it(17)*2+aux(6)+aux(43)
s(10) =< it(18)*aux(39)

  with precondition: [V1>=2,V>=0,Out>=1,V1>=Out] 

* Chain [[16,17,18,21],19,23]: 3*it(16)+1*it(17)+3*it(18)+3*it(21)+2*s(8)+1*s(10)+2*s(12)+3
  Such that:it(18) =< V1-V
it(16) =< V1/3-V/3
aux(2) =< V
aux(7) =< 2*V
aux(44) =< V1
aux(45) =< V1+V
aux(46) =< 2*V1
aux(47) =< V1/2
s(12) =< aux(45)
it(16) =< aux(46)
it(16) =< aux(44)
it(17) =< aux(44)
it(18) =< aux(44)
it(21) =< aux(44)
s(8) =< aux(44)
it(18) =< aux(46)
it(21) =< aux(46)
it(16) =< aux(45)
it(18) =< aux(45)
it(21) =< aux(45)
it(17) =< aux(46)
it(16) =< aux(47)
it(18) =< aux(47)
aux(6) =< aux(44)*2
it(18) =< it(17)+aux(44)+aux(2)
s(10) =< it(17)*2+aux(6)+aux(46)
s(10) =< it(17)*2+aux(6)+aux(7)
it(18) =< it(17)+aux(44)+aux(44)
s(10) =< it(18)*aux(45)

  with precondition: [V1>=2,V>=0,Out>=3,2*V+2*V1>=Out+1] 

* Chain [[16,17,18,21],19,22]: 3*it(16)+1*it(17)+3*it(18)+3*it(21)+2*s(8)+1*s(10)+2*s(12)+2
  Such that:it(18) =< V1-V
aux(4) =< V1-Out
aux(9) =< 2*V1-2*Out
it(16) =< V1/3-V/3
aux(2) =< V
aux(7) =< 2*V
aux(49) =< V1
aux(50) =< V1+V
aux(51) =< 2*V1
aux(52) =< V1/2
it(16) =< aux(51)
s(12) =< aux(50)
it(16) =< aux(49)
it(17) =< aux(49)
it(18) =< aux(49)
it(21) =< aux(49)
s(8) =< aux(49)
it(18) =< aux(51)
it(21) =< aux(51)
it(16) =< aux(50)
it(18) =< aux(50)
it(21) =< aux(50)
it(17) =< aux(51)
it(16) =< aux(52)
it(18) =< aux(52)
aux(6) =< aux(49)*2
it(18) =< it(17)+aux(49)+aux(2)
s(10) =< it(17)*2+aux(6)+aux(9)
s(10) =< it(17)*2+aux(6)+aux(7)
it(18) =< it(17)+aux(49)+aux(4)
s(10) =< it(18)*aux(50)

  with precondition: [V1>=2,V>=0,Out>=1,V1>=Out,V+V1>=Out+1] 

* Chain [23]: 1
  with precondition: [V1=0,V=Out,V>=0] 

* Chain [22]: 0
  with precondition: [Out=0,V1>=0,V>=0] 

* Chain [20,23]: 1*s(11)+3
  Such that:s(11) =< V

  with precondition: [Out=1,V1>=1,V>=0] 

* Chain [20,22]: 1*s(11)+2
  Such that:s(11) =< V

  with precondition: [Out=1,V1>=1,V>=0] 

* Chain [19,23]: 1*s(12)+1*s(13)+3
  Such that:s(12) =< V
s(13) =< Out/2

  with precondition: [V1>=1,Out>=3,2*V+1>=Out] 

* Chain [19,22]: 2*s(12)+2
  Such that:aux(48) =< V
s(12) =< aux(48)

  with precondition: [Out=1,V1>=1,V>=1] 


#### Cost of chains of start(V1,V):
* Chain [25]: 7*s(76)+13*s(78)+6*s(90)+12*s(91)+18*s(93)+6*s(95)+6*s(96)+18*s(97)+2*s(100)+4*s(101)+1*s(105)+3
  Such that:s(105) =< V+1/2
aux(63) =< V1
aux(64) =< V1-V
aux(65) =< V1+V
aux(66) =< 2*V1
aux(67) =< V1/2
aux(68) =< V1/3-V/3
aux(69) =< V
aux(70) =< 2*V
s(78) =< aux(63)
s(90) =< aux(64)
s(91) =< aux(64)
s(93) =< aux(68)
s(76) =< aux(69)
s(95) =< aux(65)
s(93) =< aux(66)
s(93) =< aux(63)
s(96) =< aux(63)
s(90) =< aux(63)
s(97) =< aux(63)
s(90) =< aux(66)
s(97) =< aux(66)
s(93) =< aux(65)
s(90) =< aux(65)
s(97) =< aux(65)
s(96) =< aux(66)
s(93) =< aux(67)
s(90) =< aux(67)
s(99) =< aux(63)*2
s(90) =< s(96)+aux(63)+aux(69)
s(100) =< s(96)*2+s(99)+aux(66)
s(100) =< s(96)*2+s(99)+aux(70)
s(90) =< s(96)+aux(63)+aux(63)
s(100) =< s(90)*aux(65)
s(91) =< aux(63)
s(91) =< aux(66)
s(91) =< aux(65)
s(91) =< aux(67)
s(91) =< s(96)+aux(63)+aux(69)
s(101) =< s(96)*2+s(99)+aux(70)
s(101) =< s(91)*aux(65)

  with precondition: [V1>=0] 

* Chain [24]: 1
  with precondition: [V=0,V1>=0] 


Closed-form bounds of start(V1,V): 
-------------------------------------
* Chain [25] with precondition: [V1>=0] 
    - Upper bound: 61*V1+3+nat(V)*7+4*V1+nat(2*V)*4+nat(V1+V)*6+nat(V+1/2)+nat(V1-V)*18+nat(V1/3-V/3)*18 
    - Complexity: n 
* Chain [24] with precondition: [V=0,V1>=0] 
    - Upper bound: 1 
    - Complexity: constant 

### Maximum cost of start(V1,V): 61*V1+2+nat(V)*7+4*V1+nat(2*V)*4+nat(V1+V)*6+nat(V+1/2)+nat(V1-V)*18+nat(V1/3-V/3)*18+1 
Asymptotic class: n 

Time statistics: 
-------------------------------------
* Partial evaluation computed in 8 ms.
* Invariants computed in 62 ms.
   - Backward Invariants 38 ms.
   - Transitive Invariants 7 ms.
* Refinement performed in 57 ms.
* Termination proved in 14 ms.
* Upper bounds computed in 312 ms.
   - Equation cost structures 61 ms.
   - Phase cost structures 69 ms.
   - Chain cost structures 144 ms.
   - Solving cost expressions 3 ms.
* Total analysis performed in 474 ms.

