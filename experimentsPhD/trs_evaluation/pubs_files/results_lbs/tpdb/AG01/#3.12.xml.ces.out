
Preprocessing Cost Relations
=====================================

#### Computed strongly connected components 
0. recursive : [app/3]
1. recursive : [reverse/2]
2. recursive : [shuffle/2]
3. non_recursive : [start/2]

#### Obtained direct recursion through partial evaluation 
0. SCC is partially evaluated into app/3
1. SCC is partially evaluated into reverse/2
2. SCC is partially evaluated into shuffle/2
3. SCC is partially evaluated into start/2

Control-Flow Refinement of Cost Relations
=====================================

### Specialization of cost equations app/3 
* CE 6 is refined into CE [11] 
* CE 5 is refined into CE [12] 


#### Refined cost equations app/3 
* CE 11: app(V1,V,Out) = 1+ app(W1,V,X1)
     [V1+X1>=Out,Out>=X1+1,V>=0,V1+X1=Out+W1] 
* CE 12: app(A,B,B) = 1
     [B>=0,A=0] 

### Cost equations --> "Loop" of app/3 
* CEs [12] --> Loop 10 
* CEs [11] --> Loop 11 

#### Loops of app/3 
* Loop 10: app(A,B,B) [B>=0,A=0] 
* Loop 11: app(V1,V,Out)->  app(V1',V,Out')
                  [V1+Out'>=Out,Out>=Out'+1,V>=0,V1+Out'=Out+V1'] 

### Ranking functions of CR app(V1,V,Out) 
* RF of phase [11]: [V1]

#### Partial ranking functions of CR app(V1,V,Out) 
* Partial RF of phase [11]:
  - RF of loop [11:1]:
    V1

Discarded unfeasible chain [[11]]...(Non-terminating chain proved terminating)

### Resulting Chains:app(V1,V,Out) 
* [[11],10]
* [10]


### Specialization of cost equations reverse/2 
* CE 8 is refined into CE [13,14] 
* CE 7 is refined into CE [15] 


#### Refined cost equations reverse/2 
* CE 13: reverse(V1,Out) = 1+ reverse(W1,X1)+ app(X1,Y1,Out):[[11],10]
     [V1+X1>=Out,Out>=X1+1,X1>=1,Out+W1=V1+X1,Out=X1+Y1] 
* CE 14: reverse(V1,Out) = 1+ reverse(W1,X1)+ app(Y1,Out,Out):[10]
     [V1>=Out,Out>=1,Out+W1=V1,X1=0,Y1=0] 
* CE 15: reverse(V1,Out) = 1
     [Out=0,V1=0] 

### Cost equations --> "Loop" of reverse/2 
* CEs [15] --> Loop 12 
* CEs [13] --> Loop 13 
* CEs [14] --> Loop 14 

#### Loops of reverse/2 
* Loop 12: reverse(V1,Out) [Out=0,V1=0] 
* Loop 13: reverse(V1,Out)->  reverse(V1',Out')
                  [Out+V1'>=V1+1,V1>=V1'+1,V1'>=0,V1+Out'=Out+V1'] 
* Loop 14: reverse(V1,Out)->  reverse(V1',Out')
                  [V1>=Out,Out>=1,V1=Out+V1',Out'=0] 

### Ranking functions of CR reverse(V1,Out) 
* RF of phase [13]: [V1]

#### Partial ranking functions of CR reverse(V1,Out) 
* Partial RF of phase [13]:
  - RF of loop [13:1]:
    V1

Discarded unfeasible chain [[13]]...(Non-terminating chain proved terminating)

### Resulting Chains:reverse(V1,Out) 
* [[13],14,12]
* [14,12]
* [12]


### Specialization of cost equations shuffle/2 
* CE 10 is refined into CE [16,17,18] 
* CE 9 is refined into CE [19] 


#### Refined cost equations shuffle/2 
* CE 16: shuffle(V1,Out) = 1+ reverse(W1,W1):[[13],14,12]+ shuffle(W1,X1)
     [V1>=W1+1,W1>=2,Out+W1=V1+X1] 
* CE 17: shuffle(V1,Out) = 1+ reverse(W1,W1):[14,12]+ shuffle(W1,X1)
     [V1>=W1+1,W1>=1,Out+W1=V1+X1] 
* CE 18: shuffle(V1,Out) = 1+ reverse(W1,X1):[12]+ shuffle(Y1,Z1)
     [V1>=1,V1+Z1=Out,Y1=0,X1=0,W1=0] 
* CE 19: shuffle(V1,Out) = 1
     [Out=0,V1=0] 

### Cost equations --> "Loop" of shuffle/2 
* CEs [19] --> Loop 15 
* CEs [16] --> Loop 16 
* CEs [17] --> Loop 17 
* CEs [18] --> Loop 18 

#### Loops of shuffle/2 
* Loop 15: shuffle(V1,Out) [Out=0,V1=0] 
* Loop 16: shuffle(V1,Out)->  shuffle(V1',Out')
                  [V1>=V1'+1,V1'>=2,V1+Out'=Out+V1'] 
* Loop 17: shuffle(V1,Out)->  shuffle(V1',Out')
                  [V1>=V1'+1,V1'>=1,V1+Out'=Out+V1'] 
* Loop 18: shuffle(V1,Out)->  shuffle(V1',Out')
                  [V1>=1,V1+Out'=Out,V1'=0] 

### Ranking functions of CR shuffle(V1,Out) 
* RF of phase [16,17]: [V1-1]

#### Partial ranking functions of CR shuffle(V1,Out) 
* Partial RF of phase [16,17]:
  - RF of loop [16:1]:
    V1-2
  - RF of loop [17:1]:
    V1-1

Discarded unfeasible chain [[16,17]]...(Non-terminating chain proved terminating)

### Resulting Chains:shuffle(V1,Out) 
* [[16,17],18,15]
* [18,15]
* [15]


### Specialization of cost equations start/2 
* CE 2 is refined into CE [20,21] 
* CE 4 is refined into CE [22,23,24] 
* CE 3 is refined into CE [25,26,27] 


#### Refined cost equations start/2 
* CE 20: start(V1,V) = 0+ app(V1,W1,X1):[[11],10]
     [X1>=V1,V1>=1,X1=V1+W1,X1=V1+V] 
* CE 21: start(V1,V) = 0+ app(W1,V,V):[10]
     [V>=0,W1=0,V1=0] 
* CE 22: start(V1,V) = 0+ shuffle(V1,V1):[[16,17],18,15]
     [V1>=2] 
* CE 23: start(V1,V) = 0+ shuffle(V1,V1):[18,15]
     [V1>=1] 
* CE 24: start(V1,V) = 0+ shuffle(W1,X1):[15]
     [X1=0,W1=0,V1=0] 
* CE 25: start(V1,V) = 0+ reverse(V1,V1):[[13],14,12]
     [V1>=2] 
* CE 26: start(V1,V) = 0+ reverse(V1,V1):[14,12]
     [V1>=1] 
* CE 27: start(V1,V) = 0+ reverse(W1,X1):[12]
     [X1=0,W1=0,V1=0] 

### Cost equations --> "Loop" of start/2 
* CEs [25] --> Loop 19 
* CEs [22] --> Loop 20 
* CEs [20] --> Loop 21 
* CEs [26] --> Loop 22 
* CEs [23] --> Loop 23 
* CEs [21] --> Loop 24 
* CEs [27] --> Loop 25 
* CEs [24] --> Loop 26 

#### Loops of start/2 
* Loop 19: start(V1,V) [V1>=2] 
* Loop 20: start(V1,V) [V1>=2] 
* Loop 21: start(V1,V) [V>=0,V1>=1] 
* Loop 22: start(V1,V) [V1>=1] 
* Loop 23: start(V1,V) [V1>=1] 
* Loop 24: start(V1,V) [V>=0,V1=0] 
* Loop 25: start(V1,V) [V1=0] 
* Loop 26: start(V1,V) [V1=0] 

### Ranking functions of CR start(V1,V) 

#### Partial ranking functions of CR start(V1,V) 


### Resulting Chains:start(V1,V) 
* [26]
* [25]
* [24]
* [23]
* [22]
* [21]
* [20]
* [19]


Computing Bounds
=====================================

#### Computing cost of phase [11] 

#### Cost of loops [11] 

 * loop 11:app(V1,V,Out) -> [app(V1',V',Out')] 
1
##### Pending set app(V1,V,Out)
* Psum in loop 11: [#(11)>=1,#(11)=<1]

###### Computing sum for #(11)>=1  in loop 11 
   - Applying inductive sum strategy 
   - No strategy succeeded 
 * Adding constraints: [] 

##### Pending set start(V1,V)
* Psum in loop 11: [#(11)=<1]

###### Computing sum for #(11)=<1  in loop 11 
   - Applying inductive sum strategy 
     - head Candidate: V1 
     - tail Candidate: V1 
 * Adding constraints: [#(11)=<V1,#(11)=<V1-V1'] 

##### Empy Pending set: Done 

#### Cost of phase [11]:app(V1,V,Out) -> [app(V1',V',Out')] 
1* #(11)+0
  Such that:#(11) =< V1
#(11) =< V1-V1'
 * Renamed intermediate variables: 
[#(11)>>s(1)]

#### Cost of chains of app(V1,V,Out):
* Chain [[11],10]: 1*s(1)+1
  Such that:s(1) =< -V+Out

  with precondition: [V+V1=Out,V1>=1,V>=0] 

* Chain [10]: 1
  with precondition: [V1=0,V=Out,V>=0] 


#### Computing cost of phase [13] 
 * Renamed intermediate variables: 
[s(1)>>s(2)]
 * Renamed intermediate variables: 
[s(2)>>s(4)]
 * Renamed intermediate variables: 
[s(4)>>s(5)]

#### Cost of loops [13] 

 * loop 13:reverse(V1,Out) -> [reverse(V1',Out')] 
1*s(5)+2
  Such that:s(5) =< Out'

##### Pending set reverse(V1,Out)
* Psum in loop 13: [#(13)>=1,#(13)=<1,sm(13,5)=<Out']

###### Computing sum for #(13)>=1  in loop 13 
   - Applying inductive sum strategy 
   - No strategy succeeded 
 * Adding constraints: [] 

##### Pending set start(V1,V)
* Psum in loop 13: [#(13)=<1,sm(13,5)=<Out']

###### Computing sum for #(13)=<1  in loop 13 
   - Applying inductive sum strategy 
     - head Candidate: V1 
     - tail Candidate: V1 
 * Adding constraints: [#(13)=<V1,#(13)=<V1-V1'] 

##### Pending set start(V1,V)
* Psum in loop 13: [sm(13,5)=<Out']

###### Computing sum for sm(13,5)=<Out'  in loop 13 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [s(6)=<V1-1] 
 * Adding constraints: [sm(13,5)=< #(13)*s(6)] 

##### Pending set reverse(V1,Out)
* Pmax/min: [s(6)=<V1-1]

###### Computing max_min for s(6)=<V1-1  
   - Found a solution using transitive invariants 
 * Adding constraints:[s(6)=<V1-1] 

##### Empy Pending set: Done 

#### Cost of phase [13]:reverse(V1,Out) -> [reverse(V1',Out')] 
2* #(13)+1*sm(13,5)+0
  Such that:s(6) =< V1-1
#(13) =< V1
#(13) =< V1-V1'
sm(13,5) =< #(13)*s(6)
 * Renamed intermediate variables: 
[s(8)>>s(9),#(13)>>s(10),sm(13,5)>>s(11)]

#### Cost of chains of reverse(V1,Out):
* Chain [[13],14,12]: 2*s(10)+1*s(11)+3
  Such that:s(9) =< Out-1
s(10) =< s(9)
s(11) =< s(10)*s(9)

  with precondition: [Out=V1,Out>=2] 

* Chain [14,12]: 3
  with precondition: [V1=Out,V1>=1] 

* Chain [12]: 1
  with precondition: [V1=0,Out=0] 


#### Computing cost of phase [16,17] 
 * Renamed intermediate variables: 
[s(9)>>s(12),s(10)>>s(13),s(11)>>s(14)]
 * Renamed intermediate variables: 
[s(12)>>s(18),s(13)>>s(19),s(14)>>s(20)]
 * Renamed intermediate variables: 
[s(18)>>s(21),s(19)>>s(22),s(20)>>s(23)]

#### Cost of loops [16,17] 

 * loop 16:shuffle(V1,Out) -> [shuffle(V1',Out')] 
2*s(22)+1*s(23)+4
  Such that:s(21) =< V1'-1
s(22) =< s(21)
s(23) =< s(22)*s(21)

 * loop 17:shuffle(V1,Out) -> [shuffle(V1',Out')] 
4
##### Pending set shuffle(V1,Out)
* Pmax/min: [s(21)=<V1-2]
* Psum in loop 16: [#(16)>=1,#(16)=<1,sm(16,21)=<V1'-1]
* Psum in loop 17: [#(17)>=1,#(17)=<1]

###### Computing max_min for s(21)=<V1-2  
   - Found a solution using transitive invariants 
 * Adding constraints:[s(21)=<V1-2] 

##### Pending set shuffle(V1,Out)
* Psum in loop 16: [#(16)>=1,#(16)=<1,sm(16,21)=<V1'-1]
* Psum in loop 17: [#(17)>=1,#(17)=<1]

###### Computing sum for #(16)>=1  in loop 16 
   - Applying inductive sum strategy 
   - No strategy succeeded 
 * Adding constraints: [] 

##### Pending set shuffle(V1,Out)
* Psum in loop 16: [#(16)=<1,sm(16,21)=<V1'-1]
* Psum in loop 17: [#(17)>=1,#(17)=<1]

###### Computing sum for #(16)=<1  in loop 16 
   - Applying inductive sum strategy 
     - head Candidate: V1-2 
       - Loop 17 is collaborative and bounds [#(17)] 
     - tail Candidate: V1-2 
       - Loop 17 is collaborative and bounds [#(17)] 
 * Adding constraints: [#(16)+ #(17)=<V1-2,#(16)+ #(17)=<V1-V1'] 

##### Pending set shuffle(V1,Out)
* Psum in loop 16: [sm(16,21)=<V1'-1]
* Psum in loop 17: [#(17)>=1,#(17)=<1]

###### Computing sum for sm(16,21)=<V1'-1  in loop 16 
   - Applying inductive sum strategy 
   - Applying basic product strategy 
     - Adding to Pmax/min: [s(24)=<V1-2] 
 * Adding constraints: [sm(16,21)=< #(16)*s(24)] 

##### Pending set shuffle(V1,Out)
* Pmax/min: [s(24)=<V1-2]
* Psum in loop 17: [#(17)>=1,#(17)=<1]

###### Computing max_min for s(24)=<V1-2  
   - Found a solution using cacheing 
 * Adding constraints:[s(24)=<s(21)] 

##### Pending set shuffle(V1,Out)
* Psum in loop 17: [#(17)>=1,#(17)=<1]

###### Computing sum for #(17)>=1  in loop 17 
   - Applying inductive sum strategy 
   - No strategy succeeded 
 * Adding constraints: [] 

##### Pending set shuffle(V1,Out)
* Psum in loop 17: [#(17)=<1]

###### Computing sum for #(17)=<1  in loop 17 
   - Applying inductive sum strategy 
     - head Candidate: V1-1 
       - Loop 16 is collaborative
     - tail Candidate: V1-1 
       - Loop 16 is collaborative
 * Adding constraints: [#(17)=<V1-1,#(17)=<V1-V1'] 

##### Empy Pending set: Done 
 * Removed the redundant constraints [#(17)=<s(25)] (They are implied by #(16)+ #(17)=<s(25))
 * Removed the redundant constraints [#(17)=<s(26)] (They are implied by #(16)+ #(17)=<s(26))

#### Cost of phase [16,17]:shuffle(V1,Out) -> [shuffle(V1',Out')] 
4* #(17)+4* #(16)+2*sm(16,22)+1*sm(16,23)+0
  Such that:s(30) =< V1-2
s(26) =< V1-1
s(25) =< V1-V1'
#(16)+ #(17) =< s(30)
#(16)+ #(17) =< s(26)
#(16)+ #(17) =< s(25)
s(24) =< s(30)
sm(16,21) =< #(16)*s(24)
sm(16,22) =< sm(16,21)
sm(16,23) =< sm(16,22)*s(30)
 * Renamed intermediate variables: 
[s(24)>>s(31),s(30)>>s(32),s(33)>>s(34),#(16)>>s(35),#(17)>>s(36),sm(16,21)>>s(37),sm(16,22)>>s(38),sm(16,23)>>s(39)]

#### Cost of chains of shuffle(V1,Out):
* Chain [[16,17],18,15]: 4*s(36)+4*s(35)+2*s(38)+1*s(39)+3
  Such that:s(32) =< V1-2
s(34) =< V1-1
s(35)+s(36) =< s(32)
s(35)+s(36) =< s(34)
s(31) =< s(32)
s(37) =< s(35)*s(31)
s(38) =< s(37)
s(39) =< s(38)*s(32)

  with precondition: [V1=Out,V1>=2] 

* Chain [18,15]: 3
  with precondition: [V1=Out,V1>=1] 

* Chain [15]: 1
  with precondition: [V1=0,Out=0] 

 * Renamed intermediate variables: 
[s(1)>>s(2)]
 * Renamed intermediate variables: 
[s(2)>>s(40)]
 * Renamed intermediate variables: 
[s(40)>>s(42)]
 * Renamed intermediate variables: 
[s(31)>>s(43),s(32)>>s(44),s(34)>>s(45),s(35)>>s(46),s(36)>>s(47),s(37)>>s(48),s(38)>>s(49),s(39)>>s(50)]
 * Renamed intermediate variables: 
[s(44)>>s(59),s(45)>>s(60),s(46)>>s(61),s(47)>>s(62),s(43)>>s(63),s(48)>>s(64),s(49)>>s(65),s(50)>>s(66)]
 * Renamed intermediate variables: 
[s(59)>>s(75),s(60)>>s(76),s(61)>>s(77),s(62)>>s(78),s(63)>>s(79),s(64)>>s(80),s(65)>>s(81),s(66)>>s(82)]
 * Renamed intermediate variables: 
[s(9)>>s(12),s(10)>>s(13),s(11)>>s(14)]
 * Renamed intermediate variables: 
[s(12)>>s(83),s(13)>>s(84),s(14)>>s(85)]
 * Renamed intermediate variables: 
[s(83)>>s(89),s(84)>>s(90),s(85)>>s(91)]

#### Cost of chains of start(V1,V):
* Chain [26]: 1
  with precondition: [V1=0] 

* Chain [25]: 1
  with precondition: [V1=0] 

* Chain [24]: 1
  with precondition: [V1=0,V>=0] 

* Chain [23]: 3
  with precondition: [V1>=1] 

* Chain [22]: 3
  with precondition: [V1>=1] 

* Chain [21]: 1*s(42)+1
  Such that:s(42) =< V1

  with precondition: [V1>=1,V>=0] 

* Chain [20]: 4*s(78)+4*s(77)+2*s(81)+1*s(82)+3
  Such that:s(75) =< V1-2
s(76) =< V1-1
s(77)+s(78) =< s(75)
s(77)+s(78) =< s(76)
s(79) =< s(75)
s(80) =< s(77)*s(79)
s(81) =< s(80)
s(82) =< s(81)*s(75)

  with precondition: [V1>=2] 

* Chain [19]: 2*s(90)+1*s(91)+3
  Such that:s(89) =< V1-1
s(90) =< s(89)
s(91) =< s(90)*s(89)

  with precondition: [V1>=2] 


Closed-form bounds of start(V1,V): 
-------------------------------------
* Chain [26] with precondition: [V1=0] 
    - Lower bound: 1 
    - Complexity: constant
 * Chain [25] with precondition: [V1=0] 
    - Lower bound: 1 
    - Complexity: constant
 * Chain [24] with precondition: [V1=0,V>=0] 
    - Lower bound: 1 
    - Complexity: constant
 * Chain [23] with precondition: [V1>=1] 
    - Lower bound: 3 
    - Complexity: constant
 * Chain [22] with precondition: [V1>=1] 
    - Lower bound: 3 
    - Complexity: constant
 * Chain [21] with precondition: [V1>=1,V>=0] 
    - Lower bound: 1 
    - Complexity: constant
 * Chain [20] with precondition: [V1>=2] 
    - Lower bound: 3 
    - Complexity: constant
 * Chain [19] with precondition: [V1>=2] 
    - Lower bound: 3 
    - Complexity: constant
 
### Partitioned lower bound of start(V1,V): 
* 1 
 if [V1>=1,V>=0]
 or [V1=0]
* 3 
 if [0>=V+1,V1>=1]
Possible lower bounds : [1,3]
Maximum lower bound complexity: constant

Time statistics: 
-------------------------------------
* Partial evaluation computed in 18 ms.
* Invariants computed in 87 ms.
   - Backward Invariants 37 ms.
   - Transitive Invariants 17 ms.
* Refinement performed in 115 ms.
* Termination proved in 21 ms.
* Upper bounds computed in 181 ms.
   - Equation cost structures 41 ms.
   - Phase cost structures 68 ms.
   - Chain cost structures 40 ms.
   - Solving cost expressions 4 ms.
* Total analysis performed in 461 ms.

